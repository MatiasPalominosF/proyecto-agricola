{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar tslib = require('tslib');\n\nvar util = require('@firebase/util');\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\n\n\nvar Component =\n/** @class */\nfunction () {\n  /**\r\n   *\r\n   * @param name The public service name, e.g. app, auth, firestore, database\r\n   * @param instanceFactory Service factory responsible for creating the public interface\r\n   * @param type whether the service provided by the component is public or private\r\n   */\n  function Component(name, instanceFactory, type) {\n    this.name = name;\n    this.instanceFactory = instanceFactory;\n    this.type = type;\n    this.multipleInstances = false;\n    /**\r\n     * Properties to be added to the service namespace\r\n     */\n\n    this.serviceProps = {};\n    this.instantiationMode = \"LAZY\"\n    /* LAZY */\n    ;\n  }\n\n  Component.prototype.setInstantiationMode = function (mode) {\n    this.instantiationMode = mode;\n    return this;\n  };\n\n  Component.prototype.setMultipleInstances = function (multipleInstances) {\n    this.multipleInstances = multipleInstances;\n    return this;\n  };\n\n  Component.prototype.setServiceProps = function (props) {\n    this.serviceProps = props;\n    return this;\n  };\n\n  return Component;\n}();\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]';\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\n\nvar Provider =\n/** @class */\nfunction () {\n  function Provider(name, container) {\n    this.name = name;\n    this.container = container;\n    this.component = null;\n    this.instances = new Map();\n    this.instancesDeferred = new Map();\n  }\n  /**\r\n   * @param identifier A provider can provide mulitple instances of a service\r\n   * if this.component.multipleInstances is true.\r\n   */\n\n\n  Provider.prototype.get = function (identifier) {\n    if (identifier === void 0) {\n      identifier = DEFAULT_ENTRY_NAME;\n    } // if multipleInstances is not supported, use the default name\n\n\n    var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n\n    if (!this.instancesDeferred.has(normalizedIdentifier)) {\n      var deferred = new util.Deferred();\n      this.instancesDeferred.set(normalizedIdentifier, deferred); // If the service instance is available, resolve the promise with it immediately\n\n      try {\n        var instance = this.getOrInitializeService(normalizedIdentifier);\n\n        if (instance) {\n          deferred.resolve(instance);\n        }\n      } catch (e) {// when the instance factory throws an exception during get(), it should not cause\n        // a fatal error. We just return the unresolved promise in this case.\n      }\n    }\n\n    return this.instancesDeferred.get(normalizedIdentifier).promise;\n  };\n\n  Provider.prototype.getImmediate = function (options) {\n    var _a = tslib.__assign({\n      identifier: DEFAULT_ENTRY_NAME,\n      optional: false\n    }, options),\n        identifier = _a.identifier,\n        optional = _a.optional; // if multipleInstances is not supported, use the default name\n\n\n    var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n\n    try {\n      var instance = this.getOrInitializeService(normalizedIdentifier);\n\n      if (!instance) {\n        if (optional) {\n          return null;\n        }\n\n        throw Error(\"Service \" + this.name + \" is not available\");\n      }\n\n      return instance;\n    } catch (e) {\n      if (optional) {\n        return null;\n      } else {\n        throw e;\n      }\n    }\n  };\n\n  Provider.prototype.getComponent = function () {\n    return this.component;\n  };\n\n  Provider.prototype.setComponent = function (component) {\n    var e_1, _a;\n\n    if (component.name !== this.name) {\n      throw Error(\"Mismatching Component \" + component.name + \" for Provider \" + this.name + \".\");\n    }\n\n    if (this.component) {\n      throw Error(\"Component for \" + this.name + \" has already been provided\");\n    }\n\n    this.component = component; // if the service is eager, initialize the default instance\n\n    if (isComponentEager(component)) {\n      try {\n        this.getOrInitializeService(DEFAULT_ENTRY_NAME);\n      } catch (e) {// when the instance factory for an eager Component throws an exception during the eager\n        // initialization, it should not cause a fatal error.\n        // TODO: Investigate if we need to make it configurable, because some component may want to cause\n        // a fatal error in this case?\n      }\n    }\n\n    try {\n      // Create service instances for the pending promises and resolve them\n      // NOTE: if this.multipleInstances is false, only the default instance will be created\n      // and all promises with resolve with it regardless of the identifier.\n      for (var _b = tslib.__values(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = tslib.__read(_c.value, 2),\n            instanceIdentifier = _d[0],\n            instanceDeferred = _d[1];\n\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n\n        try {\n          // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n          var instance = this.getOrInitializeService(normalizedIdentifier);\n          instanceDeferred.resolve(instance);\n        } catch (e) {// when the instance factory throws an exception, it should not cause\n          // a fatal error. We just leave the promise unresolved.\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n\n  Provider.prototype.clearInstance = function (identifier) {\n    if (identifier === void 0) {\n      identifier = DEFAULT_ENTRY_NAME;\n    }\n\n    this.instancesDeferred.delete(identifier);\n    this.instances.delete(identifier);\n  }; // app.delete() will call this method on every provider to delete the services\n  // TODO: should we mark the provider as deleted?\n\n\n  Provider.prototype.delete = function () {\n    return tslib.__awaiter(this, void 0, void 0, function () {\n      var services;\n      return tslib.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            services = Array.from(this.instances.values());\n            return [4\n            /*yield*/\n            , Promise.all(tslib.__spread(services.filter(function (service) {\n              return 'INTERNAL' in service;\n            }) // legacy services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map(function (service) {\n              return service.INTERNAL.delete();\n            }), services.filter(function (service) {\n              return '_delete' in service;\n            }) // modularized services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map(function (service) {\n              return service._delete();\n            })))];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Provider.prototype.isComponentSet = function () {\n    return this.component != null;\n  };\n\n  Provider.prototype.getOrInitializeService = function (identifier) {\n    var instance = this.instances.get(identifier);\n\n    if (!instance && this.component) {\n      instance = this.component.instanceFactory(this.container, normalizeIdentifierForFactory(identifier));\n      this.instances.set(identifier, instance);\n    }\n\n    return instance || null;\n  };\n\n  Provider.prototype.normalizeInstanceIdentifier = function (identifier) {\n    if (this.component) {\n      return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n    } else {\n      return identifier; // assume multiple instances are supported before the component is provided.\n    }\n  };\n\n  return Provider;\n}(); // undefined should be passed to the service factory for the default instance\n\n\nfunction normalizeIdentifierForFactory(identifier) {\n  return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\n\nfunction isComponentEager(component) {\n  return component.instantiationMode === \"EAGER\"\n  /* EAGER */\n  ;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\n\n\nvar ComponentContainer =\n/** @class */\nfunction () {\n  function ComponentContainer(name) {\n    this.name = name;\n    this.providers = new Map();\n  }\n  /**\r\n   *\r\n   * @param component Component being added\r\n   * @param overwrite When a component with the same name has already been registered,\r\n   * if overwrite is true: overwrite the existing component with the new component and create a new\r\n   * provider with the new component. It can be useful in tests where you want to use different mocks\r\n   * for different tests.\r\n   * if overwrite is false: throw an exception\r\n   */\n\n\n  ComponentContainer.prototype.addComponent = function (component) {\n    var provider = this.getProvider(component.name);\n\n    if (provider.isComponentSet()) {\n      throw new Error(\"Component \" + component.name + \" has already been registered with \" + this.name);\n    }\n\n    provider.setComponent(component);\n  };\n\n  ComponentContainer.prototype.addOrOverwriteComponent = function (component) {\n    var provider = this.getProvider(component.name);\n\n    if (provider.isComponentSet()) {\n      // delete the existing provider from the container, so we can register the new component\n      this.providers.delete(component.name);\n    }\n\n    this.addComponent(component);\n  };\n  /**\r\n   * getProvider provides a type safe interface where it can only be called with a field name\r\n   * present in NameServiceMapping interface.\r\n   *\r\n   * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n   * themselves.\r\n   */\n\n\n  ComponentContainer.prototype.getProvider = function (name) {\n    if (this.providers.has(name)) {\n      return this.providers.get(name);\n    } // create a Provider for a service that hasn't registered with Firebase\n\n\n    var provider = new Provider(name, this);\n    this.providers.set(name, provider);\n    return provider;\n  };\n\n  ComponentContainer.prototype.getProviders = function () {\n    return Array.from(this.providers.values());\n  };\n\n  return ComponentContainer;\n}();\n\nexports.Component = Component;\nexports.ComponentContainer = ComponentContainer;\nexports.Provider = Provider; //# sourceMappingURL=index.cjs.js.map","map":{"version":3,"sources":["C:/Users/matia/Desktop/Proyecto/proyecto-agricola/node_modules/@firebase/component/dist/index.cjs.js"],"names":["Object","defineProperty","exports","value","tslib","require","util","Component","name","instanceFactory","type","multipleInstances","serviceProps","instantiationMode","prototype","setInstantiationMode","mode","setMultipleInstances","setServiceProps","props","DEFAULT_ENTRY_NAME","Provider","container","component","instances","Map","instancesDeferred","get","identifier","normalizedIdentifier","normalizeInstanceIdentifier","has","deferred","Deferred","set","instance","getOrInitializeService","resolve","e","promise","getImmediate","options","_a","__assign","optional","Error","getComponent","setComponent","e_1","isComponentEager","_b","__values","entries","_c","next","done","_d","__read","instanceIdentifier","instanceDeferred","e_1_1","error","return","call","clearInstance","delete","__awaiter","services","__generator","label","Array","from","values","Promise","all","__spread","filter","service","map","INTERNAL","_delete","sent","isComponentSet","normalizeIdentifierForFactory","undefined","ComponentContainer","providers","addComponent","provider","getProvider","addOrOverwriteComponent","getProviders"],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nObject.defineProperty(exports, '__esModule', { value: true });\r\n\r\nvar tslib = require('tslib');\r\nvar util = require('@firebase/util');\r\n\r\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nvar Component = /** @class */ (function () {\r\n    /**\r\n     *\r\n     * @param name The public service name, e.g. app, auth, firestore, database\r\n     * @param instanceFactory Service factory responsible for creating the public interface\r\n     * @param type whether the service provided by the component is public or private\r\n     */\r\n    function Component(name, instanceFactory, type) {\r\n        this.name = name;\r\n        this.instanceFactory = instanceFactory;\r\n        this.type = type;\r\n        this.multipleInstances = false;\r\n        /**\r\n         * Properties to be added to the service namespace\r\n         */\r\n        this.serviceProps = {};\r\n        this.instantiationMode = \"LAZY\" /* LAZY */;\r\n    }\r\n    Component.prototype.setInstantiationMode = function (mode) {\r\n        this.instantiationMode = mode;\r\n        return this;\r\n    };\r\n    Component.prototype.setMultipleInstances = function (multipleInstances) {\r\n        this.multipleInstances = multipleInstances;\r\n        return this;\r\n    };\r\n    Component.prototype.setServiceProps = function (props) {\r\n        this.serviceProps = props;\r\n        return this;\r\n    };\r\n    return Component;\r\n}());\r\n\r\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]';\r\n\r\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\r\nvar Provider = /** @class */ (function () {\r\n    function Provider(name, container) {\r\n        this.name = name;\r\n        this.container = container;\r\n        this.component = null;\r\n        this.instances = new Map();\r\n        this.instancesDeferred = new Map();\r\n    }\r\n    /**\r\n     * @param identifier A provider can provide mulitple instances of a service\r\n     * if this.component.multipleInstances is true.\r\n     */\r\n    Provider.prototype.get = function (identifier) {\r\n        if (identifier === void 0) { identifier = DEFAULT_ENTRY_NAME; }\r\n        // if multipleInstances is not supported, use the default name\r\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\r\n            var deferred = new util.Deferred();\r\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\r\n            // If the service instance is available, resolve the promise with it immediately\r\n            try {\r\n                var instance = this.getOrInitializeService(normalizedIdentifier);\r\n                if (instance) {\r\n                    deferred.resolve(instance);\r\n                }\r\n            }\r\n            catch (e) {\r\n                // when the instance factory throws an exception during get(), it should not cause\r\n                // a fatal error. We just return the unresolved promise in this case.\r\n            }\r\n        }\r\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\r\n    };\r\n    Provider.prototype.getImmediate = function (options) {\r\n        var _a = tslib.__assign({ identifier: DEFAULT_ENTRY_NAME, optional: false }, options), identifier = _a.identifier, optional = _a.optional;\r\n        // if multipleInstances is not supported, use the default name\r\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        try {\r\n            var instance = this.getOrInitializeService(normalizedIdentifier);\r\n            if (!instance) {\r\n                if (optional) {\r\n                    return null;\r\n                }\r\n                throw Error(\"Service \" + this.name + \" is not available\");\r\n            }\r\n            return instance;\r\n        }\r\n        catch (e) {\r\n            if (optional) {\r\n                return null;\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n    };\r\n    Provider.prototype.getComponent = function () {\r\n        return this.component;\r\n    };\r\n    Provider.prototype.setComponent = function (component) {\r\n        var e_1, _a;\r\n        if (component.name !== this.name) {\r\n            throw Error(\"Mismatching Component \" + component.name + \" for Provider \" + this.name + \".\");\r\n        }\r\n        if (this.component) {\r\n            throw Error(\"Component for \" + this.name + \" has already been provided\");\r\n        }\r\n        this.component = component;\r\n        // if the service is eager, initialize the default instance\r\n        if (isComponentEager(component)) {\r\n            try {\r\n                this.getOrInitializeService(DEFAULT_ENTRY_NAME);\r\n            }\r\n            catch (e) {\r\n                // when the instance factory for an eager Component throws an exception during the eager\r\n                // initialization, it should not cause a fatal error.\r\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\r\n                // a fatal error in this case?\r\n            }\r\n        }\r\n        try {\r\n            // Create service instances for the pending promises and resolve them\r\n            // NOTE: if this.multipleInstances is false, only the default instance will be created\r\n            // and all promises with resolve with it regardless of the identifier.\r\n            for (var _b = tslib.__values(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var _d = tslib.__read(_c.value, 2), instanceIdentifier = _d[0], instanceDeferred = _d[1];\r\n                var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n                try {\r\n                    // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\r\n                    var instance = this.getOrInitializeService(normalizedIdentifier);\r\n                    instanceDeferred.resolve(instance);\r\n                }\r\n                catch (e) {\r\n                    // when the instance factory throws an exception, it should not cause\r\n                    // a fatal error. We just leave the promise unresolved.\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    };\r\n    Provider.prototype.clearInstance = function (identifier) {\r\n        if (identifier === void 0) { identifier = DEFAULT_ENTRY_NAME; }\r\n        this.instancesDeferred.delete(identifier);\r\n        this.instances.delete(identifier);\r\n    };\r\n    // app.delete() will call this method on every provider to delete the services\r\n    // TODO: should we mark the provider as deleted?\r\n    Provider.prototype.delete = function () {\r\n        return tslib.__awaiter(this, void 0, void 0, function () {\r\n            var services;\r\n            return tslib.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        services = Array.from(this.instances.values());\r\n                        return [4 /*yield*/, Promise.all(tslib.__spread(services\r\n                                .filter(function (service) { return 'INTERNAL' in service; }) // legacy services\r\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                                .map(function (service) { return service.INTERNAL.delete(); }), services\r\n                                .filter(function (service) { return '_delete' in service; }) // modularized services\r\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                                .map(function (service) { return service._delete(); })))];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Provider.prototype.isComponentSet = function () {\r\n        return this.component != null;\r\n    };\r\n    Provider.prototype.getOrInitializeService = function (identifier) {\r\n        var instance = this.instances.get(identifier);\r\n        if (!instance && this.component) {\r\n            instance = this.component.instanceFactory(this.container, normalizeIdentifierForFactory(identifier));\r\n            this.instances.set(identifier, instance);\r\n        }\r\n        return instance || null;\r\n    };\r\n    Provider.prototype.normalizeInstanceIdentifier = function (identifier) {\r\n        if (this.component) {\r\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\r\n        }\r\n        else {\r\n            return identifier; // assume multiple instances are supported before the component is provided.\r\n        }\r\n    };\r\n    return Provider;\r\n}());\r\n// undefined should be passed to the service factory for the default instance\r\nfunction normalizeIdentifierForFactory(identifier) {\r\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\r\n}\r\nfunction isComponentEager(component) {\r\n    return component.instantiationMode === \"EAGER\" /* EAGER */;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nvar ComponentContainer = /** @class */ (function () {\r\n    function ComponentContainer(name) {\r\n        this.name = name;\r\n        this.providers = new Map();\r\n    }\r\n    /**\r\n     *\r\n     * @param component Component being added\r\n     * @param overwrite When a component with the same name has already been registered,\r\n     * if overwrite is true: overwrite the existing component with the new component and create a new\r\n     * provider with the new component. It can be useful in tests where you want to use different mocks\r\n     * for different tests.\r\n     * if overwrite is false: throw an exception\r\n     */\r\n    ComponentContainer.prototype.addComponent = function (component) {\r\n        var provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            throw new Error(\"Component \" + component.name + \" has already been registered with \" + this.name);\r\n        }\r\n        provider.setComponent(component);\r\n    };\r\n    ComponentContainer.prototype.addOrOverwriteComponent = function (component) {\r\n        var provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            // delete the existing provider from the container, so we can register the new component\r\n            this.providers.delete(component.name);\r\n        }\r\n        this.addComponent(component);\r\n    };\r\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */\r\n    ComponentContainer.prototype.getProvider = function (name) {\r\n        if (this.providers.has(name)) {\r\n            return this.providers.get(name);\r\n        }\r\n        // create a Provider for a service that hasn't registered with Firebase\r\n        var provider = new Provider(name, this);\r\n        this.providers.set(name, provider);\r\n        return provider;\r\n    };\r\n    ComponentContainer.prototype.getProviders = function () {\r\n        return Array.from(this.providers.values());\r\n    };\r\n    return ComponentContainer;\r\n}());\r\n\r\nexports.Component = Component;\r\nexports.ComponentContainer = ComponentContainer;\r\nexports.Provider = Provider;\r\n//# sourceMappingURL=index.cjs.js.map\r\n"]},"metadata":{},"sourceType":"script"}