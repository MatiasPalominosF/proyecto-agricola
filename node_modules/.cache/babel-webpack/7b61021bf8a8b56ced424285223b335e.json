{"ast":null,"code":"import _defineProperty from \"C:/Users/matia/Desktop/Proyecto/proyecto-agricola/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _possibleConstructorReturn from \"C:/Users/matia/Desktop/Proyecto/proyecto-agricola/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _toArray from \"C:/Users/matia/Desktop/Proyecto/proyecto-agricola/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _construct from \"C:/Users/matia/Desktop/Proyecto/proyecto-agricola/node_modules/@babel/runtime/helpers/esm/construct\";\nimport _slicedToArray from \"C:/Users/matia/Desktop/Proyecto/proyecto-agricola/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _assertThisInitialized from \"C:/Users/matia/Desktop/Proyecto/proyecto-agricola/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _createForOfIteratorHelper from \"C:/Users/matia/Desktop/Proyecto/proyecto-agricola/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _get from \"C:/Users/matia/Desktop/Proyecto/proyecto-agricola/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/Users/matia/Desktop/Proyecto/proyecto-agricola/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/Users/matia/Desktop/Proyecto/proyecto-agricola/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/matia/Desktop/Proyecto/proyecto-agricola/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _toConsumableArray from \"C:/Users/matia/Desktop/Proyecto/proyecto-agricola/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"C:/Users/matia/Desktop/Proyecto/proyecto-agricola/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/matia/Desktop/Proyecto/proyecto-agricola/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar _BoundPropertyMapping;\n\nimport _regeneratorRuntime from \"C:/Users/matia/Desktop/Proyecto/proyecto-agricola/node_modules/@babel/runtime/regenerator\";\n\n/**\r\n * @license Angular v12.1.0\r\n * (c) 2010-2021 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\nvar TagContentType;\n\n(function (TagContentType) {\n  TagContentType[TagContentType[\"RAW_TEXT\"] = 0] = \"RAW_TEXT\";\n  TagContentType[TagContentType[\"ESCAPABLE_RAW_TEXT\"] = 1] = \"ESCAPABLE_RAW_TEXT\";\n  TagContentType[TagContentType[\"PARSABLE_DATA\"] = 2] = \"PARSABLE_DATA\";\n})(TagContentType || (TagContentType = {}));\n\nfunction splitNsName(elementName) {\n  if (elementName[0] != ':') {\n    return [null, elementName];\n  }\n\n  var colonIndex = elementName.indexOf(':', 1);\n\n  if (colonIndex == -1) {\n    throw new Error(\"Unsupported format \\\"\".concat(elementName, \"\\\" expecting \\\":namespace:name\\\"\"));\n  }\n\n  return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n} // `<ng-container>` tags work the same regardless the namespace\n\n\nfunction isNgContainer(tagName) {\n  return splitNsName(tagName)[1] === 'ng-container';\n} // `<ng-content>` tags work the same regardless the namespace\n\n\nfunction isNgContent(tagName) {\n  return splitNsName(tagName)[1] === 'ng-content';\n} // `<ng-template>` tags work the same regardless the namespace\n\n\nfunction isNgTemplate(tagName) {\n  return splitNsName(tagName)[1] === 'ng-template';\n}\n\nfunction getNsPrefix(fullName) {\n  return fullName === null ? null : splitNsName(fullName)[0];\n}\n\nfunction mergeNsAndName(prefix, localName) {\n  return prefix ? \":\".concat(prefix, \":\").concat(localName) : localName;\n} // see https://www.w3.org/TR/html51/syntax.html#named-character-references\n// see https://html.spec.whatwg.org/multipage/entities.json\n// This list is not exhaustive to keep the compiler footprint low.\n// The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not\n// exist.\n\n\nvar NAMED_ENTITIES = {\n  'Aacute': \"\\xC1\",\n  'aacute': \"\\xE1\",\n  'Acirc': \"\\xC2\",\n  'acirc': \"\\xE2\",\n  'acute': \"\\xB4\",\n  'AElig': \"\\xC6\",\n  'aelig': \"\\xE6\",\n  'Agrave': \"\\xC0\",\n  'agrave': \"\\xE0\",\n  'alefsym': \"\\u2135\",\n  'Alpha': \"\\u0391\",\n  'alpha': \"\\u03B1\",\n  'amp': '&',\n  'and': \"\\u2227\",\n  'ang': \"\\u2220\",\n  'apos': \"'\",\n  'Aring': \"\\xC5\",\n  'aring': \"\\xE5\",\n  'asymp': \"\\u2248\",\n  'Atilde': \"\\xC3\",\n  'atilde': \"\\xE3\",\n  'Auml': \"\\xC4\",\n  'auml': \"\\xE4\",\n  'bdquo': \"\\u201E\",\n  'Beta': \"\\u0392\",\n  'beta': \"\\u03B2\",\n  'brvbar': \"\\xA6\",\n  'bull': \"\\u2022\",\n  'cap': \"\\u2229\",\n  'Ccedil': \"\\xC7\",\n  'ccedil': \"\\xE7\",\n  'cedil': \"\\xB8\",\n  'cent': \"\\xA2\",\n  'Chi': \"\\u03A7\",\n  'chi': \"\\u03C7\",\n  'circ': \"\\u02C6\",\n  'clubs': \"\\u2663\",\n  'cong': \"\\u2245\",\n  'copy': \"\\xA9\",\n  'crarr': \"\\u21B5\",\n  'cup': \"\\u222A\",\n  'curren': \"\\xA4\",\n  'dagger': \"\\u2020\",\n  'Dagger': \"\\u2021\",\n  'darr': \"\\u2193\",\n  'dArr': \"\\u21D3\",\n  'deg': \"\\xB0\",\n  'Delta': \"\\u0394\",\n  'delta': \"\\u03B4\",\n  'diams': \"\\u2666\",\n  'divide': \"\\xF7\",\n  'Eacute': \"\\xC9\",\n  'eacute': \"\\xE9\",\n  'Ecirc': \"\\xCA\",\n  'ecirc': \"\\xEA\",\n  'Egrave': \"\\xC8\",\n  'egrave': \"\\xE8\",\n  'empty': \"\\u2205\",\n  'emsp': \"\\u2003\",\n  'ensp': \"\\u2002\",\n  'Epsilon': \"\\u0395\",\n  'epsilon': \"\\u03B5\",\n  'equiv': \"\\u2261\",\n  'Eta': \"\\u0397\",\n  'eta': \"\\u03B7\",\n  'ETH': \"\\xD0\",\n  'eth': \"\\xF0\",\n  'Euml': \"\\xCB\",\n  'euml': \"\\xEB\",\n  'euro': \"\\u20AC\",\n  'exist': \"\\u2203\",\n  'fnof': \"\\u0192\",\n  'forall': \"\\u2200\",\n  'frac12': \"\\xBD\",\n  'frac14': \"\\xBC\",\n  'frac34': \"\\xBE\",\n  'frasl': \"\\u2044\",\n  'Gamma': \"\\u0393\",\n  'gamma': \"\\u03B3\",\n  'ge': \"\\u2265\",\n  'gt': '>',\n  'harr': \"\\u2194\",\n  'hArr': \"\\u21D4\",\n  'hearts': \"\\u2665\",\n  'hellip': \"\\u2026\",\n  'Iacute': \"\\xCD\",\n  'iacute': \"\\xED\",\n  'Icirc': \"\\xCE\",\n  'icirc': \"\\xEE\",\n  'iexcl': \"\\xA1\",\n  'Igrave': \"\\xCC\",\n  'igrave': \"\\xEC\",\n  'image': \"\\u2111\",\n  'infin': \"\\u221E\",\n  'int': \"\\u222B\",\n  'Iota': \"\\u0399\",\n  'iota': \"\\u03B9\",\n  'iquest': \"\\xBF\",\n  'isin': \"\\u2208\",\n  'Iuml': \"\\xCF\",\n  'iuml': \"\\xEF\",\n  'Kappa': \"\\u039A\",\n  'kappa': \"\\u03BA\",\n  'Lambda': \"\\u039B\",\n  'lambda': \"\\u03BB\",\n  'lang': \"\\u27E8\",\n  'laquo': \"\\xAB\",\n  'larr': \"\\u2190\",\n  'lArr': \"\\u21D0\",\n  'lceil': \"\\u2308\",\n  'ldquo': \"\\u201C\",\n  'le': \"\\u2264\",\n  'lfloor': \"\\u230A\",\n  'lowast': \"\\u2217\",\n  'loz': \"\\u25CA\",\n  'lrm': \"\\u200E\",\n  'lsaquo': \"\\u2039\",\n  'lsquo': \"\\u2018\",\n  'lt': '<',\n  'macr': \"\\xAF\",\n  'mdash': \"\\u2014\",\n  'micro': \"\\xB5\",\n  'middot': \"\\xB7\",\n  'minus': \"\\u2212\",\n  'Mu': \"\\u039C\",\n  'mu': \"\\u03BC\",\n  'nabla': \"\\u2207\",\n  'nbsp': \"\\xA0\",\n  'ndash': \"\\u2013\",\n  'ne': \"\\u2260\",\n  'ni': \"\\u220B\",\n  'not': \"\\xAC\",\n  'notin': \"\\u2209\",\n  'nsub': \"\\u2284\",\n  'Ntilde': \"\\xD1\",\n  'ntilde': \"\\xF1\",\n  'Nu': \"\\u039D\",\n  'nu': \"\\u03BD\",\n  'Oacute': \"\\xD3\",\n  'oacute': \"\\xF3\",\n  'Ocirc': \"\\xD4\",\n  'ocirc': \"\\xF4\",\n  'OElig': \"\\u0152\",\n  'oelig': \"\\u0153\",\n  'Ograve': \"\\xD2\",\n  'ograve': \"\\xF2\",\n  'oline': \"\\u203E\",\n  'Omega': \"\\u03A9\",\n  'omega': \"\\u03C9\",\n  'Omicron': \"\\u039F\",\n  'omicron': \"\\u03BF\",\n  'oplus': \"\\u2295\",\n  'or': \"\\u2228\",\n  'ordf': \"\\xAA\",\n  'ordm': \"\\xBA\",\n  'Oslash': \"\\xD8\",\n  'oslash': \"\\xF8\",\n  'Otilde': \"\\xD5\",\n  'otilde': \"\\xF5\",\n  'otimes': \"\\u2297\",\n  'Ouml': \"\\xD6\",\n  'ouml': \"\\xF6\",\n  'para': \"\\xB6\",\n  'permil': \"\\u2030\",\n  'perp': \"\\u22A5\",\n  'Phi': \"\\u03A6\",\n  'phi': \"\\u03C6\",\n  'Pi': \"\\u03A0\",\n  'pi': \"\\u03C0\",\n  'piv': \"\\u03D6\",\n  'plusmn': \"\\xB1\",\n  'pound': \"\\xA3\",\n  'prime': \"\\u2032\",\n  'Prime': \"\\u2033\",\n  'prod': \"\\u220F\",\n  'prop': \"\\u221D\",\n  'Psi': \"\\u03A8\",\n  'psi': \"\\u03C8\",\n  'quot': \"\\\"\",\n  'radic': \"\\u221A\",\n  'rang': \"\\u27E9\",\n  'raquo': \"\\xBB\",\n  'rarr': \"\\u2192\",\n  'rArr': \"\\u21D2\",\n  'rceil': \"\\u2309\",\n  'rdquo': \"\\u201D\",\n  'real': \"\\u211C\",\n  'reg': \"\\xAE\",\n  'rfloor': \"\\u230B\",\n  'Rho': \"\\u03A1\",\n  'rho': \"\\u03C1\",\n  'rlm': \"\\u200F\",\n  'rsaquo': \"\\u203A\",\n  'rsquo': \"\\u2019\",\n  'sbquo': \"\\u201A\",\n  'Scaron': \"\\u0160\",\n  'scaron': \"\\u0161\",\n  'sdot': \"\\u22C5\",\n  'sect': \"\\xA7\",\n  'shy': \"\\xAD\",\n  'Sigma': \"\\u03A3\",\n  'sigma': \"\\u03C3\",\n  'sigmaf': \"\\u03C2\",\n  'sim': \"\\u223C\",\n  'spades': \"\\u2660\",\n  'sub': \"\\u2282\",\n  'sube': \"\\u2286\",\n  'sum': \"\\u2211\",\n  'sup': \"\\u2283\",\n  'sup1': \"\\xB9\",\n  'sup2': \"\\xB2\",\n  'sup3': \"\\xB3\",\n  'supe': \"\\u2287\",\n  'szlig': \"\\xDF\",\n  'Tau': \"\\u03A4\",\n  'tau': \"\\u03C4\",\n  'there4': \"\\u2234\",\n  'Theta': \"\\u0398\",\n  'theta': \"\\u03B8\",\n  'thetasym': \"\\u03D1\",\n  'thinsp': \"\\u2009\",\n  'THORN': \"\\xDE\",\n  'thorn': \"\\xFE\",\n  'tilde': \"\\u02DC\",\n  'times': \"\\xD7\",\n  'trade': \"\\u2122\",\n  'Uacute': \"\\xDA\",\n  'uacute': \"\\xFA\",\n  'uarr': \"\\u2191\",\n  'uArr': \"\\u21D1\",\n  'Ucirc': \"\\xDB\",\n  'ucirc': \"\\xFB\",\n  'Ugrave': \"\\xD9\",\n  'ugrave': \"\\xF9\",\n  'uml': \"\\xA8\",\n  'upsih': \"\\u03D2\",\n  'Upsilon': \"\\u03A5\",\n  'upsilon': \"\\u03C5\",\n  'Uuml': \"\\xDC\",\n  'uuml': \"\\xFC\",\n  'weierp': \"\\u2118\",\n  'Xi': \"\\u039E\",\n  'xi': \"\\u03BE\",\n  'Yacute': \"\\xDD\",\n  'yacute': \"\\xFD\",\n  'yen': \"\\xA5\",\n  'yuml': \"\\xFF\",\n  'Yuml': \"\\u0178\",\n  'Zeta': \"\\u0396\",\n  'zeta': \"\\u03B6\",\n  'zwj': \"\\u200D\",\n  'zwnj': \"\\u200C\"\n}; // The &ngsp; pseudo-entity is denoting a space. see:\n// https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart\n\nvar NGSP_UNICODE = \"\\uE500\";\nNAMED_ENTITIES['ngsp'] = NGSP_UNICODE;\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\nvar HtmlTagDefinition = /*#__PURE__*/function () {\n  function HtmlTagDefinition() {\n    var _this = this;\n\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        closedByChildren = _ref2.closedByChildren,\n        implicitNamespacePrefix = _ref2.implicitNamespacePrefix,\n        _ref2$contentType = _ref2.contentType,\n        contentType = _ref2$contentType === void 0 ? TagContentType.PARSABLE_DATA : _ref2$contentType,\n        _ref2$closedByParent = _ref2.closedByParent,\n        closedByParent = _ref2$closedByParent === void 0 ? false : _ref2$closedByParent,\n        _ref2$isVoid = _ref2.isVoid,\n        isVoid = _ref2$isVoid === void 0 ? false : _ref2$isVoid,\n        _ref2$ignoreFirstLf = _ref2.ignoreFirstLf,\n        ignoreFirstLf = _ref2$ignoreFirstLf === void 0 ? false : _ref2$ignoreFirstLf,\n        _ref2$preventNamespac = _ref2.preventNamespaceInheritance,\n        preventNamespaceInheritance = _ref2$preventNamespac === void 0 ? false : _ref2$preventNamespac;\n\n    _classCallCheck(this, HtmlTagDefinition);\n\n    this.closedByChildren = {};\n    this.closedByParent = false;\n    this.canSelfClose = false;\n\n    if (closedByChildren && closedByChildren.length > 0) {\n      closedByChildren.forEach(function (tagName) {\n        return _this.closedByChildren[tagName] = true;\n      });\n    }\n\n    this.isVoid = isVoid;\n    this.closedByParent = closedByParent || isVoid;\n    this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n    this.contentType = contentType;\n    this.ignoreFirstLf = ignoreFirstLf;\n    this.preventNamespaceInheritance = preventNamespaceInheritance;\n  }\n\n  _createClass(HtmlTagDefinition, [{\n    key: \"isClosedByChild\",\n    value: function isClosedByChild(name) {\n      return this.isVoid || name.toLowerCase() in this.closedByChildren;\n    }\n  }, {\n    key: \"getContentType\",\n    value: function getContentType(prefix) {\n      if (typeof this.contentType === 'object') {\n        var overrideType = prefix == null ? undefined : this.contentType[prefix];\n        return overrideType !== null && overrideType !== void 0 ? overrideType : this.contentType.default;\n      }\n\n      return this.contentType;\n    }\n  }]);\n\n  return HtmlTagDefinition;\n}();\n\nvar _DEFAULT_TAG_DEFINITION; // see https://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\n\n\nvar TAG_DEFINITIONS;\n\nfunction getHtmlTagDefinition(tagName) {\n  var _a, _b;\n\n  if (!TAG_DEFINITIONS) {\n    _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\n    TAG_DEFINITIONS = {\n      'base': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'meta': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'area': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'embed': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'link': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'img': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'input': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'param': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'hr': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'br': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'source': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'track': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'wbr': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'p': new HtmlTagDefinition({\n        closedByChildren: ['address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'],\n        closedByParent: true\n      }),\n      'thead': new HtmlTagDefinition({\n        closedByChildren: ['tbody', 'tfoot']\n      }),\n      'tbody': new HtmlTagDefinition({\n        closedByChildren: ['tbody', 'tfoot'],\n        closedByParent: true\n      }),\n      'tfoot': new HtmlTagDefinition({\n        closedByChildren: ['tbody'],\n        closedByParent: true\n      }),\n      'tr': new HtmlTagDefinition({\n        closedByChildren: ['tr'],\n        closedByParent: true\n      }),\n      'td': new HtmlTagDefinition({\n        closedByChildren: ['td', 'th'],\n        closedByParent: true\n      }),\n      'th': new HtmlTagDefinition({\n        closedByChildren: ['td', 'th'],\n        closedByParent: true\n      }),\n      'col': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'svg': new HtmlTagDefinition({\n        implicitNamespacePrefix: 'svg'\n      }),\n      'foreignObject': new HtmlTagDefinition({\n        // Usually the implicit namespace here would be redundant since it will be inherited from\n        // the parent `svg`, but we have to do it for `foreignObject`, because the way the parser\n        // works is that the parent node of an end tag is its own start tag which means that\n        // the `preventNamespaceInheritance` on `foreignObject` would have it default to the\n        // implicit namespace which is `html`, unless specified otherwise.\n        implicitNamespacePrefix: 'svg',\n        // We want to prevent children of foreignObject from inheriting its namespace, because\n        // the point of the element is to allow nodes from other namespaces to be inserted.\n        preventNamespaceInheritance: true\n      }),\n      'math': new HtmlTagDefinition({\n        implicitNamespacePrefix: 'math'\n      }),\n      'li': new HtmlTagDefinition({\n        closedByChildren: ['li'],\n        closedByParent: true\n      }),\n      'dt': new HtmlTagDefinition({\n        closedByChildren: ['dt', 'dd']\n      }),\n      'dd': new HtmlTagDefinition({\n        closedByChildren: ['dt', 'dd'],\n        closedByParent: true\n      }),\n      'rb': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'rt': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'rtc': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'rp': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'optgroup': new HtmlTagDefinition({\n        closedByChildren: ['optgroup'],\n        closedByParent: true\n      }),\n      'option': new HtmlTagDefinition({\n        closedByChildren: ['option', 'optgroup'],\n        closedByParent: true\n      }),\n      'pre': new HtmlTagDefinition({\n        ignoreFirstLf: true\n      }),\n      'listing': new HtmlTagDefinition({\n        ignoreFirstLf: true\n      }),\n      'style': new HtmlTagDefinition({\n        contentType: TagContentType.RAW_TEXT\n      }),\n      'script': new HtmlTagDefinition({\n        contentType: TagContentType.RAW_TEXT\n      }),\n      'title': new HtmlTagDefinition({\n        // The browser supports two separate `title` tags which have to use\n        // a different content type: `HTMLTitleElement` and `SVGTitleElement`\n        contentType: {\n          default: TagContentType.ESCAPABLE_RAW_TEXT,\n          svg: TagContentType.PARSABLE_DATA\n        }\n      }),\n      'textarea': new HtmlTagDefinition({\n        contentType: TagContentType.ESCAPABLE_RAW_TEXT,\n        ignoreFirstLf: true\n      })\n    };\n  } // We have to make both a case-sensitive and a case-insesitive lookup, because\n  // HTML tag names are case insensitive, whereas some SVG tags are case sensitive.\n\n\n  return (_b = (_a = TAG_DEFINITIONS[tagName]) !== null && _a !== void 0 ? _a : TAG_DEFINITIONS[tagName.toLowerCase()]) !== null && _b !== void 0 ? _b : _DEFAULT_TAG_DEFINITION;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar _SELECTOR_REGEXP = new RegExp('(\\\\:not\\\\()|' + // 1: \":not(\"\n'(([\\\\.\\\\#]?)[-\\\\w]+)|' + // 2: \"tag\"; 3: \".\"/\"#\";\n// \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n// 4: attribute; 5: attribute_string; 6: attribute_value\n'(?:\\\\[([-.\\\\w*\\\\\\\\$]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' + // \"[name]\", \"[name=value]\",\n// \"[name=\"value\"]\",\n// \"[name='value']\"\n'(\\\\))|' + // 7: \")\"\n'(\\\\s*,\\\\s*)', // 8: \",\"\n'g');\n/**\r\n * A css selector contains an element name,\r\n * css classes and attribute/value pairs with the purpose\r\n * of selecting subsets out of them.\r\n */\n\n\nvar CssSelector = /*#__PURE__*/function () {\n  function CssSelector() {\n    _classCallCheck(this, CssSelector);\n\n    this.element = null;\n    this.classNames = [];\n    /**\r\n     * The selectors are encoded in pairs where:\r\n     * - even locations are attribute names\r\n     * - odd locations are attribute values.\r\n     *\r\n     * Example:\r\n     * Selector: `[key1=value1][key2]` would parse to:\r\n     * ```\r\n     * ['key1', 'value1', 'key2', '']\r\n     * ```\r\n     */\n\n    this.attrs = [];\n    this.notSelectors = [];\n  }\n\n  _createClass(CssSelector, [{\n    key: \"unescapeAttribute\",\n    value:\n    /**\r\n     * Unescape `\\$` sequences from the CSS attribute selector.\r\n     *\r\n     * This is needed because `$` can have a special meaning in CSS selectors,\r\n     * but we might want to match an attribute that contains `$`.\r\n     * [MDN web link for more\r\n     * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\r\n     * @param attr the attribute to unescape.\r\n     * @returns the unescaped string.\r\n     */\n    function unescapeAttribute(attr) {\n      var result = '';\n      var escaping = false;\n\n      for (var i = 0; i < attr.length; i++) {\n        var char = attr.charAt(i);\n\n        if (char === '\\\\') {\n          escaping = true;\n          continue;\n        }\n\n        if (char === '$' && !escaping) {\n          throw new Error(\"Error in attribute selector \\\"\".concat(attr, \"\\\". \") + \"Unescaped \\\"$\\\" is not supported. Please escape with \\\"\\\\$\\\".\");\n        }\n\n        escaping = false;\n        result += char;\n      }\n\n      return result;\n    }\n    /**\r\n     * Escape `$` sequences from the CSS attribute selector.\r\n     *\r\n     * This is needed because `$` can have a special meaning in CSS selectors,\r\n     * with this method we are escaping `$` with `\\$'.\r\n     * [MDN web link for more\r\n     * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\r\n     * @param attr the attribute to escape.\r\n     * @returns the escaped string.\r\n     */\n\n  }, {\n    key: \"escapeAttribute\",\n    value: function escapeAttribute(attr) {\n      return attr.replace(/\\\\/g, '\\\\\\\\').replace(/\\$/g, '\\\\$');\n    }\n  }, {\n    key: \"isElementSelector\",\n    value: function isElementSelector() {\n      return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 && this.notSelectors.length === 0;\n    }\n  }, {\n    key: \"hasElementSelector\",\n    value: function hasElementSelector() {\n      return !!this.element;\n    }\n  }, {\n    key: \"setElement\",\n    value: function setElement() {\n      var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      this.element = element;\n    }\n    /** Gets a template string for an element that matches the selector. */\n\n  }, {\n    key: \"getMatchingElementTemplate\",\n    value: function getMatchingElementTemplate() {\n      var tagName = this.element || 'div';\n      var classAttr = this.classNames.length > 0 ? \" class=\\\"\".concat(this.classNames.join(' '), \"\\\"\") : '';\n      var attrs = '';\n\n      for (var i = 0; i < this.attrs.length; i += 2) {\n        var attrName = this.attrs[i];\n        var attrValue = this.attrs[i + 1] !== '' ? \"=\\\"\".concat(this.attrs[i + 1], \"\\\"\") : '';\n        attrs += \" \".concat(attrName).concat(attrValue);\n      }\n\n      return getHtmlTagDefinition(tagName).isVoid ? \"<\".concat(tagName).concat(classAttr).concat(attrs, \"/>\") : \"<\".concat(tagName).concat(classAttr).concat(attrs, \"></\").concat(tagName, \">\");\n    }\n  }, {\n    key: \"getAttrs\",\n    value: function getAttrs() {\n      var result = [];\n\n      if (this.classNames.length > 0) {\n        result.push('class', this.classNames.join(' '));\n      }\n\n      return result.concat(this.attrs);\n    }\n  }, {\n    key: \"addAttribute\",\n    value: function addAttribute(name) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      this.attrs.push(name, value && value.toLowerCase() || '');\n    }\n  }, {\n    key: \"addClassName\",\n    value: function addClassName(name) {\n      this.classNames.push(name.toLowerCase());\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var res = this.element || '';\n\n      if (this.classNames) {\n        this.classNames.forEach(function (klass) {\n          return res += \".\".concat(klass);\n        });\n      }\n\n      if (this.attrs) {\n        for (var i = 0; i < this.attrs.length; i += 2) {\n          var name = this.escapeAttribute(this.attrs[i]);\n          var value = this.attrs[i + 1];\n          res += \"[\".concat(name).concat(value ? '=' + value : '', \"]\");\n        }\n      }\n\n      this.notSelectors.forEach(function (notSelector) {\n        return res += \":not(\".concat(notSelector, \")\");\n      });\n      return res;\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(selector) {\n      var results = [];\n\n      var _addResult = function _addResult(res, cssSel) {\n        if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 && cssSel.attrs.length == 0) {\n          cssSel.element = '*';\n        }\n\n        res.push(cssSel);\n      };\n\n      var cssSelector = new CssSelector();\n      var match;\n      var current = cssSelector;\n      var inNot = false;\n      _SELECTOR_REGEXP.lastIndex = 0;\n\n      while (match = _SELECTOR_REGEXP.exec(selector)) {\n        if (match[1\n        /* NOT */\n        ]) {\n          if (inNot) {\n            throw new Error('Nesting :not in a selector is not allowed');\n          }\n\n          inNot = true;\n          current = new CssSelector();\n          cssSelector.notSelectors.push(current);\n        }\n\n        var tag = match[2\n        /* TAG */\n        ];\n\n        if (tag) {\n          var prefix = match[3\n          /* PREFIX */\n          ];\n\n          if (prefix === '#') {\n            // #hash\n            current.addAttribute('id', tag.substr(1));\n          } else if (prefix === '.') {\n            // Class\n            current.addClassName(tag.substr(1));\n          } else {\n            // Element\n            current.setElement(tag);\n          }\n        }\n\n        var attribute = match[4\n        /* ATTRIBUTE */\n        ];\n\n        if (attribute) {\n          current.addAttribute(current.unescapeAttribute(attribute), match[6\n          /* ATTRIBUTE_VALUE */\n          ]);\n        }\n\n        if (match[7\n        /* NOT_END */\n        ]) {\n          inNot = false;\n          current = cssSelector;\n        }\n\n        if (match[8\n        /* SEPARATOR */\n        ]) {\n          if (inNot) {\n            throw new Error('Multiple selectors in :not are not supported');\n          }\n\n          _addResult(results, cssSelector);\n\n          cssSelector = current = new CssSelector();\n        }\n      }\n\n      _addResult(results, cssSelector);\n\n      return results;\n    }\n  }]);\n\n  return CssSelector;\n}();\n/**\r\n * Reads a list of CssSelectors and allows to calculate which ones\r\n * are contained in a given CssSelector.\r\n */\n\n\nvar SelectorMatcher = /*#__PURE__*/function () {\n  function SelectorMatcher() {\n    _classCallCheck(this, SelectorMatcher);\n\n    this._elementMap = new Map();\n    this._elementPartialMap = new Map();\n    this._classMap = new Map();\n    this._classPartialMap = new Map();\n    this._attrValueMap = new Map();\n    this._attrValuePartialMap = new Map();\n    this._listContexts = [];\n  }\n\n  _createClass(SelectorMatcher, [{\n    key: \"addSelectables\",\n    value: function addSelectables(cssSelectors, callbackCtxt) {\n      var listContext = null;\n\n      if (cssSelectors.length > 1) {\n        listContext = new SelectorListContext(cssSelectors);\n\n        this._listContexts.push(listContext);\n      }\n\n      for (var i = 0; i < cssSelectors.length; i++) {\n        this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n      }\n    }\n    /**\r\n     * Add an object that can be found later on by calling `match`.\r\n     * @param cssSelector A css selector\r\n     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\r\n     */\n\n  }, {\n    key: \"_addSelectable\",\n    value: function _addSelectable(cssSelector, callbackCtxt, listContext) {\n      var matcher = this;\n      var element = cssSelector.element;\n      var classNames = cssSelector.classNames;\n      var attrs = cssSelector.attrs;\n      var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n\n      if (element) {\n        var isTerminal = attrs.length === 0 && classNames.length === 0;\n\n        if (isTerminal) {\n          this._addTerminal(matcher._elementMap, element, selectable);\n        } else {\n          matcher = this._addPartial(matcher._elementPartialMap, element);\n        }\n      }\n\n      if (classNames) {\n        for (var i = 0; i < classNames.length; i++) {\n          var _isTerminal = attrs.length === 0 && i === classNames.length - 1;\n\n          var className = classNames[i];\n\n          if (_isTerminal) {\n            this._addTerminal(matcher._classMap, className, selectable);\n          } else {\n            matcher = this._addPartial(matcher._classPartialMap, className);\n          }\n        }\n      }\n\n      if (attrs) {\n        for (var _i = 0; _i < attrs.length; _i += 2) {\n          var _isTerminal2 = _i === attrs.length - 2;\n\n          var name = attrs[_i];\n          var value = attrs[_i + 1];\n\n          if (_isTerminal2) {\n            var terminalMap = matcher._attrValueMap;\n            var terminalValuesMap = terminalMap.get(name);\n\n            if (!terminalValuesMap) {\n              terminalValuesMap = new Map();\n              terminalMap.set(name, terminalValuesMap);\n            }\n\n            this._addTerminal(terminalValuesMap, value, selectable);\n          } else {\n            var partialMap = matcher._attrValuePartialMap;\n            var partialValuesMap = partialMap.get(name);\n\n            if (!partialValuesMap) {\n              partialValuesMap = new Map();\n              partialMap.set(name, partialValuesMap);\n            }\n\n            matcher = this._addPartial(partialValuesMap, value);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_addTerminal\",\n    value: function _addTerminal(map, name, selectable) {\n      var terminalList = map.get(name);\n\n      if (!terminalList) {\n        terminalList = [];\n        map.set(name, terminalList);\n      }\n\n      terminalList.push(selectable);\n    }\n  }, {\n    key: \"_addPartial\",\n    value: function _addPartial(map, name) {\n      var matcher = map.get(name);\n\n      if (!matcher) {\n        matcher = new SelectorMatcher();\n        map.set(name, matcher);\n      }\n\n      return matcher;\n    }\n    /**\r\n     * Find the objects that have been added via `addSelectable`\r\n     * whose css selector is contained in the given css selector.\r\n     * @param cssSelector A css selector\r\n     * @param matchedCallback This callback will be called with the object handed into `addSelectable`\r\n     * @return boolean true if a match was found\r\n     */\n\n  }, {\n    key: \"match\",\n    value: function match(cssSelector, matchedCallback) {\n      var result = false;\n      var element = cssSelector.element;\n      var classNames = cssSelector.classNames;\n      var attrs = cssSelector.attrs;\n\n      for (var i = 0; i < this._listContexts.length; i++) {\n        this._listContexts[i].alreadyMatched = false;\n      }\n\n      result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n      result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;\n\n      if (classNames) {\n        for (var _i2 = 0; _i2 < classNames.length; _i2++) {\n          var className = classNames[_i2];\n          result = this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n          result = this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) || result;\n        }\n      }\n\n      if (attrs) {\n        for (var _i3 = 0; _i3 < attrs.length; _i3 += 2) {\n          var name = attrs[_i3];\n          var value = attrs[_i3 + 1];\n\n          var terminalValuesMap = this._attrValueMap.get(name);\n\n          if (value) {\n            result = this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n          }\n\n          result = this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n\n          var partialValuesMap = this._attrValuePartialMap.get(name);\n\n          if (value) {\n            result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n          }\n\n          result = this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n        }\n      }\n\n      return result;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_matchTerminal\",\n    value: function _matchTerminal(map, name, cssSelector, matchedCallback) {\n      if (!map || typeof name !== 'string') {\n        return false;\n      }\n\n      var selectables = map.get(name) || [];\n      var starSelectables = map.get('*');\n\n      if (starSelectables) {\n        selectables = selectables.concat(starSelectables);\n      }\n\n      if (selectables.length === 0) {\n        return false;\n      }\n\n      var selectable;\n      var result = false;\n\n      for (var i = 0; i < selectables.length; i++) {\n        selectable = selectables[i];\n        result = selectable.finalize(cssSelector, matchedCallback) || result;\n      }\n\n      return result;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_matchPartial\",\n    value: function _matchPartial(map, name, cssSelector, matchedCallback) {\n      if (!map || typeof name !== 'string') {\n        return false;\n      }\n\n      var nestedSelector = map.get(name);\n\n      if (!nestedSelector) {\n        return false;\n      } // TODO(perf): get rid of recursion and measure again\n      // TODO(perf): don't pass the whole selector into the recursion,\n      // but only the not processed parts\n\n\n      return nestedSelector.match(cssSelector, matchedCallback);\n    }\n  }], [{\n    key: \"createNotMatcher\",\n    value: function createNotMatcher(notSelectors) {\n      var notMatcher = new SelectorMatcher();\n      notMatcher.addSelectables(notSelectors, null);\n      return notMatcher;\n    }\n  }]);\n\n  return SelectorMatcher;\n}();\n\nvar SelectorListContext = function SelectorListContext(selectors) {\n  _classCallCheck(this, SelectorListContext);\n\n  this.selectors = selectors;\n  this.alreadyMatched = false;\n}; // Store context to pass back selector and context when a selector is matched\n\n\nvar SelectorContext = /*#__PURE__*/function () {\n  function SelectorContext(selector, cbContext, listContext) {\n    _classCallCheck(this, SelectorContext);\n\n    this.selector = selector;\n    this.cbContext = cbContext;\n    this.listContext = listContext;\n    this.notSelectors = selector.notSelectors;\n  }\n\n  _createClass(SelectorContext, [{\n    key: \"finalize\",\n    value: function finalize(cssSelector, callback) {\n      var result = true;\n\n      if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n        var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n        result = !notMatcher.match(cssSelector, null);\n      }\n\n      if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n        if (this.listContext) {\n          this.listContext.alreadyMatched = true;\n        }\n\n        callback(this.selector, this.cbContext);\n      }\n\n      return result;\n    }\n  }]);\n\n  return SelectorContext;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar createInject = makeMetadataFactory('Inject', function (token) {\n  return {\n    token: token\n  };\n});\nvar createInjectionToken = makeMetadataFactory('InjectionToken', function (desc) {\n  return {\n    _desc: desc,\n    ɵprov: undefined\n  };\n});\nvar createAttribute = makeMetadataFactory('Attribute', function (attributeName) {\n  return {\n    attributeName: attributeName\n  };\n}); // Stores the default value of `emitDistinctChangesOnly` when the `emitDistinctChangesOnly` is not\n// explicitly set.\n\nvar emitDistinctChangesOnlyDefaultValue = true;\nvar createContentChildren = makeMetadataFactory('ContentChildren', function (selector) {\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Object.assign({\n    selector: selector,\n    first: false,\n    isViewQuery: false,\n    descendants: false,\n    emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue\n  }, data);\n});\nvar createContentChild = makeMetadataFactory('ContentChild', function (selector) {\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Object.assign({\n    selector: selector,\n    first: true,\n    isViewQuery: false,\n    descendants: true\n  }, data);\n});\nvar createViewChildren = makeMetadataFactory('ViewChildren', function (selector) {\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Object.assign({\n    selector: selector,\n    first: false,\n    isViewQuery: true,\n    descendants: true,\n    emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue\n  }, data);\n});\nvar createViewChild = makeMetadataFactory('ViewChild', function (selector, data) {\n  return Object.assign({\n    selector: selector,\n    first: true,\n    isViewQuery: true,\n    descendants: true\n  }, data);\n});\nvar createDirective = makeMetadataFactory('Directive', function () {\n  var dir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return dir;\n});\nvar ViewEncapsulation;\n\n(function (ViewEncapsulation) {\n  ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\"; // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\n\n  ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n  ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation || (ViewEncapsulation = {}));\n\nvar ChangeDetectionStrategy;\n\n(function (ChangeDetectionStrategy) {\n  ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n  ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));\n\nvar createComponent = makeMetadataFactory('Component', function () {\n  var c = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return Object.assign({\n    changeDetection: ChangeDetectionStrategy.Default\n  }, c);\n});\nvar createPipe = makeMetadataFactory('Pipe', function (p) {\n  return Object.assign({\n    pure: true\n  }, p);\n});\nvar createInput = makeMetadataFactory('Input', function (bindingPropertyName) {\n  return {\n    bindingPropertyName: bindingPropertyName\n  };\n});\nvar createOutput = makeMetadataFactory('Output', function (bindingPropertyName) {\n  return {\n    bindingPropertyName: bindingPropertyName\n  };\n});\nvar createHostBinding = makeMetadataFactory('HostBinding', function (hostPropertyName) {\n  return {\n    hostPropertyName: hostPropertyName\n  };\n});\nvar createHostListener = makeMetadataFactory('HostListener', function (eventName, args) {\n  return {\n    eventName: eventName,\n    args: args\n  };\n});\nvar createNgModule = makeMetadataFactory('NgModule', function (ngModule) {\n  return ngModule;\n});\nvar createInjectable = makeMetadataFactory('Injectable', function () {\n  var injectable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return injectable;\n});\nvar CUSTOM_ELEMENTS_SCHEMA = {\n  name: 'custom-elements'\n};\nvar NO_ERRORS_SCHEMA = {\n  name: 'no-errors-schema'\n};\nvar createOptional = makeMetadataFactory('Optional');\nvar createSelf = makeMetadataFactory('Self');\nvar createSkipSelf = makeMetadataFactory('SkipSelf');\nvar createHost = makeMetadataFactory('Host');\nvar Type = Function;\nvar SecurityContext;\n\n(function (SecurityContext) {\n  SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\n  SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\n  SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\n  SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\n  SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\n  SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n})(SecurityContext || (SecurityContext = {}));\n\nvar MissingTranslationStrategy;\n\n(function (MissingTranslationStrategy) {\n  MissingTranslationStrategy[MissingTranslationStrategy[\"Error\"] = 0] = \"Error\";\n  MissingTranslationStrategy[MissingTranslationStrategy[\"Warning\"] = 1] = \"Warning\";\n  MissingTranslationStrategy[MissingTranslationStrategy[\"Ignore\"] = 2] = \"Ignore\";\n})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));\n\nfunction makeMetadataFactory(name, props) {\n  // This must be declared as a function, not a fat arrow, so that ES2015 devmode produces code\n  // that works with the static_reflector.ts in the ViewEngine compiler.\n  // In particular, `_registerDecoratorOrConstructor` assumes that the value returned here can be\n  // new'ed.\n  function factory() {\n    var values = props ? props.apply(void 0, arguments) : {};\n    return Object.assign({\n      ngMetadataName: name\n    }, values);\n  }\n\n  factory.isTypeOf = function (obj) {\n    return obj && obj.ngMetadataName === name;\n  };\n\n  factory.ngMetadataName = name;\n  return factory;\n}\n\nfunction parserSelectorToSimpleSelector(selector) {\n  var classes = selector.classNames && selector.classNames.length ? [8\n  /* CLASS */\n  ].concat(_toConsumableArray(selector.classNames)) : [];\n  var elementName = selector.element && selector.element !== '*' ? selector.element : '';\n  return [elementName].concat(_toConsumableArray(selector.attrs), _toConsumableArray(classes));\n}\n\nfunction parserSelectorToNegativeSelector(selector) {\n  var classes = selector.classNames && selector.classNames.length ? [8\n  /* CLASS */\n  ].concat(_toConsumableArray(selector.classNames)) : [];\n\n  if (selector.element) {\n    return [1\n    /* NOT */\n    | 4\n    /* ELEMENT */\n    , selector.element].concat(_toConsumableArray(selector.attrs), _toConsumableArray(classes));\n  } else if (selector.attrs.length) {\n    return [1\n    /* NOT */\n    | 2\n    /* ATTRIBUTE */\n    ].concat(_toConsumableArray(selector.attrs), _toConsumableArray(classes));\n  } else {\n    return selector.classNames && selector.classNames.length ? [1\n    /* NOT */\n    | 8\n    /* CLASS */\n    ].concat(_toConsumableArray(selector.classNames)) : [];\n  }\n}\n\nfunction parserSelectorToR3Selector(selector) {\n  var positive = parserSelectorToSimpleSelector(selector);\n  var negative = selector.notSelectors && selector.notSelectors.length ? selector.notSelectors.map(function (notSelector) {\n    return parserSelectorToNegativeSelector(notSelector);\n  }) : [];\n  return positive.concat.apply(positive, _toConsumableArray(negative));\n}\n\nfunction parseSelectorToR3Selector(selector) {\n  return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];\n}\n\nvar core = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  createInject: createInject,\n  createInjectionToken: createInjectionToken,\n  createAttribute: createAttribute,\n  emitDistinctChangesOnlyDefaultValue: emitDistinctChangesOnlyDefaultValue,\n  createContentChildren: createContentChildren,\n  createContentChild: createContentChild,\n  createViewChildren: createViewChildren,\n  createViewChild: createViewChild,\n  createDirective: createDirective,\n\n  get ViewEncapsulation() {\n    return ViewEncapsulation;\n  },\n\n  get ChangeDetectionStrategy() {\n    return ChangeDetectionStrategy;\n  },\n\n  createComponent: createComponent,\n  createPipe: createPipe,\n  createInput: createInput,\n  createOutput: createOutput,\n  createHostBinding: createHostBinding,\n  createHostListener: createHostListener,\n  createNgModule: createNgModule,\n  createInjectable: createInjectable,\n  CUSTOM_ELEMENTS_SCHEMA: CUSTOM_ELEMENTS_SCHEMA,\n  NO_ERRORS_SCHEMA: NO_ERRORS_SCHEMA,\n  createOptional: createOptional,\n  createSelf: createSelf,\n  createSkipSelf: createSkipSelf,\n  createHost: createHost,\n  Type: Type,\n\n  get SecurityContext() {\n    return SecurityContext;\n  },\n\n  get MissingTranslationStrategy() {\n    return MissingTranslationStrategy;\n  },\n\n  parseSelectorToR3Selector: parseSelectorToR3Selector\n});\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n//// Types\n\nvar TypeModifier;\n\n(function (TypeModifier) {\n  TypeModifier[TypeModifier[\"Const\"] = 0] = \"Const\";\n})(TypeModifier || (TypeModifier = {}));\n\nvar Type$1 = /*#__PURE__*/function () {\n  function Type$1() {\n    var modifiers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, Type$1);\n\n    this.modifiers = modifiers;\n  }\n\n  _createClass(Type$1, [{\n    key: \"hasModifier\",\n    value: function hasModifier(modifier) {\n      return this.modifiers.indexOf(modifier) !== -1;\n    }\n  }]);\n\n  return Type$1;\n}();\n\nvar BuiltinTypeName;\n\n(function (BuiltinTypeName) {\n  BuiltinTypeName[BuiltinTypeName[\"Dynamic\"] = 0] = \"Dynamic\";\n  BuiltinTypeName[BuiltinTypeName[\"Bool\"] = 1] = \"Bool\";\n  BuiltinTypeName[BuiltinTypeName[\"String\"] = 2] = \"String\";\n  BuiltinTypeName[BuiltinTypeName[\"Int\"] = 3] = \"Int\";\n  BuiltinTypeName[BuiltinTypeName[\"Number\"] = 4] = \"Number\";\n  BuiltinTypeName[BuiltinTypeName[\"Function\"] = 5] = \"Function\";\n  BuiltinTypeName[BuiltinTypeName[\"Inferred\"] = 6] = \"Inferred\";\n  BuiltinTypeName[BuiltinTypeName[\"None\"] = 7] = \"None\";\n})(BuiltinTypeName || (BuiltinTypeName = {}));\n\nvar BuiltinType = /*#__PURE__*/function (_Type$) {\n  _inherits(BuiltinType, _Type$);\n\n  var _super = _createSuper(BuiltinType);\n\n  function BuiltinType(name, modifiers) {\n    var _this2;\n\n    _classCallCheck(this, BuiltinType);\n\n    _this2 = _super.call(this, modifiers);\n    _this2.name = name;\n    return _this2;\n  }\n\n  _createClass(BuiltinType, [{\n    key: \"visitType\",\n    value: function visitType(visitor, context) {\n      return visitor.visitBuiltinType(this, context);\n    }\n  }]);\n\n  return BuiltinType;\n}(Type$1);\n\nvar ExpressionType = /*#__PURE__*/function (_Type$2) {\n  _inherits(ExpressionType, _Type$2);\n\n  var _super2 = _createSuper(ExpressionType);\n\n  function ExpressionType(value, modifiers) {\n    var _this3;\n\n    var typeParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, ExpressionType);\n\n    _this3 = _super2.call(this, modifiers);\n    _this3.value = value;\n    _this3.typeParams = typeParams;\n    return _this3;\n  }\n\n  _createClass(ExpressionType, [{\n    key: \"visitType\",\n    value: function visitType(visitor, context) {\n      return visitor.visitExpressionType(this, context);\n    }\n  }]);\n\n  return ExpressionType;\n}(Type$1);\n\nvar ArrayType = /*#__PURE__*/function (_Type$3) {\n  _inherits(ArrayType, _Type$3);\n\n  var _super3 = _createSuper(ArrayType);\n\n  function ArrayType(of, modifiers) {\n    var _this4;\n\n    _classCallCheck(this, ArrayType);\n\n    _this4 = _super3.call(this, modifiers);\n    _this4.of = of;\n    return _this4;\n  }\n\n  _createClass(ArrayType, [{\n    key: \"visitType\",\n    value: function visitType(visitor, context) {\n      return visitor.visitArrayType(this, context);\n    }\n  }]);\n\n  return ArrayType;\n}(Type$1);\n\nvar MapType = /*#__PURE__*/function (_Type$4) {\n  _inherits(MapType, _Type$4);\n\n  var _super4 = _createSuper(MapType);\n\n  function MapType(valueType, modifiers) {\n    var _this5;\n\n    _classCallCheck(this, MapType);\n\n    _this5 = _super4.call(this, modifiers);\n    _this5.valueType = valueType || null;\n    return _this5;\n  }\n\n  _createClass(MapType, [{\n    key: \"visitType\",\n    value: function visitType(visitor, context) {\n      return visitor.visitMapType(this, context);\n    }\n  }]);\n\n  return MapType;\n}(Type$1);\n\nvar DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nvar INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nvar BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nvar INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nvar NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nvar STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nvar FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nvar NONE_TYPE = new BuiltinType(BuiltinTypeName.None); ///// Expressions\n\nvar UnaryOperator;\n\n(function (UnaryOperator) {\n  UnaryOperator[UnaryOperator[\"Minus\"] = 0] = \"Minus\";\n  UnaryOperator[UnaryOperator[\"Plus\"] = 1] = \"Plus\";\n})(UnaryOperator || (UnaryOperator = {}));\n\nvar BinaryOperator;\n\n(function (BinaryOperator) {\n  BinaryOperator[BinaryOperator[\"Equals\"] = 0] = \"Equals\";\n  BinaryOperator[BinaryOperator[\"NotEquals\"] = 1] = \"NotEquals\";\n  BinaryOperator[BinaryOperator[\"Identical\"] = 2] = \"Identical\";\n  BinaryOperator[BinaryOperator[\"NotIdentical\"] = 3] = \"NotIdentical\";\n  BinaryOperator[BinaryOperator[\"Minus\"] = 4] = \"Minus\";\n  BinaryOperator[BinaryOperator[\"Plus\"] = 5] = \"Plus\";\n  BinaryOperator[BinaryOperator[\"Divide\"] = 6] = \"Divide\";\n  BinaryOperator[BinaryOperator[\"Multiply\"] = 7] = \"Multiply\";\n  BinaryOperator[BinaryOperator[\"Modulo\"] = 8] = \"Modulo\";\n  BinaryOperator[BinaryOperator[\"And\"] = 9] = \"And\";\n  BinaryOperator[BinaryOperator[\"Or\"] = 10] = \"Or\";\n  BinaryOperator[BinaryOperator[\"BitwiseAnd\"] = 11] = \"BitwiseAnd\";\n  BinaryOperator[BinaryOperator[\"Lower\"] = 12] = \"Lower\";\n  BinaryOperator[BinaryOperator[\"LowerEquals\"] = 13] = \"LowerEquals\";\n  BinaryOperator[BinaryOperator[\"Bigger\"] = 14] = \"Bigger\";\n  BinaryOperator[BinaryOperator[\"BiggerEquals\"] = 15] = \"BiggerEquals\";\n  BinaryOperator[BinaryOperator[\"NullishCoalesce\"] = 16] = \"NullishCoalesce\";\n})(BinaryOperator || (BinaryOperator = {}));\n\nfunction nullSafeIsEquivalent(base, other) {\n  if (base == null || other == null) {\n    return base == other;\n  }\n\n  return base.isEquivalent(other);\n}\n\nfunction areAllEquivalentPredicate(base, other, equivalentPredicate) {\n  var len = base.length;\n\n  if (len !== other.length) {\n    return false;\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (!equivalentPredicate(base[i], other[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction areAllEquivalent(base, other) {\n  return areAllEquivalentPredicate(base, other, function (baseElement, otherElement) {\n    return baseElement.isEquivalent(otherElement);\n  });\n}\n\nvar Expression = /*#__PURE__*/function () {\n  function Expression(type, sourceSpan) {\n    _classCallCheck(this, Expression);\n\n    this.type = type || null;\n    this.sourceSpan = sourceSpan || null;\n  }\n\n  _createClass(Expression, [{\n    key: \"prop\",\n    value: function prop(name, sourceSpan) {\n      return new ReadPropExpr(this, name, null, sourceSpan);\n    }\n  }, {\n    key: \"key\",\n    value: function key(index, type, sourceSpan) {\n      return new ReadKeyExpr(this, index, type, sourceSpan);\n    }\n  }, {\n    key: \"callMethod\",\n    value: function callMethod(name, params, sourceSpan) {\n      return new InvokeMethodExpr(this, name, params, null, sourceSpan);\n    }\n  }, {\n    key: \"callFn\",\n    value: function callFn(params, sourceSpan, pure) {\n      return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);\n    }\n  }, {\n    key: \"instantiate\",\n    value: function instantiate(params, type, sourceSpan) {\n      return new InstantiateExpr(this, params, type, sourceSpan);\n    }\n  }, {\n    key: \"conditional\",\n    value: function conditional(trueCase) {\n      var falseCase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var sourceSpan = arguments.length > 2 ? arguments[2] : undefined;\n      return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"notEquals\",\n    value: function notEquals(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"identical\",\n    value: function identical(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"notIdentical\",\n    value: function notIdentical(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"minus\",\n    value: function minus(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"plus\",\n    value: function plus(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"divide\",\n    value: function divide(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"modulo\",\n    value: function modulo(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"and\",\n    value: function and(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"bitwiseAnd\",\n    value: function bitwiseAnd(rhs, sourceSpan) {\n      var parens = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);\n    }\n  }, {\n    key: \"or\",\n    value: function or(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"lower\",\n    value: function lower(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"lowerEquals\",\n    value: function lowerEquals(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"bigger\",\n    value: function bigger(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"biggerEquals\",\n    value: function biggerEquals(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"isBlank\",\n    value: function isBlank(sourceSpan) {\n      // Note: We use equals by purpose here to compare to null and undefined in JS.\n      // We use the typed null to allow strictNullChecks to narrow types.\n      return this.equals(TYPED_NULL_EXPR, sourceSpan);\n    }\n  }, {\n    key: \"cast\",\n    value: function cast(type, sourceSpan) {\n      return new CastExpr(this, type, sourceSpan);\n    }\n  }, {\n    key: \"nullishCoalesce\",\n    value: function nullishCoalesce(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"toStmt\",\n    value: function toStmt() {\n      return new ExpressionStatement(this, null);\n    }\n  }]);\n\n  return Expression;\n}();\n\nvar BuiltinVar;\n\n(function (BuiltinVar) {\n  BuiltinVar[BuiltinVar[\"This\"] = 0] = \"This\";\n  BuiltinVar[BuiltinVar[\"Super\"] = 1] = \"Super\";\n  BuiltinVar[BuiltinVar[\"CatchError\"] = 2] = \"CatchError\";\n  BuiltinVar[BuiltinVar[\"CatchStack\"] = 3] = \"CatchStack\";\n})(BuiltinVar || (BuiltinVar = {}));\n\nvar ReadVarExpr = /*#__PURE__*/function (_Expression) {\n  _inherits(ReadVarExpr, _Expression);\n\n  var _super5 = _createSuper(ReadVarExpr);\n\n  function ReadVarExpr(name, type, sourceSpan) {\n    var _this6;\n\n    _classCallCheck(this, ReadVarExpr);\n\n    _this6 = _super5.call(this, type, sourceSpan);\n\n    if (typeof name === 'string') {\n      _this6.name = name;\n      _this6.builtin = null;\n    } else {\n      _this6.name = null;\n      _this6.builtin = name;\n    }\n\n    return _this6;\n  }\n\n  _createClass(ReadVarExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof ReadVarExpr && this.name === e.name && this.builtin === e.builtin;\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitReadVarExpr(this, context);\n    }\n  }, {\n    key: \"set\",\n    value: function set(value) {\n      if (!this.name) {\n        throw new Error(\"Built in variable \".concat(this.builtin, \" can not be assigned to.\"));\n      }\n\n      return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n    }\n  }]);\n\n  return ReadVarExpr;\n}(Expression);\n\nvar TypeofExpr = /*#__PURE__*/function (_Expression2) {\n  _inherits(TypeofExpr, _Expression2);\n\n  var _super6 = _createSuper(TypeofExpr);\n\n  function TypeofExpr(expr, type, sourceSpan) {\n    var _this7;\n\n    _classCallCheck(this, TypeofExpr);\n\n    _this7 = _super6.call(this, type, sourceSpan);\n    _this7.expr = expr;\n    return _this7;\n  }\n\n  _createClass(TypeofExpr, [{\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitTypeofExpr(this, context);\n    }\n  }, {\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return this.expr.isConstant();\n    }\n  }]);\n\n  return TypeofExpr;\n}(Expression);\n\nvar WrappedNodeExpr = /*#__PURE__*/function (_Expression3) {\n  _inherits(WrappedNodeExpr, _Expression3);\n\n  var _super7 = _createSuper(WrappedNodeExpr);\n\n  function WrappedNodeExpr(node, type, sourceSpan) {\n    var _this8;\n\n    _classCallCheck(this, WrappedNodeExpr);\n\n    _this8 = _super7.call(this, type, sourceSpan);\n    _this8.node = node;\n    return _this8;\n  }\n\n  _createClass(WrappedNodeExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof WrappedNodeExpr && this.node === e.node;\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitWrappedNodeExpr(this, context);\n    }\n  }]);\n\n  return WrappedNodeExpr;\n}(Expression);\n\nvar WriteVarExpr = /*#__PURE__*/function (_Expression4) {\n  _inherits(WriteVarExpr, _Expression4);\n\n  var _super8 = _createSuper(WriteVarExpr);\n\n  function WriteVarExpr(name, value, type, sourceSpan) {\n    var _this9;\n\n    _classCallCheck(this, WriteVarExpr);\n\n    _this9 = _super8.call(this, type || value.type, sourceSpan);\n    _this9.name = name;\n    _this9.value = value;\n    return _this9;\n  }\n\n  _createClass(WriteVarExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitWriteVarExpr(this, context);\n    }\n  }, {\n    key: \"toDeclStmt\",\n    value: function toDeclStmt(type, modifiers) {\n      return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n    }\n  }, {\n    key: \"toConstDecl\",\n    value: function toConstDecl() {\n      return this.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]);\n    }\n  }]);\n\n  return WriteVarExpr;\n}(Expression);\n\nvar WriteKeyExpr = /*#__PURE__*/function (_Expression5) {\n  _inherits(WriteKeyExpr, _Expression5);\n\n  var _super9 = _createSuper(WriteKeyExpr);\n\n  function WriteKeyExpr(receiver, index, value, type, sourceSpan) {\n    var _this10;\n\n    _classCallCheck(this, WriteKeyExpr);\n\n    _this10 = _super9.call(this, type || value.type, sourceSpan);\n    _this10.receiver = receiver;\n    _this10.index = index;\n    _this10.value = value;\n    return _this10;\n  }\n\n  _createClass(WriteKeyExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitWriteKeyExpr(this, context);\n    }\n  }]);\n\n  return WriteKeyExpr;\n}(Expression);\n\nvar WritePropExpr = /*#__PURE__*/function (_Expression6) {\n  _inherits(WritePropExpr, _Expression6);\n\n  var _super10 = _createSuper(WritePropExpr);\n\n  function WritePropExpr(receiver, name, value, type, sourceSpan) {\n    var _this11;\n\n    _classCallCheck(this, WritePropExpr);\n\n    _this11 = _super10.call(this, type || value.type, sourceSpan);\n    _this11.receiver = receiver;\n    _this11.name = name;\n    _this11.value = value;\n    return _this11;\n  }\n\n  _createClass(WritePropExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name && this.value.isEquivalent(e.value);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitWritePropExpr(this, context);\n    }\n  }]);\n\n  return WritePropExpr;\n}(Expression);\n\nvar BuiltinMethod;\n\n(function (BuiltinMethod) {\n  BuiltinMethod[BuiltinMethod[\"ConcatArray\"] = 0] = \"ConcatArray\";\n  BuiltinMethod[BuiltinMethod[\"SubscribeObservable\"] = 1] = \"SubscribeObservable\";\n  BuiltinMethod[BuiltinMethod[\"Bind\"] = 2] = \"Bind\";\n})(BuiltinMethod || (BuiltinMethod = {}));\n\nvar InvokeMethodExpr = /*#__PURE__*/function (_Expression7) {\n  _inherits(InvokeMethodExpr, _Expression7);\n\n  var _super11 = _createSuper(InvokeMethodExpr);\n\n  function InvokeMethodExpr(receiver, method, args, type, sourceSpan) {\n    var _this12;\n\n    _classCallCheck(this, InvokeMethodExpr);\n\n    _this12 = _super11.call(this, type, sourceSpan);\n    _this12.receiver = receiver;\n    _this12.args = args;\n\n    if (typeof method === 'string') {\n      _this12.name = method;\n      _this12.builtin = null;\n    } else {\n      _this12.name = null;\n      _this12.builtin = method;\n    }\n\n    return _this12;\n  }\n\n  _createClass(InvokeMethodExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof InvokeMethodExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name && this.builtin === e.builtin && areAllEquivalent(this.args, e.args);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitInvokeMethodExpr(this, context);\n    }\n  }]);\n\n  return InvokeMethodExpr;\n}(Expression);\n\nvar InvokeFunctionExpr = /*#__PURE__*/function (_Expression8) {\n  _inherits(InvokeFunctionExpr, _Expression8);\n\n  var _super12 = _createSuper(InvokeFunctionExpr);\n\n  function InvokeFunctionExpr(fn, args, type, sourceSpan) {\n    var _this13;\n\n    var pure = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    _classCallCheck(this, InvokeFunctionExpr);\n\n    _this13 = _super12.call(this, type, sourceSpan);\n    _this13.fn = fn;\n    _this13.args = args;\n    _this13.pure = pure;\n    return _this13;\n  }\n\n  _createClass(InvokeFunctionExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) && areAllEquivalent(this.args, e.args) && this.pure === e.pure;\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitInvokeFunctionExpr(this, context);\n    }\n  }]);\n\n  return InvokeFunctionExpr;\n}(Expression);\n\nvar TaggedTemplateExpr = /*#__PURE__*/function (_Expression9) {\n  _inherits(TaggedTemplateExpr, _Expression9);\n\n  var _super13 = _createSuper(TaggedTemplateExpr);\n\n  function TaggedTemplateExpr(tag, template, type, sourceSpan) {\n    var _this14;\n\n    _classCallCheck(this, TaggedTemplateExpr);\n\n    _this14 = _super13.call(this, type, sourceSpan);\n    _this14.tag = tag;\n    _this14.template = template;\n    return _this14;\n  }\n\n  _createClass(TaggedTemplateExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof TaggedTemplateExpr && this.tag.isEquivalent(e.tag) && areAllEquivalentPredicate(this.template.elements, e.template.elements, function (a, b) {\n        return a.text === b.text;\n      }) && areAllEquivalent(this.template.expressions, e.template.expressions);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitTaggedTemplateExpr(this, context);\n    }\n  }]);\n\n  return TaggedTemplateExpr;\n}(Expression);\n\nvar InstantiateExpr = /*#__PURE__*/function (_Expression10) {\n  _inherits(InstantiateExpr, _Expression10);\n\n  var _super14 = _createSuper(InstantiateExpr);\n\n  function InstantiateExpr(classExpr, args, type, sourceSpan) {\n    var _this15;\n\n    _classCallCheck(this, InstantiateExpr);\n\n    _this15 = _super14.call(this, type, sourceSpan);\n    _this15.classExpr = classExpr;\n    _this15.args = args;\n    return _this15;\n  }\n\n  _createClass(InstantiateExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) && areAllEquivalent(this.args, e.args);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitInstantiateExpr(this, context);\n    }\n  }]);\n\n  return InstantiateExpr;\n}(Expression);\n\nvar LiteralExpr = /*#__PURE__*/function (_Expression11) {\n  _inherits(LiteralExpr, _Expression11);\n\n  var _super15 = _createSuper(LiteralExpr);\n\n  function LiteralExpr(value, type, sourceSpan) {\n    var _this16;\n\n    _classCallCheck(this, LiteralExpr);\n\n    _this16 = _super15.call(this, type, sourceSpan);\n    _this16.value = value;\n    return _this16;\n  }\n\n  _createClass(LiteralExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof LiteralExpr && this.value === e.value;\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return true;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitLiteralExpr(this, context);\n    }\n  }]);\n\n  return LiteralExpr;\n}(Expression);\n\nvar TemplateLiteral = function TemplateLiteral(elements, expressions) {\n  _classCallCheck(this, TemplateLiteral);\n\n  this.elements = elements;\n  this.expressions = expressions;\n};\n\nvar TemplateLiteralElement = function TemplateLiteralElement(text, sourceSpan, rawText) {\n  _classCallCheck(this, TemplateLiteralElement);\n\n  var _a;\n\n  this.text = text;\n  this.sourceSpan = sourceSpan; // If `rawText` is not provided, try to extract the raw string from its\n  // associated `sourceSpan`. If that is also not available, \"fake\" the raw\n  // string instead by escaping the following control sequences:\n  // - \"\\\" would otherwise indicate that the next character is a control character.\n  // - \"`\" and \"${\" are template string control sequences that would otherwise prematurely\n  // indicate the end of the template literal element.\n\n  this.rawText = (_a = rawText !== null && rawText !== void 0 ? rawText : sourceSpan === null || sourceSpan === void 0 ? void 0 : sourceSpan.toString()) !== null && _a !== void 0 ? _a : escapeForTemplateLiteral(escapeSlashes(text));\n};\n\nvar MessagePiece = function MessagePiece(text, sourceSpan) {\n  _classCallCheck(this, MessagePiece);\n\n  this.text = text;\n  this.sourceSpan = sourceSpan;\n};\n\nvar LiteralPiece = /*#__PURE__*/function (_MessagePiece) {\n  _inherits(LiteralPiece, _MessagePiece);\n\n  var _super16 = _createSuper(LiteralPiece);\n\n  function LiteralPiece() {\n    _classCallCheck(this, LiteralPiece);\n\n    return _super16.apply(this, arguments);\n  }\n\n  return LiteralPiece;\n}(MessagePiece);\n\nvar PlaceholderPiece = /*#__PURE__*/function (_MessagePiece2) {\n  _inherits(PlaceholderPiece, _MessagePiece2);\n\n  var _super17 = _createSuper(PlaceholderPiece);\n\n  function PlaceholderPiece() {\n    _classCallCheck(this, PlaceholderPiece);\n\n    return _super17.apply(this, arguments);\n  }\n\n  return PlaceholderPiece;\n}(MessagePiece);\n\nvar LocalizedString = /*#__PURE__*/function (_Expression12) {\n  _inherits(LocalizedString, _Expression12);\n\n  var _super18 = _createSuper(LocalizedString);\n\n  function LocalizedString(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {\n    var _this17;\n\n    _classCallCheck(this, LocalizedString);\n\n    _this17 = _super18.call(this, STRING_TYPE, sourceSpan);\n    _this17.metaBlock = metaBlock;\n    _this17.messageParts = messageParts;\n    _this17.placeHolderNames = placeHolderNames;\n    _this17.expressions = expressions;\n    return _this17;\n  }\n\n  _createClass(LocalizedString, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      // return e instanceof LocalizedString && this.message === e.message;\n      return false;\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitLocalizedString(this, context);\n    }\n    /**\r\n     * Serialize the given `meta` and `messagePart` into \"cooked\" and \"raw\" strings that can be used\r\n     * in a `$localize` tagged string. The format of the metadata is the same as that parsed by\r\n     * `parseI18nMeta()`.\r\n     *\r\n     * @param meta The metadata to serialize\r\n     * @param messagePart The first part of the tagged string\r\n     */\n\n  }, {\n    key: \"serializeI18nHead\",\n    value: function serializeI18nHead() {\n      var MEANING_SEPARATOR = '|';\n      var ID_SEPARATOR = '@@';\n      var LEGACY_ID_INDICATOR = '␟';\n      var metaBlock = this.metaBlock.description || '';\n\n      if (this.metaBlock.meaning) {\n        metaBlock = \"\".concat(this.metaBlock.meaning).concat(MEANING_SEPARATOR).concat(metaBlock);\n      }\n\n      if (this.metaBlock.customId) {\n        metaBlock = \"\".concat(metaBlock).concat(ID_SEPARATOR).concat(this.metaBlock.customId);\n      }\n\n      if (this.metaBlock.legacyIds) {\n        this.metaBlock.legacyIds.forEach(function (legacyId) {\n          metaBlock = \"\".concat(metaBlock).concat(LEGACY_ID_INDICATOR).concat(legacyId);\n        });\n      }\n\n      return createCookedRawString(metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));\n    }\n  }, {\n    key: \"getMessagePartSourceSpan\",\n    value: function getMessagePartSourceSpan(i) {\n      var _a, _b;\n\n      return (_b = (_a = this.messageParts[i]) === null || _a === void 0 ? void 0 : _a.sourceSpan) !== null && _b !== void 0 ? _b : this.sourceSpan;\n    }\n  }, {\n    key: \"getPlaceholderSourceSpan\",\n    value: function getPlaceholderSourceSpan(i) {\n      var _a, _b, _c, _d;\n\n      return (_d = (_b = (_a = this.placeHolderNames[i]) === null || _a === void 0 ? void 0 : _a.sourceSpan) !== null && _b !== void 0 ? _b : (_c = this.expressions[i]) === null || _c === void 0 ? void 0 : _c.sourceSpan) !== null && _d !== void 0 ? _d : this.sourceSpan;\n    }\n    /**\r\n     * Serialize the given `placeholderName` and `messagePart` into \"cooked\" and \"raw\" strings that\r\n     * can be used in a `$localize` tagged string.\r\n     *\r\n     * @param placeholderName The placeholder name to serialize\r\n     * @param messagePart The following message string after this placeholder\r\n     */\n\n  }, {\n    key: \"serializeI18nTemplatePart\",\n    value: function serializeI18nTemplatePart(partIndex) {\n      var placeholderName = this.placeHolderNames[partIndex - 1].text;\n      var messagePart = this.messageParts[partIndex];\n      return createCookedRawString(placeholderName, messagePart.text, this.getMessagePartSourceSpan(partIndex));\n    }\n  }]);\n\n  return LocalizedString;\n}(Expression);\n\nvar escapeSlashes = function escapeSlashes(str) {\n  return str.replace(/\\\\/g, '\\\\\\\\');\n};\n\nvar escapeStartingColon = function escapeStartingColon(str) {\n  return str.replace(/^:/, '\\\\:');\n};\n\nvar escapeColons = function escapeColons(str) {\n  return str.replace(/:/g, '\\\\:');\n};\n\nvar escapeForTemplateLiteral = function escapeForTemplateLiteral(str) {\n  return str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\n};\n/**\r\n * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.\r\n *\r\n * The `raw` text must have various character sequences escaped:\r\n * * \"\\\" would otherwise indicate that the next character is a control character.\r\n * * \"`\" and \"${\" are template string control sequences that would otherwise prematurely indicate\r\n *   the end of a message part.\r\n * * \":\" inside a metablock would prematurely indicate the end of the metablock.\r\n * * \":\" at the start of a messagePart with no metablock would erroneously indicate the start of a\r\n *   metablock.\r\n *\r\n * @param metaBlock Any metadata that should be prepended to the string\r\n * @param messagePart The message part of the string\r\n */\n\n\nfunction createCookedRawString(metaBlock, messagePart, range) {\n  if (metaBlock === '') {\n    return {\n      cooked: messagePart,\n      raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),\n      range: range\n    };\n  } else {\n    return {\n      cooked: \":\".concat(metaBlock, \":\").concat(messagePart),\n      raw: escapeForTemplateLiteral(\":\".concat(escapeColons(escapeSlashes(metaBlock)), \":\").concat(escapeSlashes(messagePart))),\n      range: range\n    };\n  }\n}\n\nvar ExternalExpr = /*#__PURE__*/function (_Expression13) {\n  _inherits(ExternalExpr, _Expression13);\n\n  var _super19 = _createSuper(ExternalExpr);\n\n  function ExternalExpr(value, type) {\n    var _this18;\n\n    var typeParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var sourceSpan = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, ExternalExpr);\n\n    _this18 = _super19.call(this, type, sourceSpan);\n    _this18.value = value;\n    _this18.typeParams = typeParams;\n    return _this18;\n  }\n\n  _createClass(ExternalExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof ExternalExpr && this.value.name === e.value.name && this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitExternalExpr(this, context);\n    }\n  }]);\n\n  return ExternalExpr;\n}(Expression);\n\nvar ExternalReference = function ExternalReference(moduleName, name, runtime) {\n  _classCallCheck(this, ExternalReference);\n\n  this.moduleName = moduleName;\n  this.name = name;\n  this.runtime = runtime;\n};\n\nvar ConditionalExpr = /*#__PURE__*/function (_Expression14) {\n  _inherits(ConditionalExpr, _Expression14);\n\n  var _super20 = _createSuper(ConditionalExpr);\n\n  function ConditionalExpr(condition, trueCase) {\n    var _this19;\n\n    var falseCase = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var type = arguments.length > 3 ? arguments[3] : undefined;\n    var sourceSpan = arguments.length > 4 ? arguments[4] : undefined;\n\n    _classCallCheck(this, ConditionalExpr);\n\n    _this19 = _super20.call(this, type || trueCase.type, sourceSpan);\n    _this19.condition = condition;\n    _this19.falseCase = falseCase;\n    _this19.trueCase = trueCase;\n    return _this19;\n  }\n\n  _createClass(ConditionalExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) && this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitConditionalExpr(this, context);\n    }\n  }]);\n\n  return ConditionalExpr;\n}(Expression);\n\nvar NotExpr = /*#__PURE__*/function (_Expression15) {\n  _inherits(NotExpr, _Expression15);\n\n  var _super21 = _createSuper(NotExpr);\n\n  function NotExpr(condition, sourceSpan) {\n    var _this20;\n\n    _classCallCheck(this, NotExpr);\n\n    _this20 = _super21.call(this, BOOL_TYPE, sourceSpan);\n    _this20.condition = condition;\n    return _this20;\n  }\n\n  _createClass(NotExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitNotExpr(this, context);\n    }\n  }]);\n\n  return NotExpr;\n}(Expression);\n\nvar AssertNotNull = /*#__PURE__*/function (_Expression16) {\n  _inherits(AssertNotNull, _Expression16);\n\n  var _super22 = _createSuper(AssertNotNull);\n\n  function AssertNotNull(condition, sourceSpan) {\n    var _this21;\n\n    _classCallCheck(this, AssertNotNull);\n\n    _this21 = _super22.call(this, condition.type, sourceSpan);\n    _this21.condition = condition;\n    return _this21;\n  }\n\n  _createClass(AssertNotNull, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof AssertNotNull && this.condition.isEquivalent(e.condition);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitAssertNotNullExpr(this, context);\n    }\n  }]);\n\n  return AssertNotNull;\n}(Expression);\n\nvar CastExpr = /*#__PURE__*/function (_Expression17) {\n  _inherits(CastExpr, _Expression17);\n\n  var _super23 = _createSuper(CastExpr);\n\n  function CastExpr(value, type, sourceSpan) {\n    var _this22;\n\n    _classCallCheck(this, CastExpr);\n\n    _this22 = _super23.call(this, type, sourceSpan);\n    _this22.value = value;\n    return _this22;\n  }\n\n  _createClass(CastExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof CastExpr && this.value.isEquivalent(e.value);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitCastExpr(this, context);\n    }\n  }]);\n\n  return CastExpr;\n}(Expression);\n\nvar FnParam = /*#__PURE__*/function () {\n  function FnParam(name) {\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, FnParam);\n\n    this.name = name;\n    this.type = type;\n  }\n\n  _createClass(FnParam, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(param) {\n      return this.name === param.name;\n    }\n  }]);\n\n  return FnParam;\n}();\n\nvar FunctionExpr = /*#__PURE__*/function (_Expression18) {\n  _inherits(FunctionExpr, _Expression18);\n\n  var _super24 = _createSuper(FunctionExpr);\n\n  function FunctionExpr(params, statements, type, sourceSpan, name) {\n    var _this23;\n\n    _classCallCheck(this, FunctionExpr);\n\n    _this23 = _super24.call(this, type, sourceSpan);\n    _this23.params = params;\n    _this23.statements = statements;\n    _this23.name = name;\n    return _this23;\n  }\n\n  _createClass(FunctionExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) && areAllEquivalent(this.statements, e.statements);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitFunctionExpr(this, context);\n    }\n  }, {\n    key: \"toDeclStmt\",\n    value: function toDeclStmt(name, modifiers) {\n      return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n    }\n  }]);\n\n  return FunctionExpr;\n}(Expression);\n\nvar UnaryOperatorExpr = /*#__PURE__*/function (_Expression19) {\n  _inherits(UnaryOperatorExpr, _Expression19);\n\n  var _super25 = _createSuper(UnaryOperatorExpr);\n\n  function UnaryOperatorExpr(operator, expr, type, sourceSpan) {\n    var _this24;\n\n    var parens = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n\n    _classCallCheck(this, UnaryOperatorExpr);\n\n    _this24 = _super25.call(this, type || NUMBER_TYPE, sourceSpan);\n    _this24.operator = operator;\n    _this24.expr = expr;\n    _this24.parens = parens;\n    return _this24;\n  }\n\n  _createClass(UnaryOperatorExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof UnaryOperatorExpr && this.operator === e.operator && this.expr.isEquivalent(e.expr);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitUnaryOperatorExpr(this, context);\n    }\n  }]);\n\n  return UnaryOperatorExpr;\n}(Expression);\n\nvar BinaryOperatorExpr = /*#__PURE__*/function (_Expression20) {\n  _inherits(BinaryOperatorExpr, _Expression20);\n\n  var _super26 = _createSuper(BinaryOperatorExpr);\n\n  function BinaryOperatorExpr(operator, lhs, rhs, type, sourceSpan) {\n    var _this25;\n\n    var parens = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n    _classCallCheck(this, BinaryOperatorExpr);\n\n    _this25 = _super26.call(this, type || lhs.type, sourceSpan);\n    _this25.operator = operator;\n    _this25.rhs = rhs;\n    _this25.parens = parens;\n    _this25.lhs = lhs;\n    return _this25;\n  }\n\n  _createClass(BinaryOperatorExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof BinaryOperatorExpr && this.operator === e.operator && this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitBinaryOperatorExpr(this, context);\n    }\n  }]);\n\n  return BinaryOperatorExpr;\n}(Expression);\n\nvar ReadPropExpr = /*#__PURE__*/function (_Expression21) {\n  _inherits(ReadPropExpr, _Expression21);\n\n  var _super27 = _createSuper(ReadPropExpr);\n\n  function ReadPropExpr(receiver, name, type, sourceSpan) {\n    var _this26;\n\n    _classCallCheck(this, ReadPropExpr);\n\n    _this26 = _super27.call(this, type, sourceSpan);\n    _this26.receiver = receiver;\n    _this26.name = name;\n    return _this26;\n  }\n\n  _createClass(ReadPropExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name;\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitReadPropExpr(this, context);\n    }\n  }, {\n    key: \"set\",\n    value: function set(value) {\n      return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n    }\n  }]);\n\n  return ReadPropExpr;\n}(Expression);\n\nvar ReadKeyExpr = /*#__PURE__*/function (_Expression22) {\n  _inherits(ReadKeyExpr, _Expression22);\n\n  var _super28 = _createSuper(ReadKeyExpr);\n\n  function ReadKeyExpr(receiver, index, type, sourceSpan) {\n    var _this27;\n\n    _classCallCheck(this, ReadKeyExpr);\n\n    _this27 = _super28.call(this, type, sourceSpan);\n    _this27.receiver = receiver;\n    _this27.index = index;\n    return _this27;\n  }\n\n  _createClass(ReadKeyExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitReadKeyExpr(this, context);\n    }\n  }, {\n    key: \"set\",\n    value: function set(value) {\n      return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n    }\n  }]);\n\n  return ReadKeyExpr;\n}(Expression);\n\nvar LiteralArrayExpr = /*#__PURE__*/function (_Expression23) {\n  _inherits(LiteralArrayExpr, _Expression23);\n\n  var _super29 = _createSuper(LiteralArrayExpr);\n\n  function LiteralArrayExpr(entries, type, sourceSpan) {\n    var _this28;\n\n    _classCallCheck(this, LiteralArrayExpr);\n\n    _this28 = _super29.call(this, type, sourceSpan);\n    _this28.entries = entries;\n    return _this28;\n  }\n\n  _createClass(LiteralArrayExpr, [{\n    key: \"isConstant\",\n    value: function isConstant() {\n      return this.entries.every(function (e) {\n        return e.isConstant();\n      });\n    }\n  }, {\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitLiteralArrayExpr(this, context);\n    }\n  }]);\n\n  return LiteralArrayExpr;\n}(Expression);\n\nvar LiteralMapEntry = /*#__PURE__*/function () {\n  function LiteralMapEntry(key, value, quoted) {\n    _classCallCheck(this, LiteralMapEntry);\n\n    this.key = key;\n    this.value = value;\n    this.quoted = quoted;\n  }\n\n  _createClass(LiteralMapEntry, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return this.key === e.key && this.value.isEquivalent(e.value);\n    }\n  }]);\n\n  return LiteralMapEntry;\n}();\n\nvar LiteralMapExpr = /*#__PURE__*/function (_Expression24) {\n  _inherits(LiteralMapExpr, _Expression24);\n\n  var _super30 = _createSuper(LiteralMapExpr);\n\n  function LiteralMapExpr(entries, type, sourceSpan) {\n    var _this29;\n\n    _classCallCheck(this, LiteralMapExpr);\n\n    _this29 = _super30.call(this, type, sourceSpan);\n    _this29.entries = entries;\n    _this29.valueType = null;\n\n    if (type) {\n      _this29.valueType = type.valueType;\n    }\n\n    return _this29;\n  }\n\n  _createClass(LiteralMapExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return this.entries.every(function (e) {\n        return e.value.isConstant();\n      });\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitLiteralMapExpr(this, context);\n    }\n  }]);\n\n  return LiteralMapExpr;\n}(Expression);\n\nvar CommaExpr = /*#__PURE__*/function (_Expression25) {\n  _inherits(CommaExpr, _Expression25);\n\n  var _super31 = _createSuper(CommaExpr);\n\n  function CommaExpr(parts, sourceSpan) {\n    var _this30;\n\n    _classCallCheck(this, CommaExpr);\n\n    _this30 = _super31.call(this, parts[parts.length - 1].type, sourceSpan);\n    _this30.parts = parts;\n    return _this30;\n  }\n\n  _createClass(CommaExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitCommaExpr(this, context);\n    }\n  }]);\n\n  return CommaExpr;\n}(Expression);\n\nvar THIS_EXPR = new ReadVarExpr(BuiltinVar.This, null, null);\nvar SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super, null, null);\nvar CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError, null, null);\nvar CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack, null, null);\nvar NULL_EXPR = new LiteralExpr(null, null, null);\nvar TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null); //// Statements\n\nvar StmtModifier;\n\n(function (StmtModifier) {\n  StmtModifier[StmtModifier[\"Final\"] = 0] = \"Final\";\n  StmtModifier[StmtModifier[\"Private\"] = 1] = \"Private\";\n  StmtModifier[StmtModifier[\"Exported\"] = 2] = \"Exported\";\n  StmtModifier[StmtModifier[\"Static\"] = 3] = \"Static\";\n})(StmtModifier || (StmtModifier = {}));\n\nvar LeadingComment = /*#__PURE__*/function () {\n  function LeadingComment(text, multiline, trailingNewline) {\n    _classCallCheck(this, LeadingComment);\n\n    this.text = text;\n    this.multiline = multiline;\n    this.trailingNewline = trailingNewline;\n  }\n\n  _createClass(LeadingComment, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.multiline ? \" \".concat(this.text, \" \") : this.text;\n    }\n  }]);\n\n  return LeadingComment;\n}();\n\nvar JSDocComment = /*#__PURE__*/function (_LeadingComment) {\n  _inherits(JSDocComment, _LeadingComment);\n\n  var _super32 = _createSuper(JSDocComment);\n\n  function JSDocComment(tags) {\n    var _this31;\n\n    _classCallCheck(this, JSDocComment);\n\n    _this31 = _super32.call(this, '',\n    /* multiline */\n    true,\n    /* trailingNewline */\n    true);\n    _this31.tags = tags;\n    return _this31;\n  }\n\n  _createClass(JSDocComment, [{\n    key: \"toString\",\n    value: function toString() {\n      return serializeTags(this.tags);\n    }\n  }]);\n\n  return JSDocComment;\n}(LeadingComment);\n\nvar Statement = /*#__PURE__*/function () {\n  function Statement() {\n    var modifiers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var sourceSpan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var leadingComments = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, Statement);\n\n    this.modifiers = modifiers;\n    this.sourceSpan = sourceSpan;\n    this.leadingComments = leadingComments;\n  }\n\n  _createClass(Statement, [{\n    key: \"hasModifier\",\n    value: function hasModifier(modifier) {\n      return this.modifiers.indexOf(modifier) !== -1;\n    }\n  }, {\n    key: \"addLeadingComment\",\n    value: function addLeadingComment(leadingComment) {\n      var _a;\n\n      this.leadingComments = (_a = this.leadingComments) !== null && _a !== void 0 ? _a : [];\n      this.leadingComments.push(leadingComment);\n    }\n  }]);\n\n  return Statement;\n}();\n\nvar DeclareVarStmt = /*#__PURE__*/function (_Statement) {\n  _inherits(DeclareVarStmt, _Statement);\n\n  var _super33 = _createSuper(DeclareVarStmt);\n\n  function DeclareVarStmt(name, value, type, modifiers, sourceSpan, leadingComments) {\n    var _this32;\n\n    _classCallCheck(this, DeclareVarStmt);\n\n    _this32 = _super33.call(this, modifiers, sourceSpan, leadingComments);\n    _this32.name = name;\n    _this32.value = value;\n    _this32.type = type || value && value.type || null;\n    return _this32;\n  }\n\n  _createClass(DeclareVarStmt, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(stmt) {\n      return stmt instanceof DeclareVarStmt && this.name === stmt.name && (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);\n    }\n  }, {\n    key: \"visitStatement\",\n    value: function visitStatement(visitor, context) {\n      return visitor.visitDeclareVarStmt(this, context);\n    }\n  }]);\n\n  return DeclareVarStmt;\n}(Statement);\n\nvar DeclareFunctionStmt = /*#__PURE__*/function (_Statement2) {\n  _inherits(DeclareFunctionStmt, _Statement2);\n\n  var _super34 = _createSuper(DeclareFunctionStmt);\n\n  function DeclareFunctionStmt(name, params, statements, type, modifiers, sourceSpan, leadingComments) {\n    var _this33;\n\n    _classCallCheck(this, DeclareFunctionStmt);\n\n    _this33 = _super34.call(this, modifiers, sourceSpan, leadingComments);\n    _this33.name = name;\n    _this33.params = params;\n    _this33.statements = statements;\n    _this33.type = type || null;\n    return _this33;\n  }\n\n  _createClass(DeclareFunctionStmt, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(stmt) {\n      return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) && areAllEquivalent(this.statements, stmt.statements);\n    }\n  }, {\n    key: \"visitStatement\",\n    value: function visitStatement(visitor, context) {\n      return visitor.visitDeclareFunctionStmt(this, context);\n    }\n  }]);\n\n  return DeclareFunctionStmt;\n}(Statement);\n\nvar ExpressionStatement = /*#__PURE__*/function (_Statement3) {\n  _inherits(ExpressionStatement, _Statement3);\n\n  var _super35 = _createSuper(ExpressionStatement);\n\n  function ExpressionStatement(expr, sourceSpan, leadingComments) {\n    var _this34;\n\n    _classCallCheck(this, ExpressionStatement);\n\n    _this34 = _super35.call(this, [], sourceSpan, leadingComments);\n    _this34.expr = expr;\n    return _this34;\n  }\n\n  _createClass(ExpressionStatement, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(stmt) {\n      return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n    }\n  }, {\n    key: \"visitStatement\",\n    value: function visitStatement(visitor, context) {\n      return visitor.visitExpressionStmt(this, context);\n    }\n  }]);\n\n  return ExpressionStatement;\n}(Statement);\n\nvar ReturnStatement = /*#__PURE__*/function (_Statement4) {\n  _inherits(ReturnStatement, _Statement4);\n\n  var _super36 = _createSuper(ReturnStatement);\n\n  function ReturnStatement(value) {\n    var _this35;\n\n    var sourceSpan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var leadingComments = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, ReturnStatement);\n\n    _this35 = _super36.call(this, [], sourceSpan, leadingComments);\n    _this35.value = value;\n    return _this35;\n  }\n\n  _createClass(ReturnStatement, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(stmt) {\n      return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n    }\n  }, {\n    key: \"visitStatement\",\n    value: function visitStatement(visitor, context) {\n      return visitor.visitReturnStmt(this, context);\n    }\n  }]);\n\n  return ReturnStatement;\n}(Statement);\n\nvar AbstractClassPart = /*#__PURE__*/function () {\n  function AbstractClassPart() {\n    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var modifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    _classCallCheck(this, AbstractClassPart);\n\n    this.type = type;\n    this.modifiers = modifiers;\n  }\n\n  _createClass(AbstractClassPart, [{\n    key: \"hasModifier\",\n    value: function hasModifier(modifier) {\n      return this.modifiers.indexOf(modifier) !== -1;\n    }\n  }]);\n\n  return AbstractClassPart;\n}();\n\nvar ClassField = /*#__PURE__*/function (_AbstractClassPart) {\n  _inherits(ClassField, _AbstractClassPart);\n\n  var _super37 = _createSuper(ClassField);\n\n  function ClassField(name, type, modifiers, initializer) {\n    var _this36;\n\n    _classCallCheck(this, ClassField);\n\n    _this36 = _super37.call(this, type, modifiers);\n    _this36.name = name;\n    _this36.initializer = initializer;\n    return _this36;\n  }\n\n  _createClass(ClassField, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(f) {\n      return this.name === f.name;\n    }\n  }]);\n\n  return ClassField;\n}(AbstractClassPart);\n\nvar ClassMethod = /*#__PURE__*/function (_AbstractClassPart2) {\n  _inherits(ClassMethod, _AbstractClassPart2);\n\n  var _super38 = _createSuper(ClassMethod);\n\n  function ClassMethod(name, params, body, type, modifiers) {\n    var _this37;\n\n    _classCallCheck(this, ClassMethod);\n\n    _this37 = _super38.call(this, type, modifiers);\n    _this37.name = name;\n    _this37.params = params;\n    _this37.body = body;\n    return _this37;\n  }\n\n  _createClass(ClassMethod, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(m) {\n      return this.name === m.name && areAllEquivalent(this.body, m.body);\n    }\n  }]);\n\n  return ClassMethod;\n}(AbstractClassPart);\n\nvar ClassGetter = /*#__PURE__*/function (_AbstractClassPart3) {\n  _inherits(ClassGetter, _AbstractClassPart3);\n\n  var _super39 = _createSuper(ClassGetter);\n\n  function ClassGetter(name, body, type, modifiers) {\n    var _this38;\n\n    _classCallCheck(this, ClassGetter);\n\n    _this38 = _super39.call(this, type, modifiers);\n    _this38.name = name;\n    _this38.body = body;\n    return _this38;\n  }\n\n  _createClass(ClassGetter, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(m) {\n      return this.name === m.name && areAllEquivalent(this.body, m.body);\n    }\n  }]);\n\n  return ClassGetter;\n}(AbstractClassPart);\n\nvar ClassStmt = /*#__PURE__*/function (_Statement5) {\n  _inherits(ClassStmt, _Statement5);\n\n  var _super40 = _createSuper(ClassStmt);\n\n  function ClassStmt(name, parent, fields, getters, constructorMethod, methods, modifiers, sourceSpan, leadingComments) {\n    var _this39;\n\n    _classCallCheck(this, ClassStmt);\n\n    _this39 = _super40.call(this, modifiers, sourceSpan, leadingComments);\n    _this39.name = name;\n    _this39.parent = parent;\n    _this39.fields = fields;\n    _this39.getters = getters;\n    _this39.constructorMethod = constructorMethod;\n    _this39.methods = methods;\n    return _this39;\n  }\n\n  _createClass(ClassStmt, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(stmt) {\n      return stmt instanceof ClassStmt && this.name === stmt.name && nullSafeIsEquivalent(this.parent, stmt.parent) && areAllEquivalent(this.fields, stmt.fields) && areAllEquivalent(this.getters, stmt.getters) && this.constructorMethod.isEquivalent(stmt.constructorMethod) && areAllEquivalent(this.methods, stmt.methods);\n    }\n  }, {\n    key: \"visitStatement\",\n    value: function visitStatement(visitor, context) {\n      return visitor.visitDeclareClassStmt(this, context);\n    }\n  }]);\n\n  return ClassStmt;\n}(Statement);\n\nvar IfStmt = /*#__PURE__*/function (_Statement6) {\n  _inherits(IfStmt, _Statement6);\n\n  var _super41 = _createSuper(IfStmt);\n\n  function IfStmt(condition, trueCase) {\n    var _this40;\n\n    var falseCase = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var sourceSpan = arguments.length > 3 ? arguments[3] : undefined;\n    var leadingComments = arguments.length > 4 ? arguments[4] : undefined;\n\n    _classCallCheck(this, IfStmt);\n\n    _this40 = _super41.call(this, [], sourceSpan, leadingComments);\n    _this40.condition = condition;\n    _this40.trueCase = trueCase;\n    _this40.falseCase = falseCase;\n    return _this40;\n  }\n\n  _createClass(IfStmt, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(stmt) {\n      return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) && areAllEquivalent(this.trueCase, stmt.trueCase) && areAllEquivalent(this.falseCase, stmt.falseCase);\n    }\n  }, {\n    key: \"visitStatement\",\n    value: function visitStatement(visitor, context) {\n      return visitor.visitIfStmt(this, context);\n    }\n  }]);\n\n  return IfStmt;\n}(Statement);\n\nvar TryCatchStmt = /*#__PURE__*/function (_Statement7) {\n  _inherits(TryCatchStmt, _Statement7);\n\n  var _super42 = _createSuper(TryCatchStmt);\n\n  function TryCatchStmt(bodyStmts, catchStmts) {\n    var _this41;\n\n    var sourceSpan = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var leadingComments = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, TryCatchStmt);\n\n    _this41 = _super42.call(this, [], sourceSpan, leadingComments);\n    _this41.bodyStmts = bodyStmts;\n    _this41.catchStmts = catchStmts;\n    return _this41;\n  }\n\n  _createClass(TryCatchStmt, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(stmt) {\n      return stmt instanceof TryCatchStmt && areAllEquivalent(this.bodyStmts, stmt.bodyStmts) && areAllEquivalent(this.catchStmts, stmt.catchStmts);\n    }\n  }, {\n    key: \"visitStatement\",\n    value: function visitStatement(visitor, context) {\n      return visitor.visitTryCatchStmt(this, context);\n    }\n  }]);\n\n  return TryCatchStmt;\n}(Statement);\n\nvar ThrowStmt = /*#__PURE__*/function (_Statement8) {\n  _inherits(ThrowStmt, _Statement8);\n\n  var _super43 = _createSuper(ThrowStmt);\n\n  function ThrowStmt(error) {\n    var _this42;\n\n    var sourceSpan = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var leadingComments = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, ThrowStmt);\n\n    _this42 = _super43.call(this, [], sourceSpan, leadingComments);\n    _this42.error = error;\n    return _this42;\n  }\n\n  _createClass(ThrowStmt, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(stmt) {\n      return stmt instanceof TryCatchStmt && this.error.isEquivalent(stmt.error);\n    }\n  }, {\n    key: \"visitStatement\",\n    value: function visitStatement(visitor, context) {\n      return visitor.visitThrowStmt(this, context);\n    }\n  }]);\n\n  return ThrowStmt;\n}(Statement);\n\nvar AstTransformer = /*#__PURE__*/function () {\n  function AstTransformer() {\n    _classCallCheck(this, AstTransformer);\n  }\n\n  _createClass(AstTransformer, [{\n    key: \"transformExpr\",\n    value: function transformExpr(expr, context) {\n      return expr;\n    }\n  }, {\n    key: \"transformStmt\",\n    value: function transformStmt(stmt, context) {\n      return stmt;\n    }\n  }, {\n    key: \"visitReadVarExpr\",\n    value: function visitReadVarExpr(ast, context) {\n      return this.transformExpr(ast, context);\n    }\n  }, {\n    key: \"visitWrappedNodeExpr\",\n    value: function visitWrappedNodeExpr(ast, context) {\n      return this.transformExpr(ast, context);\n    }\n  }, {\n    key: \"visitTypeofExpr\",\n    value: function visitTypeofExpr(expr, context) {\n      return this.transformExpr(new TypeofExpr(expr.expr.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    }\n  }, {\n    key: \"visitWriteVarExpr\",\n    value: function visitWriteVarExpr(expr, context) {\n      return this.transformExpr(new WriteVarExpr(expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    }\n  }, {\n    key: \"visitWriteKeyExpr\",\n    value: function visitWriteKeyExpr(expr, context) {\n      return this.transformExpr(new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    }\n  }, {\n    key: \"visitWritePropExpr\",\n    value: function visitWritePropExpr(expr, context) {\n      return this.transformExpr(new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    }\n  }, {\n    key: \"visitInvokeMethodExpr\",\n    value: function visitInvokeMethodExpr(ast, context) {\n      var method = ast.builtin || ast.name;\n      return this.transformExpr(new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitInvokeFunctionExpr\",\n    value: function visitInvokeFunctionExpr(ast, context) {\n      return this.transformExpr(new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitTaggedTemplateExpr\",\n    value: function visitTaggedTemplateExpr(ast, context) {\n      var _this43 = this;\n\n      return this.transformExpr(new TaggedTemplateExpr(ast.tag.visitExpression(this, context), new TemplateLiteral(ast.template.elements, ast.template.expressions.map(function (e) {\n        return e.visitExpression(_this43, context);\n      })), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitInstantiateExpr\",\n    value: function visitInstantiateExpr(ast, context) {\n      return this.transformExpr(new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitLiteralExpr\",\n    value: function visitLiteralExpr(ast, context) {\n      return this.transformExpr(ast, context);\n    }\n  }, {\n    key: \"visitLocalizedString\",\n    value: function visitLocalizedString(ast, context) {\n      return this.transformExpr(new LocalizedString(ast.metaBlock, ast.messageParts, ast.placeHolderNames, this.visitAllExpressions(ast.expressions, context), ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitExternalExpr\",\n    value: function visitExternalExpr(ast, context) {\n      return this.transformExpr(ast, context);\n    }\n  }, {\n    key: \"visitConditionalExpr\",\n    value: function visitConditionalExpr(ast, context) {\n      return this.transformExpr(new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitNotExpr\",\n    value: function visitNotExpr(ast, context) {\n      return this.transformExpr(new NotExpr(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitAssertNotNullExpr\",\n    value: function visitAssertNotNullExpr(ast, context) {\n      return this.transformExpr(new AssertNotNull(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitCastExpr\",\n    value: function visitCastExpr(ast, context) {\n      return this.transformExpr(new CastExpr(ast.value.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitFunctionExpr\",\n    value: function visitFunctionExpr(ast, context) {\n      return this.transformExpr(new FunctionExpr(ast.params, this.visitAllStatements(ast.statements, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitUnaryOperatorExpr\",\n    value: function visitUnaryOperatorExpr(ast, context) {\n      return this.transformExpr(new UnaryOperatorExpr(ast.operator, ast.expr.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitBinaryOperatorExpr\",\n    value: function visitBinaryOperatorExpr(ast, context) {\n      return this.transformExpr(new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitReadPropExpr\",\n    value: function visitReadPropExpr(ast, context) {\n      return this.transformExpr(new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitReadKeyExpr\",\n    value: function visitReadKeyExpr(ast, context) {\n      return this.transformExpr(new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitLiteralArrayExpr\",\n    value: function visitLiteralArrayExpr(ast, context) {\n      return this.transformExpr(new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitLiteralMapExpr\",\n    value: function visitLiteralMapExpr(ast, context) {\n      var _this44 = this;\n\n      var entries = ast.entries.map(function (entry) {\n        return new LiteralMapEntry(entry.key, entry.value.visitExpression(_this44, context), entry.quoted);\n      });\n      var mapType = new MapType(ast.valueType);\n      return this.transformExpr(new LiteralMapExpr(entries, mapType, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitCommaExpr\",\n    value: function visitCommaExpr(ast, context) {\n      return this.transformExpr(new CommaExpr(this.visitAllExpressions(ast.parts, context), ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitAllExpressions\",\n    value: function visitAllExpressions(exprs, context) {\n      var _this45 = this;\n\n      return exprs.map(function (expr) {\n        return expr.visitExpression(_this45, context);\n      });\n    }\n  }, {\n    key: \"visitDeclareVarStmt\",\n    value: function visitDeclareVarStmt(stmt, context) {\n      var value = stmt.value && stmt.value.visitExpression(this, context);\n      return this.transformStmt(new DeclareVarStmt(stmt.name, value, stmt.type, stmt.modifiers, stmt.sourceSpan, stmt.leadingComments), context);\n    }\n  }, {\n    key: \"visitDeclareFunctionStmt\",\n    value: function visitDeclareFunctionStmt(stmt, context) {\n      return this.transformStmt(new DeclareFunctionStmt(stmt.name, stmt.params, this.visitAllStatements(stmt.statements, context), stmt.type, stmt.modifiers, stmt.sourceSpan, stmt.leadingComments), context);\n    }\n  }, {\n    key: \"visitExpressionStmt\",\n    value: function visitExpressionStmt(stmt, context) {\n      return this.transformStmt(new ExpressionStatement(stmt.expr.visitExpression(this, context), stmt.sourceSpan, stmt.leadingComments), context);\n    }\n  }, {\n    key: \"visitReturnStmt\",\n    value: function visitReturnStmt(stmt, context) {\n      return this.transformStmt(new ReturnStatement(stmt.value.visitExpression(this, context), stmt.sourceSpan, stmt.leadingComments), context);\n    }\n  }, {\n    key: \"visitDeclareClassStmt\",\n    value: function visitDeclareClassStmt(stmt, context) {\n      var _this46 = this;\n\n      var parent = stmt.parent.visitExpression(this, context);\n      var getters = stmt.getters.map(function (getter) {\n        return new ClassGetter(getter.name, _this46.visitAllStatements(getter.body, context), getter.type, getter.modifiers);\n      });\n      var ctorMethod = stmt.constructorMethod && new ClassMethod(stmt.constructorMethod.name, stmt.constructorMethod.params, this.visitAllStatements(stmt.constructorMethod.body, context), stmt.constructorMethod.type, stmt.constructorMethod.modifiers);\n      var methods = stmt.methods.map(function (method) {\n        return new ClassMethod(method.name, method.params, _this46.visitAllStatements(method.body, context), method.type, method.modifiers);\n      });\n      return this.transformStmt(new ClassStmt(stmt.name, parent, stmt.fields, getters, ctorMethod, methods, stmt.modifiers, stmt.sourceSpan), context);\n    }\n  }, {\n    key: \"visitIfStmt\",\n    value: function visitIfStmt(stmt, context) {\n      return this.transformStmt(new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan, stmt.leadingComments), context);\n    }\n  }, {\n    key: \"visitTryCatchStmt\",\n    value: function visitTryCatchStmt(stmt, context) {\n      return this.transformStmt(new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context), stmt.sourceSpan, stmt.leadingComments), context);\n    }\n  }, {\n    key: \"visitThrowStmt\",\n    value: function visitThrowStmt(stmt, context) {\n      return this.transformStmt(new ThrowStmt(stmt.error.visitExpression(this, context), stmt.sourceSpan, stmt.leadingComments), context);\n    }\n  }, {\n    key: \"visitAllStatements\",\n    value: function visitAllStatements(stmts, context) {\n      var _this47 = this;\n\n      return stmts.map(function (stmt) {\n        return stmt.visitStatement(_this47, context);\n      });\n    }\n  }]);\n\n  return AstTransformer;\n}();\n\nvar RecursiveAstVisitor = /*#__PURE__*/function () {\n  function RecursiveAstVisitor() {\n    _classCallCheck(this, RecursiveAstVisitor);\n  }\n\n  _createClass(RecursiveAstVisitor, [{\n    key: \"visitType\",\n    value: function visitType(ast, context) {\n      return ast;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(ast, context) {\n      if (ast.type) {\n        ast.type.visitType(this, context);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitBuiltinType\",\n    value: function visitBuiltinType(type, context) {\n      return this.visitType(type, context);\n    }\n  }, {\n    key: \"visitExpressionType\",\n    value: function visitExpressionType(type, context) {\n      var _this48 = this;\n\n      type.value.visitExpression(this, context);\n\n      if (type.typeParams !== null) {\n        type.typeParams.forEach(function (param) {\n          return _this48.visitType(param, context);\n        });\n      }\n\n      return this.visitType(type, context);\n    }\n  }, {\n    key: \"visitArrayType\",\n    value: function visitArrayType(type, context) {\n      return this.visitType(type, context);\n    }\n  }, {\n    key: \"visitMapType\",\n    value: function visitMapType(type, context) {\n      return this.visitType(type, context);\n    }\n  }, {\n    key: \"visitWrappedNodeExpr\",\n    value: function visitWrappedNodeExpr(ast, context) {\n      return ast;\n    }\n  }, {\n    key: \"visitTypeofExpr\",\n    value: function visitTypeofExpr(ast, context) {\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitReadVarExpr\",\n    value: function visitReadVarExpr(ast, context) {\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitWriteVarExpr\",\n    value: function visitWriteVarExpr(ast, context) {\n      ast.value.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitWriteKeyExpr\",\n    value: function visitWriteKeyExpr(ast, context) {\n      ast.receiver.visitExpression(this, context);\n      ast.index.visitExpression(this, context);\n      ast.value.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitWritePropExpr\",\n    value: function visitWritePropExpr(ast, context) {\n      ast.receiver.visitExpression(this, context);\n      ast.value.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitInvokeMethodExpr\",\n    value: function visitInvokeMethodExpr(ast, context) {\n      ast.receiver.visitExpression(this, context);\n      this.visitAllExpressions(ast.args, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitInvokeFunctionExpr\",\n    value: function visitInvokeFunctionExpr(ast, context) {\n      ast.fn.visitExpression(this, context);\n      this.visitAllExpressions(ast.args, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitTaggedTemplateExpr\",\n    value: function visitTaggedTemplateExpr(ast, context) {\n      ast.tag.visitExpression(this, context);\n      this.visitAllExpressions(ast.template.expressions, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitInstantiateExpr\",\n    value: function visitInstantiateExpr(ast, context) {\n      ast.classExpr.visitExpression(this, context);\n      this.visitAllExpressions(ast.args, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitLiteralExpr\",\n    value: function visitLiteralExpr(ast, context) {\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitLocalizedString\",\n    value: function visitLocalizedString(ast, context) {\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitExternalExpr\",\n    value: function visitExternalExpr(ast, context) {\n      var _this49 = this;\n\n      if (ast.typeParams) {\n        ast.typeParams.forEach(function (type) {\n          return type.visitType(_this49, context);\n        });\n      }\n\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitConditionalExpr\",\n    value: function visitConditionalExpr(ast, context) {\n      ast.condition.visitExpression(this, context);\n      ast.trueCase.visitExpression(this, context);\n      ast.falseCase.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitNotExpr\",\n    value: function visitNotExpr(ast, context) {\n      ast.condition.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitAssertNotNullExpr\",\n    value: function visitAssertNotNullExpr(ast, context) {\n      ast.condition.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitCastExpr\",\n    value: function visitCastExpr(ast, context) {\n      ast.value.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitFunctionExpr\",\n    value: function visitFunctionExpr(ast, context) {\n      this.visitAllStatements(ast.statements, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitUnaryOperatorExpr\",\n    value: function visitUnaryOperatorExpr(ast, context) {\n      ast.expr.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitBinaryOperatorExpr\",\n    value: function visitBinaryOperatorExpr(ast, context) {\n      ast.lhs.visitExpression(this, context);\n      ast.rhs.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitReadPropExpr\",\n    value: function visitReadPropExpr(ast, context) {\n      ast.receiver.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitReadKeyExpr\",\n    value: function visitReadKeyExpr(ast, context) {\n      ast.receiver.visitExpression(this, context);\n      ast.index.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitLiteralArrayExpr\",\n    value: function visitLiteralArrayExpr(ast, context) {\n      this.visitAllExpressions(ast.entries, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitLiteralMapExpr\",\n    value: function visitLiteralMapExpr(ast, context) {\n      var _this50 = this;\n\n      ast.entries.forEach(function (entry) {\n        return entry.value.visitExpression(_this50, context);\n      });\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitCommaExpr\",\n    value: function visitCommaExpr(ast, context) {\n      this.visitAllExpressions(ast.parts, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitAllExpressions\",\n    value: function visitAllExpressions(exprs, context) {\n      var _this51 = this;\n\n      exprs.forEach(function (expr) {\n        return expr.visitExpression(_this51, context);\n      });\n    }\n  }, {\n    key: \"visitDeclareVarStmt\",\n    value: function visitDeclareVarStmt(stmt, context) {\n      if (stmt.value) {\n        stmt.value.visitExpression(this, context);\n      }\n\n      if (stmt.type) {\n        stmt.type.visitType(this, context);\n      }\n\n      return stmt;\n    }\n  }, {\n    key: \"visitDeclareFunctionStmt\",\n    value: function visitDeclareFunctionStmt(stmt, context) {\n      this.visitAllStatements(stmt.statements, context);\n\n      if (stmt.type) {\n        stmt.type.visitType(this, context);\n      }\n\n      return stmt;\n    }\n  }, {\n    key: \"visitExpressionStmt\",\n    value: function visitExpressionStmt(stmt, context) {\n      stmt.expr.visitExpression(this, context);\n      return stmt;\n    }\n  }, {\n    key: \"visitReturnStmt\",\n    value: function visitReturnStmt(stmt, context) {\n      stmt.value.visitExpression(this, context);\n      return stmt;\n    }\n  }, {\n    key: \"visitDeclareClassStmt\",\n    value: function visitDeclareClassStmt(stmt, context) {\n      var _this52 = this;\n\n      stmt.parent.visitExpression(this, context);\n      stmt.getters.forEach(function (getter) {\n        return _this52.visitAllStatements(getter.body, context);\n      });\n\n      if (stmt.constructorMethod) {\n        this.visitAllStatements(stmt.constructorMethod.body, context);\n      }\n\n      stmt.methods.forEach(function (method) {\n        return _this52.visitAllStatements(method.body, context);\n      });\n      return stmt;\n    }\n  }, {\n    key: \"visitIfStmt\",\n    value: function visitIfStmt(stmt, context) {\n      stmt.condition.visitExpression(this, context);\n      this.visitAllStatements(stmt.trueCase, context);\n      this.visitAllStatements(stmt.falseCase, context);\n      return stmt;\n    }\n  }, {\n    key: \"visitTryCatchStmt\",\n    value: function visitTryCatchStmt(stmt, context) {\n      this.visitAllStatements(stmt.bodyStmts, context);\n      this.visitAllStatements(stmt.catchStmts, context);\n      return stmt;\n    }\n  }, {\n    key: \"visitThrowStmt\",\n    value: function visitThrowStmt(stmt, context) {\n      stmt.error.visitExpression(this, context);\n      return stmt;\n    }\n  }, {\n    key: \"visitAllStatements\",\n    value: function visitAllStatements(stmts, context) {\n      var _this53 = this;\n\n      stmts.forEach(function (stmt) {\n        return stmt.visitStatement(_this53, context);\n      });\n    }\n  }]);\n\n  return RecursiveAstVisitor;\n}();\n\nfunction findReadVarNames(stmts) {\n  var visitor = new _ReadVarVisitor();\n  visitor.visitAllStatements(stmts, null);\n  return visitor.varNames;\n}\n\nvar _ReadVarVisitor = /*#__PURE__*/function (_RecursiveAstVisitor) {\n  _inherits(_ReadVarVisitor, _RecursiveAstVisitor);\n\n  var _super44 = _createSuper(_ReadVarVisitor);\n\n  function _ReadVarVisitor() {\n    var _this54;\n\n    _classCallCheck(this, _ReadVarVisitor);\n\n    _this54 = _super44.apply(this, arguments);\n    _this54.varNames = new Set();\n    return _this54;\n  }\n\n  _createClass(_ReadVarVisitor, [{\n    key: \"visitDeclareFunctionStmt\",\n    value: function visitDeclareFunctionStmt(stmt, context) {\n      // Don't descend into nested functions\n      return stmt;\n    }\n  }, {\n    key: \"visitDeclareClassStmt\",\n    value: function visitDeclareClassStmt(stmt, context) {\n      // Don't descend into nested classes\n      return stmt;\n    }\n  }, {\n    key: \"visitReadVarExpr\",\n    value: function visitReadVarExpr(ast, context) {\n      if (ast.name) {\n        this.varNames.add(ast.name);\n      }\n\n      return null;\n    }\n  }]);\n\n  return _ReadVarVisitor;\n}(RecursiveAstVisitor);\n\nfunction collectExternalReferences(stmts) {\n  var visitor = new _FindExternalReferencesVisitor();\n  visitor.visitAllStatements(stmts, null);\n  return visitor.externalReferences;\n}\n\nvar _FindExternalReferencesVisitor = /*#__PURE__*/function (_RecursiveAstVisitor2) {\n  _inherits(_FindExternalReferencesVisitor, _RecursiveAstVisitor2);\n\n  var _super45 = _createSuper(_FindExternalReferencesVisitor);\n\n  function _FindExternalReferencesVisitor() {\n    var _this55;\n\n    _classCallCheck(this, _FindExternalReferencesVisitor);\n\n    _this55 = _super45.apply(this, arguments);\n    _this55.externalReferences = [];\n    return _this55;\n  }\n\n  _createClass(_FindExternalReferencesVisitor, [{\n    key: \"visitExternalExpr\",\n    value: function visitExternalExpr(e, context) {\n      this.externalReferences.push(e.value);\n      return _get(_getPrototypeOf(_FindExternalReferencesVisitor.prototype), \"visitExternalExpr\", this).call(this, e, context);\n    }\n  }]);\n\n  return _FindExternalReferencesVisitor;\n}(RecursiveAstVisitor);\n\nfunction applySourceSpanToStatementIfNeeded(stmt, sourceSpan) {\n  if (!sourceSpan) {\n    return stmt;\n  }\n\n  var transformer = new _ApplySourceSpanTransformer(sourceSpan);\n  return stmt.visitStatement(transformer, null);\n}\n\nfunction applySourceSpanToExpressionIfNeeded(expr, sourceSpan) {\n  if (!sourceSpan) {\n    return expr;\n  }\n\n  var transformer = new _ApplySourceSpanTransformer(sourceSpan);\n  return expr.visitExpression(transformer, null);\n}\n\nvar _ApplySourceSpanTransformer = /*#__PURE__*/function (_AstTransformer) {\n  _inherits(_ApplySourceSpanTransformer, _AstTransformer);\n\n  var _super46 = _createSuper(_ApplySourceSpanTransformer);\n\n  function _ApplySourceSpanTransformer(sourceSpan) {\n    var _this56;\n\n    _classCallCheck(this, _ApplySourceSpanTransformer);\n\n    _this56 = _super46.call(this);\n    _this56.sourceSpan = sourceSpan;\n    return _this56;\n  }\n\n  _createClass(_ApplySourceSpanTransformer, [{\n    key: \"_clone\",\n    value: function _clone(obj) {\n      var clone = Object.create(obj.constructor.prototype);\n\n      for (var _i4 = 0, _Object$keys = Object.keys(obj); _i4 < _Object$keys.length; _i4++) {\n        var prop = _Object$keys[_i4];\n        clone[prop] = obj[prop];\n      }\n\n      return clone;\n    }\n  }, {\n    key: \"transformExpr\",\n    value: function transformExpr(expr, context) {\n      if (!expr.sourceSpan) {\n        expr = this._clone(expr);\n        expr.sourceSpan = this.sourceSpan;\n      }\n\n      return expr;\n    }\n  }, {\n    key: \"transformStmt\",\n    value: function transformStmt(stmt, context) {\n      if (!stmt.sourceSpan) {\n        stmt = this._clone(stmt);\n        stmt.sourceSpan = this.sourceSpan;\n      }\n\n      return stmt;\n    }\n  }]);\n\n  return _ApplySourceSpanTransformer;\n}(AstTransformer);\n\nfunction leadingComment(text) {\n  var multiline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var trailingNewline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  return new LeadingComment(text, multiline, trailingNewline);\n}\n\nfunction jsDocComment() {\n  var tags = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return new JSDocComment(tags);\n}\n\nfunction variable(name, type, sourceSpan) {\n  return new ReadVarExpr(name, type, sourceSpan);\n}\n\nfunction importExpr(id) {\n  var typeParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var sourceSpan = arguments.length > 2 ? arguments[2] : undefined;\n  return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\n\nfunction importType(id, typeParams, typeModifiers) {\n  return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\n\nfunction expressionType(expr, typeModifiers, typeParams) {\n  return new ExpressionType(expr, typeModifiers, typeParams);\n}\n\nfunction typeofExpr(expr) {\n  return new TypeofExpr(expr);\n}\n\nfunction literalArr(values, type, sourceSpan) {\n  return new LiteralArrayExpr(values, type, sourceSpan);\n}\n\nfunction literalMap(values) {\n  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return new LiteralMapExpr(values.map(function (e) {\n    return new LiteralMapEntry(e.key, e.value, e.quoted);\n  }), type, null);\n}\n\nfunction unary(operator, expr, type, sourceSpan) {\n  return new UnaryOperatorExpr(operator, expr, type, sourceSpan);\n}\n\nfunction not(expr, sourceSpan) {\n  return new NotExpr(expr, sourceSpan);\n}\n\nfunction assertNotNull(expr, sourceSpan) {\n  return new AssertNotNull(expr, sourceSpan);\n}\n\nfunction fn(params, body, type, sourceSpan, name) {\n  return new FunctionExpr(params, body, type, sourceSpan, name);\n}\n\nfunction ifStmt(condition, thenClause, elseClause, sourceSpan, leadingComments) {\n  return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);\n}\n\nfunction taggedTemplate(tag, template, type, sourceSpan) {\n  return new TaggedTemplateExpr(tag, template, type, sourceSpan);\n}\n\nfunction literal(value, type, sourceSpan) {\n  return new LiteralExpr(value, type, sourceSpan);\n}\n\nfunction localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {\n  return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\n}\n\nfunction isNull(exp) {\n  return exp instanceof LiteralExpr && exp.value === null;\n}\n/*\r\n * Serializes a `Tag` into a string.\r\n * Returns a string like \" @foo {bar} baz\" (note the leading whitespace before `@foo`).\r\n */\n\n\nfunction tagToString(tag) {\n  var out = '';\n\n  if (tag.tagName) {\n    out += \" @\".concat(tag.tagName);\n  }\n\n  if (tag.text) {\n    if (tag.text.match(/\\/\\*|\\*\\//)) {\n      throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n    }\n\n    out += ' ' + tag.text.replace(/@/g, '\\\\@');\n  }\n\n  return out;\n}\n\nfunction serializeTags(tags) {\n  if (tags.length === 0) return '';\n\n  if (tags.length === 1 && tags[0].tagName && !tags[0].text) {\n    // The JSDOC comment is a single simple tag: e.g `/** @tagname */`.\n    return \"*\".concat(tagToString(tags[0]), \" \");\n  }\n\n  var out = '*\\n';\n\n  var _iterator = _createForOfIteratorHelper(tags),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var tag = _step.value;\n      out += ' *'; // If the tagToString is multi-line, insert \" * \" prefixes on lines.\n\n      out += tagToString(tag).replace(/\\n/g, '\\n * ');\n      out += '\\n';\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  out += ' ';\n  return out;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar CONSTANT_PREFIX = '_c';\n/**\r\n * `ConstantPool` tries to reuse literal factories when two or more literals are identical.\r\n * We determine whether literals are identical by creating a key out of their AST using the\r\n * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely\r\n * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what\r\n * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note\r\n * that we use a variable, rather than something like `null` in order to avoid collisions.\r\n */\n\nvar UNKNOWN_VALUE_KEY = variable('<unknown>');\n/**\r\n * Context to use when producing a key.\r\n *\r\n * This ensures we see the constant not the reference variable when producing\r\n * a key.\r\n */\n\nvar KEY_CONTEXT = {};\n/**\r\n * Generally all primitive values are excluded from the `ConstantPool`, but there is an exclusion\r\n * for strings that reach a certain length threshold. This constant defines the length threshold for\r\n * strings.\r\n */\n\nvar POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;\n/**\r\n * A node that is a place-holder that allows the node to be replaced when the actual\r\n * node is known.\r\n *\r\n * This allows the constant pool to change an expression from a direct reference to\r\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\r\n * change the referenced expression.\r\n */\n\nvar FixupExpression = /*#__PURE__*/function (_Expression26) {\n  _inherits(FixupExpression, _Expression26);\n\n  var _super47 = _createSuper(FixupExpression);\n\n  function FixupExpression(resolved) {\n    var _this57;\n\n    _classCallCheck(this, FixupExpression);\n\n    _this57 = _super47.call(this, resolved.type);\n    _this57.resolved = resolved;\n    _this57.original = resolved;\n    return _this57;\n  }\n\n  _createClass(FixupExpression, [{\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      if (context === KEY_CONTEXT) {\n        // When producing a key we want to traverse the constant not the\n        // variable used to refer to it.\n        return this.original.visitExpression(visitor, context);\n      } else {\n        return this.resolved.visitExpression(visitor, context);\n      }\n    }\n  }, {\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return true;\n    }\n  }, {\n    key: \"fixup\",\n    value: function fixup(expression) {\n      this.resolved = expression;\n      this.shared = true;\n    }\n  }]);\n\n  return FixupExpression;\n}(Expression);\n/**\r\n * A constant pool allows a code emitter to share constant in an output context.\r\n *\r\n * The constant pool also supports sharing access to ivy definitions references.\r\n */\n\n\nvar ConstantPool = /*#__PURE__*/function () {\n  function ConstantPool() {\n    var isClosureCompilerEnabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    _classCallCheck(this, ConstantPool);\n\n    this.isClosureCompilerEnabled = isClosureCompilerEnabled;\n    this.statements = [];\n    this.literals = new Map();\n    this.literalFactories = new Map();\n    this.injectorDefinitions = new Map();\n    this.directiveDefinitions = new Map();\n    this.componentDefinitions = new Map();\n    this.pipeDefinitions = new Map();\n    this.nextNameIndex = 0;\n  }\n\n  _createClass(ConstantPool, [{\n    key: \"getConstLiteral\",\n    value: function getConstLiteral(literal, forceShared) {\n      if (literal instanceof LiteralExpr && !isLongStringLiteral(literal) || literal instanceof FixupExpression) {\n        // Do no put simple literals into the constant pool or try to produce a constant for a\n        // reference to a constant.\n        return literal;\n      }\n\n      var key = this.keyOf(literal);\n      var fixup = this.literals.get(key);\n      var newValue = false;\n\n      if (!fixup) {\n        fixup = new FixupExpression(literal);\n        this.literals.set(key, fixup);\n        newValue = true;\n      }\n\n      if (!newValue && !fixup.shared || newValue && forceShared) {\n        // Replace the expression with a variable\n        var name = this.freshName();\n        var definition;\n        var usage;\n\n        if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {\n          // For string literals, Closure will **always** inline the string at\n          // **all** usages, duplicating it each time. For large strings, this\n          // unnecessarily bloats bundle size. To work around this restriction, we\n          // wrap the string in a function, and call that function for each usage.\n          // This tricks Closure into using inline logic for functions instead of\n          // string literals. Function calls are only inlined if the body is small\n          // enough to be worth it. By doing this, very large strings will be\n          // shared across multiple usages, rather than duplicating the string at\n          // each usage site.\n          //\n          // const myStr = function() { return \"very very very long string\"; };\n          // const usage1 = myStr();\n          // const usage2 = myStr();\n          definition = variable(name).set(new FunctionExpr([], // Params.\n          [// Statements.\n          new ReturnStatement(literal)]));\n          usage = variable(name).callFn([]);\n        } else {\n          // Just declare and use the variable directly, without a function call\n          // indirection. This saves a few bytes and avoids an unncessary call.\n          definition = variable(name).set(literal);\n          usage = variable(name);\n        }\n\n        this.statements.push(definition.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));\n        fixup.fixup(usage);\n      }\n\n      return fixup;\n    }\n  }, {\n    key: \"getDefinition\",\n    value: function getDefinition(type, kind, ctx) {\n      var forceShared = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var definitions = this.definitionsOf(kind);\n      var fixup = definitions.get(type);\n      var newValue = false;\n\n      if (!fixup) {\n        var property = this.propertyNameOf(kind);\n        fixup = new FixupExpression(ctx.importExpr(type).prop(property));\n        definitions.set(type, fixup);\n        newValue = true;\n      }\n\n      if (!newValue && !fixup.shared || newValue && forceShared) {\n        var name = this.freshName();\n        this.statements.push(variable(name).set(fixup.resolved).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));\n        fixup.fixup(variable(name));\n      }\n\n      return fixup;\n    }\n  }, {\n    key: \"getLiteralFactory\",\n    value: function getLiteralFactory(literal) {\n      // Create a pure function that builds an array of a mix of constant and variable expressions\n      if (literal instanceof LiteralArrayExpr) {\n        var argumentsForKey = literal.entries.map(function (e) {\n          return e.isConstant() ? e : UNKNOWN_VALUE_KEY;\n        });\n        var key = this.keyOf(literalArr(argumentsForKey));\n        return this._getLiteralFactory(key, literal.entries, function (entries) {\n          return literalArr(entries);\n        });\n      } else {\n        var expressionForKey = literalMap(literal.entries.map(function (e) {\n          return {\n            key: e.key,\n            value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,\n            quoted: e.quoted\n          };\n        }));\n\n        var _key = this.keyOf(expressionForKey);\n\n        return this._getLiteralFactory(_key, literal.entries.map(function (e) {\n          return e.value;\n        }), function (entries) {\n          return literalMap(entries.map(function (value, index) {\n            return {\n              key: literal.entries[index].key,\n              value: value,\n              quoted: literal.entries[index].quoted\n            };\n          }));\n        });\n      }\n    }\n  }, {\n    key: \"_getLiteralFactory\",\n    value: function _getLiteralFactory(key, values, resultMap) {\n      var _this58 = this;\n\n      var literalFactory = this.literalFactories.get(key);\n      var literalFactoryArguments = values.filter(function (e) {\n        return !e.isConstant();\n      });\n\n      if (!literalFactory) {\n        var resultExpressions = values.map(function (e, index) {\n          return e.isConstant() ? _this58.getConstLiteral(e, true) : variable(\"a\".concat(index));\n        });\n        var parameters = resultExpressions.filter(isVariable).map(function (e) {\n          return new FnParam(e.name, DYNAMIC_TYPE);\n        });\n        var pureFunctionDeclaration = fn(parameters, [new ReturnStatement(resultMap(resultExpressions))], INFERRED_TYPE);\n        var name = this.freshName();\n        this.statements.push(variable(name).set(pureFunctionDeclaration).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));\n        literalFactory = variable(name);\n        this.literalFactories.set(key, literalFactory);\n      }\n\n      return {\n        literalFactory: literalFactory,\n        literalFactoryArguments: literalFactoryArguments\n      };\n    }\n    /**\r\n     * Produce a unique name.\r\n     *\r\n     * The name might be unique among different prefixes if any of the prefixes end in\r\n     * a digit so the prefix should be a constant string (not based on user input) and\r\n     * must not end in a digit.\r\n     */\n\n  }, {\n    key: \"uniqueName\",\n    value: function uniqueName(prefix) {\n      return \"\".concat(prefix).concat(this.nextNameIndex++);\n    }\n  }, {\n    key: \"definitionsOf\",\n    value: function definitionsOf(kind) {\n      switch (kind) {\n        case 2\n        /* Component */\n        :\n          return this.componentDefinitions;\n\n        case 1\n        /* Directive */\n        :\n          return this.directiveDefinitions;\n\n        case 0\n        /* Injector */\n        :\n          return this.injectorDefinitions;\n\n        case 3\n        /* Pipe */\n        :\n          return this.pipeDefinitions;\n      }\n    }\n  }, {\n    key: \"propertyNameOf\",\n    value: function propertyNameOf(kind) {\n      switch (kind) {\n        case 2\n        /* Component */\n        :\n          return 'ɵcmp';\n\n        case 1\n        /* Directive */\n        :\n          return 'ɵdir';\n\n        case 0\n        /* Injector */\n        :\n          return 'ɵinj';\n\n        case 3\n        /* Pipe */\n        :\n          return 'ɵpipe';\n      }\n    }\n  }, {\n    key: \"freshName\",\n    value: function freshName() {\n      return this.uniqueName(CONSTANT_PREFIX);\n    }\n  }, {\n    key: \"keyOf\",\n    value: function keyOf(expression) {\n      return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n    }\n  }]);\n\n  return ConstantPool;\n}();\n/**\r\n * Visitor used to determine if 2 expressions are equivalent and can be shared in the\r\n * `ConstantPool`.\r\n *\r\n * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\r\n */\n\n\nvar KeyVisitor = /*#__PURE__*/function () {\n  function KeyVisitor() {\n    _classCallCheck(this, KeyVisitor);\n\n    this.visitWrappedNodeExpr = invalid;\n    this.visitWriteVarExpr = invalid;\n    this.visitWriteKeyExpr = invalid;\n    this.visitWritePropExpr = invalid;\n    this.visitInvokeMethodExpr = invalid;\n    this.visitInvokeFunctionExpr = invalid;\n    this.visitTaggedTemplateExpr = invalid;\n    this.visitInstantiateExpr = invalid;\n    this.visitConditionalExpr = invalid;\n    this.visitNotExpr = invalid;\n    this.visitAssertNotNullExpr = invalid;\n    this.visitCastExpr = invalid;\n    this.visitFunctionExpr = invalid;\n    this.visitUnaryOperatorExpr = invalid;\n    this.visitBinaryOperatorExpr = invalid;\n    this.visitReadPropExpr = invalid;\n    this.visitReadKeyExpr = invalid;\n    this.visitCommaExpr = invalid;\n    this.visitLocalizedString = invalid;\n  }\n\n  _createClass(KeyVisitor, [{\n    key: \"visitLiteralExpr\",\n    value: function visitLiteralExpr(ast) {\n      return \"\".concat(typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value);\n    }\n  }, {\n    key: \"visitLiteralArrayExpr\",\n    value: function visitLiteralArrayExpr(ast, context) {\n      var _this59 = this;\n\n      return \"[\".concat(ast.entries.map(function (entry) {\n        return entry.visitExpression(_this59, context);\n      }).join(','), \"]\");\n    }\n  }, {\n    key: \"visitLiteralMapExpr\",\n    value: function visitLiteralMapExpr(ast, context) {\n      var _this60 = this;\n\n      var mapKey = function mapKey(entry) {\n        var quote = entry.quoted ? '\"' : '';\n        return \"\".concat(quote).concat(entry.key).concat(quote);\n      };\n\n      var mapEntry = function mapEntry(entry) {\n        return \"\".concat(mapKey(entry), \":\").concat(entry.value.visitExpression(_this60, context));\n      };\n\n      return \"{\".concat(ast.entries.map(mapEntry).join(','));\n    }\n  }, {\n    key: \"visitExternalExpr\",\n    value: function visitExternalExpr(ast) {\n      return ast.value.moduleName ? \"EX:\".concat(ast.value.moduleName, \":\").concat(ast.value.name) : \"EX:\".concat(ast.value.runtime.name);\n    }\n  }, {\n    key: \"visitReadVarExpr\",\n    value: function visitReadVarExpr(node) {\n      return \"VAR:\".concat(node.name);\n    }\n  }, {\n    key: \"visitTypeofExpr\",\n    value: function visitTypeofExpr(node, context) {\n      return \"TYPEOF:\".concat(node.expr.visitExpression(this, context));\n    }\n  }]);\n\n  return KeyVisitor;\n}();\n\nfunction invalid(arg) {\n  throw new Error(\"Invalid state: Visitor \".concat(this.constructor.name, \" doesn't handle \").concat(arg.constructor.name));\n}\n\nfunction isVariable(e) {\n  return e instanceof ReadVarExpr;\n}\n\nfunction isLongStringLiteral(expr) {\n  return expr instanceof LiteralExpr && typeof expr.value === 'string' && expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar CORE = '@angular/core';\n\nvar Identifiers = function Identifiers() {\n  _classCallCheck(this, Identifiers);\n};\n/* Methods */\n\n\nIdentifiers.NEW_METHOD = 'factory';\nIdentifiers.TRANSFORM_METHOD = 'transform';\nIdentifiers.PATCH_DEPS = 'patchedDeps';\nIdentifiers.core = {\n  name: null,\n  moduleName: CORE\n};\n/* Instructions */\n\nIdentifiers.namespaceHTML = {\n  name: 'ɵɵnamespaceHTML',\n  moduleName: CORE\n};\nIdentifiers.namespaceMathML = {\n  name: 'ɵɵnamespaceMathML',\n  moduleName: CORE\n};\nIdentifiers.namespaceSVG = {\n  name: 'ɵɵnamespaceSVG',\n  moduleName: CORE\n};\nIdentifiers.element = {\n  name: 'ɵɵelement',\n  moduleName: CORE\n};\nIdentifiers.elementStart = {\n  name: 'ɵɵelementStart',\n  moduleName: CORE\n};\nIdentifiers.elementEnd = {\n  name: 'ɵɵelementEnd',\n  moduleName: CORE\n};\nIdentifiers.advance = {\n  name: 'ɵɵadvance',\n  moduleName: CORE\n};\nIdentifiers.syntheticHostProperty = {\n  name: 'ɵɵsyntheticHostProperty',\n  moduleName: CORE\n};\nIdentifiers.syntheticHostListener = {\n  name: 'ɵɵsyntheticHostListener',\n  moduleName: CORE\n};\nIdentifiers.attribute = {\n  name: 'ɵɵattribute',\n  moduleName: CORE\n};\nIdentifiers.attributeInterpolate1 = {\n  name: 'ɵɵattributeInterpolate1',\n  moduleName: CORE\n};\nIdentifiers.attributeInterpolate2 = {\n  name: 'ɵɵattributeInterpolate2',\n  moduleName: CORE\n};\nIdentifiers.attributeInterpolate3 = {\n  name: 'ɵɵattributeInterpolate3',\n  moduleName: CORE\n};\nIdentifiers.attributeInterpolate4 = {\n  name: 'ɵɵattributeInterpolate4',\n  moduleName: CORE\n};\nIdentifiers.attributeInterpolate5 = {\n  name: 'ɵɵattributeInterpolate5',\n  moduleName: CORE\n};\nIdentifiers.attributeInterpolate6 = {\n  name: 'ɵɵattributeInterpolate6',\n  moduleName: CORE\n};\nIdentifiers.attributeInterpolate7 = {\n  name: 'ɵɵattributeInterpolate7',\n  moduleName: CORE\n};\nIdentifiers.attributeInterpolate8 = {\n  name: 'ɵɵattributeInterpolate8',\n  moduleName: CORE\n};\nIdentifiers.attributeInterpolateV = {\n  name: 'ɵɵattributeInterpolateV',\n  moduleName: CORE\n};\nIdentifiers.classProp = {\n  name: 'ɵɵclassProp',\n  moduleName: CORE\n};\nIdentifiers.elementContainerStart = {\n  name: 'ɵɵelementContainerStart',\n  moduleName: CORE\n};\nIdentifiers.elementContainerEnd = {\n  name: 'ɵɵelementContainerEnd',\n  moduleName: CORE\n};\nIdentifiers.elementContainer = {\n  name: 'ɵɵelementContainer',\n  moduleName: CORE\n};\nIdentifiers.styleMap = {\n  name: 'ɵɵstyleMap',\n  moduleName: CORE\n};\nIdentifiers.styleMapInterpolate1 = {\n  name: 'ɵɵstyleMapInterpolate1',\n  moduleName: CORE\n};\nIdentifiers.styleMapInterpolate2 = {\n  name: 'ɵɵstyleMapInterpolate2',\n  moduleName: CORE\n};\nIdentifiers.styleMapInterpolate3 = {\n  name: 'ɵɵstyleMapInterpolate3',\n  moduleName: CORE\n};\nIdentifiers.styleMapInterpolate4 = {\n  name: 'ɵɵstyleMapInterpolate4',\n  moduleName: CORE\n};\nIdentifiers.styleMapInterpolate5 = {\n  name: 'ɵɵstyleMapInterpolate5',\n  moduleName: CORE\n};\nIdentifiers.styleMapInterpolate6 = {\n  name: 'ɵɵstyleMapInterpolate6',\n  moduleName: CORE\n};\nIdentifiers.styleMapInterpolate7 = {\n  name: 'ɵɵstyleMapInterpolate7',\n  moduleName: CORE\n};\nIdentifiers.styleMapInterpolate8 = {\n  name: 'ɵɵstyleMapInterpolate8',\n  moduleName: CORE\n};\nIdentifiers.styleMapInterpolateV = {\n  name: 'ɵɵstyleMapInterpolateV',\n  moduleName: CORE\n};\nIdentifiers.classMap = {\n  name: 'ɵɵclassMap',\n  moduleName: CORE\n};\nIdentifiers.classMapInterpolate1 = {\n  name: 'ɵɵclassMapInterpolate1',\n  moduleName: CORE\n};\nIdentifiers.classMapInterpolate2 = {\n  name: 'ɵɵclassMapInterpolate2',\n  moduleName: CORE\n};\nIdentifiers.classMapInterpolate3 = {\n  name: 'ɵɵclassMapInterpolate3',\n  moduleName: CORE\n};\nIdentifiers.classMapInterpolate4 = {\n  name: 'ɵɵclassMapInterpolate4',\n  moduleName: CORE\n};\nIdentifiers.classMapInterpolate5 = {\n  name: 'ɵɵclassMapInterpolate5',\n  moduleName: CORE\n};\nIdentifiers.classMapInterpolate6 = {\n  name: 'ɵɵclassMapInterpolate6',\n  moduleName: CORE\n};\nIdentifiers.classMapInterpolate7 = {\n  name: 'ɵɵclassMapInterpolate7',\n  moduleName: CORE\n};\nIdentifiers.classMapInterpolate8 = {\n  name: 'ɵɵclassMapInterpolate8',\n  moduleName: CORE\n};\nIdentifiers.classMapInterpolateV = {\n  name: 'ɵɵclassMapInterpolateV',\n  moduleName: CORE\n};\nIdentifiers.styleProp = {\n  name: 'ɵɵstyleProp',\n  moduleName: CORE\n};\nIdentifiers.stylePropInterpolate1 = {\n  name: 'ɵɵstylePropInterpolate1',\n  moduleName: CORE\n};\nIdentifiers.stylePropInterpolate2 = {\n  name: 'ɵɵstylePropInterpolate2',\n  moduleName: CORE\n};\nIdentifiers.stylePropInterpolate3 = {\n  name: 'ɵɵstylePropInterpolate3',\n  moduleName: CORE\n};\nIdentifiers.stylePropInterpolate4 = {\n  name: 'ɵɵstylePropInterpolate4',\n  moduleName: CORE\n};\nIdentifiers.stylePropInterpolate5 = {\n  name: 'ɵɵstylePropInterpolate5',\n  moduleName: CORE\n};\nIdentifiers.stylePropInterpolate6 = {\n  name: 'ɵɵstylePropInterpolate6',\n  moduleName: CORE\n};\nIdentifiers.stylePropInterpolate7 = {\n  name: 'ɵɵstylePropInterpolate7',\n  moduleName: CORE\n};\nIdentifiers.stylePropInterpolate8 = {\n  name: 'ɵɵstylePropInterpolate8',\n  moduleName: CORE\n};\nIdentifiers.stylePropInterpolateV = {\n  name: 'ɵɵstylePropInterpolateV',\n  moduleName: CORE\n};\nIdentifiers.nextContext = {\n  name: 'ɵɵnextContext',\n  moduleName: CORE\n};\nIdentifiers.templateCreate = {\n  name: 'ɵɵtemplate',\n  moduleName: CORE\n};\nIdentifiers.text = {\n  name: 'ɵɵtext',\n  moduleName: CORE\n};\nIdentifiers.enableBindings = {\n  name: 'ɵɵenableBindings',\n  moduleName: CORE\n};\nIdentifiers.disableBindings = {\n  name: 'ɵɵdisableBindings',\n  moduleName: CORE\n};\nIdentifiers.getCurrentView = {\n  name: 'ɵɵgetCurrentView',\n  moduleName: CORE\n};\nIdentifiers.textInterpolate = {\n  name: 'ɵɵtextInterpolate',\n  moduleName: CORE\n};\nIdentifiers.textInterpolate1 = {\n  name: 'ɵɵtextInterpolate1',\n  moduleName: CORE\n};\nIdentifiers.textInterpolate2 = {\n  name: 'ɵɵtextInterpolate2',\n  moduleName: CORE\n};\nIdentifiers.textInterpolate3 = {\n  name: 'ɵɵtextInterpolate3',\n  moduleName: CORE\n};\nIdentifiers.textInterpolate4 = {\n  name: 'ɵɵtextInterpolate4',\n  moduleName: CORE\n};\nIdentifiers.textInterpolate5 = {\n  name: 'ɵɵtextInterpolate5',\n  moduleName: CORE\n};\nIdentifiers.textInterpolate6 = {\n  name: 'ɵɵtextInterpolate6',\n  moduleName: CORE\n};\nIdentifiers.textInterpolate7 = {\n  name: 'ɵɵtextInterpolate7',\n  moduleName: CORE\n};\nIdentifiers.textInterpolate8 = {\n  name: 'ɵɵtextInterpolate8',\n  moduleName: CORE\n};\nIdentifiers.textInterpolateV = {\n  name: 'ɵɵtextInterpolateV',\n  moduleName: CORE\n};\nIdentifiers.restoreView = {\n  name: 'ɵɵrestoreView',\n  moduleName: CORE\n};\nIdentifiers.pureFunction0 = {\n  name: 'ɵɵpureFunction0',\n  moduleName: CORE\n};\nIdentifiers.pureFunction1 = {\n  name: 'ɵɵpureFunction1',\n  moduleName: CORE\n};\nIdentifiers.pureFunction2 = {\n  name: 'ɵɵpureFunction2',\n  moduleName: CORE\n};\nIdentifiers.pureFunction3 = {\n  name: 'ɵɵpureFunction3',\n  moduleName: CORE\n};\nIdentifiers.pureFunction4 = {\n  name: 'ɵɵpureFunction4',\n  moduleName: CORE\n};\nIdentifiers.pureFunction5 = {\n  name: 'ɵɵpureFunction5',\n  moduleName: CORE\n};\nIdentifiers.pureFunction6 = {\n  name: 'ɵɵpureFunction6',\n  moduleName: CORE\n};\nIdentifiers.pureFunction7 = {\n  name: 'ɵɵpureFunction7',\n  moduleName: CORE\n};\nIdentifiers.pureFunction8 = {\n  name: 'ɵɵpureFunction8',\n  moduleName: CORE\n};\nIdentifiers.pureFunctionV = {\n  name: 'ɵɵpureFunctionV',\n  moduleName: CORE\n};\nIdentifiers.pipeBind1 = {\n  name: 'ɵɵpipeBind1',\n  moduleName: CORE\n};\nIdentifiers.pipeBind2 = {\n  name: 'ɵɵpipeBind2',\n  moduleName: CORE\n};\nIdentifiers.pipeBind3 = {\n  name: 'ɵɵpipeBind3',\n  moduleName: CORE\n};\nIdentifiers.pipeBind4 = {\n  name: 'ɵɵpipeBind4',\n  moduleName: CORE\n};\nIdentifiers.pipeBindV = {\n  name: 'ɵɵpipeBindV',\n  moduleName: CORE\n};\nIdentifiers.hostProperty = {\n  name: 'ɵɵhostProperty',\n  moduleName: CORE\n};\nIdentifiers.property = {\n  name: 'ɵɵproperty',\n  moduleName: CORE\n};\nIdentifiers.propertyInterpolate = {\n  name: 'ɵɵpropertyInterpolate',\n  moduleName: CORE\n};\nIdentifiers.propertyInterpolate1 = {\n  name: 'ɵɵpropertyInterpolate1',\n  moduleName: CORE\n};\nIdentifiers.propertyInterpolate2 = {\n  name: 'ɵɵpropertyInterpolate2',\n  moduleName: CORE\n};\nIdentifiers.propertyInterpolate3 = {\n  name: 'ɵɵpropertyInterpolate3',\n  moduleName: CORE\n};\nIdentifiers.propertyInterpolate4 = {\n  name: 'ɵɵpropertyInterpolate4',\n  moduleName: CORE\n};\nIdentifiers.propertyInterpolate5 = {\n  name: 'ɵɵpropertyInterpolate5',\n  moduleName: CORE\n};\nIdentifiers.propertyInterpolate6 = {\n  name: 'ɵɵpropertyInterpolate6',\n  moduleName: CORE\n};\nIdentifiers.propertyInterpolate7 = {\n  name: 'ɵɵpropertyInterpolate7',\n  moduleName: CORE\n};\nIdentifiers.propertyInterpolate8 = {\n  name: 'ɵɵpropertyInterpolate8',\n  moduleName: CORE\n};\nIdentifiers.propertyInterpolateV = {\n  name: 'ɵɵpropertyInterpolateV',\n  moduleName: CORE\n};\nIdentifiers.i18n = {\n  name: 'ɵɵi18n',\n  moduleName: CORE\n};\nIdentifiers.i18nAttributes = {\n  name: 'ɵɵi18nAttributes',\n  moduleName: CORE\n};\nIdentifiers.i18nExp = {\n  name: 'ɵɵi18nExp',\n  moduleName: CORE\n};\nIdentifiers.i18nStart = {\n  name: 'ɵɵi18nStart',\n  moduleName: CORE\n};\nIdentifiers.i18nEnd = {\n  name: 'ɵɵi18nEnd',\n  moduleName: CORE\n};\nIdentifiers.i18nApply = {\n  name: 'ɵɵi18nApply',\n  moduleName: CORE\n};\nIdentifiers.i18nPostprocess = {\n  name: 'ɵɵi18nPostprocess',\n  moduleName: CORE\n};\nIdentifiers.pipe = {\n  name: 'ɵɵpipe',\n  moduleName: CORE\n};\nIdentifiers.projection = {\n  name: 'ɵɵprojection',\n  moduleName: CORE\n};\nIdentifiers.projectionDef = {\n  name: 'ɵɵprojectionDef',\n  moduleName: CORE\n};\nIdentifiers.reference = {\n  name: 'ɵɵreference',\n  moduleName: CORE\n};\nIdentifiers.inject = {\n  name: 'ɵɵinject',\n  moduleName: CORE\n};\nIdentifiers.injectAttribute = {\n  name: 'ɵɵinjectAttribute',\n  moduleName: CORE\n};\nIdentifiers.directiveInject = {\n  name: 'ɵɵdirectiveInject',\n  moduleName: CORE\n};\nIdentifiers.invalidFactory = {\n  name: 'ɵɵinvalidFactory',\n  moduleName: CORE\n};\nIdentifiers.invalidFactoryDep = {\n  name: 'ɵɵinvalidFactoryDep',\n  moduleName: CORE\n};\nIdentifiers.templateRefExtractor = {\n  name: 'ɵɵtemplateRefExtractor',\n  moduleName: CORE\n};\nIdentifiers.forwardRef = {\n  name: 'forwardRef',\n  moduleName: CORE\n};\nIdentifiers.resolveForwardRef = {\n  name: 'resolveForwardRef',\n  moduleName: CORE\n};\nIdentifiers.ɵɵdefineInjectable = {\n  name: 'ɵɵdefineInjectable',\n  moduleName: CORE\n};\nIdentifiers.declareInjectable = {\n  name: 'ɵɵngDeclareInjectable',\n  moduleName: CORE\n};\nIdentifiers.InjectableDeclaration = {\n  name: 'ɵɵInjectableDeclaration',\n  moduleName: CORE\n};\nIdentifiers.resolveWindow = {\n  name: 'ɵɵresolveWindow',\n  moduleName: CORE\n};\nIdentifiers.resolveDocument = {\n  name: 'ɵɵresolveDocument',\n  moduleName: CORE\n};\nIdentifiers.resolveBody = {\n  name: 'ɵɵresolveBody',\n  moduleName: CORE\n};\nIdentifiers.defineComponent = {\n  name: 'ɵɵdefineComponent',\n  moduleName: CORE\n};\nIdentifiers.declareComponent = {\n  name: 'ɵɵngDeclareComponent',\n  moduleName: CORE\n};\nIdentifiers.setComponentScope = {\n  name: 'ɵɵsetComponentScope',\n  moduleName: CORE\n};\nIdentifiers.ChangeDetectionStrategy = {\n  name: 'ChangeDetectionStrategy',\n  moduleName: CORE\n};\nIdentifiers.ViewEncapsulation = {\n  name: 'ViewEncapsulation',\n  moduleName: CORE\n};\nIdentifiers.ComponentDeclaration = {\n  name: 'ɵɵComponentDeclaration',\n  moduleName: CORE\n};\nIdentifiers.FactoryDeclaration = {\n  name: 'ɵɵFactoryDeclaration',\n  moduleName: CORE\n};\nIdentifiers.declareFactory = {\n  name: 'ɵɵngDeclareFactory',\n  moduleName: CORE\n};\nIdentifiers.FactoryTarget = {\n  name: 'ɵɵFactoryTarget',\n  moduleName: CORE\n};\nIdentifiers.defineDirective = {\n  name: 'ɵɵdefineDirective',\n  moduleName: CORE\n};\nIdentifiers.declareDirective = {\n  name: 'ɵɵngDeclareDirective',\n  moduleName: CORE\n};\nIdentifiers.DirectiveDeclaration = {\n  name: 'ɵɵDirectiveDeclaration',\n  moduleName: CORE\n};\nIdentifiers.InjectorDef = {\n  name: 'ɵɵInjectorDef',\n  moduleName: CORE\n};\nIdentifiers.InjectorDeclaration = {\n  name: 'ɵɵInjectorDeclaration',\n  moduleName: CORE\n};\nIdentifiers.defineInjector = {\n  name: 'ɵɵdefineInjector',\n  moduleName: CORE\n};\nIdentifiers.declareInjector = {\n  name: 'ɵɵngDeclareInjector',\n  moduleName: CORE\n};\nIdentifiers.NgModuleDeclaration = {\n  name: 'ɵɵNgModuleDeclaration',\n  moduleName: CORE\n};\nIdentifiers.ModuleWithProviders = {\n  name: 'ModuleWithProviders',\n  moduleName: CORE\n};\nIdentifiers.defineNgModule = {\n  name: 'ɵɵdefineNgModule',\n  moduleName: CORE\n};\nIdentifiers.declareNgModule = {\n  name: 'ɵɵngDeclareNgModule',\n  moduleName: CORE\n};\nIdentifiers.setNgModuleScope = {\n  name: 'ɵɵsetNgModuleScope',\n  moduleName: CORE\n};\nIdentifiers.PipeDeclaration = {\n  name: 'ɵɵPipeDeclaration',\n  moduleName: CORE\n};\nIdentifiers.definePipe = {\n  name: 'ɵɵdefinePipe',\n  moduleName: CORE\n};\nIdentifiers.declarePipe = {\n  name: 'ɵɵngDeclarePipe',\n  moduleName: CORE\n};\nIdentifiers.declareClassMetadata = {\n  name: 'ɵɵngDeclareClassMetadata',\n  moduleName: CORE\n};\nIdentifiers.setClassMetadata = {\n  name: 'ɵsetClassMetadata',\n  moduleName: CORE\n};\nIdentifiers.queryRefresh = {\n  name: 'ɵɵqueryRefresh',\n  moduleName: CORE\n};\nIdentifiers.viewQuery = {\n  name: 'ɵɵviewQuery',\n  moduleName: CORE\n};\nIdentifiers.loadQuery = {\n  name: 'ɵɵloadQuery',\n  moduleName: CORE\n};\nIdentifiers.contentQuery = {\n  name: 'ɵɵcontentQuery',\n  moduleName: CORE\n};\nIdentifiers.NgOnChangesFeature = {\n  name: 'ɵɵNgOnChangesFeature',\n  moduleName: CORE\n};\nIdentifiers.InheritDefinitionFeature = {\n  name: 'ɵɵInheritDefinitionFeature',\n  moduleName: CORE\n};\nIdentifiers.CopyDefinitionFeature = {\n  name: 'ɵɵCopyDefinitionFeature',\n  moduleName: CORE\n};\nIdentifiers.ProvidersFeature = {\n  name: 'ɵɵProvidersFeature',\n  moduleName: CORE\n};\nIdentifiers.listener = {\n  name: 'ɵɵlistener',\n  moduleName: CORE\n};\nIdentifiers.getInheritedFactory = {\n  name: 'ɵɵgetInheritedFactory',\n  moduleName: CORE\n}; // sanitization-related functions\n\nIdentifiers.sanitizeHtml = {\n  name: 'ɵɵsanitizeHtml',\n  moduleName: CORE\n};\nIdentifiers.sanitizeStyle = {\n  name: 'ɵɵsanitizeStyle',\n  moduleName: CORE\n};\nIdentifiers.sanitizeResourceUrl = {\n  name: 'ɵɵsanitizeResourceUrl',\n  moduleName: CORE\n};\nIdentifiers.sanitizeScript = {\n  name: 'ɵɵsanitizeScript',\n  moduleName: CORE\n};\nIdentifiers.sanitizeUrl = {\n  name: 'ɵɵsanitizeUrl',\n  moduleName: CORE\n};\nIdentifiers.sanitizeUrlOrResourceUrl = {\n  name: 'ɵɵsanitizeUrlOrResourceUrl',\n  moduleName: CORE\n};\nIdentifiers.trustConstantHtml = {\n  name: 'ɵɵtrustConstantHtml',\n  moduleName: CORE\n};\nIdentifiers.trustConstantResourceUrl = {\n  name: 'ɵɵtrustConstantResourceUrl',\n  moduleName: CORE\n};\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\nvar DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n\nfunction dashCaseToCamelCase(input) {\n  return input.replace(DASH_CASE_REGEXP, function () {\n    for (var _len = arguments.length, m = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {\n      m[_key2] = arguments[_key2];\n    }\n\n    return m[1].toUpperCase();\n  });\n}\n\nfunction splitAtColon(input, defaultValues) {\n  return _splitAt(input, ':', defaultValues);\n}\n\nfunction splitAtPeriod(input, defaultValues) {\n  return _splitAt(input, '.', defaultValues);\n}\n\nfunction _splitAt(input, character, defaultValues) {\n  var characterIndex = input.indexOf(character);\n  if (characterIndex == -1) return defaultValues;\n  return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\n\nfunction visitValue(value, visitor, context) {\n  if (Array.isArray(value)) {\n    return visitor.visitArray(value, context);\n  }\n\n  if (isStrictStringMap(value)) {\n    return visitor.visitStringMap(value, context);\n  }\n\n  if (value == null || typeof value == 'string' || typeof value == 'number' || typeof value == 'boolean') {\n    return visitor.visitPrimitive(value, context);\n  }\n\n  return visitor.visitOther(value, context);\n}\n\nfunction isDefined(val) {\n  return val !== null && val !== undefined;\n}\n\nfunction noUndefined(val) {\n  return val === undefined ? null : val;\n}\n\nvar ValueTransformer = /*#__PURE__*/function () {\n  function ValueTransformer() {\n    _classCallCheck(this, ValueTransformer);\n  }\n\n  _createClass(ValueTransformer, [{\n    key: \"visitArray\",\n    value: function visitArray(arr, context) {\n      var _this61 = this;\n\n      return arr.map(function (value) {\n        return visitValue(value, _this61, context);\n      });\n    }\n  }, {\n    key: \"visitStringMap\",\n    value: function visitStringMap(map, context) {\n      var _this62 = this;\n\n      var result = {};\n      Object.keys(map).forEach(function (key) {\n        result[key] = visitValue(map[key], _this62, context);\n      });\n      return result;\n    }\n  }, {\n    key: \"visitPrimitive\",\n    value: function visitPrimitive(value, context) {\n      return value;\n    }\n  }, {\n    key: \"visitOther\",\n    value: function visitOther(value, context) {\n      return value;\n    }\n  }]);\n\n  return ValueTransformer;\n}();\n\nvar SyncAsync = {\n  assertSync: function assertSync(value) {\n    if (isPromise(value)) {\n      throw new Error(\"Illegal state: value cannot be a promise\");\n    }\n\n    return value;\n  },\n  then: function then(value, cb) {\n    return isPromise(value) ? value.then(cb) : cb(value);\n  },\n  all: function all(syncAsyncValues) {\n    return syncAsyncValues.some(isPromise) ? Promise.all(syncAsyncValues) : syncAsyncValues;\n  }\n};\n\nfunction error(msg) {\n  throw new Error(\"Internal Error: \".concat(msg));\n}\n\nfunction syntaxError(msg, parseErrors) {\n  var error = Error(msg);\n  error[ERROR_SYNTAX_ERROR] = true;\n  if (parseErrors) error[ERROR_PARSE_ERRORS] = parseErrors;\n  return error;\n}\n\nvar ERROR_SYNTAX_ERROR = 'ngSyntaxError';\nvar ERROR_PARSE_ERRORS = 'ngParseErrors';\n\nfunction isSyntaxError(error) {\n  return error[ERROR_SYNTAX_ERROR];\n}\n\nfunction getParseErrors(error) {\n  return error[ERROR_PARSE_ERRORS] || [];\n} // Escape characters that have a special meaning in Regular Expressions\n\n\nfunction escapeRegExp(s) {\n  return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\n\nvar STRING_MAP_PROTO = Object.getPrototypeOf({});\n\nfunction isStrictStringMap(obj) {\n  return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n}\n\nfunction utf8Encode(str) {\n  var encoded = [];\n\n  for (var index = 0; index < str.length; index++) {\n    var codePoint = str.charCodeAt(index); // decode surrogate\n    // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\n    if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > index + 1) {\n      var low = str.charCodeAt(index + 1);\n\n      if (low >= 0xdc00 && low <= 0xdfff) {\n        index++;\n        codePoint = (codePoint - 0xd800 << 10) + low - 0xdc00 + 0x10000;\n      }\n    }\n\n    if (codePoint <= 0x7f) {\n      encoded.push(codePoint);\n    } else if (codePoint <= 0x7ff) {\n      encoded.push(codePoint >> 6 & 0x1F | 0xc0, codePoint & 0x3f | 0x80);\n    } else if (codePoint <= 0xffff) {\n      encoded.push(codePoint >> 12 | 0xe0, codePoint >> 6 & 0x3f | 0x80, codePoint & 0x3f | 0x80);\n    } else if (codePoint <= 0x1fffff) {\n      encoded.push(codePoint >> 18 & 0x07 | 0xf0, codePoint >> 12 & 0x3f | 0x80, codePoint >> 6 & 0x3f | 0x80, codePoint & 0x3f | 0x80);\n    }\n  }\n\n  return encoded;\n}\n\nfunction stringify(token) {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (Array.isArray(token)) {\n    return '[' + token.map(stringify).join(', ') + ']';\n  }\n\n  if (token == null) {\n    return '' + token;\n  }\n\n  if (token.overriddenName) {\n    return \"\".concat(token.overriddenName);\n  }\n\n  if (token.name) {\n    return \"\".concat(token.name);\n  }\n\n  if (!token.toString) {\n    return 'object';\n  } // WARNING: do not try to `JSON.stringify(token)` here\n  // see https://github.com/angular/angular/issues/23440\n\n\n  var res = token.toString();\n\n  if (res == null) {\n    return '' + res;\n  }\n\n  var newLineIndex = res.indexOf('\\n');\n  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n/**\r\n * Lazily retrieves the reference value from a forwardRef.\r\n */\n\n\nfunction resolveForwardRef(type) {\n  if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__')) {\n    return type();\n  } else {\n    return type;\n  }\n}\n/**\r\n * Determine if the argument is shaped like a Promise\r\n */\n\n\nfunction isPromise(obj) {\n  // allow any Promise/A+ compliant thenable.\n  // It's up to the caller to ensure that obj.then conforms to the spec\n  return !!obj && typeof obj.then === 'function';\n}\n\nvar Version = function Version(full) {\n  _classCallCheck(this, Version);\n\n  this.full = full;\n  var splits = full.split('.');\n  this.major = splits[0];\n  this.minor = splits[1];\n  this.patch = splits.slice(2).join('.');\n};\n\nvar __window = typeof window !== 'undefined' && window;\n\nvar __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self;\n\nvar __global = typeof global !== 'undefined' && global; // Check __global first, because in Node tests both __global and __window may be defined and _global\n// should be __global in that case.\n\n\nvar _global = __global || __window || __self;\n\nfunction newArray(size, value) {\n  var list = [];\n\n  for (var i = 0; i < size; i++) {\n    list.push(value);\n  }\n\n  return list;\n}\n/**\r\n * Partitions a given array into 2 arrays, based on a boolean value returned by the condition\r\n * function.\r\n *\r\n * @param arr Input array that should be partitioned\r\n * @param conditionFn Condition function that is called for each item in a given array and returns a\r\n * boolean value.\r\n */\n\n\nfunction partitionArray(arr, conditionFn) {\n  var truthy = [];\n  var falsy = [];\n\n  var _iterator2 = _createForOfIteratorHelper(arr),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var item = _step2.value;\n      (conditionFn(item) ? truthy : falsy).push(item);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return [truthy, falsy];\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * This is an R3 `Node`-like wrapper for a raw `html.Comment` node. We do not currently\r\n * require the implementation of a visitor for Comments as they are only collected at\r\n * the top-level of the R3 AST, and only if `Render3ParseOptions['collectCommentNodes']`\r\n * is true.\r\n */\n\n\nvar Comment = /*#__PURE__*/function () {\n  function Comment(value, sourceSpan) {\n    _classCallCheck(this, Comment);\n\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(Comment, [{\n    key: \"visit\",\n    value: function visit(_visitor) {\n      throw new Error('visit() not implemented for Comment');\n    }\n  }]);\n\n  return Comment;\n}();\n\nvar Text = /*#__PURE__*/function () {\n  function Text(value, sourceSpan) {\n    _classCallCheck(this, Text);\n\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(Text, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitText(this);\n    }\n  }]);\n\n  return Text;\n}();\n\nvar BoundText = /*#__PURE__*/function () {\n  function BoundText(value, sourceSpan, i18n) {\n    _classCallCheck(this, BoundText);\n\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.i18n = i18n;\n  }\n\n  _createClass(BoundText, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitBoundText(this);\n    }\n  }]);\n\n  return BoundText;\n}();\n/**\r\n * Represents a text attribute in the template.\r\n *\r\n * `valueSpan` may not be present in cases where there is no value `<div a></div>`.\r\n * `keySpan` may also not be present for synthetic attributes from ICU expansions.\r\n */\n\n\nvar TextAttribute = /*#__PURE__*/function () {\n  function TextAttribute(name, value, sourceSpan, keySpan, valueSpan, i18n) {\n    _classCallCheck(this, TextAttribute);\n\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n    this.i18n = i18n;\n  }\n\n  _createClass(TextAttribute, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitTextAttribute(this);\n    }\n  }]);\n\n  return TextAttribute;\n}();\n\nvar BoundAttribute = /*#__PURE__*/function () {\n  function BoundAttribute(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan, i18n) {\n    _classCallCheck(this, BoundAttribute);\n\n    this.name = name;\n    this.type = type;\n    this.securityContext = securityContext;\n    this.value = value;\n    this.unit = unit;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n    this.i18n = i18n;\n  }\n\n  _createClass(BoundAttribute, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitBoundAttribute(this);\n    }\n  }], [{\n    key: \"fromBoundElementProperty\",\n    value: function fromBoundElementProperty(prop, i18n) {\n      if (prop.keySpan === undefined) {\n        throw new Error(\"Unexpected state: keySpan must be defined for bound attributes but was not for \".concat(prop.name, \": \").concat(prop.sourceSpan));\n      }\n\n      return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n);\n    }\n  }]);\n\n  return BoundAttribute;\n}();\n\nvar BoundEvent = /*#__PURE__*/function () {\n  function BoundEvent(name, type, handler, target, phase, sourceSpan, handlerSpan, keySpan) {\n    _classCallCheck(this, BoundEvent);\n\n    this.name = name;\n    this.type = type;\n    this.handler = handler;\n    this.target = target;\n    this.phase = phase;\n    this.sourceSpan = sourceSpan;\n    this.handlerSpan = handlerSpan;\n    this.keySpan = keySpan;\n  }\n\n  _createClass(BoundEvent, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitBoundEvent(this);\n    }\n  }], [{\n    key: \"fromParsedEvent\",\n    value: function fromParsedEvent(event) {\n      var target = event.type === 0\n      /* Regular */\n      ? event.targetOrPhase : null;\n      var phase = event.type === 1\n      /* Animation */\n      ? event.targetOrPhase : null;\n\n      if (event.keySpan === undefined) {\n        throw new Error(\"Unexpected state: keySpan must be defined for bound event but was not for \".concat(event.name, \": \").concat(event.sourceSpan));\n      }\n\n      return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan, event.keySpan);\n    }\n  }]);\n\n  return BoundEvent;\n}();\n\nvar Element = /*#__PURE__*/function () {\n  function Element(name, attributes, inputs, outputs, children, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    _classCallCheck(this, Element);\n\n    this.name = name;\n    this.attributes = attributes;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.children = children;\n    this.references = references;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.i18n = i18n;\n  }\n\n  _createClass(Element, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitElement(this);\n    }\n  }]);\n\n  return Element;\n}();\n\nvar Template = /*#__PURE__*/function () {\n  function Template(tagName, attributes, inputs, outputs, templateAttrs, children, references, variables, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    _classCallCheck(this, Template);\n\n    this.tagName = tagName;\n    this.attributes = attributes;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.templateAttrs = templateAttrs;\n    this.children = children;\n    this.references = references;\n    this.variables = variables;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.i18n = i18n;\n  }\n\n  _createClass(Template, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitTemplate(this);\n    }\n  }]);\n\n  return Template;\n}();\n\nvar Content = /*#__PURE__*/function () {\n  function Content(selector, attributes, sourceSpan, i18n) {\n    _classCallCheck(this, Content);\n\n    this.selector = selector;\n    this.attributes = attributes;\n    this.sourceSpan = sourceSpan;\n    this.i18n = i18n;\n    this.name = 'ng-content';\n  }\n\n  _createClass(Content, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitContent(this);\n    }\n  }]);\n\n  return Content;\n}();\n\nvar Variable = /*#__PURE__*/function () {\n  function Variable(name, value, sourceSpan, keySpan, valueSpan) {\n    _classCallCheck(this, Variable);\n\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n  }\n\n  _createClass(Variable, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitVariable(this);\n    }\n  }]);\n\n  return Variable;\n}();\n\nvar Reference = /*#__PURE__*/function () {\n  function Reference(name, value, sourceSpan, keySpan, valueSpan) {\n    _classCallCheck(this, Reference);\n\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.keySpan = keySpan;\n    this.valueSpan = valueSpan;\n  }\n\n  _createClass(Reference, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitReference(this);\n    }\n  }]);\n\n  return Reference;\n}();\n\nvar Icu = /*#__PURE__*/function () {\n  function Icu(vars, placeholders, sourceSpan, i18n) {\n    _classCallCheck(this, Icu);\n\n    this.vars = vars;\n    this.placeholders = placeholders;\n    this.sourceSpan = sourceSpan;\n    this.i18n = i18n;\n  }\n\n  _createClass(Icu, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitIcu(this);\n    }\n  }]);\n\n  return Icu;\n}();\n\nvar NullVisitor = /*#__PURE__*/function () {\n  function NullVisitor() {\n    _classCallCheck(this, NullVisitor);\n  }\n\n  _createClass(NullVisitor, [{\n    key: \"visitElement\",\n    value: function visitElement(element) {}\n  }, {\n    key: \"visitTemplate\",\n    value: function visitTemplate(template) {}\n  }, {\n    key: \"visitContent\",\n    value: function visitContent(content) {}\n  }, {\n    key: \"visitVariable\",\n    value: function visitVariable(variable) {}\n  }, {\n    key: \"visitReference\",\n    value: function visitReference(reference) {}\n  }, {\n    key: \"visitTextAttribute\",\n    value: function visitTextAttribute(attribute) {}\n  }, {\n    key: \"visitBoundAttribute\",\n    value: function visitBoundAttribute(attribute) {}\n  }, {\n    key: \"visitBoundEvent\",\n    value: function visitBoundEvent(attribute) {}\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {}\n  }, {\n    key: \"visitBoundText\",\n    value: function visitBoundText(text) {}\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu) {}\n  }]);\n\n  return NullVisitor;\n}();\n\nvar RecursiveVisitor = /*#__PURE__*/function () {\n  function RecursiveVisitor() {\n    _classCallCheck(this, RecursiveVisitor);\n  }\n\n  _createClass(RecursiveVisitor, [{\n    key: \"visitElement\",\n    value: function visitElement(element) {\n      visitAll(this, element.attributes);\n      visitAll(this, element.children);\n      visitAll(this, element.references);\n    }\n  }, {\n    key: \"visitTemplate\",\n    value: function visitTemplate(template) {\n      visitAll(this, template.attributes);\n      visitAll(this, template.children);\n      visitAll(this, template.references);\n      visitAll(this, template.variables);\n    }\n  }, {\n    key: \"visitContent\",\n    value: function visitContent(content) {}\n  }, {\n    key: \"visitVariable\",\n    value: function visitVariable(variable) {}\n  }, {\n    key: \"visitReference\",\n    value: function visitReference(reference) {}\n  }, {\n    key: \"visitTextAttribute\",\n    value: function visitTextAttribute(attribute) {}\n  }, {\n    key: \"visitBoundAttribute\",\n    value: function visitBoundAttribute(attribute) {}\n  }, {\n    key: \"visitBoundEvent\",\n    value: function visitBoundEvent(attribute) {}\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {}\n  }, {\n    key: \"visitBoundText\",\n    value: function visitBoundText(text) {}\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu) {}\n  }]);\n\n  return RecursiveVisitor;\n}();\n\nvar TransformVisitor = /*#__PURE__*/function () {\n  function TransformVisitor() {\n    _classCallCheck(this, TransformVisitor);\n  }\n\n  _createClass(TransformVisitor, [{\n    key: \"visitElement\",\n    value: function visitElement(element) {\n      var newAttributes = transformAll(this, element.attributes);\n      var newInputs = transformAll(this, element.inputs);\n      var newOutputs = transformAll(this, element.outputs);\n      var newChildren = transformAll(this, element.children);\n      var newReferences = transformAll(this, element.references);\n\n      if (newAttributes != element.attributes || newInputs != element.inputs || newOutputs != element.outputs || newChildren != element.children || newReferences != element.references) {\n        return new Element(element.name, newAttributes, newInputs, newOutputs, newChildren, newReferences, element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n      }\n\n      return element;\n    }\n  }, {\n    key: \"visitTemplate\",\n    value: function visitTemplate(template) {\n      var newAttributes = transformAll(this, template.attributes);\n      var newInputs = transformAll(this, template.inputs);\n      var newOutputs = transformAll(this, template.outputs);\n      var newTemplateAttrs = transformAll(this, template.templateAttrs);\n      var newChildren = transformAll(this, template.children);\n      var newReferences = transformAll(this, template.references);\n      var newVariables = transformAll(this, template.variables);\n\n      if (newAttributes != template.attributes || newInputs != template.inputs || newOutputs != template.outputs || newTemplateAttrs != template.templateAttrs || newChildren != template.children || newReferences != template.references || newVariables != template.variables) {\n        return new Template(template.tagName, newAttributes, newInputs, newOutputs, newTemplateAttrs, newChildren, newReferences, newVariables, template.sourceSpan, template.startSourceSpan, template.endSourceSpan);\n      }\n\n      return template;\n    }\n  }, {\n    key: \"visitContent\",\n    value: function visitContent(content) {\n      return content;\n    }\n  }, {\n    key: \"visitVariable\",\n    value: function visitVariable(variable) {\n      return variable;\n    }\n  }, {\n    key: \"visitReference\",\n    value: function visitReference(reference) {\n      return reference;\n    }\n  }, {\n    key: \"visitTextAttribute\",\n    value: function visitTextAttribute(attribute) {\n      return attribute;\n    }\n  }, {\n    key: \"visitBoundAttribute\",\n    value: function visitBoundAttribute(attribute) {\n      return attribute;\n    }\n  }, {\n    key: \"visitBoundEvent\",\n    value: function visitBoundEvent(attribute) {\n      return attribute;\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {\n      return text;\n    }\n  }, {\n    key: \"visitBoundText\",\n    value: function visitBoundText(text) {\n      return text;\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu) {\n      return icu;\n    }\n  }]);\n\n  return TransformVisitor;\n}();\n\nfunction visitAll(visitor, nodes) {\n  var result = [];\n\n  if (visitor.visit) {\n    var _iterator3 = _createForOfIteratorHelper(nodes),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var node = _step3.value;\n        var newNode = visitor.visit(node) || node.visit(visitor);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  } else {\n    var _iterator4 = _createForOfIteratorHelper(nodes),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _node = _step4.value;\n\n        var _newNode = _node.visit(visitor);\n\n        if (_newNode) {\n          result.push(_newNode);\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n\n  return result;\n}\n\nfunction transformAll(visitor, nodes) {\n  var result = [];\n  var changed = false;\n\n  var _iterator5 = _createForOfIteratorHelper(nodes),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var node = _step5.value;\n      var newNode = node.visit(visitor);\n\n      if (newNode) {\n        result.push(newNode);\n      }\n\n      changed = changed || newNode != node;\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return changed ? result : nodes;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar Message =\n/**\r\n * @param nodes message AST\r\n * @param placeholders maps placeholder names to static content and their source spans\r\n * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\r\n * @param meaning\r\n * @param description\r\n * @param customId\r\n */\nfunction Message(nodes, placeholders, placeholderToMessage, meaning, description, customId) {\n  _classCallCheck(this, Message);\n\n  this.nodes = nodes;\n  this.placeholders = placeholders;\n  this.placeholderToMessage = placeholderToMessage;\n  this.meaning = meaning;\n  this.description = description;\n  this.customId = customId;\n  this.id = this.customId;\n  /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */\n\n  this.legacyIds = [];\n\n  if (nodes.length) {\n    this.sources = [{\n      filePath: nodes[0].sourceSpan.start.file.url,\n      startLine: nodes[0].sourceSpan.start.line + 1,\n      startCol: nodes[0].sourceSpan.start.col + 1,\n      endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n      endCol: nodes[0].sourceSpan.start.col + 1\n    }];\n  } else {\n    this.sources = [];\n  }\n};\n\nvar Text$1 = /*#__PURE__*/function () {\n  function Text$1(value, sourceSpan) {\n    _classCallCheck(this, Text$1);\n\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(Text$1, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitText(this, context);\n    }\n  }]);\n\n  return Text$1;\n}(); // TODO(vicb): do we really need this node (vs an array) ?\n\n\nvar Container = /*#__PURE__*/function () {\n  function Container(children, sourceSpan) {\n    _classCallCheck(this, Container);\n\n    this.children = children;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(Container, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitContainer(this, context);\n    }\n  }]);\n\n  return Container;\n}();\n\nvar Icu$1 = /*#__PURE__*/function () {\n  function Icu$1(expression, type, cases, sourceSpan) {\n    _classCallCheck(this, Icu$1);\n\n    this.expression = expression;\n    this.type = type;\n    this.cases = cases;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(Icu$1, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitIcu(this, context);\n    }\n  }]);\n\n  return Icu$1;\n}();\n\nvar TagPlaceholder = /*#__PURE__*/function () {\n  function TagPlaceholder(tag, attrs, startName, closeName, children, isVoid, // TODO sourceSpan should cover all (we need a startSourceSpan and endSourceSpan)\n  sourceSpan, startSourceSpan, endSourceSpan) {\n    _classCallCheck(this, TagPlaceholder);\n\n    this.tag = tag;\n    this.attrs = attrs;\n    this.startName = startName;\n    this.closeName = closeName;\n    this.children = children;\n    this.isVoid = isVoid;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n\n  _createClass(TagPlaceholder, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitTagPlaceholder(this, context);\n    }\n  }]);\n\n  return TagPlaceholder;\n}();\n\nvar Placeholder = /*#__PURE__*/function () {\n  function Placeholder(value, name, sourceSpan) {\n    _classCallCheck(this, Placeholder);\n\n    this.value = value;\n    this.name = name;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(Placeholder, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitPlaceholder(this, context);\n    }\n  }]);\n\n  return Placeholder;\n}();\n\nvar IcuPlaceholder = /*#__PURE__*/function () {\n  function IcuPlaceholder(value, name, sourceSpan) {\n    _classCallCheck(this, IcuPlaceholder);\n\n    this.value = value;\n    this.name = name;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(IcuPlaceholder, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitIcuPlaceholder(this, context);\n    }\n  }]);\n\n  return IcuPlaceholder;\n}(); // Clone the AST\n\n\nvar CloneVisitor = /*#__PURE__*/function () {\n  function CloneVisitor() {\n    _classCallCheck(this, CloneVisitor);\n  }\n\n  _createClass(CloneVisitor, [{\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      return new Text$1(text.value, text.sourceSpan);\n    }\n  }, {\n    key: \"visitContainer\",\n    value: function visitContainer(container, context) {\n      var _this63 = this;\n\n      var children = container.children.map(function (n) {\n        return n.visit(_this63, context);\n      });\n      return new Container(children, container.sourceSpan);\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu, context) {\n      var _this64 = this;\n\n      var cases = {};\n      Object.keys(icu.cases).forEach(function (key) {\n        return cases[key] = icu.cases[key].visit(_this64, context);\n      });\n      var msg = new Icu$1(icu.expression, icu.type, cases, icu.sourceSpan);\n      msg.expressionPlaceholder = icu.expressionPlaceholder;\n      return msg;\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph, context) {\n      var _this65 = this;\n\n      var children = ph.children.map(function (n) {\n        return n.visit(_this65, context);\n      });\n      return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph, context) {\n      return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n    }\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {\n      return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n    }\n  }]);\n\n  return CloneVisitor;\n}(); // Visit all the nodes recursively\n\n\nvar RecurseVisitor = /*#__PURE__*/function () {\n  function RecurseVisitor() {\n    _classCallCheck(this, RecurseVisitor);\n  }\n\n  _createClass(RecurseVisitor, [{\n    key: \"visitText\",\n    value: function visitText(text, context) {}\n  }, {\n    key: \"visitContainer\",\n    value: function visitContainer(container, context) {\n      var _this66 = this;\n\n      container.children.forEach(function (child) {\n        return child.visit(_this66);\n      });\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu, context) {\n      var _this67 = this;\n\n      Object.keys(icu.cases).forEach(function (k) {\n        icu.cases[k].visit(_this67);\n      });\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph, context) {\n      var _this68 = this;\n\n      ph.children.forEach(function (child) {\n        return child.visit(_this68);\n      });\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph, context) {}\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {}\n  }]);\n\n  return RecurseVisitor;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Represents a big integer using a buffer of its individual digits, with the least significant\r\n * digit stored at the beginning of the array (little endian).\r\n *\r\n * For performance reasons, each instance is mutable. The addition operation can be done in-place\r\n * to reduce memory pressure of allocation for the digits array.\r\n */\n\n\nvar BigInteger = /*#__PURE__*/function () {\n  /**\r\n   * Creates a big integer using its individual digits in little endian storage.\r\n   */\n  function BigInteger(digits) {\n    _classCallCheck(this, BigInteger);\n\n    this.digits = digits;\n  }\n\n  _createClass(BigInteger, [{\n    key: \"clone\",\n    value:\n    /**\r\n     * Creates a clone of this instance.\r\n     */\n    function clone() {\n      return new BigInteger(this.digits.slice());\n    }\n    /**\r\n     * Returns a new big integer with the sum of `this` and `other` as its value. This does not mutate\r\n     * `this` but instead returns a new instance, unlike `addToSelf`.\r\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(other) {\n      var result = this.clone();\n      result.addToSelf(other);\n      return result;\n    }\n    /**\r\n     * Adds `other` to the instance itself, thereby mutating its value.\r\n     */\n\n  }, {\n    key: \"addToSelf\",\n    value: function addToSelf(other) {\n      var maxNrOfDigits = Math.max(this.digits.length, other.digits.length);\n      var carry = 0;\n\n      for (var i = 0; i < maxNrOfDigits; i++) {\n        var digitSum = carry;\n\n        if (i < this.digits.length) {\n          digitSum += this.digits[i];\n        }\n\n        if (i < other.digits.length) {\n          digitSum += other.digits[i];\n        }\n\n        if (digitSum >= 10) {\n          this.digits[i] = digitSum - 10;\n          carry = 1;\n        } else {\n          this.digits[i] = digitSum;\n          carry = 0;\n        }\n      } // Apply a remaining carry if needed.\n\n\n      if (carry > 0) {\n        this.digits[maxNrOfDigits] = 1;\n      }\n    }\n    /**\r\n     * Builds the decimal string representation of the big integer. As this is stored in\r\n     * little endian, the digits are concatenated in reverse order.\r\n     */\n\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var res = '';\n\n      for (var i = this.digits.length - 1; i >= 0; i--) {\n        res += this.digits[i];\n      }\n\n      return res;\n    }\n  }], [{\n    key: \"zero\",\n    value: function zero() {\n      return new BigInteger([0]);\n    }\n  }, {\n    key: \"one\",\n    value: function one() {\n      return new BigInteger([1]);\n    }\n  }]);\n\n  return BigInteger;\n}();\n/**\r\n * Represents a big integer which is optimized for multiplication operations, as its power-of-twos\r\n * are memoized. See `multiplyBy()` for details on the multiplication algorithm.\r\n */\n\n\nvar BigIntForMultiplication = /*#__PURE__*/function () {\n  function BigIntForMultiplication(value) {\n    _classCallCheck(this, BigIntForMultiplication);\n\n    this.powerOfTwos = [value];\n  }\n  /**\r\n   * Returns the big integer itself.\r\n   */\n\n\n  _createClass(BigIntForMultiplication, [{\n    key: \"getValue\",\n    value: function getValue() {\n      return this.powerOfTwos[0];\n    }\n    /**\r\n     * Computes the value for `num * b`, where `num` is a JS number and `b` is a big integer. The\r\n     * value for `b` is represented by a storage model that is optimized for this computation.\r\n     *\r\n     * This operation is implemented in N(log2(num)) by continuous halving of the number, where the\r\n     * least-significant bit (LSB) is tested in each iteration. If the bit is set, the bit's index is\r\n     * used as exponent into the power-of-two multiplication of `b`.\r\n     *\r\n     * As an example, consider the multiplication num=42, b=1337. In binary 42 is 0b00101010 and the\r\n     * algorithm unrolls into the following iterations:\r\n     *\r\n     *  Iteration | num        | LSB  | b * 2^iter | Add? | product\r\n     * -----------|------------|------|------------|------|--------\r\n     *  0         | 0b00101010 | 0    | 1337       | No   | 0\r\n     *  1         | 0b00010101 | 1    | 2674       | Yes  | 2674\r\n     *  2         | 0b00001010 | 0    | 5348       | No   | 2674\r\n     *  3         | 0b00000101 | 1    | 10696      | Yes  | 13370\r\n     *  4         | 0b00000010 | 0    | 21392      | No   | 13370\r\n     *  5         | 0b00000001 | 1    | 42784      | Yes  | 56154\r\n     *  6         | 0b00000000 | 0    | 85568      | No   | 56154\r\n     *\r\n     * The computed product of 56154 is indeed the correct result.\r\n     *\r\n     * The `BigIntForMultiplication` representation for a big integer provides memoized access to the\r\n     * power-of-two values to reduce the workload in computing those values.\r\n     */\n\n  }, {\n    key: \"multiplyBy\",\n    value: function multiplyBy(num) {\n      var product = BigInteger.zero();\n      this.multiplyByAndAddTo(num, product);\n      return product;\n    }\n    /**\r\n     * See `multiplyBy()` for details. This function allows for the computed product to be added\r\n     * directly to the provided result big integer.\r\n     */\n\n  }, {\n    key: \"multiplyByAndAddTo\",\n    value: function multiplyByAndAddTo(num, result) {\n      for (var exponent = 0; num !== 0; num = num >>> 1, exponent++) {\n        if (num & 1) {\n          var value = this.getMultipliedByPowerOfTwo(exponent);\n          result.addToSelf(value);\n        }\n      }\n    }\n    /**\r\n     * Computes and memoizes the big integer value for `this.number * 2^exponent`.\r\n     */\n\n  }, {\n    key: \"getMultipliedByPowerOfTwo\",\n    value: function getMultipliedByPowerOfTwo(exponent) {\n      // Compute the powers up until the requested exponent, where each value is computed from its\n      // predecessor. This is simple as `this.number * 2^(exponent - 1)` only has to be doubled (i.e.\n      // added to itself) to reach `this.number * 2^exponent`.\n      for (var i = this.powerOfTwos.length; i <= exponent; i++) {\n        var previousPower = this.powerOfTwos[i - 1];\n        this.powerOfTwos[i] = previousPower.add(previousPower);\n      }\n\n      return this.powerOfTwos[exponent];\n    }\n  }]);\n\n  return BigIntForMultiplication;\n}();\n/**\r\n * Represents an exponentiation operation for the provided base, of which exponents are computed and\r\n * memoized. The results are represented by a `BigIntForMultiplication` which is tailored for\r\n * multiplication operations by memoizing the power-of-twos. This effectively results in a matrix\r\n * representation that is lazily computed upon request.\r\n */\n\n\nvar BigIntExponentiation = /*#__PURE__*/function () {\n  function BigIntExponentiation(base) {\n    _classCallCheck(this, BigIntExponentiation);\n\n    this.base = base;\n    this.exponents = [new BigIntForMultiplication(BigInteger.one())];\n  }\n  /**\r\n   * Compute the value for `this.base^exponent`, resulting in a big integer that is optimized for\r\n   * further multiplication operations.\r\n   */\n\n\n  _createClass(BigIntExponentiation, [{\n    key: \"toThePowerOf\",\n    value: function toThePowerOf(exponent) {\n      // Compute the results up until the requested exponent, where every value is computed from its\n      // predecessor. This is because `this.base^(exponent - 1)` only has to be multiplied by `base`\n      // to reach `this.base^exponent`.\n      for (var i = this.exponents.length; i <= exponent; i++) {\n        var value = this.exponents[i - 1].multiplyBy(this.base);\n        this.exponents[i] = new BigIntForMultiplication(value);\n      }\n\n      return this.exponents[exponent];\n    }\n  }]);\n\n  return BigIntExponentiation;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Return the message id or compute it using the XLIFF1 digest.\r\n */\n\n\nfunction _digest2(message) {\n  return message.id || computeDigest(message);\n}\n/**\r\n * Compute the message id using the XLIFF1 digest.\r\n */\n\n\nfunction computeDigest(message) {\n  return sha1(serializeNodes(message.nodes).join('') + \"[\".concat(message.meaning, \"]\"));\n}\n/**\r\n * Return the message id or compute it using the XLIFF2/XMB/$localize digest.\r\n */\n\n\nfunction decimalDigest(message) {\n  return message.id || computeDecimalDigest(message);\n}\n/**\r\n * Compute the message id using the XLIFF2/XMB/$localize digest.\r\n */\n\n\nfunction computeDecimalDigest(message) {\n  var visitor = new _SerializerIgnoreIcuExpVisitor();\n  var parts = message.nodes.map(function (a) {\n    return a.visit(visitor, null);\n  });\n  return computeMsgId(parts.join(''), message.meaning);\n}\n/**\r\n * Serialize the i18n ast to something xml-like in order to generate an UID.\r\n *\r\n * The visitor is also used in the i18n parser tests\r\n *\r\n * @internal\r\n */\n\n\nvar _SerializerVisitor = /*#__PURE__*/function () {\n  function _SerializerVisitor() {\n    _classCallCheck(this, _SerializerVisitor);\n  }\n\n  _createClass(_SerializerVisitor, [{\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      return text.value;\n    }\n  }, {\n    key: \"visitContainer\",\n    value: function visitContainer(container, context) {\n      var _this69 = this;\n\n      return \"[\".concat(container.children.map(function (child) {\n        return child.visit(_this69);\n      }).join(', '), \"]\");\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu, context) {\n      var _this70 = this;\n\n      var strCases = Object.keys(icu.cases).map(function (k) {\n        return \"\".concat(k, \" {\").concat(icu.cases[k].visit(_this70), \"}\");\n      });\n      return \"{\".concat(icu.expression, \", \").concat(icu.type, \", \").concat(strCases.join(', '), \"}\");\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph, context) {\n      var _this71 = this;\n\n      return ph.isVoid ? \"<ph tag name=\\\"\".concat(ph.startName, \"\\\"/>\") : \"<ph tag name=\\\"\".concat(ph.startName, \"\\\">\").concat(ph.children.map(function (child) {\n        return child.visit(_this71);\n      }).join(', '), \"</ph name=\\\"\").concat(ph.closeName, \"\\\">\");\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph, context) {\n      return ph.value ? \"<ph name=\\\"\".concat(ph.name, \"\\\">\").concat(ph.value, \"</ph>\") : \"<ph name=\\\"\".concat(ph.name, \"\\\"/>\");\n    }\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {\n      return \"<ph icu name=\\\"\".concat(ph.name, \"\\\">\").concat(ph.value.visit(this), \"</ph>\");\n    }\n  }]);\n\n  return _SerializerVisitor;\n}();\n\nvar serializerVisitor = new _SerializerVisitor();\n\nfunction serializeNodes(nodes) {\n  return nodes.map(function (a) {\n    return a.visit(serializerVisitor, null);\n  });\n}\n/**\r\n * Serialize the i18n ast to something xml-like in order to generate an UID.\r\n *\r\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\r\n *\r\n * @internal\r\n */\n\n\nvar _SerializerIgnoreIcuExpVisitor = /*#__PURE__*/function (_SerializerVisitor2) {\n  _inherits(_SerializerIgnoreIcuExpVisitor, _SerializerVisitor2);\n\n  var _super48 = _createSuper(_SerializerIgnoreIcuExpVisitor);\n\n  function _SerializerIgnoreIcuExpVisitor() {\n    _classCallCheck(this, _SerializerIgnoreIcuExpVisitor);\n\n    return _super48.apply(this, arguments);\n  }\n\n  _createClass(_SerializerIgnoreIcuExpVisitor, [{\n    key: \"visitIcu\",\n    value: function visitIcu(icu, context) {\n      var _this72 = this;\n\n      var strCases = Object.keys(icu.cases).map(function (k) {\n        return \"\".concat(k, \" {\").concat(icu.cases[k].visit(_this72), \"}\");\n      }); // Do not take the expression into account\n\n      return \"{\".concat(icu.type, \", \").concat(strCases.join(', '), \"}\");\n    }\n  }]);\n\n  return _SerializerIgnoreIcuExpVisitor;\n}(_SerializerVisitor);\n/**\r\n * Compute the SHA1 of the given string\r\n *\r\n * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\r\n *\r\n * WARNING: this function has not been designed not tested with security in mind.\r\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\r\n */\n\n\nfunction sha1(str) {\n  var utf8 = utf8Encode(str);\n  var words32 = bytesToWords32(utf8, Endian.Big);\n  var len = utf8.length * 8;\n  var w = newArray(80);\n  var a = 0x67452301,\n      b = 0xefcdab89,\n      c = 0x98badcfe,\n      d = 0x10325476,\n      e = 0xc3d2e1f0;\n  words32[len >> 5] |= 0x80 << 24 - len % 32;\n  words32[(len + 64 >> 9 << 4) + 15] = len;\n\n  for (var i = 0; i < words32.length; i += 16) {\n    var h0 = a,\n        h1 = b,\n        h2 = c,\n        h3 = d,\n        h4 = e;\n\n    for (var j = 0; j < 80; j++) {\n      if (j < 16) {\n        w[j] = words32[i + j];\n      } else {\n        w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n      }\n\n      var fkVal = fk(j, b, c, d);\n      var f = fkVal[0];\n      var k = fkVal[1];\n      var temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n      e = d;\n      d = c;\n      c = rol32(b, 30);\n      b = a;\n      a = temp;\n    }\n\n    a = add32(a, h0);\n    b = add32(b, h1);\n    c = add32(c, h2);\n    d = add32(d, h3);\n    e = add32(e, h4);\n  }\n\n  return bytesToHexString(words32ToByteString([a, b, c, d, e]));\n}\n\nfunction fk(index, b, c, d) {\n  if (index < 20) {\n    return [b & c | ~b & d, 0x5a827999];\n  }\n\n  if (index < 40) {\n    return [b ^ c ^ d, 0x6ed9eba1];\n  }\n\n  if (index < 60) {\n    return [b & c | b & d | c & d, 0x8f1bbcdc];\n  }\n\n  return [b ^ c ^ d, 0xca62c1d6];\n}\n/**\r\n * Compute the fingerprint of the given string\r\n *\r\n * The output is 64 bit number encoded as a decimal string\r\n *\r\n * based on:\r\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\r\n */\n\n\nfunction fingerprint(str) {\n  var utf8 = utf8Encode(str);\n  var hi = hash32(utf8, 0);\n  var lo = hash32(utf8, 102072);\n\n  if (hi == 0 && (lo == 0 || lo == 1)) {\n    hi = hi ^ 0x130f9bef;\n    lo = lo ^ -0x6b5f56d8;\n  }\n\n  return [hi, lo];\n}\n\nfunction computeMsgId(msg) {\n  var meaning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var msgFingerprint = fingerprint(msg);\n\n  if (meaning) {\n    var meaningFingerprint = fingerprint(meaning);\n    msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);\n  }\n\n  var hi = msgFingerprint[0];\n  var lo = msgFingerprint[1];\n  return wordsToDecimalString(hi & 0x7fffffff, lo);\n}\n\nfunction hash32(bytes, c) {\n  var a = 0x9e3779b9,\n      b = 0x9e3779b9;\n  var i;\n  var len = bytes.length;\n\n  for (i = 0; i + 12 <= len; i += 12) {\n    a = add32(a, wordAt(bytes, i, Endian.Little));\n    b = add32(b, wordAt(bytes, i + 4, Endian.Little));\n    c = add32(c, wordAt(bytes, i + 8, Endian.Little));\n    var res = mix(a, b, c);\n    a = res[0], b = res[1], c = res[2];\n  }\n\n  a = add32(a, wordAt(bytes, i, Endian.Little));\n  b = add32(b, wordAt(bytes, i + 4, Endian.Little)); // the first byte of c is reserved for the length\n\n  c = add32(c, len);\n  c = add32(c, wordAt(bytes, i + 8, Endian.Little) << 8);\n  return mix(a, b, c)[2];\n} // clang-format off\n\n\nfunction mix(a, b, c) {\n  a = sub32(a, b);\n  a = sub32(a, c);\n  a ^= c >>> 13;\n  b = sub32(b, c);\n  b = sub32(b, a);\n  b ^= a << 8;\n  c = sub32(c, a);\n  c = sub32(c, b);\n  c ^= b >>> 13;\n  a = sub32(a, b);\n  a = sub32(a, c);\n  a ^= c >>> 12;\n  b = sub32(b, c);\n  b = sub32(b, a);\n  b ^= a << 16;\n  c = sub32(c, a);\n  c = sub32(c, b);\n  c ^= b >>> 5;\n  a = sub32(a, b);\n  a = sub32(a, c);\n  a ^= c >>> 3;\n  b = sub32(b, c);\n  b = sub32(b, a);\n  b ^= a << 10;\n  c = sub32(c, a);\n  c = sub32(c, b);\n  c ^= b >>> 15;\n  return [a, b, c];\n} // clang-format on\n// Utils\n\n\nvar Endian;\n\n(function (Endian) {\n  Endian[Endian[\"Little\"] = 0] = \"Little\";\n  Endian[Endian[\"Big\"] = 1] = \"Big\";\n})(Endian || (Endian = {}));\n\nfunction add32(a, b) {\n  return add32to64(a, b)[1];\n}\n\nfunction add32to64(a, b) {\n  var low = (a & 0xffff) + (b & 0xffff);\n  var high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n  return [high >>> 16, high << 16 | low & 0xffff];\n}\n\nfunction add64(a, b) {\n  var ah = a[0],\n      al = a[1];\n  var bh = b[0],\n      bl = b[1];\n  var result = add32to64(al, bl);\n  var carry = result[0];\n  var l = result[1];\n  var h = add32(add32(ah, bh), carry);\n  return [h, l];\n}\n\nfunction sub32(a, b) {\n  var low = (a & 0xffff) - (b & 0xffff);\n  var high = (a >> 16) - (b >> 16) + (low >> 16);\n  return high << 16 | low & 0xffff;\n} // Rotate a 32b number left `count` position\n\n\nfunction rol32(a, count) {\n  return a << count | a >>> 32 - count;\n} // Rotate a 64b number left `count` position\n\n\nfunction rol64(num, count) {\n  var hi = num[0],\n      lo = num[1];\n  var h = hi << count | lo >>> 32 - count;\n  var l = lo << count | hi >>> 32 - count;\n  return [h, l];\n}\n\nfunction bytesToWords32(bytes, endian) {\n  var size = bytes.length + 3 >>> 2;\n  var words32 = [];\n\n  for (var i = 0; i < size; i++) {\n    words32[i] = wordAt(bytes, i * 4, endian);\n  }\n\n  return words32;\n}\n\nfunction byteAt(bytes, index) {\n  return index >= bytes.length ? 0 : bytes[index];\n}\n\nfunction wordAt(bytes, index, endian) {\n  var word = 0;\n\n  if (endian === Endian.Big) {\n    for (var i = 0; i < 4; i++) {\n      word += byteAt(bytes, index + i) << 24 - 8 * i;\n    }\n  } else {\n    for (var _i5 = 0; _i5 < 4; _i5++) {\n      word += byteAt(bytes, index + _i5) << 8 * _i5;\n    }\n  }\n\n  return word;\n}\n\nfunction words32ToByteString(words32) {\n  return words32.reduce(function (bytes, word) {\n    return bytes.concat(word32ToByteString(word));\n  }, []);\n}\n\nfunction word32ToByteString(word) {\n  var bytes = [];\n\n  for (var i = 0; i < 4; i++) {\n    bytes.push(word >>> 8 * (3 - i) & 0xff);\n  }\n\n  return bytes;\n}\n\nfunction bytesToHexString(bytes) {\n  var hex = '';\n\n  for (var i = 0; i < bytes.length; i++) {\n    var b = byteAt(bytes, i);\n    hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\n  }\n\n  return hex.toLowerCase();\n}\n/**\r\n * Create a shared exponentiation pool for base-256 computations. This shared pool provides memoized\r\n * power-of-256 results with memoized power-of-two computations for efficient multiplication.\r\n *\r\n * For our purposes, this can be safely stored as a global without memory concerns. The reason is\r\n * that we encode two words, so only need the 0th (for the low word) and 4th (for the high word)\r\n * exponent.\r\n */\n\n\nvar base256 = new BigIntExponentiation(256);\n/**\r\n * Represents two 32-bit words as a single decimal number. This requires a big integer storage\r\n * model as JS numbers are not accurate enough to represent the 64-bit number.\r\n *\r\n * Based on https://www.danvk.org/hex2dec.html\r\n */\n\nfunction wordsToDecimalString(hi, lo) {\n  // Encode the four bytes in lo in the lower digits of the decimal number.\n  // Note: the multiplication results in lo itself but represented by a big integer using its\n  // decimal digits.\n  var decimal = base256.toThePowerOf(0).multiplyBy(lo); // Encode the four bytes in hi above the four lo bytes. lo is a maximum of (2^8)^4, which is why\n  // this multiplication factor is applied.\n\n  base256.toThePowerOf(4).multiplyByAndAddTo(hi, decimal);\n  return decimal.toString();\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar Serializer = /*#__PURE__*/function () {\n  function Serializer() {\n    _classCallCheck(this, Serializer);\n  }\n\n  _createClass(Serializer, [{\n    key: \"createNameMapper\",\n    value: // Creates a name mapper, see `PlaceholderMapper`\n    // Returning `null` means that no name mapping is used.\n    function createNameMapper(message) {\n      return null;\n    }\n  }]);\n\n  return Serializer;\n}();\n/**\r\n * A simple mapper that take a function to transform an internal name to a public name\r\n */\n\n\nvar SimplePlaceholderMapper = /*#__PURE__*/function (_RecurseVisitor) {\n  _inherits(SimplePlaceholderMapper, _RecurseVisitor);\n\n  var _super49 = _createSuper(SimplePlaceholderMapper);\n\n  // create a mapping from the message\n  function SimplePlaceholderMapper(message, mapName) {\n    var _this73;\n\n    _classCallCheck(this, SimplePlaceholderMapper);\n\n    _this73 = _super49.call(this);\n    _this73.mapName = mapName;\n    _this73.internalToPublic = {};\n    _this73.publicToNextId = {};\n    _this73.publicToInternal = {};\n    message.nodes.forEach(function (node) {\n      return node.visit(_assertThisInitialized(_this73));\n    });\n    return _this73;\n  }\n\n  _createClass(SimplePlaceholderMapper, [{\n    key: \"toPublicName\",\n    value: function toPublicName(internalName) {\n      return this.internalToPublic.hasOwnProperty(internalName) ? this.internalToPublic[internalName] : null;\n    }\n  }, {\n    key: \"toInternalName\",\n    value: function toInternalName(publicName) {\n      return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] : null;\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      return null;\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph, context) {\n      this.visitPlaceholderName(ph.startName);\n\n      _get(_getPrototypeOf(SimplePlaceholderMapper.prototype), \"visitTagPlaceholder\", this).call(this, ph, context);\n\n      this.visitPlaceholderName(ph.closeName);\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph, context) {\n      this.visitPlaceholderName(ph.name);\n    }\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {\n      this.visitPlaceholderName(ph.name);\n    } // XMB placeholders could only contains A-Z, 0-9 and _\n\n  }, {\n    key: \"visitPlaceholderName\",\n    value: function visitPlaceholderName(internalName) {\n      if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n        return;\n      }\n\n      var publicName = this.mapName(internalName);\n\n      if (this.publicToInternal.hasOwnProperty(publicName)) {\n        // Create a new XMB when it has already been used\n        var nextId = this.publicToNextId[publicName];\n        this.publicToNextId[publicName] = nextId + 1;\n        publicName = \"\".concat(publicName, \"_\").concat(nextId);\n      } else {\n        this.publicToNextId[publicName] = 1;\n      }\n\n      this.internalToPublic[internalName] = publicName;\n      this.publicToInternal[publicName] = internalName;\n    }\n  }]);\n\n  return SimplePlaceholderMapper;\n}(RecurseVisitor);\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar _Visitor = /*#__PURE__*/function () {\n  function _Visitor() {\n    _classCallCheck(this, _Visitor);\n  }\n\n  _createClass(_Visitor, [{\n    key: \"visitTag\",\n    value: function visitTag(tag) {\n      var _this74 = this;\n\n      var strAttrs = this._serializeAttributes(tag.attrs);\n\n      if (tag.children.length == 0) {\n        return \"<\".concat(tag.name).concat(strAttrs, \"/>\");\n      }\n\n      var strChildren = tag.children.map(function (node) {\n        return node.visit(_this74);\n      });\n      return \"<\".concat(tag.name).concat(strAttrs, \">\").concat(strChildren.join(''), \"</\").concat(tag.name, \">\");\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {\n      return text.value;\n    }\n  }, {\n    key: \"visitDeclaration\",\n    value: function visitDeclaration(decl) {\n      return \"<?xml\".concat(this._serializeAttributes(decl.attrs), \" ?>\");\n    }\n  }, {\n    key: \"_serializeAttributes\",\n    value: function _serializeAttributes(attrs) {\n      var strAttrs = Object.keys(attrs).map(function (name) {\n        return \"\".concat(name, \"=\\\"\").concat(attrs[name], \"\\\"\");\n      }).join(' ');\n      return strAttrs.length > 0 ? ' ' + strAttrs : '';\n    }\n  }, {\n    key: \"visitDoctype\",\n    value: function visitDoctype(doctype) {\n      return \"<!DOCTYPE \".concat(doctype.rootTag, \" [\\n\").concat(doctype.dtd, \"\\n]>\");\n    }\n  }]);\n\n  return _Visitor;\n}();\n\nvar _visitor = new _Visitor();\n\nfunction serialize(nodes) {\n  return nodes.map(function (node) {\n    return node.visit(_visitor);\n  }).join('');\n}\n\nvar Declaration = /*#__PURE__*/function () {\n  function Declaration(unescapedAttrs) {\n    var _this75 = this;\n\n    _classCallCheck(this, Declaration);\n\n    this.attrs = {};\n    Object.keys(unescapedAttrs).forEach(function (k) {\n      _this75.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n\n  _createClass(Declaration, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitDeclaration(this);\n    }\n  }]);\n\n  return Declaration;\n}();\n\nvar Doctype = /*#__PURE__*/function () {\n  function Doctype(rootTag, dtd) {\n    _classCallCheck(this, Doctype);\n\n    this.rootTag = rootTag;\n    this.dtd = dtd;\n  }\n\n  _createClass(Doctype, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitDoctype(this);\n    }\n  }]);\n\n  return Doctype;\n}();\n\nvar Tag = /*#__PURE__*/function () {\n  function Tag(name) {\n    var _this76 = this;\n\n    var unescapedAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    _classCallCheck(this, Tag);\n\n    this.name = name;\n    this.children = children;\n    this.attrs = {};\n    Object.keys(unescapedAttrs).forEach(function (k) {\n      _this76.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n\n  _createClass(Tag, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitTag(this);\n    }\n  }]);\n\n  return Tag;\n}();\n\nvar Text$2 = /*#__PURE__*/function () {\n  function Text$2(unescapedValue) {\n    _classCallCheck(this, Text$2);\n\n    this.value = escapeXml(unescapedValue);\n  }\n\n  _createClass(Text$2, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitText(this);\n    }\n  }]);\n\n  return Text$2;\n}();\n\nvar CR = /*#__PURE__*/function (_Text$) {\n  _inherits(CR, _Text$);\n\n  var _super50 = _createSuper(CR);\n\n  function CR() {\n    var ws = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    _classCallCheck(this, CR);\n\n    return _super50.call(this, \"\\n\".concat(new Array(ws + 1).join(' ')));\n  }\n\n  return CR;\n}(Text$2);\n\nvar _ESCAPED_CHARS = [[/&/g, '&amp;'], [/\"/g, '&quot;'], [/'/g, '&apos;'], [/</g, '&lt;'], [/>/g, '&gt;']]; // Escape `_ESCAPED_CHARS` characters in the given text with encoded entities\n\nfunction escapeXml(text) {\n  return _ESCAPED_CHARS.reduce(function (text, entry) {\n    return text.replace(entry[0], entry[1]);\n  }, text);\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar _MESSAGES_TAG = 'messagebundle';\nvar _MESSAGE_TAG = 'msg';\nvar _PLACEHOLDER_TAG = 'ph';\nvar _EXAMPLE_TAG = 'ex';\nvar _SOURCE_TAG = 'source';\nvar _DOCTYPE = \"<!ELEMENT messagebundle (msg)*>\\n<!ATTLIST messagebundle class CDATA #IMPLIED>\\n\\n<!ELEMENT msg (#PCDATA|ph|source)*>\\n<!ATTLIST msg id CDATA #IMPLIED>\\n<!ATTLIST msg seq CDATA #IMPLIED>\\n<!ATTLIST msg name CDATA #IMPLIED>\\n<!ATTLIST msg desc CDATA #IMPLIED>\\n<!ATTLIST msg meaning CDATA #IMPLIED>\\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\\n<!ATTLIST msg xml:space (default|preserve) \\\"default\\\">\\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\\n\\n<!ELEMENT source (#PCDATA)>\\n\\n<!ELEMENT ph (#PCDATA|ex)*>\\n<!ATTLIST ph name CDATA #REQUIRED>\\n\\n<!ELEMENT ex (#PCDATA)>\";\n\nvar Xmb = /*#__PURE__*/function (_Serializer) {\n  _inherits(Xmb, _Serializer);\n\n  var _super51 = _createSuper(Xmb);\n\n  function Xmb() {\n    _classCallCheck(this, Xmb);\n\n    return _super51.apply(this, arguments);\n  }\n\n  _createClass(Xmb, [{\n    key: \"write\",\n    value: function write(messages, locale) {\n      var exampleVisitor = new ExampleVisitor();\n      var visitor = new _Visitor$1();\n      var rootNode = new Tag(_MESSAGES_TAG);\n      messages.forEach(function (message) {\n        var attrs = {\n          id: message.id\n        };\n\n        if (message.description) {\n          attrs['desc'] = message.description;\n        }\n\n        if (message.meaning) {\n          attrs['meaning'] = message.meaning;\n        }\n\n        var sourceTags = [];\n        message.sources.forEach(function (source) {\n          sourceTags.push(new Tag(_SOURCE_TAG, {}, [new Text$2(\"\".concat(source.filePath, \":\").concat(source.startLine).concat(source.endLine !== source.startLine ? ',' + source.endLine : ''))]));\n        });\n        rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, [].concat(sourceTags, _toConsumableArray(visitor.serialize(message.nodes)))));\n      });\n      rootNode.children.push(new CR());\n      return serialize([new Declaration({\n        version: '1.0',\n        encoding: 'UTF-8'\n      }), new CR(), new Doctype(_MESSAGES_TAG, _DOCTYPE), new CR(), exampleVisitor.addDefaultExamples(rootNode), new CR()]);\n    }\n  }, {\n    key: \"load\",\n    value: function load(content, url) {\n      throw new Error('Unsupported');\n    }\n  }, {\n    key: \"digest\",\n    value: function digest(message) {\n      return digest$1(message);\n    }\n  }, {\n    key: \"createNameMapper\",\n    value: function createNameMapper(message) {\n      return new SimplePlaceholderMapper(message, toPublicName);\n    }\n  }]);\n\n  return Xmb;\n}(Serializer);\n\nvar _Visitor$1 = /*#__PURE__*/function () {\n  function _Visitor$1() {\n    _classCallCheck(this, _Visitor$1);\n  }\n\n  _createClass(_Visitor$1, [{\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      return [new Text$2(text.value)];\n    }\n  }, {\n    key: \"visitContainer\",\n    value: function visitContainer(container, context) {\n      var _this77 = this;\n\n      var nodes = [];\n      container.children.forEach(function (node) {\n        return nodes.push.apply(nodes, _toConsumableArray(node.visit(_this77)));\n      });\n      return nodes;\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu, context) {\n      var _this78 = this;\n\n      var nodes = [new Text$2(\"{\".concat(icu.expressionPlaceholder, \", \").concat(icu.type, \", \"))];\n      Object.keys(icu.cases).forEach(function (c) {\n        nodes.push.apply(nodes, [new Text$2(\"\".concat(c, \" {\"))].concat(_toConsumableArray(icu.cases[c].visit(_this78)), [new Text$2(\"} \")]));\n      });\n      nodes.push(new Text$2(\"}\"));\n      return nodes;\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph, context) {\n      var startTagAsText = new Text$2(\"<\".concat(ph.tag, \">\"));\n      var startEx = new Tag(_EXAMPLE_TAG, {}, [startTagAsText]); // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n\n      var startTagPh = new Tag(_PLACEHOLDER_TAG, {\n        name: ph.startName\n      }, [startEx, startTagAsText]);\n\n      if (ph.isVoid) {\n        // void tags have no children nor closing tags\n        return [startTagPh];\n      }\n\n      var closeTagAsText = new Text$2(\"</\".concat(ph.tag, \">\"));\n      var closeEx = new Tag(_EXAMPLE_TAG, {}, [closeTagAsText]); // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n\n      var closeTagPh = new Tag(_PLACEHOLDER_TAG, {\n        name: ph.closeName\n      }, [closeEx, closeTagAsText]);\n      return [startTagPh].concat(_toConsumableArray(this.serialize(ph.children)), [closeTagPh]);\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph, context) {\n      var interpolationAsText = new Text$2(\"{{\".concat(ph.value, \"}}\")); // Example tag needs to be not-empty for TC.\n\n      var exTag = new Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);\n      return [// TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n      new Tag(_PLACEHOLDER_TAG, {\n        name: ph.name\n      }, [exTag, interpolationAsText])];\n    }\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {\n      var icuExpression = ph.value.expression;\n      var icuType = ph.value.type;\n      var icuCases = Object.keys(ph.value.cases).map(function (value) {\n        return value + ' {...}';\n      }).join(' ');\n      var icuAsText = new Text$2(\"{\".concat(icuExpression, \", \").concat(icuType, \", \").concat(icuCases, \"}\"));\n      var exTag = new Tag(_EXAMPLE_TAG, {}, [icuAsText]);\n      return [// TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n      new Tag(_PLACEHOLDER_TAG, {\n        name: ph.name\n      }, [exTag, icuAsText])];\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(nodes) {\n      var _ref3,\n          _this79 = this;\n\n      return (_ref3 = []).concat.apply(_ref3, _toConsumableArray(nodes.map(function (node) {\n        return node.visit(_this79);\n      })));\n    }\n  }]);\n\n  return _Visitor$1;\n}();\n\nfunction digest$1(message) {\n  return decimalDigest(message);\n} // TC requires at least one non-empty example on placeholders\n\n\nvar ExampleVisitor = /*#__PURE__*/function () {\n  function ExampleVisitor() {\n    _classCallCheck(this, ExampleVisitor);\n  }\n\n  _createClass(ExampleVisitor, [{\n    key: \"addDefaultExamples\",\n    value: function addDefaultExamples(node) {\n      node.visit(this);\n      return node;\n    }\n  }, {\n    key: \"visitTag\",\n    value: function visitTag(tag) {\n      var _this80 = this;\n\n      if (tag.name === _PLACEHOLDER_TAG) {\n        if (!tag.children || tag.children.length == 0) {\n          var exText = new Text$2(tag.attrs['name'] || '...');\n          tag.children = [new Tag(_EXAMPLE_TAG, {}, [exText])];\n        }\n      } else if (tag.children) {\n        tag.children.forEach(function (node) {\n          return node.visit(_this80);\n        });\n      }\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {}\n  }, {\n    key: \"visitDeclaration\",\n    value: function visitDeclaration(decl) {}\n  }, {\n    key: \"visitDoctype\",\n    value: function visitDoctype(doctype) {}\n  }]);\n\n  return ExampleVisitor;\n}(); // XMB/XTB placeholders can only contain A-Z, 0-9 and _\n\n\nfunction toPublicName(internalName) {\n  return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */\n\n\nvar CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';\n/**\r\n * Prefix for non-`goog.getMsg` i18n-related vars.\r\n * Note: the prefix uses lowercase characters intentionally due to a Closure behavior that\r\n * considers variables like `I18N_0` as constants and throws an error when their value changes.\r\n */\n\nvar TRANSLATION_VAR_PREFIX = 'i18n_';\n/** Name of the i18n attributes **/\n\nvar I18N_ATTR = 'i18n';\nvar I18N_ATTR_PREFIX = 'i18n-';\n/** Prefix of var expressions used in ICUs */\n\nvar I18N_ICU_VAR_PREFIX = 'VAR_';\n/** Prefix of ICU expressions for post processing */\n\nvar I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\n/** Placeholder wrapper for i18n expressions **/\n\nvar I18N_PLACEHOLDER_SYMBOL = '�';\n\nfunction isI18nAttribute(name) {\n  return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\n}\n\nfunction isI18nRootNode(meta) {\n  return meta instanceof Message;\n}\n\nfunction isSingleI18nIcu(meta) {\n  return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu$1;\n}\n\nfunction hasI18nMeta(node) {\n  return !!node.i18n;\n}\n\nfunction hasI18nAttrs(element) {\n  return element.attrs.some(function (attr) {\n    return isI18nAttribute(attr.name);\n  });\n}\n\nfunction icuFromI18nMessage(message) {\n  return message.nodes[0];\n}\n\nfunction wrapI18nPlaceholder(content) {\n  var contextId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var blockId = contextId > 0 ? \":\".concat(contextId) : '';\n  return \"\".concat(I18N_PLACEHOLDER_SYMBOL).concat(content).concat(blockId).concat(I18N_PLACEHOLDER_SYMBOL);\n}\n\nfunction assembleI18nBoundString(strings) {\n  var bindingStartIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var contextId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (!strings.length) return '';\n  var acc = '';\n  var lastIdx = strings.length - 1;\n\n  for (var i = 0; i < lastIdx; i++) {\n    acc += \"\".concat(strings[i]).concat(wrapI18nPlaceholder(bindingStartIndex + i, contextId));\n  }\n\n  acc += strings[lastIdx];\n  return acc;\n}\n\nfunction getSeqNumberGenerator() {\n  var startsAt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var current = startsAt;\n  return function () {\n    return current++;\n  };\n}\n\nfunction placeholdersToParams(placeholders) {\n  var params = {};\n  placeholders.forEach(function (values, key) {\n    params[key] = literal(values.length > 1 ? \"[\".concat(values.join('|'), \"]\") : values[0]);\n  });\n  return params;\n}\n\nfunction updatePlaceholderMap(map, name) {\n  var current = map.get(name) || [];\n\n  for (var _len2 = arguments.length, values = new Array(_len2 > 2 ? _len2 - 2 : 0), _key3 = 2; _key3 < _len2; _key3++) {\n    values[_key3 - 2] = arguments[_key3];\n  }\n\n  current.push.apply(current, values);\n  map.set(name, current);\n}\n\nfunction assembleBoundTextPlaceholders(meta) {\n  var bindingStartIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var contextId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var startIdx = bindingStartIndex;\n  var placeholders = new Map();\n  var node = meta instanceof Message ? meta.nodes.find(function (node) {\n    return node instanceof Container;\n  }) : meta;\n\n  if (node) {\n    node.children.filter(function (child) {\n      return child instanceof Placeholder;\n    }).forEach(function (child, idx) {\n      var content = wrapI18nPlaceholder(startIdx + idx, contextId);\n      updatePlaceholderMap(placeholders, child.name, content);\n    });\n  }\n\n  return placeholders;\n}\n/**\r\n * Format the placeholder names in a map of placeholders to expressions.\r\n *\r\n * The placeholder names are converted from \"internal\" format (e.g. `START_TAG_DIV_1`) to \"external\"\r\n * format (e.g. `startTagDiv_1`).\r\n *\r\n * @param params A map of placeholder names to expressions.\r\n * @param useCamelCase whether to camelCase the placeholder name when formatting.\r\n * @returns A new map of formatted placeholder names to expressions.\r\n */\n\n\nfunction i18nFormatPlaceholderNames() {\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var useCamelCase = arguments.length > 1 ? arguments[1] : undefined;\n  var _params = {};\n\n  if (params && Object.keys(params).length) {\n    Object.keys(params).forEach(function (key) {\n      return _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key];\n    });\n  }\n\n  return _params;\n}\n/**\r\n * Converts internal placeholder names to public-facing format\r\n * (for example to use in goog.getMsg call).\r\n * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.\r\n *\r\n * @param name The placeholder name that should be formatted\r\n * @returns Formatted placeholder name\r\n */\n\n\nfunction formatI18nPlaceholderName(name) {\n  var useCamelCase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var publicName = toPublicName(name);\n\n  if (!useCamelCase) {\n    return publicName;\n  }\n\n  var chunks = publicName.split('_');\n\n  if (chunks.length === 1) {\n    // if no \"_\" found - just lowercase the value\n    return name.toLowerCase();\n  }\n\n  var postfix; // eject last element if it's a number\n\n  if (/^\\d+$/.test(chunks[chunks.length - 1])) {\n    postfix = chunks.pop();\n  }\n\n  var raw = chunks.shift().toLowerCase();\n\n  if (chunks.length) {\n    raw += chunks.map(function (c) {\n      return c.charAt(0).toUpperCase() + c.slice(1).toLowerCase();\n    }).join('');\n  }\n\n  return postfix ? \"\".concat(raw, \"_\").concat(postfix) : raw;\n}\n/**\r\n * Generates a prefix for translation const name.\r\n *\r\n * @param extra Additional local prefix that should be injected into translation var name\r\n * @returns Complete translation const prefix\r\n */\n\n\nfunction getTranslationConstPrefix(extra) {\n  return \"\".concat(CLOSURE_TRANSLATION_VAR_PREFIX).concat(extra).toUpperCase();\n}\n/**\r\n * Generate AST to declare a variable. E.g. `var I18N_1;`.\r\n * @param variable the name of the variable to declare.\r\n */\n\n\nfunction declareI18nVariable(variable) {\n  return new DeclareVarStmt(variable.name, undefined, INFERRED_TYPE, undefined, variable.sourceSpan);\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in\r\n * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may\r\n * bot work in some cases when object keys are mangled by minifier.\r\n *\r\n * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with\r\n * inputs that contain potentially unsafe chars.\r\n */\n\n\nvar UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\n/** Name of the temporary to use during data binding */\n\nvar TEMPORARY_NAME = '_t';\n/** Name of the context parameter passed into a template function */\n\nvar CONTEXT_NAME = 'ctx';\n/** Name of the RenderFlag passed into a template function */\n\nvar RENDER_FLAGS = 'rf';\n/** The prefix reference variables */\n\nvar REFERENCE_PREFIX = '_r';\n/** The name of the implicit context reference */\n\nvar IMPLICIT_REFERENCE = '$implicit';\n/** Non bindable attribute name **/\n\nvar NON_BINDABLE_ATTR = 'ngNonBindable';\n/** Name for the variable keeping track of the context returned by `ɵɵrestoreView`. */\n\nvar RESTORED_VIEW_CONTEXT_NAME = 'restoredCtx';\n/**\r\n * Creates an allocator for a temporary variable.\r\n *\r\n * A variable declaration is added to the statements the first time the allocator is invoked.\r\n */\n\nfunction temporaryAllocator(statements, name) {\n  var temp = null;\n  return function () {\n    if (!temp) {\n      statements.push(new DeclareVarStmt(TEMPORARY_NAME, undefined, DYNAMIC_TYPE));\n      temp = variable(name);\n    }\n\n    return temp;\n  };\n}\n\nfunction unsupported(feature) {\n  if (this) {\n    throw new Error(\"Builder \".concat(this.constructor.name, \" doesn't support \").concat(feature, \" yet\"));\n  }\n\n  throw new Error(\"Feature \".concat(feature, \" is not supported yet\"));\n}\n\nfunction invalid$1(arg) {\n  throw new Error(\"Invalid state: Visitor \".concat(this.constructor.name, \" doesn't handle \").concat(arg.constructor.name));\n}\n\nfunction asLiteral(value) {\n  if (Array.isArray(value)) {\n    return literalArr(value.map(asLiteral));\n  }\n\n  return literal(value, INFERRED_TYPE);\n}\n\nfunction conditionallyCreateMapObjectLiteral(keys, keepDeclared) {\n  if (Object.getOwnPropertyNames(keys).length > 0) {\n    return mapToExpression(keys, keepDeclared);\n  }\n\n  return null;\n}\n\nfunction mapToExpression(map, keepDeclared) {\n  return literalMap(Object.getOwnPropertyNames(map).map(function (key) {\n    // canonical syntax: `dirProp: publicProp`\n    // if there is no `:`, use dirProp = elProp\n    var value = map[key];\n    var declaredName;\n    var publicName;\n    var minifiedName;\n    var needsDeclaredName;\n\n    if (Array.isArray(value)) {\n      var _value = _slicedToArray(value, 2);\n\n      publicName = _value[0];\n      declaredName = _value[1];\n      minifiedName = key;\n      needsDeclaredName = publicName !== declaredName;\n    } else {\n      var _splitAtColon = splitAtColon(key, [key, value]);\n\n      var _splitAtColon2 = _slicedToArray(_splitAtColon, 2);\n\n      declaredName = _splitAtColon2[0];\n      publicName = _splitAtColon2[1];\n      minifiedName = declaredName; // Only include the declared name if extracted from the key, i.e. the key contains a colon.\n      // Otherwise the declared name should be omitted even if it is different from the public name,\n      // as it may have already been minified.\n\n      needsDeclaredName = publicName !== declaredName && key.includes(':');\n    }\n\n    return {\n      key: minifiedName,\n      // put quotes around keys that contain potentially unsafe characters\n      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n      value: keepDeclared && needsDeclaredName ? literalArr([asLiteral(publicName), asLiteral(declaredName)]) : asLiteral(publicName)\n    };\n  }));\n}\n/**\r\n *  Remove trailing null nodes as they are implied.\r\n */\n\n\nfunction trimTrailingNulls(parameters) {\n  while (isNull(parameters[parameters.length - 1])) {\n    parameters.pop();\n  }\n\n  return parameters;\n}\n\nfunction getQueryPredicate(query, constantPool) {\n  if (Array.isArray(query.predicate)) {\n    var predicate = [];\n    query.predicate.forEach(function (selector) {\n      // Each item in predicates array may contain strings with comma-separated refs\n      // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them\n      // as separate array entities\n      var selectors = selector.split(',').map(function (token) {\n        return literal(token.trim());\n      });\n      predicate.push.apply(predicate, _toConsumableArray(selectors));\n    });\n    return constantPool.getConstLiteral(literalArr(predicate), true);\n  } else {\n    return query.predicate;\n  }\n}\n/**\r\n * A representation for an object literal used during codegen of definition objects. The generic\r\n * type `T` allows to reference a documented type of the generated structure, such that the\r\n * property names that are set can be resolved to their documented declaration.\r\n */\n\n\nvar DefinitionMap = /*#__PURE__*/function () {\n  function DefinitionMap() {\n    _classCallCheck(this, DefinitionMap);\n\n    this.values = [];\n  }\n\n  _createClass(DefinitionMap, [{\n    key: \"set\",\n    value: function set(key, value) {\n      if (value) {\n        this.values.push({\n          key: key,\n          value: value,\n          quoted: false\n        });\n      }\n    }\n  }, {\n    key: \"toLiteralMap\",\n    value: function toLiteralMap() {\n      return literalMap(this.values);\n    }\n  }]);\n\n  return DefinitionMap;\n}();\n/**\r\n * Extract a map of properties to values for a given element or template node, which can be used\r\n * by the directive matching machinery.\r\n *\r\n * @param elOrTpl the element or template in question\r\n * @return an object set up for directive matching. For attributes on the element/template, this\r\n * object maps a property name to its (static) value. For any bindings, this map simply maps the\r\n * property name to an empty string.\r\n */\n\n\nfunction getAttrsForDirectiveMatching(elOrTpl) {\n  var attributesMap = {};\n\n  if (elOrTpl instanceof Template && elOrTpl.tagName !== 'ng-template') {\n    elOrTpl.templateAttrs.forEach(function (a) {\n      return attributesMap[a.name] = '';\n    });\n  } else {\n    elOrTpl.attributes.forEach(function (a) {\n      if (!isI18nAttribute(a.name)) {\n        attributesMap[a.name] = a.value;\n      }\n    });\n    elOrTpl.inputs.forEach(function (i) {\n      attributesMap[i.name] = '';\n    });\n    elOrTpl.outputs.forEach(function (o) {\n      attributesMap[o.name] = '';\n    });\n  }\n\n  return attributesMap;\n}\n/** Returns a call expression to a chained instruction, e.g. `property(params[0])(params[1])`. */\n\n\nfunction chainedInstruction(reference, calls, span) {\n  var expression = importExpr(reference, null, span);\n\n  if (calls.length > 0) {\n    for (var i = 0; i < calls.length; i++) {\n      expression = expression.callFn(calls[i], span);\n    }\n  } else {\n    // Add a blank invocation, in case the `calls` array is empty.\n    expression = expression.callFn([], span);\n  }\n\n  return expression;\n}\n/**\r\n * Gets the number of arguments expected to be passed to a generated instruction in the case of\r\n * interpolation instructions.\r\n * @param interpolation An interpolation ast\r\n */\n\n\nfunction getInterpolationArgsLength(interpolation) {\n  var expressions = interpolation.expressions,\n      strings = interpolation.strings;\n\n  if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {\n    // If the interpolation has one interpolated value, but the prefix and suffix are both empty\n    // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or\n    // `textInterpolate`.\n    return 1;\n  } else {\n    return expressions.length + strings.length;\n  }\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Creates an array literal expression from the given array, mapping all values to an expression\r\n * using the provided mapping function. If the array is empty or null, then null is returned.\r\n *\r\n * @param values The array to transfer into literal array expression.\r\n * @param mapper The logic to use for creating an expression for the array's values.\r\n * @returns An array literal expression representing `values`, or null if `values` is empty or\r\n * is itself null.\r\n */\n\n\nfunction toOptionalLiteralArray(values, mapper) {\n  if (values === null || values.length === 0) {\n    return null;\n  }\n\n  return literalArr(values.map(function (value) {\n    return mapper(value);\n  }));\n}\n/**\r\n * Creates an object literal expression from the given object, mapping all values to an expression\r\n * using the provided mapping function. If the object has no keys, then null is returned.\r\n *\r\n * @param object The object to transfer into an object literal expression.\r\n * @param mapper The logic to use for creating an expression for the object's values.\r\n * @returns An object literal expression representing `object`, or null if `object` does not have\r\n * any keys.\r\n */\n\n\nfunction toOptionalLiteralMap(object, mapper) {\n  var entries = Object.keys(object).map(function (key) {\n    var value = object[key];\n    return {\n      key: key,\n      value: mapper(value),\n      quoted: true\n    };\n  });\n\n  if (entries.length > 0) {\n    return literalMap(entries);\n  } else {\n    return null;\n  }\n}\n\nfunction compileDependencies(deps) {\n  if (deps === 'invalid') {\n    // The `deps` can be set to the string \"invalid\"  by the `unwrapConstructorDependencies()`\n    // function, which tries to convert `ConstructorDeps` into `R3DependencyMetadata[]`.\n    return literal('invalid');\n  } else if (deps === null) {\n    return literal(null);\n  } else {\n    return literalArr(deps.map(compileDependency));\n  }\n}\n\nfunction compileDependency(dep) {\n  var depMeta = new DefinitionMap();\n  depMeta.set('token', dep.token);\n\n  if (dep.attributeNameType !== null) {\n    depMeta.set('attribute', literal(true));\n  }\n\n  if (dep.host) {\n    depMeta.set('host', literal(true));\n  }\n\n  if (dep.optional) {\n    depMeta.set('optional', literal(true));\n  }\n\n  if (dep.self) {\n    depMeta.set('self', literal(true));\n  }\n\n  if (dep.skipSelf) {\n    depMeta.set('skipSelf', literal(true));\n  }\n\n  return depMeta.toLiteralMap();\n}\n/**\r\n * Generate an expression that has the given `expr` wrapped in the following form:\r\n *\r\n * ```\r\n * forwardRef(() => expr)\r\n * ```\r\n */\n\n\nfunction generateForwardRef(expr) {\n  return importExpr(Identifiers.forwardRef).callFn([fn([], [new ReturnStatement(expr)])]);\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\n\n\nvar VERSION = 3;\nvar JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\n\nvar SourceMapGenerator = /*#__PURE__*/function () {\n  function SourceMapGenerator() {\n    var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, SourceMapGenerator);\n\n    this.file = file;\n    this.sourcesContent = new Map();\n    this.lines = [];\n    this.lastCol0 = 0;\n    this.hasMappings = false;\n  } // The content is `null` when the content is expected to be loaded using the URL\n\n\n  _createClass(SourceMapGenerator, [{\n    key: \"addSource\",\n    value: function addSource(url) {\n      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (!this.sourcesContent.has(url)) {\n        this.sourcesContent.set(url, content);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"addLine\",\n    value: function addLine() {\n      this.lines.push([]);\n      this.lastCol0 = 0;\n      return this;\n    }\n  }, {\n    key: \"addMapping\",\n    value: function addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {\n      if (!this.currentLine) {\n        throw new Error(\"A line must be added before mappings can be added\");\n      }\n\n      if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n        throw new Error(\"Unknown source file \\\"\".concat(sourceUrl, \"\\\"\"));\n      }\n\n      if (col0 == null) {\n        throw new Error(\"The column in the generated code must be provided\");\n      }\n\n      if (col0 < this.lastCol0) {\n        throw new Error(\"Mapping should be added in output order\");\n      }\n\n      if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n        throw new Error(\"The source location must be provided when a source url is provided\");\n      }\n\n      this.hasMappings = true;\n      this.lastCol0 = col0;\n      this.currentLine.push({\n        col0: col0,\n        sourceUrl: sourceUrl,\n        sourceLine0: sourceLine0,\n        sourceCol0: sourceCol0\n      });\n      return this;\n    }\n    /**\r\n     * @internal strip this from published d.ts files due to\r\n     * https://github.com/microsoft/TypeScript/issues/36216\r\n     */\n\n  }, {\n    key: \"currentLine\",\n    get: function get() {\n      return this.lines.slice(-1)[0];\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var _this81 = this;\n\n      if (!this.hasMappings) {\n        return null;\n      }\n\n      var sourcesIndex = new Map();\n      var sources = [];\n      var sourcesContent = [];\n      Array.from(this.sourcesContent.keys()).forEach(function (url, i) {\n        sourcesIndex.set(url, i);\n        sources.push(url);\n        sourcesContent.push(_this81.sourcesContent.get(url) || null);\n      });\n      var mappings = '';\n      var lastCol0 = 0;\n      var lastSourceIndex = 0;\n      var lastSourceLine0 = 0;\n      var lastSourceCol0 = 0;\n      this.lines.forEach(function (segments) {\n        lastCol0 = 0;\n        mappings += segments.map(function (segment) {\n          // zero-based starting column of the line in the generated code\n          var segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n          lastCol0 = segment.col0;\n\n          if (segment.sourceUrl != null) {\n            // zero-based index into the “sources” list\n            segAsStr += toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);\n            lastSourceIndex = sourcesIndex.get(segment.sourceUrl); // the zero-based starting line in the original source\n\n            segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);\n            lastSourceLine0 = segment.sourceLine0; // the zero-based starting column in the original source\n\n            segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);\n            lastSourceCol0 = segment.sourceCol0;\n          }\n\n          return segAsStr;\n        }).join(',');\n        mappings += ';';\n      });\n      mappings = mappings.slice(0, -1);\n      return {\n        'file': this.file || '',\n        'version': VERSION,\n        'sourceRoot': '',\n        'sources': sources,\n        'sourcesContent': sourcesContent,\n        'mappings': mappings\n      };\n    }\n  }, {\n    key: \"toJsComment\",\n    value: function toJsComment() {\n      return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) : '';\n    }\n  }]);\n\n  return SourceMapGenerator;\n}();\n\nfunction toBase64String(value) {\n  var b64 = '';\n  var encoded = utf8Encode(value);\n\n  for (var i = 0; i < encoded.length;) {\n    var i1 = encoded[i++];\n    var i2 = i < encoded.length ? encoded[i++] : null;\n    var i3 = i < encoded.length ? encoded[i++] : null;\n    b64 += toBase64Digit(i1 >> 2);\n    b64 += toBase64Digit((i1 & 3) << 4 | (i2 === null ? 0 : i2 >> 4));\n    b64 += i2 === null ? '=' : toBase64Digit((i2 & 15) << 2 | (i3 === null ? 0 : i3 >> 6));\n    b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);\n  }\n\n  return b64;\n}\n\nfunction toBase64VLQ(value) {\n  value = value < 0 ? (-value << 1) + 1 : value << 1;\n  var out = '';\n\n  do {\n    var digit = value & 31;\n    value = value >> 5;\n\n    if (value > 0) {\n      digit = digit | 32;\n    }\n\n    out += toBase64Digit(digit);\n  } while (value > 0);\n\n  return out;\n}\n\nvar B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfunction toBase64Digit(value) {\n  if (value < 0 || value >= 64) {\n    throw new Error(\"Can only encode value in the range [0, 63]\");\n  }\n\n  return B64_DIGITS[value];\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nvar _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nvar _INDENT_WITH = '  ';\nvar CATCH_ERROR_VAR$1 = variable('error', null, null);\nvar CATCH_STACK_VAR$1 = variable('stack', null, null);\n\nvar _EmittedLine = function _EmittedLine(indent) {\n  _classCallCheck(this, _EmittedLine);\n\n  this.indent = indent;\n  this.partsLength = 0;\n  this.parts = [];\n  this.srcSpans = [];\n};\n\nvar EmitterVisitorContext = /*#__PURE__*/function () {\n  function EmitterVisitorContext(_indent) {\n    _classCallCheck(this, EmitterVisitorContext);\n\n    this._indent = _indent;\n    this._classes = [];\n    this._preambleLineCount = 0;\n    this._lines = [new _EmittedLine(_indent)];\n  }\n\n  _createClass(EmitterVisitorContext, [{\n    key: \"_currentLine\",\n    get:\n    /**\r\n     * @internal strip this from published d.ts files due to\r\n     * https://github.com/microsoft/TypeScript/issues/36216\r\n     */\n    function get() {\n      return this._lines[this._lines.length - 1];\n    }\n  }, {\n    key: \"println\",\n    value: function println(from) {\n      var lastPart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      this.print(from || null, lastPart, true);\n    }\n  }, {\n    key: \"lineIsEmpty\",\n    value: function lineIsEmpty() {\n      return this._currentLine.parts.length === 0;\n    }\n  }, {\n    key: \"lineLength\",\n    value: function lineLength() {\n      return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n    }\n  }, {\n    key: \"print\",\n    value: function print(from, part) {\n      var newLine = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (part.length > 0) {\n        this._currentLine.parts.push(part);\n\n        this._currentLine.partsLength += part.length;\n\n        this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n      }\n\n      if (newLine) {\n        this._lines.push(new _EmittedLine(this._indent));\n      }\n    }\n  }, {\n    key: \"removeEmptyLastLine\",\n    value: function removeEmptyLastLine() {\n      if (this.lineIsEmpty()) {\n        this._lines.pop();\n      }\n    }\n  }, {\n    key: \"incIndent\",\n    value: function incIndent() {\n      this._indent++;\n\n      if (this.lineIsEmpty()) {\n        this._currentLine.indent = this._indent;\n      }\n    }\n  }, {\n    key: \"decIndent\",\n    value: function decIndent() {\n      this._indent--;\n\n      if (this.lineIsEmpty()) {\n        this._currentLine.indent = this._indent;\n      }\n    }\n  }, {\n    key: \"pushClass\",\n    value: function pushClass(clazz) {\n      this._classes.push(clazz);\n    }\n  }, {\n    key: \"popClass\",\n    value: function popClass() {\n      return this._classes.pop();\n    }\n  }, {\n    key: \"currentClass\",\n    get: function get() {\n      return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;\n    }\n  }, {\n    key: \"toSource\",\n    value: function toSource() {\n      return this.sourceLines.map(function (l) {\n        return l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '';\n      }).join('\\n');\n    }\n  }, {\n    key: \"toSourceMapGenerator\",\n    value: function toSourceMapGenerator(genFilePath) {\n      var startsAtLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var map = new SourceMapGenerator(genFilePath);\n      var firstOffsetMapped = false;\n\n      var mapFirstOffsetIfNeeded = function mapFirstOffsetIfNeeded() {\n        if (!firstOffsetMapped) {\n          // Add a single space so that tools won't try to load the file from disk.\n          // Note: We are using virtual urls like `ng:///`, so we have to\n          // provide a content here.\n          map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n          firstOffsetMapped = true;\n        }\n      };\n\n      for (var i = 0; i < startsAtLine; i++) {\n        map.addLine();\n        mapFirstOffsetIfNeeded();\n      }\n\n      this.sourceLines.forEach(function (line, lineIdx) {\n        map.addLine();\n        var spans = line.srcSpans;\n        var parts = line.parts;\n        var col0 = line.indent * _INDENT_WITH.length;\n        var spanIdx = 0; // skip leading parts without source spans\n\n        while (spanIdx < spans.length && !spans[spanIdx]) {\n          col0 += parts[spanIdx].length;\n          spanIdx++;\n        }\n\n        if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n          firstOffsetMapped = true;\n        } else {\n          mapFirstOffsetIfNeeded();\n        }\n\n        while (spanIdx < spans.length) {\n          var span = spans[spanIdx];\n          var source = span.start.file;\n          var sourceLine = span.start.line;\n          var sourceCol = span.start.col;\n          map.addSource(source.url, source.content).addMapping(col0, source.url, sourceLine, sourceCol);\n          col0 += parts[spanIdx].length;\n          spanIdx++; // assign parts without span or the same span to the previous segment\n\n          while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n            col0 += parts[spanIdx].length;\n            spanIdx++;\n          }\n        }\n      });\n      return map;\n    }\n  }, {\n    key: \"setPreambleLineCount\",\n    value: function setPreambleLineCount(count) {\n      return this._preambleLineCount = count;\n    }\n  }, {\n    key: \"spanOf\",\n    value: function spanOf(line, column) {\n      var emittedLine = this._lines[line - this._preambleLineCount];\n\n      if (emittedLine) {\n        var columnsLeft = column - _createIndent(emittedLine.indent).length;\n\n        for (var partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n          var part = emittedLine.parts[partIndex];\n\n          if (part.length > columnsLeft) {\n            return emittedLine.srcSpans[partIndex];\n          }\n\n          columnsLeft -= part.length;\n        }\n      }\n\n      return null;\n    }\n    /**\r\n     * @internal strip this from published d.ts files due to\r\n     * https://github.com/microsoft/TypeScript/issues/36216\r\n     */\n\n  }, {\n    key: \"sourceLines\",\n    get: function get() {\n      if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n        return this._lines.slice(0, -1);\n      }\n\n      return this._lines;\n    }\n  }], [{\n    key: \"createRoot\",\n    value: function createRoot() {\n      return new EmitterVisitorContext(0);\n    }\n  }]);\n\n  return EmitterVisitorContext;\n}();\n\nvar AbstractEmitterVisitor = /*#__PURE__*/function () {\n  function AbstractEmitterVisitor(_escapeDollarInStrings) {\n    _classCallCheck(this, AbstractEmitterVisitor);\n\n    this._escapeDollarInStrings = _escapeDollarInStrings;\n  }\n\n  _createClass(AbstractEmitterVisitor, [{\n    key: \"printLeadingComments\",\n    value: function printLeadingComments(stmt, ctx) {\n      if (stmt.leadingComments === undefined) {\n        return;\n      }\n\n      var _iterator6 = _createForOfIteratorHelper(stmt.leadingComments),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var comment = _step6.value;\n\n          if (comment instanceof JSDocComment) {\n            ctx.print(stmt, \"/*\".concat(comment.toString(), \"*/\"), comment.trailingNewline);\n          } else {\n            if (comment.multiline) {\n              ctx.print(stmt, \"/* \".concat(comment.text, \" */\"), comment.trailingNewline);\n            } else {\n              comment.text.split('\\n').forEach(function (line) {\n                ctx.println(stmt, \"// \".concat(line));\n              });\n            }\n          }\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  }, {\n    key: \"visitExpressionStmt\",\n    value: function visitExpressionStmt(stmt, ctx) {\n      this.printLeadingComments(stmt, ctx);\n      stmt.expr.visitExpression(this, ctx);\n      ctx.println(stmt, ';');\n      return null;\n    }\n  }, {\n    key: \"visitReturnStmt\",\n    value: function visitReturnStmt(stmt, ctx) {\n      this.printLeadingComments(stmt, ctx);\n      ctx.print(stmt, \"return \");\n      stmt.value.visitExpression(this, ctx);\n      ctx.println(stmt, ';');\n      return null;\n    }\n  }, {\n    key: \"visitIfStmt\",\n    value: function visitIfStmt(stmt, ctx) {\n      this.printLeadingComments(stmt, ctx);\n      ctx.print(stmt, \"if (\");\n      stmt.condition.visitExpression(this, ctx);\n      ctx.print(stmt, \") {\");\n      var hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n\n      if (stmt.trueCase.length <= 1 && !hasElseCase) {\n        ctx.print(stmt, \" \");\n        this.visitAllStatements(stmt.trueCase, ctx);\n        ctx.removeEmptyLastLine();\n        ctx.print(stmt, \" \");\n      } else {\n        ctx.println();\n        ctx.incIndent();\n        this.visitAllStatements(stmt.trueCase, ctx);\n        ctx.decIndent();\n\n        if (hasElseCase) {\n          ctx.println(stmt, \"} else {\");\n          ctx.incIndent();\n          this.visitAllStatements(stmt.falseCase, ctx);\n          ctx.decIndent();\n        }\n      }\n\n      ctx.println(stmt, \"}\");\n      return null;\n    }\n  }, {\n    key: \"visitThrowStmt\",\n    value: function visitThrowStmt(stmt, ctx) {\n      this.printLeadingComments(stmt, ctx);\n      ctx.print(stmt, \"throw \");\n      stmt.error.visitExpression(this, ctx);\n      ctx.println(stmt, \";\");\n      return null;\n    }\n  }, {\n    key: \"visitWriteVarExpr\",\n    value: function visitWriteVarExpr(expr, ctx) {\n      var lineWasEmpty = ctx.lineIsEmpty();\n\n      if (!lineWasEmpty) {\n        ctx.print(expr, '(');\n      }\n\n      ctx.print(expr, \"\".concat(expr.name, \" = \"));\n      expr.value.visitExpression(this, ctx);\n\n      if (!lineWasEmpty) {\n        ctx.print(expr, ')');\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitWriteKeyExpr\",\n    value: function visitWriteKeyExpr(expr, ctx) {\n      var lineWasEmpty = ctx.lineIsEmpty();\n\n      if (!lineWasEmpty) {\n        ctx.print(expr, '(');\n      }\n\n      expr.receiver.visitExpression(this, ctx);\n      ctx.print(expr, \"[\");\n      expr.index.visitExpression(this, ctx);\n      ctx.print(expr, \"] = \");\n      expr.value.visitExpression(this, ctx);\n\n      if (!lineWasEmpty) {\n        ctx.print(expr, ')');\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitWritePropExpr\",\n    value: function visitWritePropExpr(expr, ctx) {\n      var lineWasEmpty = ctx.lineIsEmpty();\n\n      if (!lineWasEmpty) {\n        ctx.print(expr, '(');\n      }\n\n      expr.receiver.visitExpression(this, ctx);\n      ctx.print(expr, \".\".concat(expr.name, \" = \"));\n      expr.value.visitExpression(this, ctx);\n\n      if (!lineWasEmpty) {\n        ctx.print(expr, ')');\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitInvokeMethodExpr\",\n    value: function visitInvokeMethodExpr(expr, ctx) {\n      expr.receiver.visitExpression(this, ctx);\n      var name = expr.name;\n\n      if (expr.builtin != null) {\n        name = this.getBuiltinMethodName(expr.builtin);\n\n        if (name == null) {\n          // some builtins just mean to skip the call.\n          return null;\n        }\n      }\n\n      ctx.print(expr, \".\".concat(name, \"(\"));\n      this.visitAllExpressions(expr.args, ctx, \",\");\n      ctx.print(expr, \")\");\n      return null;\n    }\n  }, {\n    key: \"visitInvokeFunctionExpr\",\n    value: function visitInvokeFunctionExpr(expr, ctx) {\n      expr.fn.visitExpression(this, ctx);\n      ctx.print(expr, \"(\");\n      this.visitAllExpressions(expr.args, ctx, ',');\n      ctx.print(expr, \")\");\n      return null;\n    }\n  }, {\n    key: \"visitTaggedTemplateExpr\",\n    value: function visitTaggedTemplateExpr(expr, ctx) {\n      expr.tag.visitExpression(this, ctx);\n      ctx.print(expr, '`' + expr.template.elements[0].rawText);\n\n      for (var i = 1; i < expr.template.elements.length; i++) {\n        ctx.print(expr, '${');\n        expr.template.expressions[i - 1].visitExpression(this, ctx);\n        ctx.print(expr, \"}\".concat(expr.template.elements[i].rawText));\n      }\n\n      ctx.print(expr, '`');\n      return null;\n    }\n  }, {\n    key: \"visitWrappedNodeExpr\",\n    value: function visitWrappedNodeExpr(ast, ctx) {\n      throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n    }\n  }, {\n    key: \"visitTypeofExpr\",\n    value: function visitTypeofExpr(expr, ctx) {\n      ctx.print(expr, 'typeof ');\n      expr.expr.visitExpression(this, ctx);\n    }\n  }, {\n    key: \"visitReadVarExpr\",\n    value: function visitReadVarExpr(ast, ctx) {\n      var varName = ast.name;\n\n      if (ast.builtin != null) {\n        switch (ast.builtin) {\n          case BuiltinVar.Super:\n            varName = 'super';\n            break;\n\n          case BuiltinVar.This:\n            varName = 'this';\n            break;\n\n          case BuiltinVar.CatchError:\n            varName = CATCH_ERROR_VAR$1.name;\n            break;\n\n          case BuiltinVar.CatchStack:\n            varName = CATCH_STACK_VAR$1.name;\n            break;\n\n          default:\n            throw new Error(\"Unknown builtin variable \".concat(ast.builtin));\n        }\n      }\n\n      ctx.print(ast, varName);\n      return null;\n    }\n  }, {\n    key: \"visitInstantiateExpr\",\n    value: function visitInstantiateExpr(ast, ctx) {\n      ctx.print(ast, \"new \");\n      ast.classExpr.visitExpression(this, ctx);\n      ctx.print(ast, \"(\");\n      this.visitAllExpressions(ast.args, ctx, ',');\n      ctx.print(ast, \")\");\n      return null;\n    }\n  }, {\n    key: \"visitLiteralExpr\",\n    value: function visitLiteralExpr(ast, ctx) {\n      var value = ast.value;\n\n      if (typeof value === 'string') {\n        ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n      } else {\n        ctx.print(ast, \"\".concat(value));\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitLocalizedString\",\n    value: function visitLocalizedString(ast, ctx) {\n      var head = ast.serializeI18nHead();\n      ctx.print(ast, '$localize `' + head.raw);\n\n      for (var i = 1; i < ast.messageParts.length; i++) {\n        ctx.print(ast, '${');\n        ast.expressions[i - 1].visitExpression(this, ctx);\n        ctx.print(ast, \"}\".concat(ast.serializeI18nTemplatePart(i).raw));\n      }\n\n      ctx.print(ast, '`');\n      return null;\n    }\n  }, {\n    key: \"visitConditionalExpr\",\n    value: function visitConditionalExpr(ast, ctx) {\n      ctx.print(ast, \"(\");\n      ast.condition.visitExpression(this, ctx);\n      ctx.print(ast, '? ');\n      ast.trueCase.visitExpression(this, ctx);\n      ctx.print(ast, ': ');\n      ast.falseCase.visitExpression(this, ctx);\n      ctx.print(ast, \")\");\n      return null;\n    }\n  }, {\n    key: \"visitNotExpr\",\n    value: function visitNotExpr(ast, ctx) {\n      ctx.print(ast, '!');\n      ast.condition.visitExpression(this, ctx);\n      return null;\n    }\n  }, {\n    key: \"visitAssertNotNullExpr\",\n    value: function visitAssertNotNullExpr(ast, ctx) {\n      ast.condition.visitExpression(this, ctx);\n      return null;\n    }\n  }, {\n    key: \"visitUnaryOperatorExpr\",\n    value: function visitUnaryOperatorExpr(ast, ctx) {\n      var opStr;\n\n      switch (ast.operator) {\n        case UnaryOperator.Plus:\n          opStr = '+';\n          break;\n\n        case UnaryOperator.Minus:\n          opStr = '-';\n          break;\n\n        default:\n          throw new Error(\"Unknown operator \".concat(ast.operator));\n      }\n\n      if (ast.parens) ctx.print(ast, \"(\");\n      ctx.print(ast, opStr);\n      ast.expr.visitExpression(this, ctx);\n      if (ast.parens) ctx.print(ast, \")\");\n      return null;\n    }\n  }, {\n    key: \"visitBinaryOperatorExpr\",\n    value: function visitBinaryOperatorExpr(ast, ctx) {\n      var opStr;\n\n      switch (ast.operator) {\n        case BinaryOperator.Equals:\n          opStr = '==';\n          break;\n\n        case BinaryOperator.Identical:\n          opStr = '===';\n          break;\n\n        case BinaryOperator.NotEquals:\n          opStr = '!=';\n          break;\n\n        case BinaryOperator.NotIdentical:\n          opStr = '!==';\n          break;\n\n        case BinaryOperator.And:\n          opStr = '&&';\n          break;\n\n        case BinaryOperator.BitwiseAnd:\n          opStr = '&';\n          break;\n\n        case BinaryOperator.Or:\n          opStr = '||';\n          break;\n\n        case BinaryOperator.Plus:\n          opStr = '+';\n          break;\n\n        case BinaryOperator.Minus:\n          opStr = '-';\n          break;\n\n        case BinaryOperator.Divide:\n          opStr = '/';\n          break;\n\n        case BinaryOperator.Multiply:\n          opStr = '*';\n          break;\n\n        case BinaryOperator.Modulo:\n          opStr = '%';\n          break;\n\n        case BinaryOperator.Lower:\n          opStr = '<';\n          break;\n\n        case BinaryOperator.LowerEquals:\n          opStr = '<=';\n          break;\n\n        case BinaryOperator.Bigger:\n          opStr = '>';\n          break;\n\n        case BinaryOperator.BiggerEquals:\n          opStr = '>=';\n          break;\n\n        case BinaryOperator.NullishCoalesce:\n          opStr = '??';\n          break;\n\n        default:\n          throw new Error(\"Unknown operator \".concat(ast.operator));\n      }\n\n      if (ast.parens) ctx.print(ast, \"(\");\n      ast.lhs.visitExpression(this, ctx);\n      ctx.print(ast, \" \".concat(opStr, \" \"));\n      ast.rhs.visitExpression(this, ctx);\n      if (ast.parens) ctx.print(ast, \")\");\n      return null;\n    }\n  }, {\n    key: \"visitReadPropExpr\",\n    value: function visitReadPropExpr(ast, ctx) {\n      ast.receiver.visitExpression(this, ctx);\n      ctx.print(ast, \".\");\n      ctx.print(ast, ast.name);\n      return null;\n    }\n  }, {\n    key: \"visitReadKeyExpr\",\n    value: function visitReadKeyExpr(ast, ctx) {\n      ast.receiver.visitExpression(this, ctx);\n      ctx.print(ast, \"[\");\n      ast.index.visitExpression(this, ctx);\n      ctx.print(ast, \"]\");\n      return null;\n    }\n  }, {\n    key: \"visitLiteralArrayExpr\",\n    value: function visitLiteralArrayExpr(ast, ctx) {\n      ctx.print(ast, \"[\");\n      this.visitAllExpressions(ast.entries, ctx, ',');\n      ctx.print(ast, \"]\");\n      return null;\n    }\n  }, {\n    key: \"visitLiteralMapExpr\",\n    value: function visitLiteralMapExpr(ast, ctx) {\n      var _this82 = this;\n\n      ctx.print(ast, \"{\");\n      this.visitAllObjects(function (entry) {\n        ctx.print(ast, \"\".concat(escapeIdentifier(entry.key, _this82._escapeDollarInStrings, entry.quoted), \":\"));\n        entry.value.visitExpression(_this82, ctx);\n      }, ast.entries, ctx, ',');\n      ctx.print(ast, \"}\");\n      return null;\n    }\n  }, {\n    key: \"visitCommaExpr\",\n    value: function visitCommaExpr(ast, ctx) {\n      ctx.print(ast, '(');\n      this.visitAllExpressions(ast.parts, ctx, ',');\n      ctx.print(ast, ')');\n      return null;\n    }\n  }, {\n    key: \"visitAllExpressions\",\n    value: function visitAllExpressions(expressions, ctx, separator) {\n      var _this83 = this;\n\n      this.visitAllObjects(function (expr) {\n        return expr.visitExpression(_this83, ctx);\n      }, expressions, ctx, separator);\n    }\n  }, {\n    key: \"visitAllObjects\",\n    value: function visitAllObjects(handler, expressions, ctx, separator) {\n      var incrementedIndent = false;\n\n      for (var i = 0; i < expressions.length; i++) {\n        if (i > 0) {\n          if (ctx.lineLength() > 80) {\n            ctx.print(null, separator, true);\n\n            if (!incrementedIndent) {\n              // continuation are marked with double indent.\n              ctx.incIndent();\n              ctx.incIndent();\n              incrementedIndent = true;\n            }\n          } else {\n            ctx.print(null, separator, false);\n          }\n        }\n\n        handler(expressions[i]);\n      }\n\n      if (incrementedIndent) {\n        // continuation are marked with double indent.\n        ctx.decIndent();\n        ctx.decIndent();\n      }\n    }\n  }, {\n    key: \"visitAllStatements\",\n    value: function visitAllStatements(statements, ctx) {\n      var _this84 = this;\n\n      statements.forEach(function (stmt) {\n        return stmt.visitStatement(_this84, ctx);\n      });\n    }\n  }]);\n\n  return AbstractEmitterVisitor;\n}();\n\nfunction escapeIdentifier(input, escapeDollar) {\n  var alwaysQuote = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  if (input == null) {\n    return null;\n  }\n\n  var body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, function () {\n    if ((arguments.length <= 0 ? undefined : arguments[0]) == '$') {\n      return escapeDollar ? '\\\\$' : '$';\n    } else if ((arguments.length <= 0 ? undefined : arguments[0]) == '\\n') {\n      return '\\\\n';\n    } else if ((arguments.length <= 0 ? undefined : arguments[0]) == '\\r') {\n      return '\\\\r';\n    } else {\n      return \"\\\\\".concat(arguments.length <= 0 ? undefined : arguments[0]);\n    }\n  });\n  var requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n  return requiresQuotes ? \"'\".concat(body, \"'\") : body;\n}\n\nfunction _createIndent(count) {\n  var res = '';\n\n  for (var i = 0; i < count; i++) {\n    res += _INDENT_WITH;\n  }\n\n  return res;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nfunction typeWithParameters(type, numParams) {\n  if (numParams === 0) {\n    return expressionType(type);\n  }\n\n  var params = [];\n\n  for (var i = 0; i < numParams; i++) {\n    params.push(DYNAMIC_TYPE);\n  }\n\n  return expressionType(type, undefined, params);\n}\n\nvar ANIMATE_SYMBOL_PREFIX = '@';\n\nfunction prepareSyntheticPropertyName(name) {\n  return \"\".concat(ANIMATE_SYMBOL_PREFIX).concat(name);\n}\n\nfunction prepareSyntheticListenerName(name, phase) {\n  return \"\".concat(ANIMATE_SYMBOL_PREFIX).concat(name, \".\").concat(phase);\n}\n\nfunction getSafePropertyAccessString(accessor, name) {\n  var escapedName = escapeIdentifier(name, false, false);\n  return escapedName !== name ? \"\".concat(accessor, \"[\").concat(escapedName, \"]\") : \"\".concat(accessor, \".\").concat(name);\n}\n\nfunction prepareSyntheticListenerFunctionName(name, phase) {\n  return \"animation_\".concat(name, \"_\").concat(phase);\n}\n\nfunction jitOnlyGuardedExpression(expr) {\n  return guardedExpression('ngJitMode', expr);\n}\n\nfunction devOnlyGuardedExpression(expr) {\n  return guardedExpression('ngDevMode', expr);\n}\n\nfunction guardedExpression(guard, expr) {\n  var guardExpr = new ExternalExpr({\n    name: guard,\n    moduleName: null\n  });\n  var guardNotDefined = new BinaryOperatorExpr(BinaryOperator.Identical, new TypeofExpr(guardExpr), literal('undefined'));\n  var guardUndefinedOrTrue = new BinaryOperatorExpr(BinaryOperator.Or, guardNotDefined, guardExpr,\n  /* type */\n  undefined,\n  /* sourceSpan */\n  undefined, true);\n  return new BinaryOperatorExpr(BinaryOperator.And, guardUndefinedOrTrue, expr);\n}\n\nfunction wrapReference(value) {\n  var wrapped = new WrappedNodeExpr(value);\n  return {\n    value: wrapped,\n    type: wrapped\n  };\n}\n\nfunction refsToArray(refs, shouldForwardDeclare) {\n  var values = literalArr(refs.map(function (ref) {\n    return ref.value;\n  }));\n  return shouldForwardDeclare ? fn([], [new ReturnStatement(values)]) : values;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar R3FactoryDelegateType;\n\n(function (R3FactoryDelegateType) {\n  R3FactoryDelegateType[R3FactoryDelegateType[\"Class\"] = 0] = \"Class\";\n  R3FactoryDelegateType[R3FactoryDelegateType[\"Function\"] = 1] = \"Function\";\n})(R3FactoryDelegateType || (R3FactoryDelegateType = {}));\n\nvar FactoryTarget;\n\n(function (FactoryTarget) {\n  FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n  FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\n  FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n  FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n  FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(FactoryTarget || (FactoryTarget = {}));\n/**\r\n * Construct a factory function expression for the given `R3FactoryMetadata`.\r\n */\n\n\nfunction compileFactoryFunction(meta) {\n  var t = variable('t');\n  var baseFactoryVar = null; // The type to instantiate via constructor invocation. If there is no delegated factory, meaning\n  // this type is always created by constructor invocation, then this is the type-to-create\n  // parameter provided by the user (t) if specified, or the current type if not. If there is a\n  // delegated factory (which is used to create the current type) then this is only the type-to-\n  // create parameter (t).\n\n  var typeForCtor = !isDelegatedFactoryMetadata(meta) ? new BinaryOperatorExpr(BinaryOperator.Or, t, meta.internalType) : t;\n  var ctorExpr = null;\n\n  if (meta.deps !== null) {\n    // There is a constructor (either explicitly or implicitly defined).\n    if (meta.deps !== 'invalid') {\n      ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));\n    }\n  } else {\n    // There is no constructor, use the base class' factory to construct typeForCtor.\n    baseFactoryVar = variable(\"\\u0275\".concat(meta.name, \"_BaseFactory\"));\n    ctorExpr = baseFactoryVar.callFn([typeForCtor]);\n  }\n\n  var body = [];\n  var retExpr = null;\n\n  function makeConditionalFactory(nonCtorExpr) {\n    var r = variable('r');\n    body.push(r.set(NULL_EXPR).toDeclStmt());\n    var ctorStmt = ctorExpr !== null ? r.set(ctorExpr).toStmt() : importExpr(Identifiers.invalidFactory).callFn([]).toStmt();\n    body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n    return r;\n  }\n\n  if (isDelegatedFactoryMetadata(meta)) {\n    // This type is created with a delegated factory. If a type parameter is not specified, call\n    // the factory instead.\n    var delegateArgs = injectDependencies(meta.delegateDeps, meta.target); // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.\n\n    var factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ? InstantiateExpr : InvokeFunctionExpr)(meta.delegate, delegateArgs);\n    retExpr = makeConditionalFactory(factoryExpr);\n  } else if (isExpressionFactoryMetadata(meta)) {\n    // TODO(alxhub): decide whether to lower the value here or in the caller\n    retExpr = makeConditionalFactory(meta.expression);\n  } else {\n    retExpr = ctorExpr;\n  }\n\n  if (retExpr === null) {\n    // The expression cannot be formed so render an `ɵɵinvalidFactory()` call.\n    body.push(importExpr(Identifiers.invalidFactory).callFn([]).toStmt());\n  } else if (baseFactoryVar !== null) {\n    // This factory uses a base factory, so call `ɵɵgetInheritedFactory()` to compute it.\n    var getInheritedFactoryCall = importExpr(Identifiers.getInheritedFactory).callFn([meta.internalType]); // Memoize the base factoryFn: `baseFactory || (baseFactory = ɵɵgetInheritedFactory(...))`\n\n    var baseFactory = new BinaryOperatorExpr(BinaryOperator.Or, baseFactoryVar, baseFactoryVar.set(getInheritedFactoryCall));\n    body.push(new ReturnStatement(baseFactory.callFn([typeForCtor])));\n  } else {\n    // This is straightforward factory, just return it.\n    body.push(new ReturnStatement(retExpr));\n  }\n\n  var factoryFn = fn([new FnParam('t', DYNAMIC_TYPE)], body, INFERRED_TYPE, undefined, \"\".concat(meta.name, \"_Factory\"));\n\n  if (baseFactoryVar !== null) {\n    // There is a base factory variable so wrap its declaration along with the factory function into\n    // an IIFE.\n    factoryFn = fn([], [new DeclareVarStmt(baseFactoryVar.name), new ReturnStatement(factoryFn)]).callFn([],\n    /* sourceSpan */\n    undefined,\n    /* pure */\n    true);\n  }\n\n  return {\n    expression: factoryFn,\n    statements: [],\n    type: createFactoryType(meta)\n  };\n}\n\nfunction createFactoryType(meta) {\n  var ctorDepsType = meta.deps !== null && meta.deps !== 'invalid' ? createCtorDepsType(meta.deps) : NONE_TYPE;\n  return expressionType(importExpr(Identifiers.FactoryDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]));\n}\n\nfunction injectDependencies(deps, target) {\n  return deps.map(function (dep, index) {\n    return compileInjectDependency(dep, target, index);\n  });\n}\n\nfunction compileInjectDependency(dep, target, index) {\n  // Interpret the dependency according to its resolved type.\n  if (dep.token === null) {\n    return importExpr(Identifiers.invalidFactoryDep).callFn([literal(index)]);\n  } else if (dep.attributeNameType === null) {\n    // Build up the injection flags according to the metadata.\n    var flags = 0\n    /* Default */\n    | (dep.self ? 2\n    /* Self */\n    : 0) | (dep.skipSelf ? 4\n    /* SkipSelf */\n    : 0) | (dep.host ? 1\n    /* Host */\n    : 0) | (dep.optional ? 8\n    /* Optional */\n    : 0) | (target === FactoryTarget.Pipe ? 16\n    /* ForPipe */\n    : 0); // If this dependency is optional or otherwise has non-default flags, then additional\n    // parameters describing how to inject the dependency must be passed to the inject function\n    // that's being used.\n\n    var flagsParam = flags !== 0\n    /* Default */\n    || dep.optional ? literal(flags) : null; // Build up the arguments to the injectFn call.\n\n    var injectArgs = [dep.token];\n\n    if (flagsParam) {\n      injectArgs.push(flagsParam);\n    }\n\n    var injectFn = getInjectFn(target);\n    return importExpr(injectFn).callFn(injectArgs);\n  } else {\n    // The `dep.attributeTypeName` value is defined, which indicates that this is an `@Attribute()`\n    // type dependency. For the generated JS we still want to use the `dep.token` value in case the\n    // name given for the attribute is not a string literal. For example given `@Attribute(foo())`,\n    // we want to generate `ɵɵinjectAttribute(foo())`.\n    //\n    // The `dep.attributeTypeName` is only actually used (in `createCtorDepType()`) to generate\n    // typings.\n    return importExpr(Identifiers.injectAttribute).callFn([dep.token]);\n  }\n}\n\nfunction createCtorDepsType(deps) {\n  var hasTypes = false;\n  var attributeTypes = deps.map(function (dep) {\n    var type = createCtorDepType(dep);\n\n    if (type !== null) {\n      hasTypes = true;\n      return type;\n    } else {\n      return literal(null);\n    }\n  });\n\n  if (hasTypes) {\n    return expressionType(literalArr(attributeTypes));\n  } else {\n    return NONE_TYPE;\n  }\n}\n\nfunction createCtorDepType(dep) {\n  var entries = [];\n\n  if (dep.attributeNameType !== null) {\n    entries.push({\n      key: 'attribute',\n      value: dep.attributeNameType,\n      quoted: false\n    });\n  }\n\n  if (dep.optional) {\n    entries.push({\n      key: 'optional',\n      value: literal(true),\n      quoted: false\n    });\n  }\n\n  if (dep.host) {\n    entries.push({\n      key: 'host',\n      value: literal(true),\n      quoted: false\n    });\n  }\n\n  if (dep.self) {\n    entries.push({\n      key: 'self',\n      value: literal(true),\n      quoted: false\n    });\n  }\n\n  if (dep.skipSelf) {\n    entries.push({\n      key: 'skipSelf',\n      value: literal(true),\n      quoted: false\n    });\n  }\n\n  return entries.length > 0 ? literalMap(entries) : null;\n}\n\nfunction isDelegatedFactoryMetadata(meta) {\n  return meta.delegateType !== undefined;\n}\n\nfunction isExpressionFactoryMetadata(meta) {\n  return meta.expression !== undefined;\n}\n\nfunction getInjectFn(target) {\n  switch (target) {\n    case FactoryTarget.Component:\n    case FactoryTarget.Directive:\n    case FactoryTarget.Pipe:\n      return Identifiers.directiveInject;\n\n    case FactoryTarget.NgModule:\n    case FactoryTarget.Injectable:\n    default:\n      return Identifiers.inject;\n  }\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nfunction createR3ProviderExpression(expression, isForwardRef) {\n  return {\n    expression: expression,\n    isForwardRef: isForwardRef\n  };\n}\n\nfunction _compileInjectable(meta, resolveForwardRefs) {\n  var result = null;\n  var factoryMeta = {\n    name: meta.name,\n    type: meta.type,\n    internalType: meta.internalType,\n    typeArgumentCount: meta.typeArgumentCount,\n    deps: [],\n    target: FactoryTarget.Injectable\n  };\n\n  if (meta.useClass !== undefined) {\n    // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is\n    // used to instantiate the class with dependencies injected, or deps are not specified and\n    // the factory of the class is used to instantiate it.\n    //\n    // A special case exists for useClass: Type where Type is the injectable type itself and no\n    // deps are specified, in which case 'useClass' is effectively ignored.\n    var useClassOnSelf = meta.useClass.expression.isEquivalent(meta.internalType);\n    var deps = undefined;\n\n    if (meta.deps !== undefined) {\n      deps = meta.deps;\n    }\n\n    if (deps !== undefined) {\n      // factory: () => new meta.useClass(...deps)\n      result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {\n        delegate: meta.useClass.expression,\n        delegateDeps: deps,\n        delegateType: R3FactoryDelegateType.Class\n      }));\n    } else if (useClassOnSelf) {\n      result = compileFactoryFunction(factoryMeta);\n    } else {\n      result = {\n        statements: [],\n        expression: delegateToFactory(meta.type.value, meta.useClass.expression, resolveForwardRefs)\n      };\n    }\n  } else if (meta.useFactory !== undefined) {\n    if (meta.deps !== undefined) {\n      result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {\n        delegate: meta.useFactory,\n        delegateDeps: meta.deps || [],\n        delegateType: R3FactoryDelegateType.Function\n      }));\n    } else {\n      result = {\n        statements: [],\n        expression: fn([], [new ReturnStatement(meta.useFactory.callFn([]))])\n      };\n    }\n  } else if (meta.useValue !== undefined) {\n    // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n    // client code because meta.useValue is an Expression which will be defined even if the actual\n    // value is undefined.\n    result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {\n      expression: meta.useValue.expression\n    }));\n  } else if (meta.useExisting !== undefined) {\n    // useExisting is an `inject` call on the existing token.\n    result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {\n      expression: importExpr(Identifiers.inject).callFn([meta.useExisting.expression])\n    }));\n  } else {\n    result = {\n      statements: [],\n      expression: delegateToFactory(meta.type.value, meta.internalType, resolveForwardRefs)\n    };\n  }\n\n  var token = meta.internalType;\n  var injectableProps = new DefinitionMap();\n  injectableProps.set('token', token);\n  injectableProps.set('factory', result.expression); // Only generate providedIn property if it has a non-null value\n\n  if (meta.providedIn.expression.value !== null) {\n    injectableProps.set('providedIn', meta.providedIn.isForwardRef ? generateForwardRef(meta.providedIn.expression) : meta.providedIn.expression);\n  }\n\n  var expression = importExpr(Identifiers.ɵɵdefineInjectable).callFn([injectableProps.toLiteralMap()], undefined, true);\n  return {\n    expression: expression,\n    type: createInjectableType(meta),\n    statements: result.statements\n  };\n}\n\nfunction createInjectableType(meta) {\n  return new ExpressionType(importExpr(Identifiers.InjectableDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));\n}\n\nfunction delegateToFactory(type, internalType, unwrapForwardRefs) {\n  if (type.node === internalType.node) {\n    // The types are the same, so we can simply delegate directly to the type's factory.\n    // ```\n    // factory: type.ɵfac\n    // ```\n    return internalType.prop('ɵfac');\n  }\n\n  if (!unwrapForwardRefs) {\n    // The type is not wrapped in a `forwardRef()`, so we create a simple factory function that\n    // accepts a sub-type as an argument.\n    // ```\n    // factory: function(t) { return internalType.ɵfac(t); }\n    // ```\n    return createFactoryFunction(internalType);\n  } // The internalType is actually wrapped in a `forwardRef()` so we need to resolve that before\n  // calling its factory.\n  // ```\n  // factory: function(t) { return core.resolveForwardRef(type).ɵfac(t); }\n  // ```\n\n\n  var unwrappedType = importExpr(Identifiers.resolveForwardRef).callFn([internalType]);\n  return createFactoryFunction(unwrappedType);\n}\n\nfunction createFactoryFunction(type) {\n  return fn([new FnParam('t', DYNAMIC_TYPE)], [new ReturnStatement(type.callMethod('ɵfac', [variable('t')]))]);\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nfunction assertArrayOfStrings(identifier, value) {\n  if (value == null) {\n    return;\n  }\n\n  if (!Array.isArray(value)) {\n    throw new Error(\"Expected '\".concat(identifier, \"' to be an array of strings.\"));\n  }\n\n  for (var i = 0; i < value.length; i += 1) {\n    if (typeof value[i] !== 'string') {\n      throw new Error(\"Expected '\".concat(identifier, \"' to be an array of strings.\"));\n    }\n  }\n}\n\nvar UNUSABLE_INTERPOLATION_REGEXPS = [/^\\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\\/\\// // comment\n];\n\nfunction assertInterpolationSymbols(identifier, value) {\n  if (value != null && !(Array.isArray(value) && value.length == 2)) {\n    throw new Error(\"Expected '\".concat(identifier, \"' to be an array, [start, end].\"));\n  } else if (value != null) {\n    var start = value[0];\n    var end = value[1]; // Check for unusable interpolation symbols\n\n    UNUSABLE_INTERPOLATION_REGEXPS.forEach(function (regexp) {\n      if (regexp.test(start) || regexp.test(end)) {\n        throw new Error(\"['\".concat(start, \"', '\").concat(end, \"'] contains unusable interpolation symbol.\"));\n      }\n    });\n  }\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar InterpolationConfig = /*#__PURE__*/function () {\n  function InterpolationConfig(start, end) {\n    _classCallCheck(this, InterpolationConfig);\n\n    this.start = start;\n    this.end = end;\n  }\n\n  _createClass(InterpolationConfig, null, [{\n    key: \"fromArray\",\n    value: function fromArray(markers) {\n      if (!markers) {\n        return DEFAULT_INTERPOLATION_CONFIG;\n      }\n\n      assertInterpolationSymbols('interpolation', markers);\n      return new InterpolationConfig(markers[0], markers[1]);\n    }\n  }]);\n\n  return InterpolationConfig;\n}();\n\nvar DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * A token representing the a reference to a static type.\r\n *\r\n * This token is unique for a filePath and name and can be used as a hash table key.\r\n */\n\nvar StaticSymbol = /*#__PURE__*/function () {\n  function StaticSymbol(filePath, name, members) {\n    _classCallCheck(this, StaticSymbol);\n\n    this.filePath = filePath;\n    this.name = name;\n    this.members = members;\n  }\n\n  _createClass(StaticSymbol, [{\n    key: \"assertNoMembers\",\n    value: function assertNoMembers() {\n      if (this.members.length) {\n        throw new Error(\"Illegal state: symbol without members expected, but got \".concat(JSON.stringify(this), \".\"));\n      }\n    }\n  }]);\n\n  return StaticSymbol;\n}();\n/**\r\n * A cache of static symbol used by the StaticReflector to return the same symbol for the\r\n * same symbol values.\r\n */\n\n\nvar StaticSymbolCache = /*#__PURE__*/function () {\n  function StaticSymbolCache() {\n    _classCallCheck(this, StaticSymbolCache);\n\n    this.cache = new Map();\n  }\n\n  _createClass(StaticSymbolCache, [{\n    key: \"get\",\n    value: function get(declarationFile, name, members) {\n      members = members || [];\n      var memberSuffix = members.length ? \".\".concat(members.join('.')) : '';\n      var key = \"\\\"\".concat(declarationFile, \"\\\".\").concat(name).concat(memberSuffix);\n      var result = this.cache.get(key);\n\n      if (!result) {\n        result = new StaticSymbol(declarationFile, name, members);\n        this.cache.set(key, result);\n      }\n\n      return result;\n    }\n  }]);\n\n  return StaticSymbolCache;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n// group 0: \"[prop] or (event) or @trigger\"\n// group 1: \"prop\" from \"[prop]\"\n// group 2: \"event\" from \"(event)\"\n// group 3: \"@trigger\" from \"@trigger\"\n\n\nvar HOST_REG_EXP = /^(?:(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\)))|(\\@[-\\w]+)$/;\n\nfunction sanitizeIdentifier(name) {\n  return name.replace(/\\W/g, '_');\n}\n\nvar _anonymousTypeIndex = 0;\n\nfunction identifierName(compileIdentifier) {\n  if (!compileIdentifier || !compileIdentifier.reference) {\n    return null;\n  }\n\n  var ref = compileIdentifier.reference;\n\n  if (ref instanceof StaticSymbol) {\n    return ref.name;\n  }\n\n  if (ref['__anonymousType']) {\n    return ref['__anonymousType'];\n  }\n\n  if (ref['__forward_ref__']) {\n    // We do not want to try to stringify a `forwardRef()` function because that would cause the\n    // inner function to be evaluated too early, defeating the whole point of the `forwardRef`.\n    return '__forward_ref__';\n  }\n\n  var identifier = stringify(ref);\n\n  if (identifier.indexOf('(') >= 0) {\n    // case: anonymous functions!\n    identifier = \"anonymous_\".concat(_anonymousTypeIndex++);\n    ref['__anonymousType'] = identifier;\n  } else {\n    identifier = sanitizeIdentifier(identifier);\n  }\n\n  return identifier;\n}\n\nfunction identifierModuleUrl(compileIdentifier) {\n  var ref = compileIdentifier.reference;\n\n  if (ref instanceof StaticSymbol) {\n    return ref.filePath;\n  } // Runtime type\n\n\n  return \"./\".concat(stringify(ref));\n}\n\nfunction viewClassName(compType, embeddedTemplateIndex) {\n  return \"View_\".concat(identifierName({\n    reference: compType\n  }), \"_\").concat(embeddedTemplateIndex);\n}\n\nfunction rendererTypeName(compType) {\n  return \"RenderType_\".concat(identifierName({\n    reference: compType\n  }));\n}\n\nfunction hostViewClassName(compType) {\n  return \"HostView_\".concat(identifierName({\n    reference: compType\n  }));\n}\n\nfunction componentFactoryName(compType) {\n  return \"\".concat(identifierName({\n    reference: compType\n  }), \"NgFactory\");\n}\n\nvar CompileSummaryKind;\n\n(function (CompileSummaryKind) {\n  CompileSummaryKind[CompileSummaryKind[\"Pipe\"] = 0] = \"Pipe\";\n  CompileSummaryKind[CompileSummaryKind[\"Directive\"] = 1] = \"Directive\";\n  CompileSummaryKind[CompileSummaryKind[\"NgModule\"] = 2] = \"NgModule\";\n  CompileSummaryKind[CompileSummaryKind[\"Injectable\"] = 3] = \"Injectable\";\n})(CompileSummaryKind || (CompileSummaryKind = {}));\n\nfunction tokenName(token) {\n  return token.value != null ? sanitizeIdentifier(token.value) : identifierName(token.identifier);\n}\n\nfunction tokenReference(token) {\n  if (token.identifier != null) {\n    return token.identifier.reference;\n  } else {\n    return token.value;\n  }\n}\n/**\r\n * Metadata about a stylesheet\r\n */\n\n\nvar CompileStylesheetMetadata = function CompileStylesheetMetadata() {\n  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      moduleUrl = _ref4.moduleUrl,\n      styles = _ref4.styles,\n      styleUrls = _ref4.styleUrls;\n\n  _classCallCheck(this, CompileStylesheetMetadata);\n\n  this.moduleUrl = moduleUrl || null;\n  this.styles = _normalizeArray(styles);\n  this.styleUrls = _normalizeArray(styleUrls);\n};\n/**\r\n * Metadata regarding compilation of a template.\r\n */\n\n\nvar CompileTemplateMetadata = /*#__PURE__*/function () {\n  function CompileTemplateMetadata(_ref5) {\n    var encapsulation = _ref5.encapsulation,\n        template = _ref5.template,\n        templateUrl = _ref5.templateUrl,\n        htmlAst = _ref5.htmlAst,\n        styles = _ref5.styles,\n        styleUrls = _ref5.styleUrls,\n        externalStylesheets = _ref5.externalStylesheets,\n        animations = _ref5.animations,\n        ngContentSelectors = _ref5.ngContentSelectors,\n        interpolation = _ref5.interpolation,\n        isInline = _ref5.isInline,\n        preserveWhitespaces = _ref5.preserveWhitespaces;\n\n    _classCallCheck(this, CompileTemplateMetadata);\n\n    this.encapsulation = encapsulation;\n    this.template = template;\n    this.templateUrl = templateUrl;\n    this.htmlAst = htmlAst;\n    this.styles = _normalizeArray(styles);\n    this.styleUrls = _normalizeArray(styleUrls);\n    this.externalStylesheets = _normalizeArray(externalStylesheets);\n    this.animations = animations ? flatten(animations) : [];\n    this.ngContentSelectors = ngContentSelectors || [];\n\n    if (interpolation && interpolation.length != 2) {\n      throw new Error(\"'interpolation' should have a start and an end symbol.\");\n    }\n\n    this.interpolation = interpolation;\n    this.isInline = isInline;\n    this.preserveWhitespaces = preserveWhitespaces;\n  }\n\n  _createClass(CompileTemplateMetadata, [{\n    key: \"toSummary\",\n    value: function toSummary() {\n      return {\n        ngContentSelectors: this.ngContentSelectors,\n        encapsulation: this.encapsulation,\n        styles: this.styles,\n        animations: this.animations\n      };\n    }\n  }]);\n\n  return CompileTemplateMetadata;\n}();\n/**\r\n * Metadata regarding compilation of a directive.\r\n */\n\n\nvar CompileDirectiveMetadata = /*#__PURE__*/function () {\n  function CompileDirectiveMetadata(_ref6) {\n    var isHost = _ref6.isHost,\n        type = _ref6.type,\n        isComponent = _ref6.isComponent,\n        selector = _ref6.selector,\n        exportAs = _ref6.exportAs,\n        changeDetection = _ref6.changeDetection,\n        inputs = _ref6.inputs,\n        outputs = _ref6.outputs,\n        hostListeners = _ref6.hostListeners,\n        hostProperties = _ref6.hostProperties,\n        hostAttributes = _ref6.hostAttributes,\n        providers = _ref6.providers,\n        viewProviders = _ref6.viewProviders,\n        queries = _ref6.queries,\n        guards = _ref6.guards,\n        viewQueries = _ref6.viewQueries,\n        entryComponents = _ref6.entryComponents,\n        template = _ref6.template,\n        componentViewType = _ref6.componentViewType,\n        rendererType = _ref6.rendererType,\n        componentFactory = _ref6.componentFactory;\n\n    _classCallCheck(this, CompileDirectiveMetadata);\n\n    this.isHost = !!isHost;\n    this.type = type;\n    this.isComponent = isComponent;\n    this.selector = selector;\n    this.exportAs = exportAs;\n    this.changeDetection = changeDetection;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.hostListeners = hostListeners;\n    this.hostProperties = hostProperties;\n    this.hostAttributes = hostAttributes;\n    this.providers = _normalizeArray(providers);\n    this.viewProviders = _normalizeArray(viewProviders);\n    this.queries = _normalizeArray(queries);\n    this.guards = guards;\n    this.viewQueries = _normalizeArray(viewQueries);\n    this.entryComponents = _normalizeArray(entryComponents);\n    this.template = template;\n    this.componentViewType = componentViewType;\n    this.rendererType = rendererType;\n    this.componentFactory = componentFactory;\n  }\n\n  _createClass(CompileDirectiveMetadata, [{\n    key: \"toSummary\",\n    value: function toSummary() {\n      return {\n        summaryKind: CompileSummaryKind.Directive,\n        type: this.type,\n        isComponent: this.isComponent,\n        selector: this.selector,\n        exportAs: this.exportAs,\n        inputs: this.inputs,\n        outputs: this.outputs,\n        hostListeners: this.hostListeners,\n        hostProperties: this.hostProperties,\n        hostAttributes: this.hostAttributes,\n        providers: this.providers,\n        viewProviders: this.viewProviders,\n        queries: this.queries,\n        guards: this.guards,\n        viewQueries: this.viewQueries,\n        entryComponents: this.entryComponents,\n        changeDetection: this.changeDetection,\n        template: this.template && this.template.toSummary(),\n        componentViewType: this.componentViewType,\n        rendererType: this.rendererType,\n        componentFactory: this.componentFactory\n      };\n    }\n  }], [{\n    key: \"create\",\n    value: function create(_ref7) {\n      var isHost = _ref7.isHost,\n          type = _ref7.type,\n          isComponent = _ref7.isComponent,\n          selector = _ref7.selector,\n          exportAs = _ref7.exportAs,\n          changeDetection = _ref7.changeDetection,\n          inputs = _ref7.inputs,\n          outputs = _ref7.outputs,\n          host = _ref7.host,\n          providers = _ref7.providers,\n          viewProviders = _ref7.viewProviders,\n          queries = _ref7.queries,\n          guards = _ref7.guards,\n          viewQueries = _ref7.viewQueries,\n          entryComponents = _ref7.entryComponents,\n          template = _ref7.template,\n          componentViewType = _ref7.componentViewType,\n          rendererType = _ref7.rendererType,\n          componentFactory = _ref7.componentFactory;\n      var hostListeners = {};\n      var hostProperties = {};\n      var hostAttributes = {};\n\n      if (host != null) {\n        Object.keys(host).forEach(function (key) {\n          var value = host[key];\n          var matches = key.match(HOST_REG_EXP);\n\n          if (matches === null) {\n            hostAttributes[key] = value;\n          } else if (matches[1] != null) {\n            hostProperties[matches[1]] = value;\n          } else if (matches[2] != null) {\n            hostListeners[matches[2]] = value;\n          }\n        });\n      }\n\n      var inputsMap = {};\n\n      if (inputs != null) {\n        inputs.forEach(function (bindConfig) {\n          // canonical syntax: `dirProp: elProp`\n          // if there is no `:`, use dirProp = elProp\n          var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n          inputsMap[parts[0]] = parts[1];\n        });\n      }\n\n      var outputsMap = {};\n\n      if (outputs != null) {\n        outputs.forEach(function (bindConfig) {\n          // canonical syntax: `dirProp: elProp`\n          // if there is no `:`, use dirProp = elProp\n          var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n          outputsMap[parts[0]] = parts[1];\n        });\n      }\n\n      return new CompileDirectiveMetadata({\n        isHost: isHost,\n        type: type,\n        isComponent: !!isComponent,\n        selector: selector,\n        exportAs: exportAs,\n        changeDetection: changeDetection,\n        inputs: inputsMap,\n        outputs: outputsMap,\n        hostListeners: hostListeners,\n        hostProperties: hostProperties,\n        hostAttributes: hostAttributes,\n        providers: providers,\n        viewProviders: viewProviders,\n        queries: queries,\n        guards: guards,\n        viewQueries: viewQueries,\n        entryComponents: entryComponents,\n        template: template,\n        componentViewType: componentViewType,\n        rendererType: rendererType,\n        componentFactory: componentFactory\n      });\n    }\n  }]);\n\n  return CompileDirectiveMetadata;\n}();\n\nvar CompilePipeMetadata = /*#__PURE__*/function () {\n  function CompilePipeMetadata(_ref8) {\n    var type = _ref8.type,\n        name = _ref8.name,\n        pure = _ref8.pure;\n\n    _classCallCheck(this, CompilePipeMetadata);\n\n    this.type = type;\n    this.name = name;\n    this.pure = !!pure;\n  }\n\n  _createClass(CompilePipeMetadata, [{\n    key: \"toSummary\",\n    value: function toSummary() {\n      return {\n        summaryKind: CompileSummaryKind.Pipe,\n        type: this.type,\n        name: this.name,\n        pure: this.pure\n      };\n    }\n  }]);\n\n  return CompilePipeMetadata;\n}();\n\nvar CompileShallowModuleMetadata = function CompileShallowModuleMetadata() {\n  _classCallCheck(this, CompileShallowModuleMetadata);\n};\n/**\r\n * Metadata regarding compilation of a module.\r\n */\n\n\nvar CompileNgModuleMetadata = /*#__PURE__*/function () {\n  function CompileNgModuleMetadata(_ref9) {\n    var type = _ref9.type,\n        providers = _ref9.providers,\n        declaredDirectives = _ref9.declaredDirectives,\n        exportedDirectives = _ref9.exportedDirectives,\n        declaredPipes = _ref9.declaredPipes,\n        exportedPipes = _ref9.exportedPipes,\n        entryComponents = _ref9.entryComponents,\n        bootstrapComponents = _ref9.bootstrapComponents,\n        importedModules = _ref9.importedModules,\n        exportedModules = _ref9.exportedModules,\n        schemas = _ref9.schemas,\n        transitiveModule = _ref9.transitiveModule,\n        id = _ref9.id;\n\n    _classCallCheck(this, CompileNgModuleMetadata);\n\n    this.type = type || null;\n    this.declaredDirectives = _normalizeArray(declaredDirectives);\n    this.exportedDirectives = _normalizeArray(exportedDirectives);\n    this.declaredPipes = _normalizeArray(declaredPipes);\n    this.exportedPipes = _normalizeArray(exportedPipes);\n    this.providers = _normalizeArray(providers);\n    this.entryComponents = _normalizeArray(entryComponents);\n    this.bootstrapComponents = _normalizeArray(bootstrapComponents);\n    this.importedModules = _normalizeArray(importedModules);\n    this.exportedModules = _normalizeArray(exportedModules);\n    this.schemas = _normalizeArray(schemas);\n    this.id = id || null;\n    this.transitiveModule = transitiveModule || null;\n  }\n\n  _createClass(CompileNgModuleMetadata, [{\n    key: \"toSummary\",\n    value: function toSummary() {\n      var module = this.transitiveModule;\n      return {\n        summaryKind: CompileSummaryKind.NgModule,\n        type: this.type,\n        entryComponents: module.entryComponents,\n        providers: module.providers,\n        modules: module.modules,\n        exportedDirectives: module.exportedDirectives,\n        exportedPipes: module.exportedPipes\n      };\n    }\n  }]);\n\n  return CompileNgModuleMetadata;\n}();\n\nvar TransitiveCompileNgModuleMetadata = /*#__PURE__*/function () {\n  function TransitiveCompileNgModuleMetadata() {\n    _classCallCheck(this, TransitiveCompileNgModuleMetadata);\n\n    this.directivesSet = new Set();\n    this.directives = [];\n    this.exportedDirectivesSet = new Set();\n    this.exportedDirectives = [];\n    this.pipesSet = new Set();\n    this.pipes = [];\n    this.exportedPipesSet = new Set();\n    this.exportedPipes = [];\n    this.modulesSet = new Set();\n    this.modules = [];\n    this.entryComponentsSet = new Set();\n    this.entryComponents = [];\n    this.providers = [];\n  }\n\n  _createClass(TransitiveCompileNgModuleMetadata, [{\n    key: \"addProvider\",\n    value: function addProvider(provider, module) {\n      this.providers.push({\n        provider: provider,\n        module: module\n      });\n    }\n  }, {\n    key: \"addDirective\",\n    value: function addDirective(id) {\n      if (!this.directivesSet.has(id.reference)) {\n        this.directivesSet.add(id.reference);\n        this.directives.push(id);\n      }\n    }\n  }, {\n    key: \"addExportedDirective\",\n    value: function addExportedDirective(id) {\n      if (!this.exportedDirectivesSet.has(id.reference)) {\n        this.exportedDirectivesSet.add(id.reference);\n        this.exportedDirectives.push(id);\n      }\n    }\n  }, {\n    key: \"addPipe\",\n    value: function addPipe(id) {\n      if (!this.pipesSet.has(id.reference)) {\n        this.pipesSet.add(id.reference);\n        this.pipes.push(id);\n      }\n    }\n  }, {\n    key: \"addExportedPipe\",\n    value: function addExportedPipe(id) {\n      if (!this.exportedPipesSet.has(id.reference)) {\n        this.exportedPipesSet.add(id.reference);\n        this.exportedPipes.push(id);\n      }\n    }\n  }, {\n    key: \"addModule\",\n    value: function addModule(id) {\n      if (!this.modulesSet.has(id.reference)) {\n        this.modulesSet.add(id.reference);\n        this.modules.push(id);\n      }\n    }\n  }, {\n    key: \"addEntryComponent\",\n    value: function addEntryComponent(ec) {\n      if (!this.entryComponentsSet.has(ec.componentType)) {\n        this.entryComponentsSet.add(ec.componentType);\n        this.entryComponents.push(ec);\n      }\n    }\n  }]);\n\n  return TransitiveCompileNgModuleMetadata;\n}();\n\nfunction _normalizeArray(obj) {\n  return obj || [];\n}\n\nvar ProviderMeta = function ProviderMeta(token, _ref10) {\n  var useClass = _ref10.useClass,\n      useValue = _ref10.useValue,\n      useExisting = _ref10.useExisting,\n      useFactory = _ref10.useFactory,\n      deps = _ref10.deps,\n      multi = _ref10.multi;\n\n  _classCallCheck(this, ProviderMeta);\n\n  this.token = token;\n  this.useClass = useClass || null;\n  this.useValue = useValue;\n  this.useExisting = useExisting;\n  this.useFactory = useFactory || null;\n  this.dependencies = deps || null;\n  this.multi = !!multi;\n};\n\nfunction flatten(list) {\n  return list.reduce(function (flat, item) {\n    var flatItem = Array.isArray(item) ? flatten(item) : item;\n    return flat.concat(flatItem);\n  }, []);\n}\n\nfunction jitSourceUrl(url) {\n  // Note: We need 3 \"/\" so that ng shows up as a separate domain\n  // in the chrome dev tools.\n  return url.replace(/(\\w+:\\/\\/[\\w:-]+)?(\\/+)?/, 'ng:///');\n}\n\nfunction templateSourceUrl(ngModuleType, compMeta, templateMeta) {\n  var url;\n\n  if (templateMeta.isInline) {\n    if (compMeta.type.reference instanceof StaticSymbol) {\n      // Note: a .ts file might contain multiple components with inline templates,\n      // so we need to give them unique urls, as these will be used for sourcemaps.\n      url = \"\".concat(compMeta.type.reference.filePath, \".\").concat(compMeta.type.reference.name, \".html\");\n    } else {\n      url = \"\".concat(identifierName(ngModuleType), \"/\").concat(identifierName(compMeta.type), \".html\");\n    }\n  } else {\n    url = templateMeta.templateUrl;\n  }\n\n  return compMeta.type.reference instanceof StaticSymbol ? url : jitSourceUrl(url);\n}\n\nfunction sharedStylesheetJitUrl(meta, id) {\n  var pathParts = meta.moduleUrl.split(/\\/\\\\/g);\n  var baseName = pathParts[pathParts.length - 1];\n  return jitSourceUrl(\"css/\".concat(id).concat(baseName, \".ngstyle.js\"));\n}\n\nfunction ngModuleJitUrl(moduleMeta) {\n  return jitSourceUrl(\"\".concat(identifierName(moduleMeta.type), \"/module.ngfactory.js\"));\n}\n\nfunction templateJitUrl(ngModuleType, compMeta) {\n  return jitSourceUrl(\"\".concat(identifierName(ngModuleType), \"/\").concat(identifierName(compMeta.type), \".ngfactory.js\"));\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * In TypeScript, tagged template functions expect a \"template object\", which is an array of\r\n * \"cooked\" strings plus a `raw` property that contains an array of \"raw\" strings. This is\r\n * typically constructed with a function called `__makeTemplateObject(cooked, raw)`, but it may not\r\n * be available in all environments.\r\n *\r\n * This is a JavaScript polyfill that uses __makeTemplateObject when it's available, but otherwise\r\n * creates an inline helper with the same functionality.\r\n *\r\n * In the inline function, if `Object.defineProperty` is available we use that to attach the `raw`\r\n * array.\r\n */\n\n\nvar makeTemplateObjectPolyfill = '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,\"raw\",{value:t}):e.raw=t,e})';\n\nvar AbstractJsEmitterVisitor = /*#__PURE__*/function (_AbstractEmitterVisit) {\n  _inherits(AbstractJsEmitterVisitor, _AbstractEmitterVisit);\n\n  var _super52 = _createSuper(AbstractJsEmitterVisitor);\n\n  function AbstractJsEmitterVisitor() {\n    _classCallCheck(this, AbstractJsEmitterVisitor);\n\n    return _super52.call(this, false);\n  }\n\n  _createClass(AbstractJsEmitterVisitor, [{\n    key: \"visitDeclareClassStmt\",\n    value: function visitDeclareClassStmt(stmt, ctx) {\n      var _this85 = this;\n\n      ctx.pushClass(stmt);\n\n      this._visitClassConstructor(stmt, ctx);\n\n      if (stmt.parent != null) {\n        ctx.print(stmt, \"\".concat(stmt.name, \".prototype = Object.create(\"));\n        stmt.parent.visitExpression(this, ctx);\n        ctx.println(stmt, \".prototype);\");\n      }\n\n      stmt.getters.forEach(function (getter) {\n        return _this85._visitClassGetter(stmt, getter, ctx);\n      });\n      stmt.methods.forEach(function (method) {\n        return _this85._visitClassMethod(stmt, method, ctx);\n      });\n      ctx.popClass();\n      return null;\n    }\n  }, {\n    key: \"_visitClassConstructor\",\n    value: function _visitClassConstructor(stmt, ctx) {\n      ctx.print(stmt, \"function \".concat(stmt.name, \"(\"));\n\n      if (stmt.constructorMethod != null) {\n        this._visitParams(stmt.constructorMethod.params, ctx);\n      }\n\n      ctx.println(stmt, \") {\");\n      ctx.incIndent();\n\n      if (stmt.constructorMethod != null) {\n        if (stmt.constructorMethod.body.length > 0) {\n          ctx.println(stmt, \"var self = this;\");\n          this.visitAllStatements(stmt.constructorMethod.body, ctx);\n        }\n      }\n\n      ctx.decIndent();\n      ctx.println(stmt, \"}\");\n    }\n  }, {\n    key: \"_visitClassGetter\",\n    value: function _visitClassGetter(stmt, getter, ctx) {\n      ctx.println(stmt, \"Object.defineProperty(\".concat(stmt.name, \".prototype, '\").concat(getter.name, \"', { get: function() {\"));\n      ctx.incIndent();\n\n      if (getter.body.length > 0) {\n        ctx.println(stmt, \"var self = this;\");\n        this.visitAllStatements(getter.body, ctx);\n      }\n\n      ctx.decIndent();\n      ctx.println(stmt, \"}});\");\n    }\n  }, {\n    key: \"_visitClassMethod\",\n    value: function _visitClassMethod(stmt, method, ctx) {\n      ctx.print(stmt, \"\".concat(stmt.name, \".prototype.\").concat(method.name, \" = function(\"));\n\n      this._visitParams(method.params, ctx);\n\n      ctx.println(stmt, \") {\");\n      ctx.incIndent();\n\n      if (method.body.length > 0) {\n        ctx.println(stmt, \"var self = this;\");\n        this.visitAllStatements(method.body, ctx);\n      }\n\n      ctx.decIndent();\n      ctx.println(stmt, \"};\");\n    }\n  }, {\n    key: \"visitWrappedNodeExpr\",\n    value: function visitWrappedNodeExpr(ast, ctx) {\n      throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');\n    }\n  }, {\n    key: \"visitReadVarExpr\",\n    value: function visitReadVarExpr(ast, ctx) {\n      if (ast.builtin === BuiltinVar.This) {\n        ctx.print(ast, 'self');\n      } else if (ast.builtin === BuiltinVar.Super) {\n        throw new Error(\"'super' needs to be handled at a parent ast node, not at the variable level!\");\n      } else {\n        _get(_getPrototypeOf(AbstractJsEmitterVisitor.prototype), \"visitReadVarExpr\", this).call(this, ast, ctx);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitDeclareVarStmt\",\n    value: function visitDeclareVarStmt(stmt, ctx) {\n      ctx.print(stmt, \"var \".concat(stmt.name));\n\n      if (stmt.value) {\n        ctx.print(stmt, ' = ');\n        stmt.value.visitExpression(this, ctx);\n      }\n\n      ctx.println(stmt, \";\");\n      return null;\n    }\n  }, {\n    key: \"visitCastExpr\",\n    value: function visitCastExpr(ast, ctx) {\n      ast.value.visitExpression(this, ctx);\n      return null;\n    }\n  }, {\n    key: \"visitInvokeFunctionExpr\",\n    value: function visitInvokeFunctionExpr(expr, ctx) {\n      var fnExpr = expr.fn;\n\n      if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\n        ctx.currentClass.parent.visitExpression(this, ctx);\n        ctx.print(expr, \".call(this\");\n\n        if (expr.args.length > 0) {\n          ctx.print(expr, \", \");\n          this.visitAllExpressions(expr.args, ctx, ',');\n        }\n\n        ctx.print(expr, \")\");\n      } else {\n        _get(_getPrototypeOf(AbstractJsEmitterVisitor.prototype), \"visitInvokeFunctionExpr\", this).call(this, expr, ctx);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitTaggedTemplateExpr\",\n    value: function visitTaggedTemplateExpr(ast, ctx) {\n      var _this86 = this;\n\n      // The following convoluted piece of code is effectively the downlevelled equivalent of\n      // ```\n      // tag`...`\n      // ```\n      // which is effectively like:\n      // ```\n      // tag(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n      // ```\n      var elements = ast.template.elements;\n      ast.tag.visitExpression(this, ctx);\n      ctx.print(ast, \"(\".concat(makeTemplateObjectPolyfill, \"(\"));\n      ctx.print(ast, \"[\".concat(elements.map(function (part) {\n        return escapeIdentifier(part.text, false);\n      }).join(', '), \"], \"));\n      ctx.print(ast, \"[\".concat(elements.map(function (part) {\n        return escapeIdentifier(part.rawText, false);\n      }).join(', '), \"])\"));\n      ast.template.expressions.forEach(function (expression) {\n        ctx.print(ast, ', ');\n        expression.visitExpression(_this86, ctx);\n      });\n      ctx.print(ast, ')');\n      return null;\n    }\n  }, {\n    key: \"visitFunctionExpr\",\n    value: function visitFunctionExpr(ast, ctx) {\n      ctx.print(ast, \"function\".concat(ast.name ? ' ' + ast.name : '', \"(\"));\n\n      this._visitParams(ast.params, ctx);\n\n      ctx.println(ast, \") {\");\n      ctx.incIndent();\n      this.visitAllStatements(ast.statements, ctx);\n      ctx.decIndent();\n      ctx.print(ast, \"}\");\n      return null;\n    }\n  }, {\n    key: \"visitDeclareFunctionStmt\",\n    value: function visitDeclareFunctionStmt(stmt, ctx) {\n      ctx.print(stmt, \"function \".concat(stmt.name, \"(\"));\n\n      this._visitParams(stmt.params, ctx);\n\n      ctx.println(stmt, \") {\");\n      ctx.incIndent();\n      this.visitAllStatements(stmt.statements, ctx);\n      ctx.decIndent();\n      ctx.println(stmt, \"}\");\n      return null;\n    }\n  }, {\n    key: \"visitTryCatchStmt\",\n    value: function visitTryCatchStmt(stmt, ctx) {\n      ctx.println(stmt, \"try {\");\n      ctx.incIndent();\n      this.visitAllStatements(stmt.bodyStmts, ctx);\n      ctx.decIndent();\n      ctx.println(stmt, \"} catch (\".concat(CATCH_ERROR_VAR$1.name, \") {\"));\n      ctx.incIndent();\n      var catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [StmtModifier.Final])].concat(stmt.catchStmts);\n      this.visitAllStatements(catchStmts, ctx);\n      ctx.decIndent();\n      ctx.println(stmt, \"}\");\n      return null;\n    }\n  }, {\n    key: \"visitLocalizedString\",\n    value: function visitLocalizedString(ast, ctx) {\n      var _this87 = this;\n\n      // The following convoluted piece of code is effectively the downlevelled equivalent of\n      // ```\n      // $localize `...`\n      // ```\n      // which is effectively like:\n      // ```\n      // $localize(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n      // ```\n      ctx.print(ast, \"$localize(\".concat(makeTemplateObjectPolyfill, \"(\"));\n      var parts = [ast.serializeI18nHead()];\n\n      for (var i = 1; i < ast.messageParts.length; i++) {\n        parts.push(ast.serializeI18nTemplatePart(i));\n      }\n\n      ctx.print(ast, \"[\".concat(parts.map(function (part) {\n        return escapeIdentifier(part.cooked, false);\n      }).join(', '), \"], \"));\n      ctx.print(ast, \"[\".concat(parts.map(function (part) {\n        return escapeIdentifier(part.raw, false);\n      }).join(', '), \"])\"));\n      ast.expressions.forEach(function (expression) {\n        ctx.print(ast, ', ');\n        expression.visitExpression(_this87, ctx);\n      });\n      ctx.print(ast, ')');\n      return null;\n    }\n  }, {\n    key: \"_visitParams\",\n    value: function _visitParams(params, ctx) {\n      this.visitAllObjects(function (param) {\n        return ctx.print(null, param.name);\n      }, params, ctx, ',');\n    }\n  }, {\n    key: \"getBuiltinMethodName\",\n    value: function getBuiltinMethodName(method) {\n      var name;\n\n      switch (method) {\n        case BuiltinMethod.ConcatArray:\n          name = 'concat';\n          break;\n\n        case BuiltinMethod.SubscribeObservable:\n          name = 'subscribe';\n          break;\n\n        case BuiltinMethod.Bind:\n          name = 'bind';\n          break;\n\n        default:\n          throw new Error(\"Unknown builtin method: \".concat(method));\n      }\n\n      return name;\n    }\n  }]);\n\n  return AbstractJsEmitterVisitor;\n}(AbstractEmitterVisitor);\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * The Trusted Types policy, or null if Trusted Types are not\r\n * enabled/supported, or undefined if the policy has not been created yet.\r\n */\n\n\nvar policy;\n/**\r\n * Returns the Trusted Types policy, or null if Trusted Types are not\r\n * enabled/supported. The first call to this function will create the policy.\r\n */\n\nfunction getPolicy() {\n  if (policy === undefined) {\n    policy = null;\n\n    if (_global.trustedTypes) {\n      try {\n        policy = _global.trustedTypes.createPolicy('angular#unsafe-jit', {\n          createScript: function createScript(s) {\n            return s;\n          }\n        });\n      } catch (_a) {// trustedTypes.createPolicy throws if called with a name that is\n        // already registered, even in report-only mode. Until the API changes,\n        // catch the error not to break the applications functionally. In such\n        // cases, the code will fall back to using strings.\n      }\n    }\n  }\n\n  return policy;\n}\n/**\r\n * Unsafely promote a string to a TrustedScript, falling back to strings when\r\n * Trusted Types are not available.\r\n * @security In particular, it must be assured that the provided string will\r\n * never cause an XSS vulnerability if used in a context that will be\r\n * interpreted and executed as a script by a browser, e.g. when calling eval.\r\n */\n\n\nfunction trustedScriptFromString(script) {\n  var _a;\n\n  return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createScript(script)) || script;\n}\n/**\r\n * Unsafely call the Function constructor with the given string arguments.\r\n * @security This is a security-sensitive function; any use of this function\r\n * must go through security review. In particular, it must be assured that it\r\n * is only called from the JIT compiler, as use in other code can lead to XSS\r\n * vulnerabilities.\r\n */\n\n\nfunction newTrustedFunctionForJIT() {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {\n    args[_key4] = arguments[_key4];\n  }\n\n  if (!_global.trustedTypes) {\n    // In environments that don't support Trusted Types, fall back to the most\n    // straightforward implementation:\n    return _construct(Function, args);\n  } // Chrome currently does not support passing TrustedScript to the Function\n  // constructor. The following implements the workaround proposed on the page\n  // below, where the Chromium bug is also referenced:\n  // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\n\n\n  var fnArgs = args.slice(0, -1).join(',');\n  var fnBody = args[args.length - 1];\n  var body = \"(function anonymous(\".concat(fnArgs, \"\\n) { \").concat(fnBody, \"\\n})\"); // Using eval directly confuses the compiler and prevents this module from\n  // being stripped out of JS binaries even if not used. The global['eval']\n  // indirection fixes that.\n\n  var fn = _global['eval'](trustedScriptFromString(body));\n\n  if (fn.bind === undefined) {\n    // Workaround for a browser bug that only exists in Chrome 83, where passing\n    // a TrustedScript to eval just returns the TrustedScript back without\n    // evaluating it. In that case, fall back to the most straightforward\n    // implementation:\n    return _construct(Function, args);\n  } // To completely mimic the behavior of calling \"new Function\", two more\n  // things need to happen:\n  // 1. Stringifying the resulting function should return its source code\n\n\n  fn.toString = function () {\n    return body;\n  }; // 2. When calling the resulting function, `this` should refer to `global`\n\n\n  return fn.bind(_global); // When Trusted Types support in Function constructors is widely available,\n  // the implementation of this function can be simplified to:\n  // return new Function(...args.map(a => trustedScriptFromString(a)));\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * A helper class to manage the evaluation of JIT generated code.\r\n */\n\n\nvar JitEvaluator = /*#__PURE__*/function () {\n  function JitEvaluator() {\n    _classCallCheck(this, JitEvaluator);\n  }\n\n  _createClass(JitEvaluator, [{\n    key: \"evaluateStatements\",\n    value:\n    /**\r\n     *\r\n     * @param sourceUrl The URL of the generated code.\r\n     * @param statements An array of Angular statement AST nodes to be evaluated.\r\n     * @param reflector A helper used when converting the statements to executable code.\r\n     * @param createSourceMaps If true then create a source-map for the generated code and include it\r\n     * inline as a source-map comment.\r\n     * @returns A map of all the variables in the generated code.\r\n     */\n    function evaluateStatements(sourceUrl, statements, reflector, createSourceMaps) {\n      var converter = new JitEmitterVisitor(reflector);\n      var ctx = EmitterVisitorContext.createRoot(); // Ensure generated code is in strict mode\n\n      if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n        statements = [literal('use strict').toStmt()].concat(_toConsumableArray(statements));\n      }\n\n      converter.visitAllStatements(statements, ctx);\n      converter.createReturnStmt(ctx);\n      return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n    }\n    /**\r\n     * Evaluate a piece of JIT generated code.\r\n     * @param sourceUrl The URL of this generated code.\r\n     * @param ctx A context object that contains an AST of the code to be evaluated.\r\n     * @param vars A map containing the names and values of variables that the evaluated code might\r\n     * reference.\r\n     * @param createSourceMap If true then create a source-map for the generated code and include it\r\n     * inline as a source-map comment.\r\n     * @returns The result of evaluating the code.\r\n     */\n\n  }, {\n    key: \"evaluateCode\",\n    value: function evaluateCode(sourceUrl, ctx, vars, createSourceMap) {\n      var fnBody = \"\\\"use strict\\\";\".concat(ctx.toSource(), \"\\n//# sourceURL=\").concat(sourceUrl);\n      var fnArgNames = [];\n      var fnArgValues = [];\n\n      for (var argName in vars) {\n        fnArgValues.push(vars[argName]);\n        fnArgNames.push(argName);\n      }\n\n      if (createSourceMap) {\n        // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n        // E.g. ```\n        // function anonymous(a,b,c\n        // /**/) { ... }```\n        // We don't want to hard code this fact, so we auto detect it via an empty function first.\n        var emptyFn = newTrustedFunctionForJIT.apply(void 0, _toConsumableArray(fnArgNames.concat('return null;'))).toString();\n        var headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n        fnBody += \"\\n\".concat(ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment());\n      }\n\n      var fn = newTrustedFunctionForJIT.apply(void 0, _toConsumableArray(fnArgNames.concat(fnBody)));\n      return this.executeFunction(fn, fnArgValues);\n    }\n    /**\r\n     * Execute a JIT generated function by calling it.\r\n     *\r\n     * This method can be overridden in tests to capture the functions that are generated\r\n     * by this `JitEvaluator` class.\r\n     *\r\n     * @param fn A function to execute.\r\n     * @param args The arguments to pass to the function being executed.\r\n     * @returns The return value of the executed function.\r\n     */\n\n  }, {\n    key: \"executeFunction\",\n    value: function executeFunction(fn, args) {\n      return fn.apply(void 0, _toConsumableArray(args));\n    }\n  }]);\n\n  return JitEvaluator;\n}();\n/**\r\n * An Angular AST visitor that converts AST nodes into executable JavaScript code.\r\n */\n\n\nvar JitEmitterVisitor = /*#__PURE__*/function (_AbstractJsEmitterVis) {\n  _inherits(JitEmitterVisitor, _AbstractJsEmitterVis);\n\n  var _super53 = _createSuper(JitEmitterVisitor);\n\n  function JitEmitterVisitor(reflector) {\n    var _this88;\n\n    _classCallCheck(this, JitEmitterVisitor);\n\n    _this88 = _super53.call(this);\n    _this88.reflector = reflector;\n    _this88._evalArgNames = [];\n    _this88._evalArgValues = [];\n    _this88._evalExportedVars = [];\n    return _this88;\n  }\n\n  _createClass(JitEmitterVisitor, [{\n    key: \"createReturnStmt\",\n    value: function createReturnStmt(ctx) {\n      var stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(function (resultVar) {\n        return new LiteralMapEntry(resultVar, variable(resultVar), false);\n      })));\n      stmt.visitStatement(this, ctx);\n    }\n  }, {\n    key: \"getArgs\",\n    value: function getArgs() {\n      var result = {};\n\n      for (var i = 0; i < this._evalArgNames.length; i++) {\n        result[this._evalArgNames[i]] = this._evalArgValues[i];\n      }\n\n      return result;\n    }\n  }, {\n    key: \"visitExternalExpr\",\n    value: function visitExternalExpr(ast, ctx) {\n      this._emitReferenceToExternal(ast, this.reflector.resolveExternalReference(ast.value), ctx);\n\n      return null;\n    }\n  }, {\n    key: \"visitWrappedNodeExpr\",\n    value: function visitWrappedNodeExpr(ast, ctx) {\n      this._emitReferenceToExternal(ast, ast.node, ctx);\n\n      return null;\n    }\n  }, {\n    key: \"visitDeclareVarStmt\",\n    value: function visitDeclareVarStmt(stmt, ctx) {\n      if (stmt.hasModifier(StmtModifier.Exported)) {\n        this._evalExportedVars.push(stmt.name);\n      }\n\n      return _get(_getPrototypeOf(JitEmitterVisitor.prototype), \"visitDeclareVarStmt\", this).call(this, stmt, ctx);\n    }\n  }, {\n    key: \"visitDeclareFunctionStmt\",\n    value: function visitDeclareFunctionStmt(stmt, ctx) {\n      if (stmt.hasModifier(StmtModifier.Exported)) {\n        this._evalExportedVars.push(stmt.name);\n      }\n\n      return _get(_getPrototypeOf(JitEmitterVisitor.prototype), \"visitDeclareFunctionStmt\", this).call(this, stmt, ctx);\n    }\n  }, {\n    key: \"visitDeclareClassStmt\",\n    value: function visitDeclareClassStmt(stmt, ctx) {\n      if (stmt.hasModifier(StmtModifier.Exported)) {\n        this._evalExportedVars.push(stmt.name);\n      }\n\n      return _get(_getPrototypeOf(JitEmitterVisitor.prototype), \"visitDeclareClassStmt\", this).call(this, stmt, ctx);\n    }\n  }, {\n    key: \"_emitReferenceToExternal\",\n    value: function _emitReferenceToExternal(ast, value, ctx) {\n      var id = this._evalArgValues.indexOf(value);\n\n      if (id === -1) {\n        id = this._evalArgValues.length;\n\n        this._evalArgValues.push(value);\n\n        var name = identifierName({\n          reference: value\n        }) || 'val';\n\n        this._evalArgNames.push(\"jit_\".concat(name, \"_\").concat(id));\n      }\n\n      ctx.print(ast, this._evalArgNames[id]);\n    }\n  }]);\n\n  return JitEmitterVisitor;\n}(AbstractJsEmitterVisitor);\n\nfunction isUseStrictStatement(statement) {\n  return statement.isEquivalent(literal('use strict').toStmt());\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar $EOF = 0;\nvar $BSPACE = 8;\nvar $TAB = 9;\nvar $LF = 10;\nvar $VTAB = 11;\nvar $FF = 12;\nvar $CR = 13;\nvar $SPACE = 32;\nvar $BANG = 33;\nvar $DQ = 34;\nvar $HASH = 35;\nvar $$ = 36;\nvar $PERCENT = 37;\nvar $AMPERSAND = 38;\nvar $SQ = 39;\nvar $LPAREN = 40;\nvar $RPAREN = 41;\nvar $STAR = 42;\nvar $PLUS = 43;\nvar $COMMA = 44;\nvar $MINUS = 45;\nvar $PERIOD = 46;\nvar $SLASH = 47;\nvar $COLON = 58;\nvar $SEMICOLON = 59;\nvar $LT = 60;\nvar $EQ = 61;\nvar $GT = 62;\nvar $QUESTION = 63;\nvar $0 = 48;\nvar $7 = 55;\nvar $9 = 57;\nvar $A = 65;\nvar $E = 69;\nvar $F = 70;\nvar $X = 88;\nvar $Z = 90;\nvar $LBRACKET = 91;\nvar $BACKSLASH = 92;\nvar $RBRACKET = 93;\nvar $CARET = 94;\nvar $_ = 95;\nvar $a = 97;\nvar $b = 98;\nvar $e = 101;\nvar $f = 102;\nvar $n = 110;\nvar $r = 114;\nvar $t = 116;\nvar $u = 117;\nvar $v = 118;\nvar $x = 120;\nvar $z = 122;\nvar $LBRACE = 123;\nvar $BAR = 124;\nvar $RBRACE = 125;\nvar $NBSP = 160;\nvar $PIPE = 124;\nvar $TILDA = 126;\nvar $AT = 64;\nvar $BT = 96;\n\nfunction isWhitespace(code) {\n  return code >= $TAB && code <= $SPACE || code == $NBSP;\n}\n\nfunction isDigit(code) {\n  return $0 <= code && code <= $9;\n}\n\nfunction isAsciiLetter(code) {\n  return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\n\nfunction isAsciiHexDigit(code) {\n  return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\n\nfunction isNewLine(code) {\n  return code === $LF || code === $CR;\n}\n\nfunction isOctalDigit(code) {\n  return $0 <= code && code <= $7;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar ParseLocation = /*#__PURE__*/function () {\n  function ParseLocation(file, offset, line, col) {\n    _classCallCheck(this, ParseLocation);\n\n    this.file = file;\n    this.offset = offset;\n    this.line = line;\n    this.col = col;\n  }\n\n  _createClass(ParseLocation, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.offset != null ? \"\".concat(this.file.url, \"@\").concat(this.line, \":\").concat(this.col) : this.file.url;\n    }\n  }, {\n    key: \"moveBy\",\n    value: function moveBy(delta) {\n      var source = this.file.content;\n      var len = source.length;\n      var offset = this.offset;\n      var line = this.line;\n      var col = this.col;\n\n      while (offset > 0 && delta < 0) {\n        offset--;\n        delta++;\n        var ch = source.charCodeAt(offset);\n\n        if (ch == $LF) {\n          line--;\n          var priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));\n          col = priorLine > 0 ? offset - priorLine : offset;\n        } else {\n          col--;\n        }\n      }\n\n      while (offset < len && delta > 0) {\n        var _ch = source.charCodeAt(offset);\n\n        offset++;\n        delta--;\n\n        if (_ch == $LF) {\n          line++;\n          col = 0;\n        } else {\n          col++;\n        }\n      }\n\n      return new ParseLocation(this.file, offset, line, col);\n    } // Return the source around the location\n    // Up to `maxChars` or `maxLines` on each side of the location\n\n  }, {\n    key: \"getContext\",\n    value: function getContext(maxChars, maxLines) {\n      var content = this.file.content;\n      var startOffset = this.offset;\n\n      if (startOffset != null) {\n        if (startOffset > content.length - 1) {\n          startOffset = content.length - 1;\n        }\n\n        var endOffset = startOffset;\n        var ctxChars = 0;\n        var ctxLines = 0;\n\n        while (ctxChars < maxChars && startOffset > 0) {\n          startOffset--;\n          ctxChars++;\n\n          if (content[startOffset] == '\\n') {\n            if (++ctxLines == maxLines) {\n              break;\n            }\n          }\n        }\n\n        ctxChars = 0;\n        ctxLines = 0;\n\n        while (ctxChars < maxChars && endOffset < content.length - 1) {\n          endOffset++;\n          ctxChars++;\n\n          if (content[endOffset] == '\\n') {\n            if (++ctxLines == maxLines) {\n              break;\n            }\n          }\n        }\n\n        return {\n          before: content.substring(startOffset, this.offset),\n          after: content.substring(this.offset, endOffset + 1)\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return ParseLocation;\n}();\n\nvar ParseSourceFile = function ParseSourceFile(content, url) {\n  _classCallCheck(this, ParseSourceFile);\n\n  this.content = content;\n  this.url = url;\n};\n\nvar ParseSourceSpan = /*#__PURE__*/function () {\n  /**\r\n   * Create an object that holds information about spans of tokens/nodes captured during\r\n   * lexing/parsing of text.\r\n   *\r\n   * @param start\r\n   * The location of the start of the span (having skipped leading trivia).\r\n   * Skipping leading trivia makes source-spans more \"user friendly\", since things like HTML\r\n   * elements will appear to begin at the start of the opening tag, rather than at the start of any\r\n   * leading trivia, which could include newlines.\r\n   *\r\n   * @param end\r\n   * The location of the end of the span.\r\n   *\r\n   * @param fullStart\r\n   * The start of the token without skipping the leading trivia.\r\n   * This is used by tooling that splits tokens further, such as extracting Angular interpolations\r\n   * from text tokens. Such tooling creates new source-spans relative to the original token's\r\n   * source-span. If leading trivia characters have been skipped then the new source-spans may be\r\n   * incorrectly offset.\r\n   *\r\n   * @param details\r\n   * Additional information (such as identifier names) that should be associated with the span.\r\n   */\n  function ParseSourceSpan(start, end) {\n    var fullStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : start;\n    var details = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    _classCallCheck(this, ParseSourceSpan);\n\n    this.start = start;\n    this.end = end;\n    this.fullStart = fullStart;\n    this.details = details;\n  }\n\n  _createClass(ParseSourceSpan, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.start.file.content.substring(this.start.offset, this.end.offset);\n    }\n  }]);\n\n  return ParseSourceSpan;\n}();\n\nvar ParseErrorLevel;\n\n(function (ParseErrorLevel) {\n  ParseErrorLevel[ParseErrorLevel[\"WARNING\"] = 0] = \"WARNING\";\n  ParseErrorLevel[ParseErrorLevel[\"ERROR\"] = 1] = \"ERROR\";\n})(ParseErrorLevel || (ParseErrorLevel = {}));\n\nvar ParseError = /*#__PURE__*/function () {\n  function ParseError(span, msg) {\n    var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ParseErrorLevel.ERROR;\n\n    _classCallCheck(this, ParseError);\n\n    this.span = span;\n    this.msg = msg;\n    this.level = level;\n  }\n\n  _createClass(ParseError, [{\n    key: \"contextualMessage\",\n    value: function contextualMessage() {\n      var ctx = this.span.start.getContext(100, 3);\n      return ctx ? \"\".concat(this.msg, \" (\\\"\").concat(ctx.before, \"[\").concat(ParseErrorLevel[this.level], \" ->]\").concat(ctx.after, \"\\\")\") : this.msg;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var details = this.span.details ? \", \".concat(this.span.details) : '';\n      return \"\".concat(this.contextualMessage(), \": \").concat(this.span.start).concat(details);\n    }\n  }]);\n\n  return ParseError;\n}();\n\nfunction typeSourceSpan(kind, type) {\n  var moduleUrl = identifierModuleUrl(type);\n  var sourceFileName = moduleUrl != null ? \"in \".concat(kind, \" \").concat(identifierName(type), \" in \").concat(moduleUrl) : \"in \".concat(kind, \" \").concat(identifierName(type));\n  var sourceFile = new ParseSourceFile('', sourceFileName);\n  return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n/**\r\n * Generates Source Span object for a given R3 Type for JIT mode.\r\n *\r\n * @param kind Component or Directive.\r\n * @param typeName name of the Component or Directive.\r\n * @param sourceUrl reference to Component or Directive source.\r\n * @returns instance of ParseSourceSpan that represent a given Component or Directive.\r\n */\n\n\nfunction r3JitTypeSourceSpan(kind, typeName, sourceUrl) {\n  var sourceFileName = \"in \".concat(kind, \" \").concat(typeName, \" in \").concat(sourceUrl);\n  var sourceFile = new ParseSourceFile('', sourceFileName);\n  return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nfunction _compileInjector(meta) {\n  var definitionMap = new DefinitionMap();\n\n  if (meta.providers !== null) {\n    definitionMap.set('providers', meta.providers);\n  }\n\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', literalArr(meta.imports));\n  }\n\n  var expression = importExpr(Identifiers.defineInjector).callFn([definitionMap.toLiteralMap()], undefined, true);\n  var type = createInjectorType(meta);\n  return {\n    expression: expression,\n    type: type,\n    statements: []\n  };\n}\n\nfunction createInjectorType(meta) {\n  return new ExpressionType(importExpr(Identifiers.InjectorDeclaration, [new ExpressionType(meta.type.type)]));\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Implementation of `CompileReflector` which resolves references to @angular/core\r\n * symbols at runtime, according to a consumer-provided mapping.\r\n *\r\n * Only supports `resolveExternalReference`, all other methods throw.\r\n */\n\n\nvar R3JitReflector = /*#__PURE__*/function () {\n  function R3JitReflector(context) {\n    _classCallCheck(this, R3JitReflector);\n\n    this.context = context;\n  }\n\n  _createClass(R3JitReflector, [{\n    key: \"resolveExternalReference\",\n    value: function resolveExternalReference(ref) {\n      // This reflector only handles @angular/core imports.\n      if (ref.moduleName !== '@angular/core') {\n        throw new Error(\"Cannot resolve external reference to \".concat(ref.moduleName, \", only references to @angular/core are supported.\"));\n      }\n\n      if (!this.context.hasOwnProperty(ref.name)) {\n        throw new Error(\"No value provided for @angular/core symbol '\".concat(ref.name, \"'.\"));\n      }\n\n      return this.context[ref.name];\n    }\n  }, {\n    key: \"parameters\",\n    value: function parameters(typeOrFunc) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"annotations\",\n    value: function annotations(typeOrFunc) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"shallowAnnotations\",\n    value: function shallowAnnotations(typeOrFunc) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"tryAnnotations\",\n    value: function tryAnnotations(typeOrFunc) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"propMetadata\",\n    value: function propMetadata(typeOrFunc) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"hasLifecycleHook\",\n    value: function hasLifecycleHook(type, lcProperty) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"guards\",\n    value: function guards(typeOrFunc) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"componentModuleUrl\",\n    value: function componentModuleUrl(type, cmpMetadata) {\n      throw new Error('Not implemented.');\n    }\n  }]);\n\n  return R3JitReflector;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\r\n */\n\n\nfunction _compileNgModule(meta) {\n  var internalType = meta.internalType,\n      bootstrap = meta.bootstrap,\n      declarations = meta.declarations,\n      imports = meta.imports,\n      exports = meta.exports,\n      schemas = meta.schemas,\n      containsForwardDecls = meta.containsForwardDecls,\n      emitInline = meta.emitInline,\n      id = meta.id;\n  var statements = [];\n  var definitionMap = new DefinitionMap();\n  definitionMap.set('type', internalType);\n\n  if (bootstrap.length > 0) {\n    definitionMap.set('bootstrap', refsToArray(bootstrap, containsForwardDecls));\n  } // If requested to emit scope information inline, pass the `declarations`, `imports` and `exports`\n  // to the `ɵɵdefineNgModule()` call. The JIT compilation uses this.\n\n\n  if (emitInline) {\n    if (declarations.length > 0) {\n      definitionMap.set('declarations', refsToArray(declarations, containsForwardDecls));\n    }\n\n    if (imports.length > 0) {\n      definitionMap.set('imports', refsToArray(imports, containsForwardDecls));\n    }\n\n    if (exports.length > 0) {\n      definitionMap.set('exports', refsToArray(exports, containsForwardDecls));\n    }\n  } // If not emitting inline, the scope information is not passed into `ɵɵdefineNgModule` as it would\n  // prevent tree-shaking of the declarations, imports and exports references.\n  else {\n      var setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n\n      if (setNgModuleScopeCall !== null) {\n        statements.push(setNgModuleScopeCall);\n      }\n    }\n\n  if (schemas !== null && schemas.length > 0) {\n    definitionMap.set('schemas', literalArr(schemas.map(function (ref) {\n      return ref.value;\n    })));\n  }\n\n  if (id !== null) {\n    definitionMap.set('id', id);\n  }\n\n  var expression = importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()], undefined, true);\n  var type = createNgModuleType(meta);\n  return {\n    expression: expression,\n    type: type,\n    statements: statements\n  };\n}\n/**\r\n * This function is used in JIT mode to generate the call to `ɵɵdefineNgModule()` from a call to\r\n * `ɵɵngDeclareNgModule()`.\r\n */\n\n\nfunction compileNgModuleDeclarationExpression(meta) {\n  var definitionMap = new DefinitionMap();\n  definitionMap.set('type', new WrappedNodeExpr(meta.type));\n\n  if (meta.bootstrap !== undefined) {\n    definitionMap.set('bootstrap', new WrappedNodeExpr(meta.bootstrap));\n  }\n\n  if (meta.declarations !== undefined) {\n    definitionMap.set('declarations', new WrappedNodeExpr(meta.declarations));\n  }\n\n  if (meta.imports !== undefined) {\n    definitionMap.set('imports', new WrappedNodeExpr(meta.imports));\n  }\n\n  if (meta.exports !== undefined) {\n    definitionMap.set('exports', new WrappedNodeExpr(meta.exports));\n  }\n\n  if (meta.schemas !== undefined) {\n    definitionMap.set('schemas', new WrappedNodeExpr(meta.schemas));\n  }\n\n  if (meta.id !== undefined) {\n    definitionMap.set('id', new WrappedNodeExpr(meta.id));\n  }\n\n  return importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()]);\n}\n\nfunction createNgModuleType(_ref11) {\n  var moduleType = _ref11.type,\n      declarations = _ref11.declarations,\n      imports = _ref11.imports,\n      exports = _ref11.exports;\n  return new ExpressionType(importExpr(Identifiers.NgModuleDeclaration, [new ExpressionType(moduleType.type), tupleTypeOf(declarations), tupleTypeOf(imports), tupleTypeOf(exports)]));\n}\n/**\r\n * Generates a function call to `ɵɵsetNgModuleScope` with all necessary information so that the\r\n * transitive module scope can be computed during runtime in JIT mode. This call is marked pure\r\n * such that the references to declarations, imports and exports may be elided causing these\r\n * symbols to become tree-shakeable.\r\n */\n\n\nfunction generateSetNgModuleScopeCall(meta) {\n  var moduleType = meta.adjacentType,\n      declarations = meta.declarations,\n      imports = meta.imports,\n      exports = meta.exports,\n      containsForwardDecls = meta.containsForwardDecls;\n  var scopeMap = new DefinitionMap();\n\n  if (declarations.length > 0) {\n    scopeMap.set('declarations', refsToArray(declarations, containsForwardDecls));\n  }\n\n  if (imports.length > 0) {\n    scopeMap.set('imports', refsToArray(imports, containsForwardDecls));\n  }\n\n  if (exports.length > 0) {\n    scopeMap.set('exports', refsToArray(exports, containsForwardDecls));\n  }\n\n  if (Object.keys(scopeMap.values).length === 0) {\n    return null;\n  } // setNgModuleScope(...)\n\n\n  var fnCall = new InvokeFunctionExpr(\n  /* fn */\n  importExpr(Identifiers.setNgModuleScope),\n  /* args */\n  [moduleType, scopeMap.toLiteralMap()]); // (ngJitMode guard) && setNgModuleScope(...)\n\n  var guardedCall = jitOnlyGuardedExpression(fnCall); // function() { (ngJitMode guard) && setNgModuleScope(...); }\n\n  var iife = new FunctionExpr(\n  /* params */\n  [],\n  /* statements */\n  [guardedCall.toStmt()]); // (function() { (ngJitMode guard) && setNgModuleScope(...); })()\n\n  var iifeCall = new InvokeFunctionExpr(\n  /* fn */\n  iife,\n  /* args */\n  []);\n  return iifeCall.toStmt();\n}\n\nfunction tupleTypeOf(exp) {\n  var types = exp.map(function (ref) {\n    return typeofExpr(ref.type);\n  });\n  return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nfunction compilePipeFromMetadata(metadata) {\n  var definitionMapValues = []; // e.g. `name: 'myPipe'`\n\n  definitionMapValues.push({\n    key: 'name',\n    value: literal(metadata.pipeName),\n    quoted: false\n  }); // e.g. `type: MyPipe`\n\n  definitionMapValues.push({\n    key: 'type',\n    value: metadata.type.value,\n    quoted: false\n  }); // e.g. `pure: true`\n\n  definitionMapValues.push({\n    key: 'pure',\n    value: literal(metadata.pure),\n    quoted: false\n  });\n  var expression = importExpr(Identifiers.definePipe).callFn([literalMap(definitionMapValues)], undefined, true);\n  var type = createPipeType(metadata);\n  return {\n    expression: expression,\n    type: type,\n    statements: []\n  };\n}\n\nfunction createPipeType(metadata) {\n  return new ExpressionType(importExpr(Identifiers.PipeDeclaration, [typeWithParameters(metadata.type.type, metadata.typeArgumentCount), new ExpressionType(new LiteralExpr(metadata.pipeName))]));\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar ParserError = function ParserError(message, input, errLocation, ctxLocation) {\n  _classCallCheck(this, ParserError);\n\n  this.input = input;\n  this.errLocation = errLocation;\n  this.ctxLocation = ctxLocation;\n  this.message = \"Parser Error: \".concat(message, \" \").concat(errLocation, \" [\").concat(input, \"] in \").concat(ctxLocation);\n};\n\nvar ParseSpan = /*#__PURE__*/function () {\n  function ParseSpan(start, end) {\n    _classCallCheck(this, ParseSpan);\n\n    this.start = start;\n    this.end = end;\n  }\n\n  _createClass(ParseSpan, [{\n    key: \"toAbsolute\",\n    value: function toAbsolute(absoluteOffset) {\n      return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\n    }\n  }]);\n\n  return ParseSpan;\n}();\n\nvar AST = /*#__PURE__*/function () {\n  function AST(span,\n  /**\r\n   * Absolute location of the expression AST in a source code file.\r\n   */\n  sourceSpan) {\n    _classCallCheck(this, AST);\n\n    this.span = span;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(AST, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return null;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return 'AST';\n    }\n  }]);\n\n  return AST;\n}();\n\nvar ASTWithName = /*#__PURE__*/function (_AST) {\n  _inherits(ASTWithName, _AST);\n\n  var _super54 = _createSuper(ASTWithName);\n\n  function ASTWithName(span, sourceSpan, nameSpan) {\n    var _this89;\n\n    _classCallCheck(this, ASTWithName);\n\n    _this89 = _super54.call(this, span, sourceSpan);\n    _this89.nameSpan = nameSpan;\n    return _this89;\n  }\n\n  return ASTWithName;\n}(AST);\n/**\r\n * Represents a quoted expression of the form:\r\n *\r\n * quote = prefix `:` uninterpretedExpression\r\n * prefix = identifier\r\n * uninterpretedExpression = arbitrary string\r\n *\r\n * A quoted expression is meant to be pre-processed by an AST transformer that\r\n * converts it into another AST that no longer contains quoted expressions.\r\n * It is meant to allow third-party developers to extend Angular template\r\n * expression language. The `uninterpretedExpression` part of the quote is\r\n * therefore not interpreted by the Angular's own expression parser.\r\n */\n\n\nvar Quote = /*#__PURE__*/function (_AST2) {\n  _inherits(Quote, _AST2);\n\n  var _super55 = _createSuper(Quote);\n\n  function Quote(span, sourceSpan, prefix, uninterpretedExpression, location) {\n    var _this90;\n\n    _classCallCheck(this, Quote);\n\n    _this90 = _super55.call(this, span, sourceSpan);\n    _this90.prefix = prefix;\n    _this90.uninterpretedExpression = uninterpretedExpression;\n    _this90.location = location;\n    return _this90;\n  }\n\n  _createClass(Quote, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitQuote(this, context);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return 'Quote';\n    }\n  }]);\n\n  return Quote;\n}(AST);\n\nvar EmptyExpr = /*#__PURE__*/function (_AST3) {\n  _inherits(EmptyExpr, _AST3);\n\n  var _super56 = _createSuper(EmptyExpr);\n\n  function EmptyExpr() {\n    _classCallCheck(this, EmptyExpr);\n\n    return _super56.apply(this, arguments);\n  }\n\n  _createClass(EmptyExpr, [{\n    key: \"visit\",\n    value: function visit(visitor) {// do nothing\n\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    }\n  }]);\n\n  return EmptyExpr;\n}(AST);\n\nvar ImplicitReceiver = /*#__PURE__*/function (_AST4) {\n  _inherits(ImplicitReceiver, _AST4);\n\n  var _super57 = _createSuper(ImplicitReceiver);\n\n  function ImplicitReceiver() {\n    _classCallCheck(this, ImplicitReceiver);\n\n    return _super57.apply(this, arguments);\n  }\n\n  _createClass(ImplicitReceiver, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitImplicitReceiver(this, context);\n    }\n  }]);\n\n  return ImplicitReceiver;\n}(AST);\n/**\r\n * Receiver when something is accessed through `this` (e.g. `this.foo`). Note that this class\r\n * inherits from `ImplicitReceiver`, because accessing something through `this` is treated the\r\n * same as accessing it implicitly inside of an Angular template (e.g. `[attr.title]=\"this.title\"`\r\n * is the same as `[attr.title]=\"title\"`.). Inheriting allows for the `this` accesses to be treated\r\n * the same as implicit ones, except for a couple of exceptions like `$event` and `$any`.\r\n * TODO: we should find a way for this class not to extend from `ImplicitReceiver` in the future.\r\n */\n\n\nvar ThisReceiver = /*#__PURE__*/function (_ImplicitReceiver) {\n  _inherits(ThisReceiver, _ImplicitReceiver);\n\n  var _super58 = _createSuper(ThisReceiver);\n\n  function ThisReceiver() {\n    _classCallCheck(this, ThisReceiver);\n\n    return _super58.apply(this, arguments);\n  }\n\n  _createClass(ThisReceiver, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      var _a;\n\n      return (_a = visitor.visitThisReceiver) === null || _a === void 0 ? void 0 : _a.call(visitor, this, context);\n    }\n  }]);\n\n  return ThisReceiver;\n}(ImplicitReceiver);\n/**\r\n * Multiple expressions separated by a semicolon.\r\n */\n\n\nvar Chain = /*#__PURE__*/function (_AST5) {\n  _inherits(Chain, _AST5);\n\n  var _super59 = _createSuper(Chain);\n\n  function Chain(span, sourceSpan, expressions) {\n    var _this91;\n\n    _classCallCheck(this, Chain);\n\n    _this91 = _super59.call(this, span, sourceSpan);\n    _this91.expressions = expressions;\n    return _this91;\n  }\n\n  _createClass(Chain, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitChain(this, context);\n    }\n  }]);\n\n  return Chain;\n}(AST);\n\nvar Conditional = /*#__PURE__*/function (_AST6) {\n  _inherits(Conditional, _AST6);\n\n  var _super60 = _createSuper(Conditional);\n\n  function Conditional(span, sourceSpan, condition, trueExp, falseExp) {\n    var _this92;\n\n    _classCallCheck(this, Conditional);\n\n    _this92 = _super60.call(this, span, sourceSpan);\n    _this92.condition = condition;\n    _this92.trueExp = trueExp;\n    _this92.falseExp = falseExp;\n    return _this92;\n  }\n\n  _createClass(Conditional, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitConditional(this, context);\n    }\n  }]);\n\n  return Conditional;\n}(AST);\n\nvar PropertyRead = /*#__PURE__*/function (_ASTWithName) {\n  _inherits(PropertyRead, _ASTWithName);\n\n  var _super61 = _createSuper(PropertyRead);\n\n  function PropertyRead(span, sourceSpan, nameSpan, receiver, name) {\n    var _this93;\n\n    _classCallCheck(this, PropertyRead);\n\n    _this93 = _super61.call(this, span, sourceSpan, nameSpan);\n    _this93.receiver = receiver;\n    _this93.name = name;\n    return _this93;\n  }\n\n  _createClass(PropertyRead, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitPropertyRead(this, context);\n    }\n  }]);\n\n  return PropertyRead;\n}(ASTWithName);\n\nvar PropertyWrite = /*#__PURE__*/function (_ASTWithName2) {\n  _inherits(PropertyWrite, _ASTWithName2);\n\n  var _super62 = _createSuper(PropertyWrite);\n\n  function PropertyWrite(span, sourceSpan, nameSpan, receiver, name, value) {\n    var _this94;\n\n    _classCallCheck(this, PropertyWrite);\n\n    _this94 = _super62.call(this, span, sourceSpan, nameSpan);\n    _this94.receiver = receiver;\n    _this94.name = name;\n    _this94.value = value;\n    return _this94;\n  }\n\n  _createClass(PropertyWrite, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitPropertyWrite(this, context);\n    }\n  }]);\n\n  return PropertyWrite;\n}(ASTWithName);\n\nvar SafePropertyRead = /*#__PURE__*/function (_ASTWithName3) {\n  _inherits(SafePropertyRead, _ASTWithName3);\n\n  var _super63 = _createSuper(SafePropertyRead);\n\n  function SafePropertyRead(span, sourceSpan, nameSpan, receiver, name) {\n    var _this95;\n\n    _classCallCheck(this, SafePropertyRead);\n\n    _this95 = _super63.call(this, span, sourceSpan, nameSpan);\n    _this95.receiver = receiver;\n    _this95.name = name;\n    return _this95;\n  }\n\n  _createClass(SafePropertyRead, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitSafePropertyRead(this, context);\n    }\n  }]);\n\n  return SafePropertyRead;\n}(ASTWithName);\n\nvar KeyedRead = /*#__PURE__*/function (_AST7) {\n  _inherits(KeyedRead, _AST7);\n\n  var _super64 = _createSuper(KeyedRead);\n\n  function KeyedRead(span, sourceSpan, receiver, key) {\n    var _this96;\n\n    _classCallCheck(this, KeyedRead);\n\n    _this96 = _super64.call(this, span, sourceSpan);\n    _this96.receiver = receiver;\n    _this96.key = key;\n    return _this96;\n  }\n\n  _createClass(KeyedRead, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitKeyedRead(this, context);\n    }\n  }]);\n\n  return KeyedRead;\n}(AST);\n\nvar SafeKeyedRead = /*#__PURE__*/function (_AST8) {\n  _inherits(SafeKeyedRead, _AST8);\n\n  var _super65 = _createSuper(SafeKeyedRead);\n\n  function SafeKeyedRead(span, sourceSpan, receiver, key) {\n    var _this97;\n\n    _classCallCheck(this, SafeKeyedRead);\n\n    _this97 = _super65.call(this, span, sourceSpan);\n    _this97.receiver = receiver;\n    _this97.key = key;\n    return _this97;\n  }\n\n  _createClass(SafeKeyedRead, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitSafeKeyedRead(this, context);\n    }\n  }]);\n\n  return SafeKeyedRead;\n}(AST);\n\nvar KeyedWrite = /*#__PURE__*/function (_AST9) {\n  _inherits(KeyedWrite, _AST9);\n\n  var _super66 = _createSuper(KeyedWrite);\n\n  function KeyedWrite(span, sourceSpan, receiver, key, value) {\n    var _this98;\n\n    _classCallCheck(this, KeyedWrite);\n\n    _this98 = _super66.call(this, span, sourceSpan);\n    _this98.receiver = receiver;\n    _this98.key = key;\n    _this98.value = value;\n    return _this98;\n  }\n\n  _createClass(KeyedWrite, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitKeyedWrite(this, context);\n    }\n  }]);\n\n  return KeyedWrite;\n}(AST);\n\nvar BindingPipe = /*#__PURE__*/function (_ASTWithName4) {\n  _inherits(BindingPipe, _ASTWithName4);\n\n  var _super67 = _createSuper(BindingPipe);\n\n  function BindingPipe(span, sourceSpan, exp, name, args, nameSpan) {\n    var _this99;\n\n    _classCallCheck(this, BindingPipe);\n\n    _this99 = _super67.call(this, span, sourceSpan, nameSpan);\n    _this99.exp = exp;\n    _this99.name = name;\n    _this99.args = args;\n    return _this99;\n  }\n\n  _createClass(BindingPipe, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitPipe(this, context);\n    }\n  }]);\n\n  return BindingPipe;\n}(ASTWithName);\n\nvar LiteralPrimitive = /*#__PURE__*/function (_AST10) {\n  _inherits(LiteralPrimitive, _AST10);\n\n  var _super68 = _createSuper(LiteralPrimitive);\n\n  function LiteralPrimitive(span, sourceSpan, value) {\n    var _this100;\n\n    _classCallCheck(this, LiteralPrimitive);\n\n    _this100 = _super68.call(this, span, sourceSpan);\n    _this100.value = value;\n    return _this100;\n  }\n\n  _createClass(LiteralPrimitive, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitLiteralPrimitive(this, context);\n    }\n  }]);\n\n  return LiteralPrimitive;\n}(AST);\n\nvar LiteralArray = /*#__PURE__*/function (_AST11) {\n  _inherits(LiteralArray, _AST11);\n\n  var _super69 = _createSuper(LiteralArray);\n\n  function LiteralArray(span, sourceSpan, expressions) {\n    var _this101;\n\n    _classCallCheck(this, LiteralArray);\n\n    _this101 = _super69.call(this, span, sourceSpan);\n    _this101.expressions = expressions;\n    return _this101;\n  }\n\n  _createClass(LiteralArray, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitLiteralArray(this, context);\n    }\n  }]);\n\n  return LiteralArray;\n}(AST);\n\nvar LiteralMap = /*#__PURE__*/function (_AST12) {\n  _inherits(LiteralMap, _AST12);\n\n  var _super70 = _createSuper(LiteralMap);\n\n  function LiteralMap(span, sourceSpan, keys, values) {\n    var _this102;\n\n    _classCallCheck(this, LiteralMap);\n\n    _this102 = _super70.call(this, span, sourceSpan);\n    _this102.keys = keys;\n    _this102.values = values;\n    return _this102;\n  }\n\n  _createClass(LiteralMap, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitLiteralMap(this, context);\n    }\n  }]);\n\n  return LiteralMap;\n}(AST);\n\nvar Interpolation = /*#__PURE__*/function (_AST13) {\n  _inherits(Interpolation, _AST13);\n\n  var _super71 = _createSuper(Interpolation);\n\n  function Interpolation(span, sourceSpan, strings, expressions) {\n    var _this103;\n\n    _classCallCheck(this, Interpolation);\n\n    _this103 = _super71.call(this, span, sourceSpan);\n    _this103.strings = strings;\n    _this103.expressions = expressions;\n    return _this103;\n  }\n\n  _createClass(Interpolation, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitInterpolation(this, context);\n    }\n  }]);\n\n  return Interpolation;\n}(AST);\n\nvar Binary = /*#__PURE__*/function (_AST14) {\n  _inherits(Binary, _AST14);\n\n  var _super72 = _createSuper(Binary);\n\n  function Binary(span, sourceSpan, operation, left, right) {\n    var _this104;\n\n    _classCallCheck(this, Binary);\n\n    _this104 = _super72.call(this, span, sourceSpan);\n    _this104.operation = operation;\n    _this104.left = left;\n    _this104.right = right;\n    return _this104;\n  }\n\n  _createClass(Binary, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitBinary(this, context);\n    }\n  }]);\n\n  return Binary;\n}(AST);\n/**\r\n * For backwards compatibility reasons, `Unary` inherits from `Binary` and mimics the binary AST\r\n * node that was originally used. This inheritance relation can be deleted in some future major,\r\n * after consumers have been given a chance to fully support Unary.\r\n */\n\n\nvar Unary = /*#__PURE__*/function (_Binary) {\n  _inherits(Unary, _Binary);\n\n  var _super73 = _createSuper(Unary);\n\n  /**\r\n   * During the deprecation period this constructor is private, to avoid consumers from creating\r\n   * a `Unary` with the fallback properties for `Binary`.\r\n   */\n  function Unary(span, sourceSpan, operator, expr, binaryOp, binaryLeft, binaryRight) {\n    var _this105;\n\n    _classCallCheck(this, Unary);\n\n    _this105 = _super73.call(this, span, sourceSpan, binaryOp, binaryLeft, binaryRight);\n    _this105.operator = operator;\n    _this105.expr = expr;\n    return _this105;\n  }\n  /**\r\n   * Creates a unary minus expression \"-x\", represented as `Binary` using \"0 - x\".\r\n   */\n\n\n  _createClass(Unary, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (visitor.visitUnary !== undefined) {\n        return visitor.visitUnary(this, context);\n      }\n\n      return visitor.visitBinary(this, context);\n    }\n  }], [{\n    key: \"createMinus\",\n    value: function createMinus(span, sourceSpan, expr) {\n      return new Unary(span, sourceSpan, '-', expr, '-', new LiteralPrimitive(span, sourceSpan, 0), expr);\n    }\n    /**\r\n     * Creates a unary plus expression \"+x\", represented as `Binary` using \"x - 0\".\r\n     */\n\n  }, {\n    key: \"createPlus\",\n    value: function createPlus(span, sourceSpan, expr) {\n      return new Unary(span, sourceSpan, '+', expr, '-', expr, new LiteralPrimitive(span, sourceSpan, 0));\n    }\n  }]);\n\n  return Unary;\n}(Binary);\n\nvar PrefixNot = /*#__PURE__*/function (_AST15) {\n  _inherits(PrefixNot, _AST15);\n\n  var _super74 = _createSuper(PrefixNot);\n\n  function PrefixNot(span, sourceSpan, expression) {\n    var _this106;\n\n    _classCallCheck(this, PrefixNot);\n\n    _this106 = _super74.call(this, span, sourceSpan);\n    _this106.expression = expression;\n    return _this106;\n  }\n\n  _createClass(PrefixNot, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitPrefixNot(this, context);\n    }\n  }]);\n\n  return PrefixNot;\n}(AST);\n\nvar NonNullAssert = /*#__PURE__*/function (_AST16) {\n  _inherits(NonNullAssert, _AST16);\n\n  var _super75 = _createSuper(NonNullAssert);\n\n  function NonNullAssert(span, sourceSpan, expression) {\n    var _this107;\n\n    _classCallCheck(this, NonNullAssert);\n\n    _this107 = _super75.call(this, span, sourceSpan);\n    _this107.expression = expression;\n    return _this107;\n  }\n\n  _createClass(NonNullAssert, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitNonNullAssert(this, context);\n    }\n  }]);\n\n  return NonNullAssert;\n}(AST);\n\nvar MethodCall = /*#__PURE__*/function (_ASTWithName5) {\n  _inherits(MethodCall, _ASTWithName5);\n\n  var _super76 = _createSuper(MethodCall);\n\n  function MethodCall(span, sourceSpan, nameSpan, receiver, name, args, argumentSpan) {\n    var _this108;\n\n    _classCallCheck(this, MethodCall);\n\n    _this108 = _super76.call(this, span, sourceSpan, nameSpan);\n    _this108.receiver = receiver;\n    _this108.name = name;\n    _this108.args = args;\n    _this108.argumentSpan = argumentSpan;\n    return _this108;\n  }\n\n  _createClass(MethodCall, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitMethodCall(this, context);\n    }\n  }]);\n\n  return MethodCall;\n}(ASTWithName);\n\nvar SafeMethodCall = /*#__PURE__*/function (_ASTWithName6) {\n  _inherits(SafeMethodCall, _ASTWithName6);\n\n  var _super77 = _createSuper(SafeMethodCall);\n\n  function SafeMethodCall(span, sourceSpan, nameSpan, receiver, name, args, argumentSpan) {\n    var _this109;\n\n    _classCallCheck(this, SafeMethodCall);\n\n    _this109 = _super77.call(this, span, sourceSpan, nameSpan);\n    _this109.receiver = receiver;\n    _this109.name = name;\n    _this109.args = args;\n    _this109.argumentSpan = argumentSpan;\n    return _this109;\n  }\n\n  _createClass(SafeMethodCall, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitSafeMethodCall(this, context);\n    }\n  }]);\n\n  return SafeMethodCall;\n}(ASTWithName);\n\nvar FunctionCall = /*#__PURE__*/function (_AST17) {\n  _inherits(FunctionCall, _AST17);\n\n  var _super78 = _createSuper(FunctionCall);\n\n  function FunctionCall(span, sourceSpan, target, args) {\n    var _this110;\n\n    _classCallCheck(this, FunctionCall);\n\n    _this110 = _super78.call(this, span, sourceSpan);\n    _this110.target = target;\n    _this110.args = args;\n    return _this110;\n  }\n\n  _createClass(FunctionCall, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitFunctionCall(this, context);\n    }\n  }]);\n\n  return FunctionCall;\n}(AST);\n/**\r\n * Records the absolute position of a text span in a source file, where `start` and `end` are the\r\n * starting and ending byte offsets, respectively, of the text span in a source file.\r\n */\n\n\nvar AbsoluteSourceSpan = function AbsoluteSourceSpan(start, end) {\n  _classCallCheck(this, AbsoluteSourceSpan);\n\n  this.start = start;\n  this.end = end;\n};\n\nvar ASTWithSource = /*#__PURE__*/function (_AST18) {\n  _inherits(ASTWithSource, _AST18);\n\n  var _super79 = _createSuper(ASTWithSource);\n\n  function ASTWithSource(ast, source, location, absoluteOffset, errors) {\n    var _this111;\n\n    _classCallCheck(this, ASTWithSource);\n\n    _this111 = _super79.call(this, new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));\n    _this111.ast = ast;\n    _this111.source = source;\n    _this111.location = location;\n    _this111.errors = errors;\n    return _this111;\n  }\n\n  _createClass(ASTWithSource, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (visitor.visitASTWithSource) {\n        return visitor.visitASTWithSource(this, context);\n      }\n\n      return this.ast.visit(visitor, context);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.source, \" in \").concat(this.location);\n    }\n  }]);\n\n  return ASTWithSource;\n}(AST);\n\nvar VariableBinding =\n/**\r\n * @param sourceSpan entire span of the binding.\r\n * @param key name of the LHS along with its span.\r\n * @param value optional value for the RHS along with its span.\r\n */\nfunction VariableBinding(sourceSpan, key, value) {\n  _classCallCheck(this, VariableBinding);\n\n  this.sourceSpan = sourceSpan;\n  this.key = key;\n  this.value = value;\n};\n\nvar ExpressionBinding =\n/**\r\n * @param sourceSpan entire span of the binding.\r\n * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its\r\n * span. Note that the length of the span may not be the same as\r\n * `key.source.length`. For example,\r\n * 1. key.source = ngFor, key.span is for \"ngFor\"\r\n * 2. key.source = ngForOf, key.span is for \"of\"\r\n * 3. key.source = ngForTrackBy, key.span is for \"trackBy\"\r\n * @param value optional expression for the RHS.\r\n */\nfunction ExpressionBinding(sourceSpan, key, value) {\n  _classCallCheck(this, ExpressionBinding);\n\n  this.sourceSpan = sourceSpan;\n  this.key = key;\n  this.value = value;\n};\n\nvar RecursiveAstVisitor$1 = /*#__PURE__*/function () {\n  function RecursiveAstVisitor$1() {\n    _classCallCheck(this, RecursiveAstVisitor$1);\n  }\n\n  _createClass(RecursiveAstVisitor$1, [{\n    key: \"visit\",\n    value: function visit(ast, context) {\n      // The default implementation just visits every node.\n      // Classes that extend RecursiveAstVisitor should override this function\n      // to selectively visit the specified node.\n      ast.visit(this, context);\n    }\n  }, {\n    key: \"visitUnary\",\n    value: function visitUnary(ast, context) {\n      this.visit(ast.expr, context);\n    }\n  }, {\n    key: \"visitBinary\",\n    value: function visitBinary(ast, context) {\n      this.visit(ast.left, context);\n      this.visit(ast.right, context);\n    }\n  }, {\n    key: \"visitChain\",\n    value: function visitChain(ast, context) {\n      this.visitAll(ast.expressions, context);\n    }\n  }, {\n    key: \"visitConditional\",\n    value: function visitConditional(ast, context) {\n      this.visit(ast.condition, context);\n      this.visit(ast.trueExp, context);\n      this.visit(ast.falseExp, context);\n    }\n  }, {\n    key: \"visitPipe\",\n    value: function visitPipe(ast, context) {\n      this.visit(ast.exp, context);\n      this.visitAll(ast.args, context);\n    }\n  }, {\n    key: \"visitFunctionCall\",\n    value: function visitFunctionCall(ast, context) {\n      if (ast.target) {\n        this.visit(ast.target, context);\n      }\n\n      this.visitAll(ast.args, context);\n    }\n  }, {\n    key: \"visitImplicitReceiver\",\n    value: function visitImplicitReceiver(ast, context) {}\n  }, {\n    key: \"visitThisReceiver\",\n    value: function visitThisReceiver(ast, context) {}\n  }, {\n    key: \"visitInterpolation\",\n    value: function visitInterpolation(ast, context) {\n      this.visitAll(ast.expressions, context);\n    }\n  }, {\n    key: \"visitKeyedRead\",\n    value: function visitKeyedRead(ast, context) {\n      this.visit(ast.receiver, context);\n      this.visit(ast.key, context);\n    }\n  }, {\n    key: \"visitKeyedWrite\",\n    value: function visitKeyedWrite(ast, context) {\n      this.visit(ast.receiver, context);\n      this.visit(ast.key, context);\n      this.visit(ast.value, context);\n    }\n  }, {\n    key: \"visitLiteralArray\",\n    value: function visitLiteralArray(ast, context) {\n      this.visitAll(ast.expressions, context);\n    }\n  }, {\n    key: \"visitLiteralMap\",\n    value: function visitLiteralMap(ast, context) {\n      this.visitAll(ast.values, context);\n    }\n  }, {\n    key: \"visitLiteralPrimitive\",\n    value: function visitLiteralPrimitive(ast, context) {}\n  }, {\n    key: \"visitMethodCall\",\n    value: function visitMethodCall(ast, context) {\n      this.visit(ast.receiver, context);\n      this.visitAll(ast.args, context);\n    }\n  }, {\n    key: \"visitPrefixNot\",\n    value: function visitPrefixNot(ast, context) {\n      this.visit(ast.expression, context);\n    }\n  }, {\n    key: \"visitNonNullAssert\",\n    value: function visitNonNullAssert(ast, context) {\n      this.visit(ast.expression, context);\n    }\n  }, {\n    key: \"visitPropertyRead\",\n    value: function visitPropertyRead(ast, context) {\n      this.visit(ast.receiver, context);\n    }\n  }, {\n    key: \"visitPropertyWrite\",\n    value: function visitPropertyWrite(ast, context) {\n      this.visit(ast.receiver, context);\n      this.visit(ast.value, context);\n    }\n  }, {\n    key: \"visitSafePropertyRead\",\n    value: function visitSafePropertyRead(ast, context) {\n      this.visit(ast.receiver, context);\n    }\n  }, {\n    key: \"visitSafeMethodCall\",\n    value: function visitSafeMethodCall(ast, context) {\n      this.visit(ast.receiver, context);\n      this.visitAll(ast.args, context);\n    }\n  }, {\n    key: \"visitSafeKeyedRead\",\n    value: function visitSafeKeyedRead(ast, context) {\n      this.visit(ast.receiver, context);\n      this.visit(ast.key, context);\n    }\n  }, {\n    key: \"visitQuote\",\n    value: function visitQuote(ast, context) {} // This is not part of the AstVisitor interface, just a helper method\n\n  }, {\n    key: \"visitAll\",\n    value: function visitAll(asts, context) {\n      var _iterator7 = _createForOfIteratorHelper(asts),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var ast = _step7.value;\n          this.visit(ast, context);\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  }]);\n\n  return RecursiveAstVisitor$1;\n}();\n\nvar AstTransformer$1 = /*#__PURE__*/function () {\n  function AstTransformer$1() {\n    _classCallCheck(this, AstTransformer$1);\n  }\n\n  _createClass(AstTransformer$1, [{\n    key: \"visitImplicitReceiver\",\n    value: function visitImplicitReceiver(ast, context) {\n      return ast;\n    }\n  }, {\n    key: \"visitThisReceiver\",\n    value: function visitThisReceiver(ast, context) {\n      return ast;\n    }\n  }, {\n    key: \"visitInterpolation\",\n    value: function visitInterpolation(ast, context) {\n      return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));\n    }\n  }, {\n    key: \"visitLiteralPrimitive\",\n    value: function visitLiteralPrimitive(ast, context) {\n      return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);\n    }\n  }, {\n    key: \"visitPropertyRead\",\n    value: function visitPropertyRead(ast, context) {\n      return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n    }\n  }, {\n    key: \"visitPropertyWrite\",\n    value: function visitPropertyWrite(ast, context) {\n      return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, ast.value.visit(this));\n    }\n  }, {\n    key: \"visitSafePropertyRead\",\n    value: function visitSafePropertyRead(ast, context) {\n      return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n    }\n  }, {\n    key: \"visitMethodCall\",\n    value: function visitMethodCall(ast, context) {\n      return new MethodCall(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args), ast.argumentSpan);\n    }\n  }, {\n    key: \"visitSafeMethodCall\",\n    value: function visitSafeMethodCall(ast, context) {\n      return new SafeMethodCall(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args), ast.argumentSpan);\n    }\n  }, {\n    key: \"visitFunctionCall\",\n    value: function visitFunctionCall(ast, context) {\n      return new FunctionCall(ast.span, ast.sourceSpan, ast.target.visit(this), this.visitAll(ast.args));\n    }\n  }, {\n    key: \"visitLiteralArray\",\n    value: function visitLiteralArray(ast, context) {\n      return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n    }\n  }, {\n    key: \"visitLiteralMap\",\n    value: function visitLiteralMap(ast, context) {\n      return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));\n    }\n  }, {\n    key: \"visitUnary\",\n    value: function visitUnary(ast, context) {\n      switch (ast.operator) {\n        case '+':\n          return Unary.createPlus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n\n        case '-':\n          return Unary.createMinus(ast.span, ast.sourceSpan, ast.expr.visit(this));\n\n        default:\n          throw new Error(\"Unknown unary operator \".concat(ast.operator));\n      }\n    }\n  }, {\n    key: \"visitBinary\",\n    value: function visitBinary(ast, context) {\n      return new Binary(ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));\n    }\n  }, {\n    key: \"visitPrefixNot\",\n    value: function visitPrefixNot(ast, context) {\n      return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));\n    }\n  }, {\n    key: \"visitNonNullAssert\",\n    value: function visitNonNullAssert(ast, context) {\n      return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));\n    }\n  }, {\n    key: \"visitConditional\",\n    value: function visitConditional(ast, context) {\n      return new Conditional(ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n    }\n  }, {\n    key: \"visitPipe\",\n    value: function visitPipe(ast, context) {\n      return new BindingPipe(ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args), ast.nameSpan);\n    }\n  }, {\n    key: \"visitKeyedRead\",\n    value: function visitKeyedRead(ast, context) {\n      return new KeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));\n    }\n  }, {\n    key: \"visitKeyedWrite\",\n    value: function visitKeyedWrite(ast, context) {\n      return new KeyedWrite(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this), ast.value.visit(this));\n    }\n  }, {\n    key: \"visitAll\",\n    value: function visitAll(asts) {\n      var res = [];\n\n      for (var i = 0; i < asts.length; ++i) {\n        res[i] = asts[i].visit(this);\n      }\n\n      return res;\n    }\n  }, {\n    key: \"visitChain\",\n    value: function visitChain(ast, context) {\n      return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n    }\n  }, {\n    key: \"visitQuote\",\n    value: function visitQuote(ast, context) {\n      return new Quote(ast.span, ast.sourceSpan, ast.prefix, ast.uninterpretedExpression, ast.location);\n    }\n  }, {\n    key: \"visitSafeKeyedRead\",\n    value: function visitSafeKeyedRead(ast, context) {\n      return new SafeKeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));\n    }\n  }]);\n\n  return AstTransformer$1;\n}(); // A transformer that only creates new nodes if the transformer makes a change or\n// a change is made a child node.\n\n\nvar AstMemoryEfficientTransformer = /*#__PURE__*/function () {\n  function AstMemoryEfficientTransformer() {\n    _classCallCheck(this, AstMemoryEfficientTransformer);\n  }\n\n  _createClass(AstMemoryEfficientTransformer, [{\n    key: \"visitImplicitReceiver\",\n    value: function visitImplicitReceiver(ast, context) {\n      return ast;\n    }\n  }, {\n    key: \"visitThisReceiver\",\n    value: function visitThisReceiver(ast, context) {\n      return ast;\n    }\n  }, {\n    key: \"visitInterpolation\",\n    value: function visitInterpolation(ast, context) {\n      var expressions = this.visitAll(ast.expressions);\n      if (expressions !== ast.expressions) return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);\n      return ast;\n    }\n  }, {\n    key: \"visitLiteralPrimitive\",\n    value: function visitLiteralPrimitive(ast, context) {\n      return ast;\n    }\n  }, {\n    key: \"visitPropertyRead\",\n    value: function visitPropertyRead(ast, context) {\n      var receiver = ast.receiver.visit(this);\n\n      if (receiver !== ast.receiver) {\n        return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitPropertyWrite\",\n    value: function visitPropertyWrite(ast, context) {\n      var receiver = ast.receiver.visit(this);\n      var value = ast.value.visit(this);\n\n      if (receiver !== ast.receiver || value !== ast.value) {\n        return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitSafePropertyRead\",\n    value: function visitSafePropertyRead(ast, context) {\n      var receiver = ast.receiver.visit(this);\n\n      if (receiver !== ast.receiver) {\n        return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitMethodCall\",\n    value: function visitMethodCall(ast, context) {\n      var receiver = ast.receiver.visit(this);\n      var args = this.visitAll(ast.args);\n\n      if (receiver !== ast.receiver || args !== ast.args) {\n        return new MethodCall(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args, ast.argumentSpan);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitSafeMethodCall\",\n    value: function visitSafeMethodCall(ast, context) {\n      var receiver = ast.receiver.visit(this);\n      var args = this.visitAll(ast.args);\n\n      if (receiver !== ast.receiver || args !== ast.args) {\n        return new SafeMethodCall(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args, ast.argumentSpan);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitFunctionCall\",\n    value: function visitFunctionCall(ast, context) {\n      var target = ast.target && ast.target.visit(this);\n      var args = this.visitAll(ast.args);\n\n      if (target !== ast.target || args !== ast.args) {\n        return new FunctionCall(ast.span, ast.sourceSpan, target, args);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitLiteralArray\",\n    value: function visitLiteralArray(ast, context) {\n      var expressions = this.visitAll(ast.expressions);\n\n      if (expressions !== ast.expressions) {\n        return new LiteralArray(ast.span, ast.sourceSpan, expressions);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitLiteralMap\",\n    value: function visitLiteralMap(ast, context) {\n      var values = this.visitAll(ast.values);\n\n      if (values !== ast.values) {\n        return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitUnary\",\n    value: function visitUnary(ast, context) {\n      var expr = ast.expr.visit(this);\n\n      if (expr !== ast.expr) {\n        switch (ast.operator) {\n          case '+':\n            return Unary.createPlus(ast.span, ast.sourceSpan, expr);\n\n          case '-':\n            return Unary.createMinus(ast.span, ast.sourceSpan, expr);\n\n          default:\n            throw new Error(\"Unknown unary operator \".concat(ast.operator));\n        }\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitBinary\",\n    value: function visitBinary(ast, context) {\n      var left = ast.left.visit(this);\n      var right = ast.right.visit(this);\n\n      if (left !== ast.left || right !== ast.right) {\n        return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitPrefixNot\",\n    value: function visitPrefixNot(ast, context) {\n      var expression = ast.expression.visit(this);\n\n      if (expression !== ast.expression) {\n        return new PrefixNot(ast.span, ast.sourceSpan, expression);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitNonNullAssert\",\n    value: function visitNonNullAssert(ast, context) {\n      var expression = ast.expression.visit(this);\n\n      if (expression !== ast.expression) {\n        return new NonNullAssert(ast.span, ast.sourceSpan, expression);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitConditional\",\n    value: function visitConditional(ast, context) {\n      var condition = ast.condition.visit(this);\n      var trueExp = ast.trueExp.visit(this);\n      var falseExp = ast.falseExp.visit(this);\n\n      if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {\n        return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitPipe\",\n    value: function visitPipe(ast, context) {\n      var exp = ast.exp.visit(this);\n      var args = this.visitAll(ast.args);\n\n      if (exp !== ast.exp || args !== ast.args) {\n        return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitKeyedRead\",\n    value: function visitKeyedRead(ast, context) {\n      var obj = ast.receiver.visit(this);\n      var key = ast.key.visit(this);\n\n      if (obj !== ast.receiver || key !== ast.key) {\n        return new KeyedRead(ast.span, ast.sourceSpan, obj, key);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitKeyedWrite\",\n    value: function visitKeyedWrite(ast, context) {\n      var obj = ast.receiver.visit(this);\n      var key = ast.key.visit(this);\n      var value = ast.value.visit(this);\n\n      if (obj !== ast.receiver || key !== ast.key || value !== ast.value) {\n        return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitAll\",\n    value: function visitAll(asts) {\n      var res = [];\n      var modified = false;\n\n      for (var i = 0; i < asts.length; ++i) {\n        var original = asts[i];\n        var value = original.visit(this);\n        res[i] = value;\n        modified = modified || value !== original;\n      }\n\n      return modified ? res : asts;\n    }\n  }, {\n    key: \"visitChain\",\n    value: function visitChain(ast, context) {\n      var expressions = this.visitAll(ast.expressions);\n\n      if (expressions !== ast.expressions) {\n        return new Chain(ast.span, ast.sourceSpan, expressions);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitQuote\",\n    value: function visitQuote(ast, context) {\n      return ast;\n    }\n  }, {\n    key: \"visitSafeKeyedRead\",\n    value: function visitSafeKeyedRead(ast, context) {\n      var obj = ast.receiver.visit(this);\n      var key = ast.key.visit(this);\n\n      if (obj !== ast.receiver || key !== ast.key) {\n        return new SafeKeyedRead(ast.span, ast.sourceSpan, obj, key);\n      }\n\n      return ast;\n    }\n  }]);\n\n  return AstMemoryEfficientTransformer;\n}(); // Bindings\n\n\nvar ParsedProperty = function ParsedProperty(name, expression, type, // TODO(FW-2095): `keySpan` should really be required but allows `undefined` so VE does\n// not need to be updated. Make `keySpan` required when VE is removed.\nsourceSpan, keySpan, valueSpan) {\n  _classCallCheck(this, ParsedProperty);\n\n  this.name = name;\n  this.expression = expression;\n  this.type = type;\n  this.sourceSpan = sourceSpan;\n  this.keySpan = keySpan;\n  this.valueSpan = valueSpan;\n  this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n  this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n};\n\nvar ParsedPropertyType;\n\n(function (ParsedPropertyType) {\n  ParsedPropertyType[ParsedPropertyType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n  ParsedPropertyType[ParsedPropertyType[\"LITERAL_ATTR\"] = 1] = \"LITERAL_ATTR\";\n  ParsedPropertyType[ParsedPropertyType[\"ANIMATION\"] = 2] = \"ANIMATION\";\n})(ParsedPropertyType || (ParsedPropertyType = {}));\n\nvar ParsedEvent = // Regular events have a target\n// Animation events have a phase\nfunction ParsedEvent(name, targetOrPhase, type, handler, sourceSpan, // TODO(FW-2095): keySpan should be required but was made optional to avoid changing VE\nhandlerSpan, keySpan) {\n  _classCallCheck(this, ParsedEvent);\n\n  this.name = name;\n  this.targetOrPhase = targetOrPhase;\n  this.type = type;\n  this.handler = handler;\n  this.sourceSpan = sourceSpan;\n  this.handlerSpan = handlerSpan;\n  this.keySpan = keySpan;\n};\n/**\r\n * ParsedVariable represents a variable declaration in a microsyntax expression.\r\n */\n\n\nvar ParsedVariable = function ParsedVariable(name, value, sourceSpan, keySpan, valueSpan) {\n  _classCallCheck(this, ParsedVariable);\n\n  this.name = name;\n  this.value = value;\n  this.sourceSpan = sourceSpan;\n  this.keySpan = keySpan;\n  this.valueSpan = valueSpan;\n};\n\nvar BoundElementProperty = function BoundElementProperty(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan) {\n  _classCallCheck(this, BoundElementProperty);\n\n  this.name = name;\n  this.type = type;\n  this.securityContext = securityContext;\n  this.value = value;\n  this.unit = unit;\n  this.sourceSpan = sourceSpan;\n  this.keySpan = keySpan;\n  this.valueSpan = valueSpan;\n};\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar CORE$1 = '@angular/core';\n\nvar Identifiers$1 = function Identifiers$1() {\n  _classCallCheck(this, Identifiers$1);\n};\n\nIdentifiers$1.ANALYZE_FOR_ENTRY_COMPONENTS = {\n  name: 'ANALYZE_FOR_ENTRY_COMPONENTS',\n  moduleName: CORE$1\n};\nIdentifiers$1.ElementRef = {\n  name: 'ElementRef',\n  moduleName: CORE$1\n};\nIdentifiers$1.NgModuleRef = {\n  name: 'NgModuleRef',\n  moduleName: CORE$1\n};\nIdentifiers$1.ViewContainerRef = {\n  name: 'ViewContainerRef',\n  moduleName: CORE$1\n};\nIdentifiers$1.ChangeDetectorRef = {\n  name: 'ChangeDetectorRef',\n  moduleName: CORE$1\n};\nIdentifiers$1.QueryList = {\n  name: 'QueryList',\n  moduleName: CORE$1\n};\nIdentifiers$1.TemplateRef = {\n  name: 'TemplateRef',\n  moduleName: CORE$1\n};\nIdentifiers$1.Renderer2 = {\n  name: 'Renderer2',\n  moduleName: CORE$1\n};\nIdentifiers$1.CodegenComponentFactoryResolver = {\n  name: 'ɵCodegenComponentFactoryResolver',\n  moduleName: CORE$1\n};\nIdentifiers$1.ComponentFactoryResolver = {\n  name: 'ComponentFactoryResolver',\n  moduleName: CORE$1\n};\nIdentifiers$1.ComponentFactory = {\n  name: 'ComponentFactory',\n  moduleName: CORE$1\n};\nIdentifiers$1.ComponentRef = {\n  name: 'ComponentRef',\n  moduleName: CORE$1\n};\nIdentifiers$1.NgModuleFactory = {\n  name: 'NgModuleFactory',\n  moduleName: CORE$1\n};\nIdentifiers$1.createModuleFactory = {\n  name: 'ɵcmf',\n  moduleName: CORE$1\n};\nIdentifiers$1.moduleDef = {\n  name: 'ɵmod',\n  moduleName: CORE$1\n};\nIdentifiers$1.moduleProviderDef = {\n  name: 'ɵmpd',\n  moduleName: CORE$1\n};\nIdentifiers$1.RegisterModuleFactoryFn = {\n  name: 'ɵregisterModuleFactory',\n  moduleName: CORE$1\n};\nIdentifiers$1.inject = {\n  name: 'ɵɵinject',\n  moduleName: CORE$1\n};\nIdentifiers$1.directiveInject = {\n  name: 'ɵɵdirectiveInject',\n  moduleName: CORE$1\n};\nIdentifiers$1.INJECTOR = {\n  name: 'INJECTOR',\n  moduleName: CORE$1\n};\nIdentifiers$1.Injector = {\n  name: 'Injector',\n  moduleName: CORE$1\n};\nIdentifiers$1.ViewEncapsulation = {\n  name: 'ViewEncapsulation',\n  moduleName: CORE$1\n};\nIdentifiers$1.ChangeDetectionStrategy = {\n  name: 'ChangeDetectionStrategy',\n  moduleName: CORE$1\n};\nIdentifiers$1.SecurityContext = {\n  name: 'SecurityContext',\n  moduleName: CORE$1\n};\nIdentifiers$1.LOCALE_ID = {\n  name: 'LOCALE_ID',\n  moduleName: CORE$1\n};\nIdentifiers$1.TRANSLATIONS_FORMAT = {\n  name: 'TRANSLATIONS_FORMAT',\n  moduleName: CORE$1\n};\nIdentifiers$1.inlineInterpolate = {\n  name: 'ɵinlineInterpolate',\n  moduleName: CORE$1\n};\nIdentifiers$1.interpolate = {\n  name: 'ɵinterpolate',\n  moduleName: CORE$1\n};\nIdentifiers$1.EMPTY_ARRAY = {\n  name: 'ɵEMPTY_ARRAY',\n  moduleName: CORE$1\n};\nIdentifiers$1.EMPTY_MAP = {\n  name: 'ɵEMPTY_MAP',\n  moduleName: CORE$1\n};\nIdentifiers$1.Renderer = {\n  name: 'Renderer',\n  moduleName: CORE$1\n};\nIdentifiers$1.viewDef = {\n  name: 'ɵvid',\n  moduleName: CORE$1\n};\nIdentifiers$1.elementDef = {\n  name: 'ɵeld',\n  moduleName: CORE$1\n};\nIdentifiers$1.anchorDef = {\n  name: 'ɵand',\n  moduleName: CORE$1\n};\nIdentifiers$1.textDef = {\n  name: 'ɵted',\n  moduleName: CORE$1\n};\nIdentifiers$1.directiveDef = {\n  name: 'ɵdid',\n  moduleName: CORE$1\n};\nIdentifiers$1.providerDef = {\n  name: 'ɵprd',\n  moduleName: CORE$1\n};\nIdentifiers$1.queryDef = {\n  name: 'ɵqud',\n  moduleName: CORE$1\n};\nIdentifiers$1.pureArrayDef = {\n  name: 'ɵpad',\n  moduleName: CORE$1\n};\nIdentifiers$1.pureObjectDef = {\n  name: 'ɵpod',\n  moduleName: CORE$1\n};\nIdentifiers$1.purePipeDef = {\n  name: 'ɵppd',\n  moduleName: CORE$1\n};\nIdentifiers$1.pipeDef = {\n  name: 'ɵpid',\n  moduleName: CORE$1\n};\nIdentifiers$1.nodeValue = {\n  name: 'ɵnov',\n  moduleName: CORE$1\n};\nIdentifiers$1.ngContentDef = {\n  name: 'ɵncd',\n  moduleName: CORE$1\n};\nIdentifiers$1.unwrapValue = {\n  name: 'ɵunv',\n  moduleName: CORE$1\n};\nIdentifiers$1.createRendererType2 = {\n  name: 'ɵcrt',\n  moduleName: CORE$1\n}; // type only\n\nIdentifiers$1.RendererType2 = {\n  name: 'RendererType2',\n  moduleName: CORE$1\n}; // type only\n\nIdentifiers$1.ViewDefinition = {\n  name: 'ɵViewDefinition',\n  moduleName: CORE$1\n};\nIdentifiers$1.createComponentFactory = {\n  name: 'ɵccf',\n  moduleName: CORE$1\n};\n\nfunction createTokenForReference(reference) {\n  return {\n    identifier: {\n      reference: reference\n    }\n  };\n}\n\nfunction createTokenForExternalReference(reflector, reference) {\n  return createTokenForReference(reflector.resolveExternalReference(reference));\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar EventHandlerVars = function EventHandlerVars() {\n  _classCallCheck(this, EventHandlerVars);\n};\n\nEventHandlerVars.event = variable('$event');\n\nvar ConvertActionBindingResult = function ConvertActionBindingResult(\n/**\r\n * Render2 compatible statements,\r\n */\nstmts,\n/**\r\n * Variable name used with render2 compatible statements.\r\n */\nallowDefault) {\n  _classCallCheck(this, ConvertActionBindingResult);\n\n  this.stmts = stmts;\n  this.allowDefault = allowDefault;\n  /**\r\n   * This is bit of a hack. It converts statements which render2 expects to statements which are\r\n   * expected by render3.\r\n   *\r\n   * Example: `<div click=\"doSomething($event)\">` will generate:\r\n   *\r\n   * Render3:\r\n   * ```\r\n   * const pd_b:any = ((<any>ctx.doSomething($event)) !== false);\r\n   * return pd_b;\r\n   * ```\r\n   *\r\n   * but render2 expects:\r\n   * ```\r\n   * return ctx.doSomething($event);\r\n   * ```\r\n   */\n  // TODO(misko): remove this hack once we no longer support ViewEngine.\n\n  this.render3Stmts = stmts.map(function (statement) {\n    if (statement instanceof DeclareVarStmt && statement.name == allowDefault.name && statement.value instanceof BinaryOperatorExpr) {\n      var lhs = statement.value.lhs;\n      return new ReturnStatement(lhs.value);\n    }\n\n    return statement;\n  });\n};\n/**\r\n * Converts the given expression AST into an executable output AST, assuming the expression is\r\n * used in an action binding (e.g. an event handler).\r\n */\n\n\nfunction convertActionBinding(localResolver, implicitReceiver, action, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses, globals) {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver(globals);\n  }\n\n  var actionWithoutBuiltins = convertPropertyBindingBuiltins({\n    createLiteralArrayConverter: function createLiteralArrayConverter(argCount) {\n      // Note: no caching for literal arrays in actions.\n      return function (args) {\n        return literalArr(args);\n      };\n    },\n    createLiteralMapConverter: function createLiteralMapConverter(keys) {\n      // Note: no caching for literal maps in actions.\n      return function (values) {\n        var entries = keys.map(function (k, i) {\n          return {\n            key: k.key,\n            value: values[i],\n            quoted: k.quoted\n          };\n        });\n        return literalMap(entries);\n      };\n    },\n    createPipeConverter: function createPipeConverter(name) {\n      throw new Error(\"Illegal State: Actions are not allowed to contain pipes. Pipe: \".concat(name));\n    }\n  }, action);\n  var visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses);\n  var actionStmts = [];\n  flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n  prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  var lastIndex = actionStmts.length - 1;\n  var preventDefaultVar = null;\n\n  if (lastIndex >= 0) {\n    var lastStatement = actionStmts[lastIndex];\n    var returnExpr = convertStmtIntoExpression(lastStatement);\n\n    if (returnExpr) {\n      // Note: We need to cast the result of the method call to dynamic,\n      // as it might be a void method!\n      preventDefaultVar = createPreventDefaultVar(bindingId);\n      actionStmts[lastIndex] = preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false))).toDeclStmt(null, [StmtModifier.Final]);\n    }\n  }\n\n  return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n}\n\nfunction convertPropertyBindingBuiltins(converterFactory, ast) {\n  return convertBuiltins(converterFactory, ast);\n}\n\nvar ConvertPropertyBindingResult = function ConvertPropertyBindingResult(stmts, currValExpr) {\n  _classCallCheck(this, ConvertPropertyBindingResult);\n\n  this.stmts = stmts;\n  this.currValExpr = currValExpr;\n};\n\nvar BindingForm;\n\n(function (BindingForm) {\n  // The general form of binding expression, supports all expressions.\n  BindingForm[BindingForm[\"General\"] = 0] = \"General\"; // Try to generate a simple binding (no temporaries or statements)\n  // otherwise generate a general binding\n\n  BindingForm[BindingForm[\"TrySimple\"] = 1] = \"TrySimple\"; // Inlines assignment of temporaries into the generated expression. The result may still\n  // have statements attached for declarations of temporary variables.\n  // This is the only relevant form for Ivy, the other forms are only used in ViewEngine.\n\n  BindingForm[BindingForm[\"Expression\"] = 2] = \"Expression\";\n})(BindingForm || (BindingForm = {}));\n/**\r\n * Converts the given expression AST into an executable output AST, assuming the expression\r\n * is used in property binding. The expression has to be preprocessed via\r\n * `convertPropertyBindingBuiltins`.\r\n */\n\n\nfunction _convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId, form, interpolationFunction) {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n\n  var visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);\n  var outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n  var stmts = getStatementsFromVisitor(visitor, bindingId);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  if (visitor.temporaryCount === 0 && form == BindingForm.TrySimple) {\n    return new ConvertPropertyBindingResult([], outputExpr);\n  } else if (form === BindingForm.Expression) {\n    return new ConvertPropertyBindingResult(stmts, outputExpr);\n  }\n\n  var currValExpr = createCurrValueExpr(bindingId);\n  stmts.push(currValExpr.set(outputExpr).toDeclStmt(DYNAMIC_TYPE, [StmtModifier.Final]));\n  return new ConvertPropertyBindingResult(stmts, currValExpr);\n}\n/**\r\n * Given some expression, such as a binding or interpolation expression, and a context expression to\r\n * look values up on, visit each facet of the given expression resolving values from the context\r\n * expression such that a list of arguments can be derived from the found values that can be used as\r\n * arguments to an external update instruction.\r\n *\r\n * @param localResolver The resolver to use to look up expressions by name appropriately\r\n * @param contextVariableExpression The expression representing the context variable used to create\r\n * the final argument expressions\r\n * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to\r\n * be resolved and what arguments list to build.\r\n * @param bindingId A name prefix used to create temporary variable names if they're needed for the\r\n * arguments generated\r\n * @returns An array of expressions that can be passed as arguments to instruction expressions like\r\n * `o.importExpr(R3.propertyInterpolate).callFn(result)`\r\n */\n\n\nfunction convertUpdateArguments(localResolver, contextVariableExpression, expressionWithArgumentsToExtract, bindingId) {\n  var visitor = new _AstToIrVisitor(localResolver, contextVariableExpression, bindingId, undefined);\n  var outputExpr = expressionWithArgumentsToExtract.visit(visitor, _Mode.Expression);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  var stmts = getStatementsFromVisitor(visitor, bindingId); // Removing the first argument, because it was a length for ViewEngine, not Ivy.\n\n  var args = outputExpr.args.slice(1);\n\n  if (expressionWithArgumentsToExtract instanceof Interpolation) {\n    // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the\n    // args returned to just the value, because we're going to pass it to a special instruction.\n    var strings = expressionWithArgumentsToExtract.strings;\n\n    if (args.length === 3 && strings[0] === '' && strings[1] === '') {\n      // Single argument interpolate instructions.\n      args = [args[1]];\n    } else if (args.length >= 19) {\n      // 19 or more arguments must be passed to the `interpolateV`-style instructions, which accept\n      // an array of arguments\n      args = [literalArr(args)];\n    }\n  }\n\n  return {\n    stmts: stmts,\n    args: args\n  };\n}\n\nfunction getStatementsFromVisitor(visitor, bindingId) {\n  var stmts = [];\n\n  for (var i = 0; i < visitor.temporaryCount; i++) {\n    stmts.push(temporaryDeclaration(bindingId, i));\n  }\n\n  return stmts;\n}\n\nfunction convertBuiltins(converterFactory, ast) {\n  var visitor = new _BuiltinAstConverter(converterFactory);\n  return ast.visit(visitor);\n}\n\nfunction temporaryName(bindingId, temporaryNumber) {\n  return \"tmp_\".concat(bindingId, \"_\").concat(temporaryNumber);\n}\n\nfunction temporaryDeclaration(bindingId, temporaryNumber) {\n  return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber));\n}\n\nfunction prependTemporaryDecls(temporaryCount, bindingId, statements) {\n  for (var i = temporaryCount - 1; i >= 0; i--) {\n    statements.unshift(temporaryDeclaration(bindingId, i));\n  }\n}\n\nvar _Mode;\n\n(function (_Mode) {\n  _Mode[_Mode[\"Statement\"] = 0] = \"Statement\";\n  _Mode[_Mode[\"Expression\"] = 1] = \"Expression\";\n})(_Mode || (_Mode = {}));\n\nfunction ensureStatementMode(mode, ast) {\n  if (mode !== _Mode.Statement) {\n    throw new Error(\"Expected a statement, but saw \".concat(ast));\n  }\n}\n\nfunction ensureExpressionMode(mode, ast) {\n  if (mode !== _Mode.Expression) {\n    throw new Error(\"Expected an expression, but saw \".concat(ast));\n  }\n}\n\nfunction convertToStatementIfNeeded(mode, expr) {\n  if (mode === _Mode.Statement) {\n    return expr.toStmt();\n  } else {\n    return expr;\n  }\n}\n\nvar _BuiltinAstConverter = /*#__PURE__*/function (_AstTransformer$) {\n  _inherits(_BuiltinAstConverter, _AstTransformer$);\n\n  var _super80 = _createSuper(_BuiltinAstConverter);\n\n  function _BuiltinAstConverter(_converterFactory) {\n    var _this112;\n\n    _classCallCheck(this, _BuiltinAstConverter);\n\n    _this112 = _super80.call(this);\n    _this112._converterFactory = _converterFactory;\n    return _this112;\n  }\n\n  _createClass(_BuiltinAstConverter, [{\n    key: \"visitPipe\",\n    value: function visitPipe(ast, context) {\n      var _this113 = this;\n\n      var args = [ast.exp].concat(_toConsumableArray(ast.args)).map(function (ast) {\n        return ast.visit(_this113, context);\n      });\n      return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createPipeConverter(ast.name, args.length));\n    }\n  }, {\n    key: \"visitLiteralArray\",\n    value: function visitLiteralArray(ast, context) {\n      var _this114 = this;\n\n      var args = ast.expressions.map(function (ast) {\n        return ast.visit(_this114, context);\n      });\n      return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n    }\n  }, {\n    key: \"visitLiteralMap\",\n    value: function visitLiteralMap(ast, context) {\n      var _this115 = this;\n\n      var args = ast.values.map(function (ast) {\n        return ast.visit(_this115, context);\n      });\n      return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n    }\n  }]);\n\n  return _BuiltinAstConverter;\n}(AstTransformer$1);\n\nvar _AstToIrVisitor = /*#__PURE__*/function () {\n  function _AstToIrVisitor(_localResolver, _implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses) {\n    _classCallCheck(this, _AstToIrVisitor);\n\n    this._localResolver = _localResolver;\n    this._implicitReceiver = _implicitReceiver;\n    this.bindingId = bindingId;\n    this.interpolationFunction = interpolationFunction;\n    this.baseSourceSpan = baseSourceSpan;\n    this.implicitReceiverAccesses = implicitReceiverAccesses;\n    this._nodeMap = new Map();\n    this._resultMap = new Map();\n    this._currentTemporary = 0;\n    this.temporaryCount = 0;\n    this.usesImplicitReceiver = false;\n  }\n\n  _createClass(_AstToIrVisitor, [{\n    key: \"visitUnary\",\n    value: function visitUnary(ast, mode) {\n      var op;\n\n      switch (ast.operator) {\n        case '+':\n          op = UnaryOperator.Plus;\n          break;\n\n        case '-':\n          op = UnaryOperator.Minus;\n          break;\n\n        default:\n          throw new Error(\"Unsupported operator \".concat(ast.operator));\n      }\n\n      return convertToStatementIfNeeded(mode, new UnaryOperatorExpr(op, this._visit(ast.expr, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));\n    }\n  }, {\n    key: \"visitBinary\",\n    value: function visitBinary(ast, mode) {\n      var op;\n\n      switch (ast.operation) {\n        case '+':\n          op = BinaryOperator.Plus;\n          break;\n\n        case '-':\n          op = BinaryOperator.Minus;\n          break;\n\n        case '*':\n          op = BinaryOperator.Multiply;\n          break;\n\n        case '/':\n          op = BinaryOperator.Divide;\n          break;\n\n        case '%':\n          op = BinaryOperator.Modulo;\n          break;\n\n        case '&&':\n          op = BinaryOperator.And;\n          break;\n\n        case '||':\n          op = BinaryOperator.Or;\n          break;\n\n        case '==':\n          op = BinaryOperator.Equals;\n          break;\n\n        case '!=':\n          op = BinaryOperator.NotEquals;\n          break;\n\n        case '===':\n          op = BinaryOperator.Identical;\n          break;\n\n        case '!==':\n          op = BinaryOperator.NotIdentical;\n          break;\n\n        case '<':\n          op = BinaryOperator.Lower;\n          break;\n\n        case '>':\n          op = BinaryOperator.Bigger;\n          break;\n\n        case '<=':\n          op = BinaryOperator.LowerEquals;\n          break;\n\n        case '>=':\n          op = BinaryOperator.BiggerEquals;\n          break;\n\n        case '??':\n          return this.convertNullishCoalesce(ast, mode);\n\n        default:\n          throw new Error(\"Unsupported operation \".concat(ast.operation));\n      }\n\n      return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));\n    }\n  }, {\n    key: \"visitChain\",\n    value: function visitChain(ast, mode) {\n      ensureStatementMode(mode, ast);\n      return this.visitAll(ast.expressions, mode);\n    }\n  }, {\n    key: \"visitConditional\",\n    value: function visitConditional(ast, mode) {\n      var value = this._visit(ast.condition, _Mode.Expression);\n\n      return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression), this.convertSourceSpan(ast.span)));\n    }\n  }, {\n    key: \"visitPipe\",\n    value: function visitPipe(ast, mode) {\n      throw new Error(\"Illegal state: Pipes should have been converted into functions. Pipe: \".concat(ast.name));\n    }\n  }, {\n    key: \"visitFunctionCall\",\n    value: function visitFunctionCall(ast, mode) {\n      var convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n      var fnResult;\n\n      if (ast instanceof BuiltinFunctionCall) {\n        fnResult = ast.converter(convertedArgs);\n      } else {\n        fnResult = this._visit(ast.target, _Mode.Expression).callFn(convertedArgs, this.convertSourceSpan(ast.span));\n      }\n\n      return convertToStatementIfNeeded(mode, fnResult);\n    }\n  }, {\n    key: \"visitImplicitReceiver\",\n    value: function visitImplicitReceiver(ast, mode) {\n      ensureExpressionMode(mode, ast);\n      this.usesImplicitReceiver = true;\n      return this._implicitReceiver;\n    }\n  }, {\n    key: \"visitThisReceiver\",\n    value: function visitThisReceiver(ast, mode) {\n      return this.visitImplicitReceiver(ast, mode);\n    }\n  }, {\n    key: \"visitInterpolation\",\n    value: function visitInterpolation(ast, mode) {\n      ensureExpressionMode(mode, ast);\n      var args = [literal(ast.expressions.length)];\n\n      for (var i = 0; i < ast.strings.length - 1; i++) {\n        args.push(literal(ast.strings[i]));\n        args.push(this._visit(ast.expressions[i], _Mode.Expression));\n      }\n\n      args.push(literal(ast.strings[ast.strings.length - 1]));\n\n      if (this.interpolationFunction) {\n        return this.interpolationFunction(args);\n      }\n\n      return ast.expressions.length <= 9 ? importExpr(Identifiers$1.inlineInterpolate).callFn(args) : importExpr(Identifiers$1.interpolate).callFn([args[0], literalArr(args.slice(1), undefined, this.convertSourceSpan(ast.span))]);\n    }\n  }, {\n    key: \"visitKeyedRead\",\n    value: function visitKeyedRead(ast, mode) {\n      var leftMostSafe = this.leftMostSafeNode(ast);\n\n      if (leftMostSafe) {\n        return this.convertSafeAccess(ast, leftMostSafe, mode);\n      } else {\n        return convertToStatementIfNeeded(mode, this._visit(ast.receiver, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n      }\n    }\n  }, {\n    key: \"visitKeyedWrite\",\n    value: function visitKeyedWrite(ast, mode) {\n      var obj = this._visit(ast.receiver, _Mode.Expression);\n\n      var key = this._visit(ast.key, _Mode.Expression);\n\n      var value = this._visit(ast.value, _Mode.Expression);\n\n      if (obj === this._implicitReceiver) {\n        this._localResolver.maybeRestoreView(0, false);\n      }\n\n      return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n    }\n  }, {\n    key: \"visitLiteralArray\",\n    value: function visitLiteralArray(ast, mode) {\n      throw new Error(\"Illegal State: literal arrays should have been converted into functions\");\n    }\n  }, {\n    key: \"visitLiteralMap\",\n    value: function visitLiteralMap(ast, mode) {\n      throw new Error(\"Illegal State: literal maps should have been converted into functions\");\n    }\n  }, {\n    key: \"visitLiteralPrimitive\",\n    value: function visitLiteralPrimitive(ast, mode) {\n      // For literal values of null, undefined, true, or false allow type interference\n      // to infer the type.\n      var type = ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ? INFERRED_TYPE : undefined;\n      return convertToStatementIfNeeded(mode, literal(ast.value, type, this.convertSourceSpan(ast.span)));\n    }\n  }, {\n    key: \"_getLocal\",\n    value: function _getLocal(name, receiver) {\n      var _a;\n\n      if (((_a = this._localResolver.globals) === null || _a === void 0 ? void 0 : _a.has(name)) && receiver instanceof ThisReceiver) {\n        return null;\n      }\n\n      return this._localResolver.getLocal(name);\n    }\n  }, {\n    key: \"visitMethodCall\",\n    value: function visitMethodCall(ast, mode) {\n      if (ast.receiver instanceof ImplicitReceiver && !(ast.receiver instanceof ThisReceiver) && ast.name === '$any') {\n        var args = this.visitAll(ast.args, _Mode.Expression);\n\n        if (args.length != 1) {\n          throw new Error(\"Invalid call to $any, expected 1 argument but received \".concat(args.length || 'none'));\n        }\n\n        return args[0].cast(DYNAMIC_TYPE, this.convertSourceSpan(ast.span));\n      }\n\n      var leftMostSafe = this.leftMostSafeNode(ast);\n\n      if (leftMostSafe) {\n        return this.convertSafeAccess(ast, leftMostSafe, mode);\n      } else {\n        var _args = this.visitAll(ast.args, _Mode.Expression);\n\n        var prevUsesImplicitReceiver = this.usesImplicitReceiver;\n        var result = null;\n\n        var receiver = this._visit(ast.receiver, _Mode.Expression);\n\n        if (receiver === this._implicitReceiver) {\n          var varExpr = this._getLocal(ast.name, ast.receiver);\n\n          if (varExpr) {\n            // Restore the previous \"usesImplicitReceiver\" state since the implicit\n            // receiver has been replaced with a resolved local expression.\n            this.usesImplicitReceiver = prevUsesImplicitReceiver;\n            result = varExpr.callFn(_args);\n            this.addImplicitReceiverAccess(ast.name);\n          }\n        }\n\n        if (result == null) {\n          result = receiver.callMethod(ast.name, _args, this.convertSourceSpan(ast.span));\n        }\n\n        return convertToStatementIfNeeded(mode, result);\n      }\n    }\n  }, {\n    key: \"visitPrefixNot\",\n    value: function visitPrefixNot(ast, mode) {\n      return convertToStatementIfNeeded(mode, not(this._visit(ast.expression, _Mode.Expression)));\n    }\n  }, {\n    key: \"visitNonNullAssert\",\n    value: function visitNonNullAssert(ast, mode) {\n      return convertToStatementIfNeeded(mode, assertNotNull(this._visit(ast.expression, _Mode.Expression)));\n    }\n  }, {\n    key: \"visitPropertyRead\",\n    value: function visitPropertyRead(ast, mode) {\n      var leftMostSafe = this.leftMostSafeNode(ast);\n\n      if (leftMostSafe) {\n        return this.convertSafeAccess(ast, leftMostSafe, mode);\n      } else {\n        var result = null;\n        var prevUsesImplicitReceiver = this.usesImplicitReceiver;\n\n        var receiver = this._visit(ast.receiver, _Mode.Expression);\n\n        if (receiver === this._implicitReceiver) {\n          result = this._getLocal(ast.name, ast.receiver);\n\n          if (result) {\n            // Restore the previous \"usesImplicitReceiver\" state since the implicit\n            // receiver has been replaced with a resolved local expression.\n            this.usesImplicitReceiver = prevUsesImplicitReceiver;\n            this.addImplicitReceiverAccess(ast.name);\n          }\n        }\n\n        if (result == null) {\n          result = receiver.prop(ast.name);\n        }\n\n        return convertToStatementIfNeeded(mode, result);\n      }\n    }\n  }, {\n    key: \"visitPropertyWrite\",\n    value: function visitPropertyWrite(ast, mode) {\n      var receiver = this._visit(ast.receiver, _Mode.Expression);\n\n      var prevUsesImplicitReceiver = this.usesImplicitReceiver;\n      var varExpr = null;\n\n      if (receiver === this._implicitReceiver) {\n        var localExpr = this._getLocal(ast.name, ast.receiver);\n\n        if (localExpr) {\n          if (localExpr instanceof ReadPropExpr) {\n            // If the local variable is a property read expression, it's a reference\n            // to a 'context.property' value and will be used as the target of the\n            // write expression.\n            varExpr = localExpr; // Restore the previous \"usesImplicitReceiver\" state since the implicit\n            // receiver has been replaced with a resolved local expression.\n\n            this.usesImplicitReceiver = prevUsesImplicitReceiver;\n            this.addImplicitReceiverAccess(ast.name);\n          } else {\n            // Otherwise it's an error.\n            var _receiver = ast.name;\n            var value = ast.value instanceof PropertyRead ? ast.value.name : undefined;\n            throw new Error(\"Cannot assign value \\\"\".concat(value, \"\\\" to template variable \\\"\").concat(_receiver, \"\\\". Template variables are read-only.\"));\n          }\n        }\n      } // If no local expression could be produced, use the original receiver's\n      // property as the target.\n\n\n      if (varExpr === null) {\n        varExpr = receiver.prop(ast.name);\n      }\n\n      return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));\n    }\n  }, {\n    key: \"visitSafePropertyRead\",\n    value: function visitSafePropertyRead(ast, mode) {\n      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    }\n  }, {\n    key: \"visitSafeMethodCall\",\n    value: function visitSafeMethodCall(ast, mode) {\n      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    }\n  }, {\n    key: \"visitSafeKeyedRead\",\n    value: function visitSafeKeyedRead(ast, mode) {\n      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    }\n  }, {\n    key: \"visitAll\",\n    value: function visitAll(asts, mode) {\n      var _this116 = this;\n\n      return asts.map(function (ast) {\n        return _this116._visit(ast, mode);\n      });\n    }\n  }, {\n    key: \"visitQuote\",\n    value: function visitQuote(ast, mode) {\n      throw new Error(\"Quotes are not supported for evaluation!\\n        Statement: \".concat(ast.uninterpretedExpression, \" located at \").concat(ast.location));\n    }\n  }, {\n    key: \"_visit\",\n    value: function _visit(ast, mode) {\n      var result = this._resultMap.get(ast);\n\n      if (result) return result;\n      return (this._nodeMap.get(ast) || ast).visit(this, mode);\n    }\n  }, {\n    key: \"convertSafeAccess\",\n    value: function convertSafeAccess(ast, leftMostSafe, mode) {\n      // If the expression contains a safe access node on the left it needs to be converted to\n      // an expression that guards the access to the member by checking the receiver for blank. As\n      // execution proceeds from left to right, the left most part of the expression must be guarded\n      // first but, because member access is left associative, the right side of the expression is at\n      // the top of the AST. The desired result requires lifting a copy of the left part of the\n      // expression up to test it for blank before generating the unguarded version.\n      // Consider, for example the following expression: a?.b.c?.d.e\n      // This results in the ast:\n      //         .\n      //        / \\\n      //       ?.   e\n      //      /  \\\n      //     .    d\n      //    / \\\n      //   ?.  c\n      //  /  \\\n      // a    b\n      // The following tree should be generated:\n      //\n      //        /---- ? ----\\\n      //       /      |      \\\n      //     a   /--- ? ---\\  null\n      //        /     |     \\\n      //       .      .     null\n      //      / \\    / \\\n      //     .  c   .   e\n      //    / \\    / \\\n      //   a   b  .   d\n      //         / \\\n      //        .   c\n      //       / \\\n      //      a   b\n      //\n      // Notice that the first guard condition is the left hand of the left most safe access node\n      // which comes in as leftMostSafe to this routine.\n      var guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n\n      var temporary = undefined;\n\n      if (this.needsTemporaryInSafeAccess(leftMostSafe.receiver)) {\n        // If the expression has method calls or pipes then we need to save the result into a\n        // temporary variable to avoid calling stateful or impure code more than once.\n        temporary = this.allocateTemporary(); // Preserve the result in the temporary variable\n\n        guardedExpression = temporary.set(guardedExpression); // Ensure all further references to the guarded expression refer to the temporary instead.\n\n        this._resultMap.set(leftMostSafe.receiver, temporary);\n      }\n\n      var condition = guardedExpression.isBlank(); // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n      // leftMostNode with its unguarded version in the call to `this.visit()`.\n\n      if (leftMostSafe instanceof SafeMethodCall) {\n        this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args, leftMostSafe.argumentSpan));\n      } else if (leftMostSafe instanceof SafeKeyedRead) {\n        this._nodeMap.set(leftMostSafe, new KeyedRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.key));\n      } else {\n        this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name));\n      } // Recursively convert the node now without the guarded member access.\n\n\n      var access = this._visit(ast, _Mode.Expression); // Remove the mapping. This is not strictly required as the converter only traverses each node\n      // once but is safer if the conversion is changed to traverse the nodes more than once.\n\n\n      this._nodeMap.delete(leftMostSafe); // If we allocated a temporary, release it.\n\n\n      if (temporary) {\n        this.releaseTemporary(temporary);\n      } // Produce the conditional\n\n\n      return convertToStatementIfNeeded(mode, condition.conditional(NULL_EXPR, access));\n    }\n  }, {\n    key: \"convertNullishCoalesce\",\n    value: function convertNullishCoalesce(ast, mode) {\n      var left = this._visit(ast.left, _Mode.Expression);\n\n      var right = this._visit(ast.right, _Mode.Expression);\n\n      var temporary = this.allocateTemporary();\n      this.releaseTemporary(temporary); // Generate the following expression. It is identical to how TS\n      // transpiles binary expressions with a nullish coalescing operator.\n      // let temp;\n      // (temp = a) !== null && temp !== undefined ? temp : b;\n\n      return convertToStatementIfNeeded(mode, temporary.set(left).notIdentical(NULL_EXPR).and(temporary.notIdentical(literal(undefined))).conditional(temporary, right));\n    } // Given an expression of the form a?.b.c?.d.e then the left most safe node is\n    // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n    // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n    // safe method call as this needs to be transformed initially to:\n    //   a == null ? null : a.c.b.c?.d.e\n    // then to:\n    //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n\n  }, {\n    key: \"leftMostSafeNode\",\n    value: function leftMostSafeNode(ast) {\n      var _this117 = this;\n\n      var visit = function visit(visitor, ast) {\n        return (_this117._nodeMap.get(ast) || ast).visit(visitor);\n      };\n\n      return ast.visit({\n        visitUnary: function visitUnary(ast) {\n          return null;\n        },\n        visitBinary: function visitBinary(ast) {\n          return null;\n        },\n        visitChain: function visitChain(ast) {\n          return null;\n        },\n        visitConditional: function visitConditional(ast) {\n          return null;\n        },\n        visitFunctionCall: function visitFunctionCall(ast) {\n          return null;\n        },\n        visitImplicitReceiver: function visitImplicitReceiver(ast) {\n          return null;\n        },\n        visitThisReceiver: function visitThisReceiver(ast) {\n          return null;\n        },\n        visitInterpolation: function visitInterpolation(ast) {\n          return null;\n        },\n        visitKeyedRead: function visitKeyedRead(ast) {\n          return visit(this, ast.receiver);\n        },\n        visitKeyedWrite: function visitKeyedWrite(ast) {\n          return null;\n        },\n        visitLiteralArray: function visitLiteralArray(ast) {\n          return null;\n        },\n        visitLiteralMap: function visitLiteralMap(ast) {\n          return null;\n        },\n        visitLiteralPrimitive: function visitLiteralPrimitive(ast) {\n          return null;\n        },\n        visitMethodCall: function visitMethodCall(ast) {\n          return visit(this, ast.receiver);\n        },\n        visitPipe: function visitPipe(ast) {\n          return null;\n        },\n        visitPrefixNot: function visitPrefixNot(ast) {\n          return null;\n        },\n        visitNonNullAssert: function visitNonNullAssert(ast) {\n          return null;\n        },\n        visitPropertyRead: function visitPropertyRead(ast) {\n          return visit(this, ast.receiver);\n        },\n        visitPropertyWrite: function visitPropertyWrite(ast) {\n          return null;\n        },\n        visitQuote: function visitQuote(ast) {\n          return null;\n        },\n        visitSafeMethodCall: function visitSafeMethodCall(ast) {\n          return visit(this, ast.receiver) || ast;\n        },\n        visitSafePropertyRead: function visitSafePropertyRead(ast) {\n          return visit(this, ast.receiver) || ast;\n        },\n        visitSafeKeyedRead: function visitSafeKeyedRead(ast) {\n          return visit(this, ast.receiver) || ast;\n        }\n      });\n    } // Returns true of the AST includes a method or a pipe indicating that, if the\n    // expression is used as the target of a safe property or method access then\n    // the expression should be stored into a temporary variable.\n\n  }, {\n    key: \"needsTemporaryInSafeAccess\",\n    value: function needsTemporaryInSafeAccess(ast) {\n      var _this118 = this;\n\n      var visit = function visit(visitor, ast) {\n        return ast && (_this118._nodeMap.get(ast) || ast).visit(visitor);\n      };\n\n      var visitSome = function visitSome(visitor, ast) {\n        return ast.some(function (ast) {\n          return visit(visitor, ast);\n        });\n      };\n\n      return ast.visit({\n        visitUnary: function visitUnary(ast) {\n          return visit(this, ast.expr);\n        },\n        visitBinary: function visitBinary(ast) {\n          return visit(this, ast.left) || visit(this, ast.right);\n        },\n        visitChain: function visitChain(ast) {\n          return false;\n        },\n        visitConditional: function visitConditional(ast) {\n          return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);\n        },\n        visitFunctionCall: function visitFunctionCall(ast) {\n          return true;\n        },\n        visitImplicitReceiver: function visitImplicitReceiver(ast) {\n          return false;\n        },\n        visitThisReceiver: function visitThisReceiver(ast) {\n          return false;\n        },\n        visitInterpolation: function visitInterpolation(ast) {\n          return visitSome(this, ast.expressions);\n        },\n        visitKeyedRead: function visitKeyedRead(ast) {\n          return false;\n        },\n        visitKeyedWrite: function visitKeyedWrite(ast) {\n          return false;\n        },\n        visitLiteralArray: function visitLiteralArray(ast) {\n          return true;\n        },\n        visitLiteralMap: function visitLiteralMap(ast) {\n          return true;\n        },\n        visitLiteralPrimitive: function visitLiteralPrimitive(ast) {\n          return false;\n        },\n        visitMethodCall: function visitMethodCall(ast) {\n          return true;\n        },\n        visitPipe: function visitPipe(ast) {\n          return true;\n        },\n        visitPrefixNot: function visitPrefixNot(ast) {\n          return visit(this, ast.expression);\n        },\n        visitNonNullAssert: function visitNonNullAssert(ast) {\n          return visit(this, ast.expression);\n        },\n        visitPropertyRead: function visitPropertyRead(ast) {\n          return false;\n        },\n        visitPropertyWrite: function visitPropertyWrite(ast) {\n          return false;\n        },\n        visitQuote: function visitQuote(ast) {\n          return false;\n        },\n        visitSafeMethodCall: function visitSafeMethodCall(ast) {\n          return true;\n        },\n        visitSafePropertyRead: function visitSafePropertyRead(ast) {\n          return false;\n        },\n        visitSafeKeyedRead: function visitSafeKeyedRead(ast) {\n          return false;\n        }\n      });\n    }\n  }, {\n    key: \"allocateTemporary\",\n    value: function allocateTemporary() {\n      var tempNumber = this._currentTemporary++;\n      this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n      return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n    }\n  }, {\n    key: \"releaseTemporary\",\n    value: function releaseTemporary(temporary) {\n      this._currentTemporary--;\n\n      if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n        throw new Error(\"Temporary \".concat(temporary.name, \" released out of order\"));\n      }\n    }\n    /**\r\n     * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.\r\n     *\r\n     * `ParseSpan` objects are relative to the start of the expression.\r\n     * This method converts these to full `ParseSourceSpan` objects that\r\n     * show where the span is within the overall source file.\r\n     *\r\n     * @param span the relative span to convert.\r\n     * @returns a `ParseSourceSpan` for the given span or null if no\r\n     * `baseSourceSpan` was provided to this class.\r\n     */\n\n  }, {\n    key: \"convertSourceSpan\",\n    value: function convertSourceSpan(span) {\n      if (this.baseSourceSpan) {\n        var _start = this.baseSourceSpan.start.moveBy(span.start);\n\n        var end = this.baseSourceSpan.start.moveBy(span.end);\n        var fullStart = this.baseSourceSpan.fullStart.moveBy(span.start);\n        return new ParseSourceSpan(_start, end, fullStart);\n      } else {\n        return null;\n      }\n    }\n    /** Adds the name of an AST to the list of implicit receiver accesses. */\n\n  }, {\n    key: \"addImplicitReceiverAccess\",\n    value: function addImplicitReceiverAccess(name) {\n      if (this.implicitReceiverAccesses) {\n        this.implicitReceiverAccesses.add(name);\n      }\n    }\n  }]);\n\n  return _AstToIrVisitor;\n}();\n\nfunction flattenStatements(arg, output) {\n  if (Array.isArray(arg)) {\n    arg.forEach(function (entry) {\n      return flattenStatements(entry, output);\n    });\n  } else {\n    output.push(arg);\n  }\n}\n\nvar DefaultLocalResolver = /*#__PURE__*/function () {\n  function DefaultLocalResolver(globals) {\n    _classCallCheck(this, DefaultLocalResolver);\n\n    this.globals = globals;\n  }\n\n  _createClass(DefaultLocalResolver, [{\n    key: \"notifyImplicitReceiverUse\",\n    value: function notifyImplicitReceiverUse() {}\n  }, {\n    key: \"maybeRestoreView\",\n    value: function maybeRestoreView() {}\n  }, {\n    key: \"getLocal\",\n    value: function getLocal(name) {\n      if (name === EventHandlerVars.event.name) {\n        return EventHandlerVars.event;\n      }\n\n      return null;\n    }\n  }]);\n\n  return DefaultLocalResolver;\n}();\n\nfunction createCurrValueExpr(bindingId) {\n  return variable(\"currVal_\".concat(bindingId)); // fix syntax highlighting: `\n}\n\nfunction createPreventDefaultVar(bindingId) {\n  return variable(\"pd_\".concat(bindingId));\n}\n\nfunction convertStmtIntoExpression(stmt) {\n  if (stmt instanceof ExpressionStatement) {\n    return stmt.expr;\n  } else if (stmt instanceof ReturnStatement) {\n    return stmt.value;\n  }\n\n  return null;\n}\n\nvar BuiltinFunctionCall = /*#__PURE__*/function (_FunctionCall) {\n  _inherits(BuiltinFunctionCall, _FunctionCall);\n\n  var _super81 = _createSuper(BuiltinFunctionCall);\n\n  function BuiltinFunctionCall(span, sourceSpan, args, converter) {\n    var _this119;\n\n    _classCallCheck(this, BuiltinFunctionCall);\n\n    _this119 = _super81.call(this, span, sourceSpan, null, args);\n    _this119.args = args;\n    _this119.converter = converter;\n    return _this119;\n  }\n\n  return BuiltinFunctionCall;\n}(FunctionCall);\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * This file is a port of shadowCSS from webcomponents.js to TypeScript.\r\n *\r\n * Please make sure to keep to edits in sync with the source file.\r\n *\r\n * Source:\r\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\r\n *\r\n * The original file level comment is reproduced below\r\n */\n\n/*\r\n  This is a limited shim for ShadowDOM css styling.\r\n  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles\r\n\r\n  The intention here is to support only the styling features which can be\r\n  relatively simply implemented. The goal is to allow users to avoid the\r\n  most obvious pitfalls and do so without compromising performance significantly.\r\n  For ShadowDOM styling that's not covered here, a set of best practices\r\n  can be provided that should allow users to accomplish more complex styling.\r\n\r\n  The following is a list of specific ShadowDOM styling features and a brief\r\n  discussion of the approach used to shim.\r\n\r\n  Shimmed features:\r\n\r\n  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host\r\n  element using the :host rule. To shim this feature, the :host styles are\r\n  reformatted and prefixed with a given scope name and promoted to a\r\n  document level stylesheet.\r\n  For example, given a scope name of .foo, a rule like this:\r\n\r\n    :host {\r\n        background: red;\r\n      }\r\n    }\r\n\r\n  becomes:\r\n\r\n    .foo {\r\n      background: red;\r\n    }\r\n\r\n  * encapsulation: Styles defined within ShadowDOM, apply only to\r\n  dom inside the ShadowDOM. Polymer uses one of two techniques to implement\r\n  this feature.\r\n\r\n  By default, rules are prefixed with the host element tag name\r\n  as a descendant selector. This ensures styling does not leak out of the 'top'\r\n  of the element's ShadowDOM. For example,\r\n\r\n  div {\r\n      font-weight: bold;\r\n    }\r\n\r\n  becomes:\r\n\r\n  x-foo div {\r\n      font-weight: bold;\r\n    }\r\n\r\n  becomes:\r\n\r\n\r\n  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then\r\n  selectors are scoped by adding an attribute selector suffix to each\r\n  simple selector that contains the host element tag name. Each element\r\n  in the element's ShadowDOM template is also given the scope attribute.\r\n  Thus, these rules match only elements that have the scope attribute.\r\n  For example, given a scope name of x-foo, a rule like this:\r\n\r\n    div {\r\n      font-weight: bold;\r\n    }\r\n\r\n  becomes:\r\n\r\n    div[x-foo] {\r\n      font-weight: bold;\r\n    }\r\n\r\n  Note that elements that are dynamically added to a scope must have the scope\r\n  selector added to them manually.\r\n\r\n  * upper/lower bound encapsulation: Styles which are defined outside a\r\n  shadowRoot should not cross the ShadowDOM boundary and should not apply\r\n  inside a shadowRoot.\r\n\r\n  This styling behavior is not emulated. Some possible ways to do this that\r\n  were rejected due to complexity and/or performance concerns include: (1) reset\r\n  every possible property for every possible selector for a given scope name;\r\n  (2) re-implement css in javascript.\r\n\r\n  As an alternative, users should make sure to use selectors\r\n  specific to the scope in which they are working.\r\n\r\n  * ::distributed: This behavior is not emulated. It's often not necessary\r\n  to style the contents of a specific insertion point and instead, descendants\r\n  of the host element can be styled selectively. Users can also create an\r\n  extra node around an insertion point and style that node's contents\r\n  via descendent selectors. For example, with a shadowRoot like this:\r\n\r\n    <style>\r\n      ::content(div) {\r\n        background: red;\r\n      }\r\n    </style>\r\n    <content></content>\r\n\r\n  could become:\r\n\r\n    <style>\r\n      / *@polyfill .content-container div * /\r\n      ::content(div) {\r\n        background: red;\r\n      }\r\n    </style>\r\n    <div class=\"content-container\">\r\n      <content></content>\r\n    </div>\r\n\r\n  Note the use of @polyfill in the comment above a ShadowDOM specific style\r\n  declaration. This is a directive to the styling shim to use the selector\r\n  in comments in lieu of the next selector when running under polyfill.\r\n*/\n\n\nvar ShadowCss = /*#__PURE__*/function () {\n  function ShadowCss() {\n    _classCallCheck(this, ShadowCss);\n\n    this.strictStyling = true;\n  }\n  /*\r\n   * Shim some cssText with the given selector. Returns cssText that can\r\n   * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).\r\n   *\r\n   * When strictStyling is true:\r\n   * - selector is the attribute added to all elements inside the host,\r\n   * - hostSelector is the attribute added to the host itself.\r\n   */\n\n\n  _createClass(ShadowCss, [{\n    key: \"shimCssText\",\n    value: function shimCssText(cssText, selector) {\n      var hostSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var commentsWithHash = extractCommentsWithHash(cssText);\n      cssText = stripComments(cssText);\n      cssText = this._insertDirectives(cssText);\n\n      var scopedCssText = this._scopeCssText(cssText, selector, hostSelector);\n\n      return [scopedCssText].concat(_toConsumableArray(commentsWithHash)).join('\\n');\n    }\n  }, {\n    key: \"_insertDirectives\",\n    value: function _insertDirectives(cssText) {\n      cssText = this._insertPolyfillDirectivesInCssText(cssText);\n      return this._insertPolyfillRulesInCssText(cssText);\n    }\n    /*\r\n     * Process styles to convert native ShadowDOM rules that will trip\r\n     * up the css parser; we rely on decorating the stylesheet with inert rules.\r\n     *\r\n     * For example, we convert this rule:\r\n     *\r\n     * polyfill-next-selector { content: ':host menu-item'; }\r\n     * ::content menu-item {\r\n     *\r\n     * to this:\r\n     *\r\n     * scopeName menu-item {\r\n     *\r\n     **/\n\n  }, {\n    key: \"_insertPolyfillDirectivesInCssText\",\n    value: function _insertPolyfillDirectivesInCssText(cssText) {\n      // Difference with webcomponents.js: does not handle comments\n      return cssText.replace(_cssContentNextSelectorRe, function () {\n        return (arguments.length <= 2 ? undefined : arguments[2]) + '{';\n      });\n    }\n    /*\r\n     * Process styles to add rules which will only apply under the polyfill\r\n     *\r\n     * For example, we convert this rule:\r\n     *\r\n     * polyfill-rule {\r\n     *   content: ':host menu-item';\r\n     * ...\r\n     * }\r\n     *\r\n     * to this:\r\n     *\r\n     * scopeName menu-item {...}\r\n     *\r\n     **/\n\n  }, {\n    key: \"_insertPolyfillRulesInCssText\",\n    value: function _insertPolyfillRulesInCssText(cssText) {\n      // Difference with webcomponents.js: does not handle comments\n      return cssText.replace(_cssContentRuleRe, function () {\n        for (var _len4 = arguments.length, m = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {\n          m[_key5] = arguments[_key5];\n        }\n\n        var rule = m[0].replace(m[1], '').replace(m[2], '');\n        return m[4] + rule;\n      });\n    }\n    /* Ensure styles are scoped. Pseudo-scoping takes a rule like:\r\n     *\r\n     *  .foo {... }\r\n     *\r\n     *  and converts this to\r\n     *\r\n     *  scopeName .foo { ... }\r\n     */\n\n  }, {\n    key: \"_scopeCssText\",\n    value: function _scopeCssText(cssText, scopeSelector, hostSelector) {\n      var unscopedRules = this._extractUnscopedRulesFromCssText(cssText); // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n\n\n      cssText = this._insertPolyfillHostInCssText(cssText);\n      cssText = this._convertColonHost(cssText);\n      cssText = this._convertColonHostContext(cssText);\n      cssText = this._convertShadowDOMSelectors(cssText);\n\n      if (scopeSelector) {\n        cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n      }\n\n      cssText = cssText + '\\n' + unscopedRules;\n      return cssText.trim();\n    }\n    /*\r\n     * Process styles to add rules which will only apply under the polyfill\r\n     * and do not process via CSSOM. (CSSOM is destructive to rules on rare\r\n     * occasions, e.g. -webkit-calc on Safari.)\r\n     * For example, we convert this rule:\r\n     *\r\n     * @polyfill-unscoped-rule {\r\n     *   content: 'menu-item';\r\n     * ... }\r\n     *\r\n     * to this:\r\n     *\r\n     * menu-item {...}\r\n     *\r\n     **/\n\n  }, {\n    key: \"_extractUnscopedRulesFromCssText\",\n    value: function _extractUnscopedRulesFromCssText(cssText) {\n      // Difference with webcomponents.js: does not handle comments\n      var r = '';\n      var m;\n      _cssContentUnscopedRuleRe.lastIndex = 0;\n\n      while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n        var rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n        r += rule + '\\n\\n';\n      }\n\n      return r;\n    }\n    /*\r\n     * convert a rule like :host(.foo) > .bar { }\r\n     *\r\n     * to\r\n     *\r\n     * .foo<scopeName> > .bar\r\n     */\n\n  }, {\n    key: \"_convertColonHost\",\n    value: function _convertColonHost(cssText) {\n      return cssText.replace(_cssColonHostRe, function (_, hostSelectors, otherSelectors) {\n        if (hostSelectors) {\n          var convertedSelectors = [];\n          var hostSelectorArray = hostSelectors.split(',').map(function (p) {\n            return p.trim();\n          });\n\n          var _iterator8 = _createForOfIteratorHelper(hostSelectorArray),\n              _step8;\n\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var hostSelector = _step8.value;\n              if (!hostSelector) break;\n              var convertedSelector = _polyfillHostNoCombinator + hostSelector.replace(_polyfillHost, '') + otherSelectors;\n              convertedSelectors.push(convertedSelector);\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n\n          return convertedSelectors.join(',');\n        } else {\n          return _polyfillHostNoCombinator + otherSelectors;\n        }\n      });\n    }\n    /*\r\n     * convert a rule like :host-context(.foo) > .bar { }\r\n     *\r\n     * to\r\n     *\r\n     * .foo<scopeName> > .bar, .foo <scopeName> > .bar { }\r\n     *\r\n     * and\r\n     *\r\n     * :host-context(.foo:host) .bar { ... }\r\n     *\r\n     * to\r\n     *\r\n     * .foo<scopeName> .bar { ... }\r\n     */\n\n  }, {\n    key: \"_convertColonHostContext\",\n    value: function _convertColonHostContext(cssText) {\n      return cssText.replace(_cssColonHostContextReGlobal, function (selectorText) {\n        // We have captured a selector that contains a `:host-context` rule.\n        var _a; // For backward compatibility `:host-context` may contain a comma separated list of selectors.\n        // Each context selector group will contain a list of host-context selectors that must match\n        // an ancestor of the host.\n        // (Normally `contextSelectorGroups` will only contain a single array of context selectors.)\n\n\n        var contextSelectorGroups = [[]]; // There may be more than `:host-context` in this selector so `selectorText` could look like:\n        // `:host-context(.one):host-context(.two)`.\n        // Execute `_cssColonHostContextRe` over and over until we have extracted all the\n        // `:host-context` selectors from this selector.\n\n        var match;\n\n        while (match = _cssColonHostContextRe.exec(selectorText)) {\n          // `match` = [':host-context(<selectors>)<rest>', <selectors>, <rest>]\n          // The `<selectors>` could actually be a comma separated list: `:host-context(.one, .two)`.\n          var newContextSelectors = ((_a = match[1]) !== null && _a !== void 0 ? _a : '').trim().split(',').map(function (m) {\n            return m.trim();\n          }).filter(function (m) {\n            return m !== '';\n          }); // We must duplicate the current selector group for each of these new selectors.\n          // For example if the current groups are:\n          // ```\n          // [\n          //   ['a', 'b', 'c'],\n          //   ['x', 'y', 'z'],\n          // ]\n          // ```\n          // And we have a new set of comma separated selectors: `:host-context(m,n)` then the new\n          // groups are:\n          // ```\n          // [\n          //   ['a', 'b', 'c', 'm'],\n          //   ['x', 'y', 'z', 'm'],\n          //   ['a', 'b', 'c', 'n'],\n          //   ['x', 'y', 'z', 'n'],\n          // ]\n          // ```\n\n          var contextSelectorGroupsLength = contextSelectorGroups.length;\n          repeatGroups(contextSelectorGroups, newContextSelectors.length);\n\n          for (var i = 0; i < newContextSelectors.length; i++) {\n            for (var j = 0; j < contextSelectorGroupsLength; j++) {\n              contextSelectorGroups[j + i * contextSelectorGroupsLength].push(newContextSelectors[i]);\n            }\n          } // Update the `selectorText` and see repeat to see if there are more `:host-context`s.\n\n\n          selectorText = match[2];\n        } // The context selectors now must be combined with each other to capture all the possible\n        // selectors that `:host-context` can match. See `combineHostContextSelectors()` for more\n        // info about how this is done.\n\n\n        return contextSelectorGroups.map(function (contextSelectors) {\n          return combineHostContextSelectors(contextSelectors, selectorText);\n        }).join(', ');\n      });\n    }\n    /*\r\n     * Convert combinators like ::shadow and pseudo-elements like ::content\r\n     * by replacing with space.\r\n     */\n\n  }, {\n    key: \"_convertShadowDOMSelectors\",\n    value: function _convertShadowDOMSelectors(cssText) {\n      return _shadowDOMSelectorsRe.reduce(function (result, pattern) {\n        return result.replace(pattern, ' ');\n      }, cssText);\n    } // change a selector like 'div' to 'name div'\n\n  }, {\n    key: \"_scopeSelectors\",\n    value: function _scopeSelectors(cssText, scopeSelector, hostSelector) {\n      var _this120 = this;\n\n      return processRules(cssText, function (rule) {\n        var selector = rule.selector;\n        var content = rule.content;\n\n        if (rule.selector[0] !== '@') {\n          selector = _this120._scopeSelector(rule.selector, scopeSelector, hostSelector, _this120.strictStyling);\n        } else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') || rule.selector.startsWith('@document')) {\n          content = _this120._scopeSelectors(rule.content, scopeSelector, hostSelector);\n        } else if (rule.selector.startsWith('@font-face') || rule.selector.startsWith('@page')) {\n          content = _this120._stripScopingSelectors(rule.content);\n        }\n\n        return new CssRule(selector, content);\n      });\n    }\n    /**\r\n     * Handle a css text that is within a rule that should not contain scope selectors by simply\r\n     * removing them! An example of such a rule is `@font-face`.\r\n     *\r\n     * `@font-face` rules cannot contain nested selectors. Nor can they be nested under a selector.\r\n     * Normally this would be a syntax error by the author of the styles. But in some rare cases, such\r\n     * as importing styles from a library, and applying `:host ::ng-deep` to the imported styles, we\r\n     * can end up with broken css if the imported styles happen to contain @font-face rules.\r\n     *\r\n     * For example:\r\n     *\r\n     * ```\r\n     * :host ::ng-deep {\r\n     *   import 'some/lib/containing/font-face';\r\n     * }\r\n     *\r\n     * Similar logic applies to `@page` rules which can contain a particular set of properties,\r\n     * as well as some specific at-rules. Since they can't be encapsulated, we have to strip\r\n     * any scoping selectors from them. For more information: https://www.w3.org/TR/css-page-3\r\n     * ```\r\n     */\n\n  }, {\n    key: \"_stripScopingSelectors\",\n    value: function _stripScopingSelectors(cssText) {\n      return processRules(cssText, function (rule) {\n        var selector = rule.selector.replace(_shadowDeepSelectors, ' ').replace(_polyfillHostNoCombinatorRe, ' ');\n        return new CssRule(selector, rule.content);\n      });\n    }\n  }, {\n    key: \"_scopeSelector\",\n    value: function _scopeSelector(selector, scopeSelector, hostSelector, strict) {\n      var _this121 = this;\n\n      return selector.split(',').map(function (part) {\n        return part.trim().split(_shadowDeepSelectors);\n      }).map(function (deepParts) {\n        var _deepParts = _toArray(deepParts),\n            shallowPart = _deepParts[0],\n            otherParts = _deepParts.slice(1);\n\n        var applyScope = function applyScope(shallowPart) {\n          if (_this121._selectorNeedsScoping(shallowPart, scopeSelector)) {\n            return strict ? _this121._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) : _this121._applySelectorScope(shallowPart, scopeSelector, hostSelector);\n          } else {\n            return shallowPart;\n          }\n        };\n\n        return [applyScope(shallowPart)].concat(_toConsumableArray(otherParts)).join(' ');\n      }).join(', ');\n    }\n  }, {\n    key: \"_selectorNeedsScoping\",\n    value: function _selectorNeedsScoping(selector, scopeSelector) {\n      var re = this._makeScopeMatcher(scopeSelector);\n\n      return !re.test(selector);\n    }\n  }, {\n    key: \"_makeScopeMatcher\",\n    value: function _makeScopeMatcher(scopeSelector) {\n      var lre = /\\[/g;\n      var rre = /\\]/g;\n      scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n      return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n    }\n  }, {\n    key: \"_applySelectorScope\",\n    value: function _applySelectorScope(selector, scopeSelector, hostSelector) {\n      // Difference from webcomponents.js: scopeSelector could not be an array\n      return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\n    } // scope via name and [is=name]\n\n  }, {\n    key: \"_applySimpleSelectorScope\",\n    value: function _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {\n      // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n      _polyfillHostRe.lastIndex = 0;\n\n      if (_polyfillHostRe.test(selector)) {\n        var replaceBy = this.strictStyling ? \"[\".concat(hostSelector, \"]\") : scopeSelector;\n        return selector.replace(_polyfillHostNoCombinatorRe, function (hnc, selector) {\n          return selector.replace(/([^:]*)(:*)(.*)/, function (_, before, colon, after) {\n            return before + replaceBy + colon + after;\n          });\n        }).replace(_polyfillHostRe, replaceBy + ' ');\n      }\n\n      return scopeSelector + ' ' + selector;\n    } // return a selector with [name] suffix on each simple selector\n    // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */\n\n  }, {\n    key: \"_applyStrictSelectorScope\",\n    value: function _applyStrictSelectorScope(selector, scopeSelector, hostSelector) {\n      var _this122 = this;\n\n      var isRe = /\\[is=([^\\]]*)\\]/g;\n      scopeSelector = scopeSelector.replace(isRe, function (_) {\n        return arguments.length <= 1 ? undefined : arguments[1];\n      });\n      var attrName = '[' + scopeSelector + ']';\n\n      var _scopeSelectorPart = function _scopeSelectorPart(p) {\n        var scopedP = p.trim();\n\n        if (!scopedP) {\n          return '';\n        }\n\n        if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n          scopedP = _this122._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n        } else {\n          // remove :host since it should be unnecessary\n          var t = p.replace(_polyfillHostRe, '');\n\n          if (t.length > 0) {\n            var matches = t.match(/([^:]*)(:*)(.*)/);\n\n            if (matches) {\n              scopedP = matches[1] + attrName + matches[2] + matches[3];\n            }\n          }\n        }\n\n        return scopedP;\n      };\n\n      var safeContent = new SafeSelector(selector);\n      selector = safeContent.content();\n      var scopedSelector = '';\n      var startIndex = 0;\n      var res;\n      var sep = /( |>|\\+|~(?!=))\\s*/g; // If a selector appears before :host it should not be shimmed as it\n      // matches on ancestor elements and not on elements in the host's shadow\n      // `:host-context(div)` is transformed to\n      // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\n      // the `div` is not part of the component in the 2nd selectors and should not be scoped.\n      // Historically `component-tag:host` was matching the component so we also want to preserve\n      // this behavior to avoid breaking legacy apps (it should not match).\n      // The behavior should be:\n      // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\n      // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\n      //   `:host-context(tag)`)\n\n      var hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1; // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present\n\n      var shouldScope = !hasHost;\n\n      while ((res = sep.exec(selector)) !== null) {\n        var separator = res[1];\n\n        var _part = selector.slice(startIndex, res.index).trim();\n\n        shouldScope = shouldScope || _part.indexOf(_polyfillHostNoCombinator) > -1;\n        var scopedPart = shouldScope ? _scopeSelectorPart(_part) : _part;\n        scopedSelector += \"\".concat(scopedPart, \" \").concat(separator, \" \");\n        startIndex = sep.lastIndex;\n      }\n\n      var part = selector.substring(startIndex);\n      shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n      scopedSelector += shouldScope ? _scopeSelectorPart(part) : part; // replace the placeholders with their original values\n\n      return safeContent.restore(scopedSelector);\n    }\n  }, {\n    key: \"_insertPolyfillHostInCssText\",\n    value: function _insertPolyfillHostInCssText(selector) {\n      return selector.replace(_colonHostContextRe, _polyfillHostContext).replace(_colonHostRe, _polyfillHost);\n    }\n  }]);\n\n  return ShadowCss;\n}();\n\nvar SafeSelector = /*#__PURE__*/function () {\n  function SafeSelector(selector) {\n    var _this123 = this;\n\n    _classCallCheck(this, SafeSelector);\n\n    this.placeholders = [];\n    this.index = 0; // Replaces attribute selectors with placeholders.\n    // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n\n    selector = this._escapeRegexMatches(selector, /(\\[[^\\]]*\\])/g); // CSS allows for certain special characters to be used in selectors if they're escaped.\n    // E.g. `.foo:blue` won't match a class called `foo:blue`, because the colon denotes a\n    // pseudo-class, but writing `.foo\\:blue` will match, because the colon was escaped.\n    // Replace all escape sequences (`\\` followed by a character) with a placeholder so\n    // that our handling of pseudo-selectors doesn't mess with them.\n\n    selector = this._escapeRegexMatches(selector, /(\\\\.)/g); // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n    // WS and \"+\" would otherwise be interpreted as selector separators.\n\n    this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, function (_, pseudo, exp) {\n      var replaceBy = \"__ph-\".concat(_this123.index, \"__\");\n\n      _this123.placeholders.push(exp);\n\n      _this123.index++;\n      return pseudo + replaceBy;\n    });\n  }\n\n  _createClass(SafeSelector, [{\n    key: \"restore\",\n    value: function restore(content) {\n      var _this124 = this;\n\n      return content.replace(/__ph-(\\d+)__/g, function (_ph, index) {\n        return _this124.placeholders[+index];\n      });\n    }\n  }, {\n    key: \"content\",\n    value: function content() {\n      return this._content;\n    }\n    /**\r\n     * Replaces all of the substrings that match a regex within a\r\n     * special string (e.g. `__ph-0__`, `__ph-1__`, etc).\r\n     */\n\n  }, {\n    key: \"_escapeRegexMatches\",\n    value: function _escapeRegexMatches(content, pattern) {\n      var _this125 = this;\n\n      return content.replace(pattern, function (_, keep) {\n        var replaceBy = \"__ph-\".concat(_this125.index, \"__\");\n\n        _this125.placeholders.push(keep);\n\n        _this125.index++;\n        return replaceBy;\n      });\n    }\n  }]);\n\n  return SafeSelector;\n}();\n\nvar _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nvar _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nvar _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nvar _polyfillHost = '-shadowcsshost'; // note: :host-context pre-processed to -shadowcsshostcontext.\n\nvar _polyfillHostContext = '-shadowcsscontext';\n\nvar _parenSuffix = '(?:\\\\((' + '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' + ')\\\\))?([^,{]*)';\n\nvar _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix, 'gim');\n\nvar _cssColonHostContextReGlobal = new RegExp(_polyfillHostContext + _parenSuffix, 'gim');\n\nvar _cssColonHostContextRe = new RegExp(_polyfillHostContext + _parenSuffix, 'im');\n\nvar _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\n\nvar _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nvar _shadowDOMSelectorsRe = [/::shadow/g, /::content/g, // Deprecated selectors\n/\\/shadow-deep\\//g, /\\/shadow\\//g]; // The deep combinator is deprecated in the CSS spec\n// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.\n// see https://github.com/angular/angular/pull/17677\n\nvar _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\nvar _selectorReSuffix = '([>\\\\s~+\\[.,{:][\\\\s\\\\S]*)?$';\nvar _polyfillHostRe = /-shadowcsshost/gim;\nvar _colonHostRe = /:host/gim;\nvar _colonHostContextRe = /:host-context/gim;\nvar _commentRe = /\\/\\*\\s*[\\s\\S]*?\\*\\//g;\n\nfunction stripComments(input) {\n  return input.replace(_commentRe, '');\n}\n\nvar _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=[\\s\\S]+?\\*\\//g;\n\nfunction extractCommentsWithHash(input) {\n  return input.match(_commentWithHashRe) || [];\n}\n\nvar BLOCK_PLACEHOLDER = '%BLOCK%';\nvar QUOTE_PLACEHOLDER = '%QUOTED%';\nvar _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nvar _quotedRe = /%QUOTED%/g;\nvar CONTENT_PAIRS = new Map([['{', '}']]);\nvar QUOTE_PAIRS = new Map([[\"\\\"\", \"\\\"\"], [\"'\", \"'\"]]);\n\nvar CssRule = function CssRule(selector, content) {\n  _classCallCheck(this, CssRule);\n\n  this.selector = selector;\n  this.content = content;\n};\n\nfunction processRules(input, ruleCallback) {\n  var inputWithEscapedQuotes = escapeBlocks(input, QUOTE_PAIRS, QUOTE_PLACEHOLDER);\n  var inputWithEscapedBlocks = escapeBlocks(inputWithEscapedQuotes.escapedString, CONTENT_PAIRS, BLOCK_PLACEHOLDER);\n  var nextBlockIndex = 0;\n  var nextQuoteIndex = 0;\n  return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function () {\n    var selector = arguments.length <= 2 ? undefined : arguments[2];\n    var content = '';\n    var suffix = arguments.length <= 4 ? undefined : arguments[4];\n    var contentPrefix = '';\n\n    if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n      content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n      suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n      contentPrefix = '{';\n    }\n\n    var rule = ruleCallback(new CssRule(selector, content));\n    return \"\".concat(arguments.length <= 1 ? undefined : arguments[1]).concat(rule.selector).concat(arguments.length <= 3 ? undefined : arguments[3]).concat(contentPrefix).concat(rule.content).concat(suffix);\n  }).replace(_quotedRe, function () {\n    return inputWithEscapedQuotes.blocks[nextQuoteIndex++];\n  });\n}\n\nvar StringWithEscapedBlocks = function StringWithEscapedBlocks(escapedString, blocks) {\n  _classCallCheck(this, StringWithEscapedBlocks);\n\n  this.escapedString = escapedString;\n  this.blocks = blocks;\n};\n\nfunction escapeBlocks(input, charPairs, placeholder) {\n  var resultParts = [];\n  var escapedBlocks = [];\n  var openCharCount = 0;\n  var nonBlockStartIndex = 0;\n  var blockStartIndex = -1;\n  var openChar;\n  var closeChar;\n\n  for (var i = 0; i < input.length; i++) {\n    var char = input[i];\n\n    if (char === '\\\\') {\n      i++;\n    } else if (char === closeChar) {\n      openCharCount--;\n\n      if (openCharCount === 0) {\n        escapedBlocks.push(input.substring(blockStartIndex, i));\n        resultParts.push(placeholder);\n        nonBlockStartIndex = i;\n        blockStartIndex = -1;\n        openChar = closeChar = undefined;\n      }\n    } else if (char === openChar) {\n      openCharCount++;\n    } else if (openCharCount === 0 && charPairs.has(char)) {\n      openChar = char;\n      closeChar = charPairs.get(char);\n      openCharCount = 1;\n      blockStartIndex = i + 1;\n      resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));\n    }\n  }\n\n  if (blockStartIndex !== -1) {\n    escapedBlocks.push(input.substring(blockStartIndex));\n    resultParts.push(placeholder);\n  } else {\n    resultParts.push(input.substring(nonBlockStartIndex));\n  }\n\n  return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n/**\r\n * Combine the `contextSelectors` with the `hostMarker` and the `otherSelectors`\r\n * to create a selector that matches the same as `:host-context()`.\r\n *\r\n * Given a single context selector `A` we need to output selectors that match on the host and as an\r\n * ancestor of the host:\r\n *\r\n * ```\r\n * A <hostMarker>, A<hostMarker> {}\r\n * ```\r\n *\r\n * When there is more than one context selector we also have to create combinations of those\r\n * selectors with each other. For example if there are `A` and `B` selectors the output is:\r\n *\r\n * ```\r\n * AB<hostMarker>, AB <hostMarker>, A B<hostMarker>,\r\n * B A<hostMarker>, A B <hostMarker>, B A <hostMarker> {}\r\n * ```\r\n *\r\n * And so on...\r\n *\r\n * @param hostMarker the string that selects the host element.\r\n * @param contextSelectors an array of context selectors that will be combined.\r\n * @param otherSelectors the rest of the selectors that are not context selectors.\r\n */\n\n\nfunction combineHostContextSelectors(contextSelectors, otherSelectors) {\n  var hostMarker = _polyfillHostNoCombinator;\n  _polyfillHostRe.lastIndex = 0; // reset the regex to ensure we get an accurate test\n\n  var otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors); // If there are no context selectors then just output a host marker\n\n\n  if (contextSelectors.length === 0) {\n    return hostMarker + otherSelectors;\n  }\n\n  var combined = [contextSelectors.pop() || ''];\n\n  while (contextSelectors.length > 0) {\n    var length = combined.length;\n    var contextSelector = contextSelectors.pop();\n\n    for (var i = 0; i < length; i++) {\n      var previousSelectors = combined[i]; // Add the new selector as a descendant of the previous selectors\n\n      combined[length * 2 + i] = previousSelectors + ' ' + contextSelector; // Add the new selector as an ancestor of the previous selectors\n\n      combined[length + i] = contextSelector + ' ' + previousSelectors; // Add the new selector to act on the same element as the previous selectors\n\n      combined[i] = contextSelector + previousSelectors;\n    }\n  } // Finally connect the selector to the `hostMarker`s: either acting directly on the host\n  // (A<hostMarker>) or as an ancestor (A <hostMarker>).\n\n\n  return combined.map(function (s) {\n    return otherSelectorsHasHost ? \"\".concat(s).concat(otherSelectors) : \"\".concat(s).concat(hostMarker).concat(otherSelectors, \", \").concat(s, \" \").concat(hostMarker).concat(otherSelectors);\n  }).join(',');\n}\n/**\r\n * Mutate the given `groups` array so that there are `multiples` clones of the original array\r\n * stored.\r\n *\r\n * For example `repeatGroups([a, b], 3)` will result in `[a, b, a, b, a, b]` - but importantly the\r\n * newly added groups will be clones of the original.\r\n *\r\n * @param groups An array of groups of strings that will be repeated. This array is mutated\r\n *     in-place.\r\n * @param multiples The number of times the current groups should appear.\r\n */\n\n\nfunction repeatGroups(groups, multiples) {\n  var length = groups.length;\n\n  for (var i = 1; i < multiples; i++) {\n    for (var j = 0; j < length; j++) {\n      groups[j + i * length] = groups[j].slice(0);\n    }\n  }\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar COMPONENT_VARIABLE = '%COMP%';\nvar HOST_ATTR = \"_nghost-\".concat(COMPONENT_VARIABLE);\nvar CONTENT_ATTR = \"_ngcontent-\".concat(COMPONENT_VARIABLE);\n\nvar StylesCompileDependency = function StylesCompileDependency(name, moduleUrl, setValue) {\n  _classCallCheck(this, StylesCompileDependency);\n\n  this.name = name;\n  this.moduleUrl = moduleUrl;\n  this.setValue = setValue;\n};\n\nvar CompiledStylesheet = function CompiledStylesheet(outputCtx, stylesVar, dependencies, isShimmed, meta) {\n  _classCallCheck(this, CompiledStylesheet);\n\n  this.outputCtx = outputCtx;\n  this.stylesVar = stylesVar;\n  this.dependencies = dependencies;\n  this.isShimmed = isShimmed;\n  this.meta = meta;\n};\n\nvar StyleCompiler = /*#__PURE__*/function () {\n  function StyleCompiler(_urlResolver) {\n    _classCallCheck(this, StyleCompiler);\n\n    this._urlResolver = _urlResolver;\n    this._shadowCss = new ShadowCss();\n  }\n\n  _createClass(StyleCompiler, [{\n    key: \"compileComponent\",\n    value: function compileComponent(outputCtx, comp) {\n      var template = comp.template;\n      return this._compileStyles(outputCtx, comp, new CompileStylesheetMetadata({\n        styles: template.styles,\n        styleUrls: template.styleUrls,\n        moduleUrl: identifierModuleUrl(comp.type)\n      }), this.needsStyleShim(comp), true);\n    }\n  }, {\n    key: \"compileStyles\",\n    value: function compileStyles(outputCtx, comp, stylesheet) {\n      var shim = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.needsStyleShim(comp);\n      return this._compileStyles(outputCtx, comp, stylesheet, shim, false);\n    }\n  }, {\n    key: \"needsStyleShim\",\n    value: function needsStyleShim(comp) {\n      return comp.template.encapsulation === ViewEncapsulation.Emulated;\n    }\n  }, {\n    key: \"_compileStyles\",\n    value: function _compileStyles(outputCtx, comp, stylesheet, shim, isComponentStylesheet) {\n      var _this126 = this;\n\n      var styleExpressions = stylesheet.styles.map(function (plainStyle) {\n        return literal(_this126._shimIfNeeded(plainStyle, shim));\n      });\n      var dependencies = [];\n      stylesheet.styleUrls.forEach(function (styleUrl) {\n        var exprIndex = styleExpressions.length; // Note: This placeholder will be filled later.\n\n        styleExpressions.push(null);\n        dependencies.push(new StylesCompileDependency(getStylesVarName(null), styleUrl, function (value) {\n          return styleExpressions[exprIndex] = outputCtx.importExpr(value);\n        }));\n      }); // styles variable contains plain strings and arrays of other styles arrays (recursive),\n      // so we set its type to dynamic.\n\n      var stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);\n      var stmt = variable(stylesVar).set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const]))).toDeclStmt(null, isComponentStylesheet ? [StmtModifier.Final] : [StmtModifier.Final, StmtModifier.Exported]);\n      outputCtx.statements.push(stmt);\n      return new CompiledStylesheet(outputCtx, stylesVar, dependencies, shim, stylesheet);\n    }\n  }, {\n    key: \"_shimIfNeeded\",\n    value: function _shimIfNeeded(style, shim) {\n      return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;\n    }\n  }]);\n\n  return StyleCompiler;\n}();\n\nfunction getStylesVarName(component) {\n  var result = \"styles\";\n\n  if (component) {\n    result += \"_\".concat(identifierName(component.type));\n  }\n\n  return result;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * A path is an ordered set of elements. Typically a path is to  a\r\n * particular offset in a source file. The head of the list is the top\r\n * most node. The tail is the node that contains the offset directly.\r\n *\r\n * For example, the expression `a + b + c` might have an ast that looks\r\n * like:\r\n *     +\r\n *    / \\\r\n *   a   +\r\n *      / \\\r\n *     b   c\r\n *\r\n * The path to the node at offset 9 would be `['+' at 1-10, '+' at 7-10,\r\n * 'c' at 9-10]` and the path the node at offset 1 would be\r\n * `['+' at 1-10, 'a' at 1-2]`.\r\n */\n\n\nvar AstPath = /*#__PURE__*/function () {\n  function AstPath(path) {\n    var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n    _classCallCheck(this, AstPath);\n\n    this.path = path;\n    this.position = position;\n  }\n\n  _createClass(AstPath, [{\n    key: \"empty\",\n    get: function get() {\n      return !this.path || !this.path.length;\n    }\n  }, {\n    key: \"head\",\n    get: function get() {\n      return this.path[0];\n    }\n  }, {\n    key: \"tail\",\n    get: function get() {\n      return this.path[this.path.length - 1];\n    }\n  }, {\n    key: \"parentOf\",\n    value: function parentOf(node) {\n      return node && this.path[this.path.indexOf(node) - 1];\n    }\n  }, {\n    key: \"childOf\",\n    value: function childOf(node) {\n      return this.path[this.path.indexOf(node) + 1];\n    }\n  }, {\n    key: \"first\",\n    value: function first(ctor) {\n      for (var i = this.path.length - 1; i >= 0; i--) {\n        var item = this.path[i];\n        if (item instanceof ctor) return item;\n      }\n    }\n  }, {\n    key: \"push\",\n    value: function push(node) {\n      this.path.push(node);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      return this.path.pop();\n    }\n  }]);\n\n  return AstPath;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar NodeWithI18n = function NodeWithI18n(sourceSpan, i18n) {\n  _classCallCheck(this, NodeWithI18n);\n\n  this.sourceSpan = sourceSpan;\n  this.i18n = i18n;\n};\n\nvar Text$3 = /*#__PURE__*/function (_NodeWithI18n) {\n  _inherits(Text$3, _NodeWithI18n);\n\n  var _super82 = _createSuper(Text$3);\n\n  function Text$3(value, sourceSpan, i18n) {\n    var _this127;\n\n    _classCallCheck(this, Text$3);\n\n    _this127 = _super82.call(this, sourceSpan, i18n);\n    _this127.value = value;\n    return _this127;\n  }\n\n  _createClass(Text$3, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitText(this, context);\n    }\n  }]);\n\n  return Text$3;\n}(NodeWithI18n);\n\nvar Expansion = /*#__PURE__*/function (_NodeWithI18n2) {\n  _inherits(Expansion, _NodeWithI18n2);\n\n  var _super83 = _createSuper(Expansion);\n\n  function Expansion(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {\n    var _this128;\n\n    _classCallCheck(this, Expansion);\n\n    _this128 = _super83.call(this, sourceSpan, i18n);\n    _this128.switchValue = switchValue;\n    _this128.type = type;\n    _this128.cases = cases;\n    _this128.switchValueSourceSpan = switchValueSourceSpan;\n    return _this128;\n  }\n\n  _createClass(Expansion, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitExpansion(this, context);\n    }\n  }]);\n\n  return Expansion;\n}(NodeWithI18n);\n\nvar ExpansionCase = /*#__PURE__*/function () {\n  function ExpansionCase(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {\n    _classCallCheck(this, ExpansionCase);\n\n    this.value = value;\n    this.expression = expression;\n    this.sourceSpan = sourceSpan;\n    this.valueSourceSpan = valueSourceSpan;\n    this.expSourceSpan = expSourceSpan;\n  }\n\n  _createClass(ExpansionCase, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitExpansionCase(this, context);\n    }\n  }]);\n\n  return ExpansionCase;\n}();\n\nvar Attribute = /*#__PURE__*/function (_NodeWithI18n3) {\n  _inherits(Attribute, _NodeWithI18n3);\n\n  var _super84 = _createSuper(Attribute);\n\n  function Attribute(name, value, sourceSpan, keySpan, valueSpan, i18n) {\n    var _this129;\n\n    _classCallCheck(this, Attribute);\n\n    _this129 = _super84.call(this, sourceSpan, i18n);\n    _this129.name = name;\n    _this129.value = value;\n    _this129.keySpan = keySpan;\n    _this129.valueSpan = valueSpan;\n    return _this129;\n  }\n\n  _createClass(Attribute, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitAttribute(this, context);\n    }\n  }]);\n\n  return Attribute;\n}(NodeWithI18n);\n\nvar Element$1 = /*#__PURE__*/function (_NodeWithI18n4) {\n  _inherits(Element$1, _NodeWithI18n4);\n\n  var _super85 = _createSuper(Element$1);\n\n  function Element$1(name, attrs, children, sourceSpan, startSourceSpan) {\n    var _this130;\n\n    var endSourceSpan = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    var i18n = arguments.length > 6 ? arguments[6] : undefined;\n\n    _classCallCheck(this, Element$1);\n\n    _this130 = _super85.call(this, sourceSpan, i18n);\n    _this130.name = name;\n    _this130.attrs = attrs;\n    _this130.children = children;\n    _this130.startSourceSpan = startSourceSpan;\n    _this130.endSourceSpan = endSourceSpan;\n    return _this130;\n  }\n\n  _createClass(Element$1, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitElement(this, context);\n    }\n  }]);\n\n  return Element$1;\n}(NodeWithI18n);\n\nvar Comment$1 = /*#__PURE__*/function () {\n  function Comment$1(value, sourceSpan) {\n    _classCallCheck(this, Comment$1);\n\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(Comment$1, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitComment(this, context);\n    }\n  }]);\n\n  return Comment$1;\n}();\n\nfunction visitAll$1(visitor, nodes) {\n  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var result = [];\n  var visit = visitor.visit ? function (ast) {\n    return visitor.visit(ast, context) || ast.visit(visitor, context);\n  } : function (ast) {\n    return ast.visit(visitor, context);\n  };\n  nodes.forEach(function (ast) {\n    var astResult = visit(ast);\n\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n\nvar RecursiveVisitor$1 = /*#__PURE__*/function () {\n  function RecursiveVisitor$1() {\n    _classCallCheck(this, RecursiveVisitor$1);\n  }\n\n  _createClass(RecursiveVisitor$1, [{\n    key: \"visitElement\",\n    value: function visitElement(ast, context) {\n      this.visitChildren(context, function (visit) {\n        visit(ast.attrs);\n        visit(ast.children);\n      });\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(ast, context) {}\n  }, {\n    key: \"visitText\",\n    value: function visitText(ast, context) {}\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(ast, context) {}\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(ast, context) {\n      return this.visitChildren(context, function (visit) {\n        visit(ast.cases);\n      });\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(ast, context) {}\n  }, {\n    key: \"visitChildren\",\n    value: function visitChildren(context, cb) {\n      var results = [];\n      var t = this;\n\n      function visit(children) {\n        if (children) results.push(visitAll$1(t, children, context));\n      }\n\n      cb(visit);\n      return Array.prototype.concat.apply([], results);\n    }\n  }]);\n\n  return RecursiveVisitor$1;\n}();\n\nfunction spanOf(ast) {\n  var start = ast.sourceSpan.start.offset;\n  var end = ast.sourceSpan.end.offset;\n\n  if (ast instanceof Element$1) {\n    if (ast.endSourceSpan) {\n      end = ast.endSourceSpan.end.offset;\n    } else if (ast.children && ast.children.length) {\n      end = spanOf(ast.children[ast.children.length - 1]).end;\n    }\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n\nfunction findNode(nodes, position) {\n  var path = [];\n  var visitor = new ( /*#__PURE__*/function (_RecursiveVisitor$) {\n    _inherits(_class, _RecursiveVisitor$);\n\n    var _super86 = _createSuper(_class);\n\n    function _class() {\n      _classCallCheck(this, _class);\n\n      return _super86.apply(this, arguments);\n    }\n\n    _createClass(_class, [{\n      key: \"visit\",\n      value: function visit(ast, context) {\n        var span = spanOf(ast);\n\n        if (span.start <= position && position < span.end) {\n          path.push(ast);\n        } else {\n          // Returning a value here will result in the children being skipped.\n          return true;\n        }\n      }\n    }]);\n\n    return _class;\n  }(RecursiveVisitor$1))();\n  visitAll$1(visitor, nodes);\n  return new AstPath(path, position);\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar TokenType;\n\n(function (TokenType) {\n  TokenType[TokenType[\"TAG_OPEN_START\"] = 0] = \"TAG_OPEN_START\";\n  TokenType[TokenType[\"TAG_OPEN_END\"] = 1] = \"TAG_OPEN_END\";\n  TokenType[TokenType[\"TAG_OPEN_END_VOID\"] = 2] = \"TAG_OPEN_END_VOID\";\n  TokenType[TokenType[\"TAG_CLOSE\"] = 3] = \"TAG_CLOSE\";\n  TokenType[TokenType[\"INCOMPLETE_TAG_OPEN\"] = 4] = \"INCOMPLETE_TAG_OPEN\";\n  TokenType[TokenType[\"TEXT\"] = 5] = \"TEXT\";\n  TokenType[TokenType[\"ESCAPABLE_RAW_TEXT\"] = 6] = \"ESCAPABLE_RAW_TEXT\";\n  TokenType[TokenType[\"RAW_TEXT\"] = 7] = \"RAW_TEXT\";\n  TokenType[TokenType[\"COMMENT_START\"] = 8] = \"COMMENT_START\";\n  TokenType[TokenType[\"COMMENT_END\"] = 9] = \"COMMENT_END\";\n  TokenType[TokenType[\"CDATA_START\"] = 10] = \"CDATA_START\";\n  TokenType[TokenType[\"CDATA_END\"] = 11] = \"CDATA_END\";\n  TokenType[TokenType[\"ATTR_NAME\"] = 12] = \"ATTR_NAME\";\n  TokenType[TokenType[\"ATTR_QUOTE\"] = 13] = \"ATTR_QUOTE\";\n  TokenType[TokenType[\"ATTR_VALUE\"] = 14] = \"ATTR_VALUE\";\n  TokenType[TokenType[\"DOC_TYPE\"] = 15] = \"DOC_TYPE\";\n  TokenType[TokenType[\"EXPANSION_FORM_START\"] = 16] = \"EXPANSION_FORM_START\";\n  TokenType[TokenType[\"EXPANSION_CASE_VALUE\"] = 17] = \"EXPANSION_CASE_VALUE\";\n  TokenType[TokenType[\"EXPANSION_CASE_EXP_START\"] = 18] = \"EXPANSION_CASE_EXP_START\";\n  TokenType[TokenType[\"EXPANSION_CASE_EXP_END\"] = 19] = \"EXPANSION_CASE_EXP_END\";\n  TokenType[TokenType[\"EXPANSION_FORM_END\"] = 20] = \"EXPANSION_FORM_END\";\n  TokenType[TokenType[\"EOF\"] = 21] = \"EOF\";\n})(TokenType || (TokenType = {}));\n\nvar Token = function Token(type, parts, sourceSpan) {\n  _classCallCheck(this, Token);\n\n  this.type = type;\n  this.parts = parts;\n  this.sourceSpan = sourceSpan;\n};\n\nvar TokenError = /*#__PURE__*/function (_ParseError) {\n  _inherits(TokenError, _ParseError);\n\n  var _super87 = _createSuper(TokenError);\n\n  function TokenError(errorMsg, tokenType, span) {\n    var _this131;\n\n    _classCallCheck(this, TokenError);\n\n    _this131 = _super87.call(this, span, errorMsg);\n    _this131.tokenType = tokenType;\n    return _this131;\n  }\n\n  return TokenError;\n}(ParseError);\n\nvar TokenizeResult = function TokenizeResult(tokens, errors, nonNormalizedIcuExpressions) {\n  _classCallCheck(this, TokenizeResult);\n\n  this.tokens = tokens;\n  this.errors = errors;\n  this.nonNormalizedIcuExpressions = nonNormalizedIcuExpressions;\n};\n\nfunction tokenize(source, url, getTagDefinition) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);\n  tokenizer.tokenize();\n  return new TokenizeResult(mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);\n}\n\nvar _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n\nfunction _unexpectedCharacterErrorMsg(charCode) {\n  var char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);\n  return \"Unexpected character \\\"\".concat(char, \"\\\"\");\n}\n\nfunction _unknownEntityErrorMsg(entitySrc) {\n  return \"Unknown entity \\\"\".concat(entitySrc, \"\\\" - use the \\\"&#<decimal>;\\\" or  \\\"&#x<hex>;\\\" syntax\");\n}\n\nfunction _unparsableEntityErrorMsg(type, entityStr) {\n  return \"Unable to parse entity \\\"\".concat(entityStr, \"\\\" - \").concat(type, \" character reference entities must end with \\\";\\\"\");\n}\n\nvar CharacterReferenceType;\n\n(function (CharacterReferenceType) {\n  CharacterReferenceType[\"HEX\"] = \"hexadecimal\";\n  CharacterReferenceType[\"DEC\"] = \"decimal\";\n})(CharacterReferenceType || (CharacterReferenceType = {}));\n\nvar _ControlFlowError = function _ControlFlowError(error) {\n  _classCallCheck(this, _ControlFlowError);\n\n  this.error = error;\n}; // See https://www.w3.org/TR/html51/syntax.html#writing-html-documents\n\n\nvar _Tokenizer = /*#__PURE__*/function () {\n  /**\r\n   * @param _file The html source file being tokenized.\r\n   * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.\r\n   * @param options Configuration of the tokenization.\r\n   */\n  function _Tokenizer(_file, _getTagDefinition, options) {\n    _classCallCheck(this, _Tokenizer);\n\n    this._getTagDefinition = _getTagDefinition;\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    this._expansionCaseStack = [];\n    this._inInterpolation = false;\n    this.tokens = [];\n    this.errors = [];\n    this.nonNormalizedIcuExpressions = [];\n    this._tokenizeIcu = options.tokenizeExpansionForms || false;\n    this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n    this._leadingTriviaCodePoints = options.leadingTriviaChars && options.leadingTriviaChars.map(function (c) {\n      return c.codePointAt(0) || 0;\n    });\n    var range = options.range || {\n      endPos: _file.content.length,\n      startPos: 0,\n      startLine: 0,\n      startCol: 0\n    };\n    this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) : new PlainCharacterCursor(_file, range);\n    this._preserveLineEndings = options.preserveLineEndings || false;\n    this._escapedString = options.escapedString || false;\n    this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;\n\n    try {\n      this._cursor.init();\n    } catch (e) {\n      this.handleError(e);\n    }\n  }\n\n  _createClass(_Tokenizer, [{\n    key: \"_processCarriageReturns\",\n    value: function _processCarriageReturns(content) {\n      if (this._preserveLineEndings) {\n        return content;\n      } // https://www.w3.org/TR/html51/syntax.html#preprocessing-the-input-stream\n      // In order to keep the original position in the source, we can not\n      // pre-process it.\n      // Instead CRs are processed right before instantiating the tokens.\n\n\n      return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n    }\n  }, {\n    key: \"tokenize\",\n    value: function tokenize() {\n      while (this._cursor.peek() !== $EOF) {\n        var _start2 = this._cursor.clone();\n\n        try {\n          if (this._attemptCharCode($LT)) {\n            if (this._attemptCharCode($BANG)) {\n              if (this._attemptCharCode($LBRACKET)) {\n                this._consumeCdata(_start2);\n              } else if (this._attemptCharCode($MINUS)) {\n                this._consumeComment(_start2);\n              } else {\n                this._consumeDocType(_start2);\n              }\n            } else if (this._attemptCharCode($SLASH)) {\n              this._consumeTagClose(_start2);\n            } else {\n              this._consumeTagOpen(_start2);\n            }\n          } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n            this._consumeText();\n          }\n        } catch (e) {\n          this.handleError(e);\n        }\n      }\n\n      this._beginToken(TokenType.EOF);\n\n      this._endToken([]);\n    }\n    /**\r\n     * @returns whether an ICU token has been created\r\n     * @internal\r\n     */\n\n  }, {\n    key: \"_tokenizeExpansionForm\",\n    value: function _tokenizeExpansionForm() {\n      if (this.isExpansionFormStart()) {\n        this._consumeExpansionFormStart();\n\n        return true;\n      }\n\n      if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {\n        this._consumeExpansionCaseStart();\n\n        return true;\n      }\n\n      if (this._cursor.peek() === $RBRACE) {\n        if (this._isInExpansionCase()) {\n          this._consumeExpansionCaseEnd();\n\n          return true;\n        }\n\n        if (this._isInExpansionForm()) {\n          this._consumeExpansionFormEnd();\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_beginToken\",\n    value: function _beginToken(type) {\n      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._cursor.clone();\n      this._currentTokenStart = start;\n      this._currentTokenType = type;\n    }\n  }, {\n    key: \"_endToken\",\n    value: function _endToken(parts, end) {\n      if (this._currentTokenStart === null) {\n        throw new TokenError('Programming error - attempted to end a token when there was no start to the token', this._currentTokenType, this._cursor.getSpan(end));\n      }\n\n      if (this._currentTokenType === null) {\n        throw new TokenError('Programming error - attempted to end a token which has no token type', null, this._cursor.getSpan(this._currentTokenStart));\n      }\n\n      var token = new Token(this._currentTokenType, parts, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));\n      this.tokens.push(token);\n      this._currentTokenStart = null;\n      this._currentTokenType = null;\n      return token;\n    }\n  }, {\n    key: \"_createError\",\n    value: function _createError(msg, span) {\n      if (this._isInExpansionForm()) {\n        msg += \" (Do you have an unescaped \\\"{\\\" in your template? Use \\\"{{ '{' }}\\\") to escape it.)\";\n      }\n\n      var error = new TokenError(msg, this._currentTokenType, span);\n      this._currentTokenStart = null;\n      this._currentTokenType = null;\n      return new _ControlFlowError(error);\n    }\n  }, {\n    key: \"handleError\",\n    value: function handleError(e) {\n      if (e instanceof CursorError) {\n        e = this._createError(e.msg, this._cursor.getSpan(e.cursor));\n      }\n\n      if (e instanceof _ControlFlowError) {\n        this.errors.push(e.error);\n      } else {\n        throw e;\n      }\n    }\n  }, {\n    key: \"_attemptCharCode\",\n    value: function _attemptCharCode(charCode) {\n      if (this._cursor.peek() === charCode) {\n        this._cursor.advance();\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_attemptCharCodeCaseInsensitive\",\n    value: function _attemptCharCodeCaseInsensitive(charCode) {\n      if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {\n        this._cursor.advance();\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_requireCharCode\",\n    value: function _requireCharCode(charCode) {\n      var location = this._cursor.clone();\n\n      if (!this._attemptCharCode(charCode)) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n      }\n    }\n  }, {\n    key: \"_attemptStr\",\n    value: function _attemptStr(chars) {\n      var len = chars.length;\n\n      if (this._cursor.charsLeft() < len) {\n        return false;\n      }\n\n      var initialPosition = this._cursor.clone();\n\n      for (var i = 0; i < len; i++) {\n        if (!this._attemptCharCode(chars.charCodeAt(i))) {\n          // If attempting to parse the string fails, we want to reset the parser\n          // to where it was before the attempt\n          this._cursor = initialPosition;\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_attemptStrCaseInsensitive\",\n    value: function _attemptStrCaseInsensitive(chars) {\n      for (var i = 0; i < chars.length; i++) {\n        if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_requireStr\",\n    value: function _requireStr(chars) {\n      var location = this._cursor.clone();\n\n      if (!this._attemptStr(chars)) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n      }\n    }\n  }, {\n    key: \"_attemptCharCodeUntilFn\",\n    value: function _attemptCharCodeUntilFn(predicate) {\n      while (!predicate(this._cursor.peek())) {\n        this._cursor.advance();\n      }\n    }\n  }, {\n    key: \"_requireCharCodeUntilFn\",\n    value: function _requireCharCodeUntilFn(predicate, len) {\n      var start = this._cursor.clone();\n\n      this._attemptCharCodeUntilFn(predicate);\n\n      if (this._cursor.diff(start) < len) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n      }\n    }\n  }, {\n    key: \"_attemptUntilChar\",\n    value: function _attemptUntilChar(char) {\n      while (this._cursor.peek() !== char) {\n        this._cursor.advance();\n      }\n    }\n  }, {\n    key: \"_readChar\",\n    value: function _readChar(decodeEntities) {\n      if (decodeEntities && this._cursor.peek() === $AMPERSAND) {\n        return this._decodeEntity();\n      } else {\n        // Don't rely upon reading directly from `_input` as the actual char value\n        // may have been generated from an escape sequence.\n        var char = String.fromCodePoint(this._cursor.peek());\n\n        this._cursor.advance();\n\n        return char;\n      }\n    }\n  }, {\n    key: \"_decodeEntity\",\n    value: function _decodeEntity() {\n      var start = this._cursor.clone();\n\n      this._cursor.advance();\n\n      if (this._attemptCharCode($HASH)) {\n        var isHex = this._attemptCharCode($x) || this._attemptCharCode($X);\n\n        var codeStart = this._cursor.clone();\n\n        this._attemptCharCodeUntilFn(isDigitEntityEnd);\n\n        if (this._cursor.peek() != $SEMICOLON) {\n          // Advance cursor to include the peeked character in the string provided to the error\n          // message.\n          this._cursor.advance();\n\n          var entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;\n          throw this._createError(_unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)), this._cursor.getSpan());\n        }\n\n        var strNum = this._cursor.getChars(codeStart);\n\n        this._cursor.advance();\n\n        try {\n          var charCode = parseInt(strNum, isHex ? 16 : 10);\n          return String.fromCharCode(charCode);\n        } catch (_a) {\n          throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());\n        }\n      } else {\n        var nameStart = this._cursor.clone();\n\n        this._attemptCharCodeUntilFn(isNamedEntityEnd);\n\n        if (this._cursor.peek() != $SEMICOLON) {\n          this._cursor = nameStart;\n          return '&';\n        }\n\n        var name = this._cursor.getChars(nameStart);\n\n        this._cursor.advance();\n\n        var char = NAMED_ENTITIES[name];\n\n        if (!char) {\n          throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));\n        }\n\n        return char;\n      }\n    }\n  }, {\n    key: \"_consumeRawText\",\n    value: function _consumeRawText(decodeEntities, endMarkerPredicate) {\n      this._beginToken(decodeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT);\n\n      var parts = [];\n\n      while (true) {\n        var tagCloseStart = this._cursor.clone();\n\n        var foundEndMarker = endMarkerPredicate();\n        this._cursor = tagCloseStart;\n\n        if (foundEndMarker) {\n          break;\n        }\n\n        parts.push(this._readChar(decodeEntities));\n      }\n\n      return this._endToken([this._processCarriageReturns(parts.join(''))]);\n    }\n  }, {\n    key: \"_consumeComment\",\n    value: function _consumeComment(start) {\n      var _this132 = this;\n\n      this._beginToken(TokenType.COMMENT_START, start);\n\n      this._requireCharCode($MINUS);\n\n      this._endToken([]);\n\n      this._consumeRawText(false, function () {\n        return _this132._attemptStr('-->');\n      });\n\n      this._beginToken(TokenType.COMMENT_END);\n\n      this._requireStr('-->');\n\n      this._endToken([]);\n    }\n  }, {\n    key: \"_consumeCdata\",\n    value: function _consumeCdata(start) {\n      var _this133 = this;\n\n      this._beginToken(TokenType.CDATA_START, start);\n\n      this._requireStr('CDATA[');\n\n      this._endToken([]);\n\n      this._consumeRawText(false, function () {\n        return _this133._attemptStr(']]>');\n      });\n\n      this._beginToken(TokenType.CDATA_END);\n\n      this._requireStr(']]>');\n\n      this._endToken([]);\n    }\n  }, {\n    key: \"_consumeDocType\",\n    value: function _consumeDocType(start) {\n      this._beginToken(TokenType.DOC_TYPE, start);\n\n      var contentStart = this._cursor.clone();\n\n      this._attemptUntilChar($GT);\n\n      var content = this._cursor.getChars(contentStart);\n\n      this._cursor.advance();\n\n      this._endToken([content]);\n    }\n  }, {\n    key: \"_consumePrefixAndName\",\n    value: function _consumePrefixAndName() {\n      var nameOrPrefixStart = this._cursor.clone();\n\n      var prefix = '';\n\n      while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {\n        this._cursor.advance();\n      }\n\n      var nameStart;\n\n      if (this._cursor.peek() === $COLON) {\n        prefix = this._cursor.getChars(nameOrPrefixStart);\n\n        this._cursor.advance();\n\n        nameStart = this._cursor.clone();\n      } else {\n        nameStart = nameOrPrefixStart;\n      }\n\n      this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);\n\n      var name = this._cursor.getChars(nameStart);\n\n      return [prefix, name];\n    }\n  }, {\n    key: \"_consumeTagOpen\",\n    value: function _consumeTagOpen(start) {\n      var tagName;\n      var prefix;\n      var openTagToken;\n\n      try {\n        if (!isAsciiLetter(this._cursor.peek())) {\n          throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n        }\n\n        openTagToken = this._consumeTagOpenStart(start);\n        prefix = openTagToken.parts[0];\n        tagName = openTagToken.parts[1];\n\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n\n        while (this._cursor.peek() !== $SLASH && this._cursor.peek() !== $GT && this._cursor.peek() !== $LT && this._cursor.peek() !== $EOF) {\n          this._consumeAttributeName();\n\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n\n          if (this._attemptCharCode($EQ)) {\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n\n            this._consumeAttributeValue();\n          }\n\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n        }\n\n        this._consumeTagOpenEnd();\n      } catch (e) {\n        if (e instanceof _ControlFlowError) {\n          if (openTagToken) {\n            // We errored before we could close the opening tag, so it is incomplete.\n            openTagToken.type = TokenType.INCOMPLETE_TAG_OPEN;\n          } else {\n            // When the start tag is invalid, assume we want a \"<\" as text.\n            // Back to back text tokens are merged at the end.\n            this._beginToken(TokenType.TEXT, start);\n\n            this._endToken(['<']);\n          }\n\n          return;\n        }\n\n        throw e;\n      }\n\n      var contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);\n\n      if (contentTokenType === TagContentType.RAW_TEXT) {\n        this._consumeRawTextWithTagClose(prefix, tagName, false);\n      } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n        this._consumeRawTextWithTagClose(prefix, tagName, true);\n      }\n    }\n  }, {\n    key: \"_consumeRawTextWithTagClose\",\n    value: function _consumeRawTextWithTagClose(prefix, tagName, decodeEntities) {\n      var _this134 = this;\n\n      this._consumeRawText(decodeEntities, function () {\n        if (!_this134._attemptCharCode($LT)) return false;\n        if (!_this134._attemptCharCode($SLASH)) return false;\n\n        _this134._attemptCharCodeUntilFn(isNotWhitespace);\n\n        if (!_this134._attemptStrCaseInsensitive(tagName)) return false;\n\n        _this134._attemptCharCodeUntilFn(isNotWhitespace);\n\n        return _this134._attemptCharCode($GT);\n      });\n\n      this._beginToken(TokenType.TAG_CLOSE);\n\n      this._requireCharCodeUntilFn(function (code) {\n        return code === $GT;\n      }, 3);\n\n      this._cursor.advance(); // Consume the `>`\n\n\n      this._endToken([prefix, tagName]);\n    }\n  }, {\n    key: \"_consumeTagOpenStart\",\n    value: function _consumeTagOpenStart(start) {\n      this._beginToken(TokenType.TAG_OPEN_START, start);\n\n      var parts = this._consumePrefixAndName();\n\n      return this._endToken(parts);\n    }\n  }, {\n    key: \"_consumeAttributeName\",\n    value: function _consumeAttributeName() {\n      var attrNameStart = this._cursor.peek();\n\n      if (attrNameStart === $SQ || attrNameStart === $DQ) {\n        throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());\n      }\n\n      this._beginToken(TokenType.ATTR_NAME);\n\n      var prefixAndName = this._consumePrefixAndName();\n\n      this._endToken(prefixAndName);\n    }\n  }, {\n    key: \"_consumeAttributeValue\",\n    value: function _consumeAttributeValue() {\n      var value;\n\n      if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {\n        this._beginToken(TokenType.ATTR_QUOTE);\n\n        var quoteChar = this._cursor.peek();\n\n        this._cursor.advance();\n\n        this._endToken([String.fromCodePoint(quoteChar)]);\n\n        this._beginToken(TokenType.ATTR_VALUE);\n\n        var parts = [];\n\n        while (this._cursor.peek() !== quoteChar) {\n          parts.push(this._readChar(true));\n        }\n\n        value = parts.join('');\n\n        this._endToken([this._processCarriageReturns(value)]);\n\n        this._beginToken(TokenType.ATTR_QUOTE);\n\n        this._cursor.advance();\n\n        this._endToken([String.fromCodePoint(quoteChar)]);\n      } else {\n        this._beginToken(TokenType.ATTR_VALUE);\n\n        var valueStart = this._cursor.clone();\n\n        this._requireCharCodeUntilFn(isNameEnd, 1);\n\n        value = this._cursor.getChars(valueStart);\n\n        this._endToken([this._processCarriageReturns(value)]);\n      }\n    }\n  }, {\n    key: \"_consumeTagOpenEnd\",\n    value: function _consumeTagOpenEnd() {\n      var tokenType = this._attemptCharCode($SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;\n\n      this._beginToken(tokenType);\n\n      this._requireCharCode($GT);\n\n      this._endToken([]);\n    }\n  }, {\n    key: \"_consumeTagClose\",\n    value: function _consumeTagClose(start) {\n      this._beginToken(TokenType.TAG_CLOSE, start);\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      var prefixAndName = this._consumePrefixAndName();\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      this._requireCharCode($GT);\n\n      this._endToken(prefixAndName);\n    }\n  }, {\n    key: \"_consumeExpansionFormStart\",\n    value: function _consumeExpansionFormStart() {\n      this._beginToken(TokenType.EXPANSION_FORM_START);\n\n      this._requireCharCode($LBRACE);\n\n      this._endToken([]);\n\n      this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);\n\n      this._beginToken(TokenType.RAW_TEXT);\n\n      var condition = this._readUntil($COMMA);\n\n      var normalizedCondition = this._processCarriageReturns(condition);\n\n      if (this._i18nNormalizeLineEndingsInICUs) {\n        // We explicitly want to normalize line endings for this text.\n        this._endToken([normalizedCondition]);\n      } else {\n        // We are not normalizing line endings.\n        var conditionToken = this._endToken([condition]);\n\n        if (normalizedCondition !== condition) {\n          this.nonNormalizedIcuExpressions.push(conditionToken);\n        }\n      }\n\n      this._requireCharCode($COMMA);\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      this._beginToken(TokenType.RAW_TEXT);\n\n      var type = this._readUntil($COMMA);\n\n      this._endToken([type]);\n\n      this._requireCharCode($COMMA);\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n    }\n  }, {\n    key: \"_consumeExpansionCaseStart\",\n    value: function _consumeExpansionCaseStart() {\n      this._beginToken(TokenType.EXPANSION_CASE_VALUE);\n\n      var value = this._readUntil($LBRACE).trim();\n\n      this._endToken([value]);\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      this._beginToken(TokenType.EXPANSION_CASE_EXP_START);\n\n      this._requireCharCode($LBRACE);\n\n      this._endToken([]);\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);\n    }\n  }, {\n    key: \"_consumeExpansionCaseEnd\",\n    value: function _consumeExpansionCaseEnd() {\n      this._beginToken(TokenType.EXPANSION_CASE_EXP_END);\n\n      this._requireCharCode($RBRACE);\n\n      this._endToken([]);\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      this._expansionCaseStack.pop();\n    }\n  }, {\n    key: \"_consumeExpansionFormEnd\",\n    value: function _consumeExpansionFormEnd() {\n      this._beginToken(TokenType.EXPANSION_FORM_END);\n\n      this._requireCharCode($RBRACE);\n\n      this._endToken([]);\n\n      this._expansionCaseStack.pop();\n    }\n  }, {\n    key: \"_consumeText\",\n    value: function _consumeText() {\n      var start = this._cursor.clone();\n\n      this._beginToken(TokenType.TEXT, start);\n\n      var parts = [];\n\n      do {\n        if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n          parts.push(this._interpolationConfig.start);\n          this._inInterpolation = true;\n        } else if (this._interpolationConfig && this._inInterpolation && this._attemptStr(this._interpolationConfig.end)) {\n          parts.push(this._interpolationConfig.end);\n          this._inInterpolation = false;\n        } else {\n          parts.push(this._readChar(true));\n        }\n      } while (!this._isTextEnd()); // It is possible that an interpolation was started but not ended inside this text token.\n      // Make sure that we reset the state of the lexer correctly.\n\n\n      this._inInterpolation = false;\n\n      this._endToken([this._processCarriageReturns(parts.join(''))]);\n    }\n  }, {\n    key: \"_isTextEnd\",\n    value: function _isTextEnd() {\n      if (this._isTagStart() || this._cursor.peek() === $EOF) {\n        return true;\n      }\n\n      if (this._tokenizeIcu && !this._inInterpolation) {\n        if (this.isExpansionFormStart()) {\n          // start of an expansion form\n          return true;\n        }\n\n        if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {\n          // end of and expansion case\n          return true;\n        }\n      }\n\n      return false;\n    }\n    /**\r\n     * Returns true if the current cursor is pointing to the start of a tag\r\n     * (opening/closing/comments/cdata/etc).\r\n     */\n\n  }, {\n    key: \"_isTagStart\",\n    value: function _isTagStart() {\n      if (this._cursor.peek() === $LT) {\n        // We assume that `<` followed by whitespace is not the start of an HTML element.\n        var tmp = this._cursor.clone();\n\n        tmp.advance(); // If the next character is alphabetic, ! nor / then it is a tag start\n\n        var code = tmp.peek();\n\n        if ($a <= code && code <= $z || $A <= code && code <= $Z || code === $SLASH || code === $BANG) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_readUntil\",\n    value: function _readUntil(char) {\n      var start = this._cursor.clone();\n\n      this._attemptUntilChar(char);\n\n      return this._cursor.getChars(start);\n    }\n  }, {\n    key: \"_isInExpansionCase\",\n    value: function _isInExpansionCase() {\n      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === TokenType.EXPANSION_CASE_EXP_START;\n    }\n  }, {\n    key: \"_isInExpansionForm\",\n    value: function _isInExpansionForm() {\n      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === TokenType.EXPANSION_FORM_START;\n    }\n  }, {\n    key: \"isExpansionFormStart\",\n    value: function isExpansionFormStart() {\n      if (this._cursor.peek() !== $LBRACE) {\n        return false;\n      }\n\n      if (this._interpolationConfig) {\n        var _start3 = this._cursor.clone();\n\n        var isInterpolation = this._attemptStr(this._interpolationConfig.start);\n\n        this._cursor = _start3;\n        return !isInterpolation;\n      }\n\n      return true;\n    }\n  }]);\n\n  return _Tokenizer;\n}();\n\nfunction isNotWhitespace(code) {\n  return !isWhitespace(code) || code === $EOF;\n}\n\nfunction isNameEnd(code) {\n  return isWhitespace(code) || code === $GT || code === $LT || code === $SLASH || code === $SQ || code === $DQ || code === $EQ || code === $EOF;\n}\n\nfunction isPrefixEnd(code) {\n  return (code < $a || $z < code) && (code < $A || $Z < code) && (code < $0 || code > $9);\n}\n\nfunction isDigitEntityEnd(code) {\n  return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);\n}\n\nfunction isNamedEntityEnd(code) {\n  return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);\n}\n\nfunction isExpansionCaseStart(peek) {\n  return peek !== $RBRACE;\n}\n\nfunction compareCharCodeCaseInsensitive(code1, code2) {\n  return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);\n}\n\nfunction toUpperCaseCharCode(code) {\n  return code >= $a && code <= $z ? code - $a + $A : code;\n}\n\nfunction mergeTextTokens(srcTokens) {\n  var dstTokens = [];\n  var lastDstToken = undefined;\n\n  for (var i = 0; i < srcTokens.length; i++) {\n    var token = srcTokens[i];\n\n    if (lastDstToken && lastDstToken.type == TokenType.TEXT && token.type == TokenType.TEXT) {\n      lastDstToken.parts[0] += token.parts[0];\n      lastDstToken.sourceSpan.end = token.sourceSpan.end;\n    } else {\n      lastDstToken = token;\n      dstTokens.push(lastDstToken);\n    }\n  }\n\n  return dstTokens;\n}\n\nvar PlainCharacterCursor = /*#__PURE__*/function () {\n  function PlainCharacterCursor(fileOrCursor, range) {\n    _classCallCheck(this, PlainCharacterCursor);\n\n    if (fileOrCursor instanceof PlainCharacterCursor) {\n      this.file = fileOrCursor.file;\n      this.input = fileOrCursor.input;\n      this.end = fileOrCursor.end;\n      var state = fileOrCursor.state; // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.\n      // In ES5 bundles the object spread operator is translated into the `__assign` helper, which\n      // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is\n      // called in tight loops, this difference matters.\n\n      this.state = {\n        peek: state.peek,\n        offset: state.offset,\n        line: state.line,\n        column: state.column\n      };\n    } else {\n      if (!range) {\n        throw new Error('Programming error: the range argument must be provided with a file argument.');\n      }\n\n      this.file = fileOrCursor;\n      this.input = fileOrCursor.content;\n      this.end = range.endPos;\n      this.state = {\n        peek: -1,\n        offset: range.startPos,\n        line: range.startLine,\n        column: range.startCol\n      };\n    }\n  }\n\n  _createClass(PlainCharacterCursor, [{\n    key: \"clone\",\n    value: function clone() {\n      return new PlainCharacterCursor(this);\n    }\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      return this.state.peek;\n    }\n  }, {\n    key: \"charsLeft\",\n    value: function charsLeft() {\n      return this.end - this.state.offset;\n    }\n  }, {\n    key: \"diff\",\n    value: function diff(other) {\n      return this.state.offset - other.state.offset;\n    }\n  }, {\n    key: \"advance\",\n    value: function advance() {\n      this.advanceState(this.state);\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      this.updatePeek(this.state);\n    }\n  }, {\n    key: \"getSpan\",\n    value: function getSpan(start, leadingTriviaCodePoints) {\n      start = start || this;\n      var fullStart = start;\n\n      if (leadingTriviaCodePoints) {\n        while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {\n          if (fullStart === start) {\n            start = start.clone();\n          }\n\n          start.advance();\n        }\n      }\n\n      var startLocation = this.locationFromCursor(start);\n      var endLocation = this.locationFromCursor(this);\n      var fullStartLocation = fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;\n      return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);\n    }\n  }, {\n    key: \"getChars\",\n    value: function getChars(start) {\n      return this.input.substring(start.state.offset, this.state.offset);\n    }\n  }, {\n    key: \"charAt\",\n    value: function charAt(pos) {\n      return this.input.charCodeAt(pos);\n    }\n  }, {\n    key: \"advanceState\",\n    value: function advanceState(state) {\n      if (state.offset >= this.end) {\n        this.state = state;\n        throw new CursorError('Unexpected character \"EOF\"', this);\n      }\n\n      var currentChar = this.charAt(state.offset);\n\n      if (currentChar === $LF) {\n        state.line++;\n        state.column = 0;\n      } else if (!isNewLine(currentChar)) {\n        state.column++;\n      }\n\n      state.offset++;\n      this.updatePeek(state);\n    }\n  }, {\n    key: \"updatePeek\",\n    value: function updatePeek(state) {\n      state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);\n    }\n  }, {\n    key: \"locationFromCursor\",\n    value: function locationFromCursor(cursor) {\n      return new ParseLocation(cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);\n    }\n  }]);\n\n  return PlainCharacterCursor;\n}();\n\nvar EscapedCharacterCursor = /*#__PURE__*/function (_PlainCharacterCursor) {\n  _inherits(EscapedCharacterCursor, _PlainCharacterCursor);\n\n  var _super88 = _createSuper(EscapedCharacterCursor);\n\n  function EscapedCharacterCursor(fileOrCursor, range) {\n    var _this135;\n\n    _classCallCheck(this, EscapedCharacterCursor);\n\n    if (fileOrCursor instanceof EscapedCharacterCursor) {\n      _this135 = _super88.call(this, fileOrCursor);\n      _this135.internalState = Object.assign({}, fileOrCursor.internalState);\n    } else {\n      _this135 = _super88.call(this, fileOrCursor, range);\n      _this135.internalState = _this135.state;\n    }\n\n    return _possibleConstructorReturn(_this135);\n  }\n\n  _createClass(EscapedCharacterCursor, [{\n    key: \"advance\",\n    value: function advance() {\n      this.state = this.internalState;\n\n      _get(_getPrototypeOf(EscapedCharacterCursor.prototype), \"advance\", this).call(this);\n\n      this.processEscapeSequence();\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      _get(_getPrototypeOf(EscapedCharacterCursor.prototype), \"init\", this).call(this);\n\n      this.processEscapeSequence();\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new EscapedCharacterCursor(this);\n    }\n  }, {\n    key: \"getChars\",\n    value: function getChars(start) {\n      var cursor = start.clone();\n      var chars = '';\n\n      while (cursor.internalState.offset < this.internalState.offset) {\n        chars += String.fromCodePoint(cursor.peek());\n        cursor.advance();\n      }\n\n      return chars;\n    }\n    /**\r\n     * Process the escape sequence that starts at the current position in the text.\r\n     *\r\n     * This method is called to ensure that `peek` has the unescaped value of escape sequences.\r\n     */\n\n  }, {\n    key: \"processEscapeSequence\",\n    value: function processEscapeSequence() {\n      var _this136 = this;\n\n      var peek = function peek() {\n        return _this136.internalState.peek;\n      };\n\n      if (peek() === $BACKSLASH) {\n        // We have hit an escape sequence so we need the internal state to become independent\n        // of the external state.\n        this.internalState = Object.assign({}, this.state); // Move past the backslash\n\n        this.advanceState(this.internalState); // First check for standard control char sequences\n\n        if (peek() === $n) {\n          this.state.peek = $LF;\n        } else if (peek() === $r) {\n          this.state.peek = $CR;\n        } else if (peek() === $v) {\n          this.state.peek = $VTAB;\n        } else if (peek() === $t) {\n          this.state.peek = $TAB;\n        } else if (peek() === $b) {\n          this.state.peek = $BSPACE;\n        } else if (peek() === $f) {\n          this.state.peek = $FF;\n        } // Now consider more complex sequences\n        else if (peek() === $u) {\n            // Unicode code-point sequence\n            this.advanceState(this.internalState); // advance past the `u` char\n\n            if (peek() === $LBRACE) {\n              // Variable length Unicode, e.g. `\\x{123}`\n              this.advanceState(this.internalState); // advance past the `{` char\n              // Advance past the variable number of hex digits until we hit a `}` char\n\n              var digitStart = this.clone();\n              var length = 0;\n\n              while (peek() !== $RBRACE) {\n                this.advanceState(this.internalState);\n                length++;\n              }\n\n              this.state.peek = this.decodeHexDigits(digitStart, length);\n            } else {\n              // Fixed length Unicode, e.g. `\\u1234`\n              var _digitStart = this.clone();\n\n              this.advanceState(this.internalState);\n              this.advanceState(this.internalState);\n              this.advanceState(this.internalState);\n              this.state.peek = this.decodeHexDigits(_digitStart, 4);\n            }\n          } else if (peek() === $x) {\n            // Hex char code, e.g. `\\x2F`\n            this.advanceState(this.internalState); // advance past the `x` char\n\n            var _digitStart2 = this.clone();\n\n            this.advanceState(this.internalState);\n            this.state.peek = this.decodeHexDigits(_digitStart2, 2);\n          } else if (isOctalDigit(peek())) {\n            // Octal char code, e.g. `\\012`,\n            var octal = '';\n            var _length = 0;\n            var previous = this.clone();\n\n            while (isOctalDigit(peek()) && _length < 3) {\n              previous = this.clone();\n              octal += String.fromCodePoint(peek());\n              this.advanceState(this.internalState);\n              _length++;\n            }\n\n            this.state.peek = parseInt(octal, 8); // Backup one char\n\n            this.internalState = previous.internalState;\n          } else if (isNewLine(this.internalState.peek)) {\n            // Line continuation `\\` followed by a new line\n            this.advanceState(this.internalState); // advance over the newline\n\n            this.state = this.internalState;\n          } else {\n            // If none of the `if` blocks were executed then we just have an escaped normal character.\n            // In that case we just, effectively, skip the backslash from the character.\n            this.state.peek = this.internalState.peek;\n          }\n      }\n    }\n  }, {\n    key: \"decodeHexDigits\",\n    value: function decodeHexDigits(start, length) {\n      var hex = this.input.substr(start.internalState.offset, length);\n      var charCode = parseInt(hex, 16);\n\n      if (!isNaN(charCode)) {\n        return charCode;\n      } else {\n        start.state = start.internalState;\n        throw new CursorError('Invalid hexadecimal escape sequence', start);\n      }\n    }\n  }]);\n\n  return EscapedCharacterCursor;\n}(PlainCharacterCursor);\n\nvar CursorError = function CursorError(msg, cursor) {\n  _classCallCheck(this, CursorError);\n\n  this.msg = msg;\n  this.cursor = cursor;\n};\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar TreeError = /*#__PURE__*/function (_ParseError2) {\n  _inherits(TreeError, _ParseError2);\n\n  var _super89 = _createSuper(TreeError);\n\n  function TreeError(elementName, span, msg) {\n    var _this137;\n\n    _classCallCheck(this, TreeError);\n\n    _this137 = _super89.call(this, span, msg);\n    _this137.elementName = elementName;\n    return _this137;\n  }\n\n  _createClass(TreeError, null, [{\n    key: \"create\",\n    value: function create(elementName, span, msg) {\n      return new TreeError(elementName, span, msg);\n    }\n  }]);\n\n  return TreeError;\n}(ParseError);\n\nvar ParseTreeResult = function ParseTreeResult(rootNodes, errors) {\n  _classCallCheck(this, ParseTreeResult);\n\n  this.rootNodes = rootNodes;\n  this.errors = errors;\n};\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(getTagDefinition) {\n    _classCallCheck(this, Parser);\n\n    this.getTagDefinition = getTagDefinition;\n  }\n\n  _createClass(Parser, [{\n    key: \"parse\",\n    value: function parse(source, url, options) {\n      var tokenizeResult = tokenize(source, url, this.getTagDefinition, options);\n      var parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);\n      parser.build();\n      return new ParseTreeResult(parser.rootNodes, tokenizeResult.errors.concat(parser.errors));\n    }\n  }]);\n\n  return Parser;\n}();\n\nvar _TreeBuilder = /*#__PURE__*/function () {\n  function _TreeBuilder(tokens, getTagDefinition) {\n    _classCallCheck(this, _TreeBuilder);\n\n    this.tokens = tokens;\n    this.getTagDefinition = getTagDefinition;\n    this._index = -1;\n    this._elementStack = [];\n    this.rootNodes = [];\n    this.errors = [];\n\n    this._advance();\n  }\n\n  _createClass(_TreeBuilder, [{\n    key: \"build\",\n    value: function build() {\n      while (this._peek.type !== TokenType.EOF) {\n        if (this._peek.type === TokenType.TAG_OPEN_START || this._peek.type === TokenType.INCOMPLETE_TAG_OPEN) {\n          this._consumeStartTag(this._advance());\n        } else if (this._peek.type === TokenType.TAG_CLOSE) {\n          this._consumeEndTag(this._advance());\n        } else if (this._peek.type === TokenType.CDATA_START) {\n          this._closeVoidElement();\n\n          this._consumeCdata(this._advance());\n        } else if (this._peek.type === TokenType.COMMENT_START) {\n          this._closeVoidElement();\n\n          this._consumeComment(this._advance());\n        } else if (this._peek.type === TokenType.TEXT || this._peek.type === TokenType.RAW_TEXT || this._peek.type === TokenType.ESCAPABLE_RAW_TEXT) {\n          this._closeVoidElement();\n\n          this._consumeText(this._advance());\n        } else if (this._peek.type === TokenType.EXPANSION_FORM_START) {\n          this._consumeExpansion(this._advance());\n        } else {\n          // Skip all other tokens...\n          this._advance();\n        }\n      }\n    }\n  }, {\n    key: \"_advance\",\n    value: function _advance() {\n      var prev = this._peek;\n\n      if (this._index < this.tokens.length - 1) {\n        // Note: there is always an EOF token at the end\n        this._index++;\n      }\n\n      this._peek = this.tokens[this._index];\n      return prev;\n    }\n  }, {\n    key: \"_advanceIf\",\n    value: function _advanceIf(type) {\n      if (this._peek.type === type) {\n        return this._advance();\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_consumeCdata\",\n    value: function _consumeCdata(_startToken) {\n      this._consumeText(this._advance());\n\n      this._advanceIf(TokenType.CDATA_END);\n    }\n  }, {\n    key: \"_consumeComment\",\n    value: function _consumeComment(token) {\n      var text = this._advanceIf(TokenType.RAW_TEXT);\n\n      this._advanceIf(TokenType.COMMENT_END);\n\n      var value = text != null ? text.parts[0].trim() : null;\n\n      this._addToParent(new Comment$1(value, token.sourceSpan));\n    }\n  }, {\n    key: \"_consumeExpansion\",\n    value: function _consumeExpansion(token) {\n      var switchValue = this._advance();\n\n      var type = this._advance();\n\n      var cases = []; // read =\n\n      while (this._peek.type === TokenType.EXPANSION_CASE_VALUE) {\n        var expCase = this._parseExpansionCase();\n\n        if (!expCase) return; // error\n\n        cases.push(expCase);\n      } // read the final }\n\n\n      if (this._peek.type !== TokenType.EXPANSION_FORM_END) {\n        this.errors.push(TreeError.create(null, this._peek.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n        return;\n      }\n\n      var sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end, token.sourceSpan.fullStart);\n\n      this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n\n      this._advance();\n    }\n  }, {\n    key: \"_parseExpansionCase\",\n    value: function _parseExpansionCase() {\n      var value = this._advance(); // read {\n\n\n      if (this._peek.type !== TokenType.EXPANSION_CASE_EXP_START) {\n        this.errors.push(TreeError.create(null, this._peek.sourceSpan, \"Invalid ICU message. Missing '{'.\"));\n        return null;\n      } // read until }\n\n\n      var start = this._advance();\n\n      var exp = this._collectExpansionExpTokens(start);\n\n      if (!exp) return null;\n\n      var end = this._advance();\n\n      exp.push(new Token(TokenType.EOF, [], end.sourceSpan)); // parse everything in between { and }\n\n      var expansionCaseParser = new _TreeBuilder(exp, this.getTagDefinition);\n      expansionCaseParser.build();\n\n      if (expansionCaseParser.errors.length > 0) {\n        this.errors = this.errors.concat(expansionCaseParser.errors);\n        return null;\n      }\n\n      var sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end, value.sourceSpan.fullStart);\n      var expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end, start.sourceSpan.fullStart);\n      return new ExpansionCase(value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n    }\n  }, {\n    key: \"_collectExpansionExpTokens\",\n    value: function _collectExpansionExpTokens(start) {\n      var exp = [];\n      var expansionFormStack = [TokenType.EXPANSION_CASE_EXP_START];\n\n      while (true) {\n        if (this._peek.type === TokenType.EXPANSION_FORM_START || this._peek.type === TokenType.EXPANSION_CASE_EXP_START) {\n          expansionFormStack.push(this._peek.type);\n        }\n\n        if (this._peek.type === TokenType.EXPANSION_CASE_EXP_END) {\n          if (lastOnStack(expansionFormStack, TokenType.EXPANSION_CASE_EXP_START)) {\n            expansionFormStack.pop();\n            if (expansionFormStack.length == 0) return exp;\n          } else {\n            this.errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n            return null;\n          }\n        }\n\n        if (this._peek.type === TokenType.EXPANSION_FORM_END) {\n          if (lastOnStack(expansionFormStack, TokenType.EXPANSION_FORM_START)) {\n            expansionFormStack.pop();\n          } else {\n            this.errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n            return null;\n          }\n        }\n\n        if (this._peek.type === TokenType.EOF) {\n          this.errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n          return null;\n        }\n\n        exp.push(this._advance());\n      }\n    }\n  }, {\n    key: \"_consumeText\",\n    value: function _consumeText(token) {\n      var text = token.parts[0];\n\n      if (text.length > 0 && text[0] == '\\n') {\n        var parent = this._getParentElement();\n\n        if (parent != null && parent.children.length == 0 && this.getTagDefinition(parent.name).ignoreFirstLf) {\n          text = text.substring(1);\n        }\n      }\n\n      if (text.length > 0) {\n        this._addToParent(new Text$3(text, token.sourceSpan));\n      }\n    }\n  }, {\n    key: \"_closeVoidElement\",\n    value: function _closeVoidElement() {\n      var el = this._getParentElement();\n\n      if (el && this.getTagDefinition(el.name).isVoid) {\n        this._elementStack.pop();\n      }\n    }\n  }, {\n    key: \"_consumeStartTag\",\n    value: function _consumeStartTag(startTagToken) {\n      var _startTagToken$parts = _slicedToArray(startTagToken.parts, 2),\n          prefix = _startTagToken$parts[0],\n          name = _startTagToken$parts[1];\n\n      var attrs = [];\n\n      while (this._peek.type === TokenType.ATTR_NAME) {\n        attrs.push(this._consumeAttr(this._advance()));\n      }\n\n      var fullName = this._getElementFullName(prefix, name, this._getParentElement());\n\n      var selfClosing = false; // Note: There could have been a tokenizer error\n      // so that we don't get a token for the end tag...\n\n      if (this._peek.type === TokenType.TAG_OPEN_END_VOID) {\n        this._advance();\n\n        selfClosing = true;\n        var tagDef = this.getTagDefinition(fullName);\n\n        if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n          this.errors.push(TreeError.create(fullName, startTagToken.sourceSpan, \"Only void and foreign elements can be self closed \\\"\".concat(startTagToken.parts[1], \"\\\"\")));\n        }\n      } else if (this._peek.type === TokenType.TAG_OPEN_END) {\n        this._advance();\n\n        selfClosing = false;\n      }\n\n      var end = this._peek.sourceSpan.fullStart;\n      var span = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart); // Create a separate `startSpan` because `span` will be modified when there is an `end` span.\n\n      var startSpan = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\n      var el = new Element$1(fullName, attrs, [], span, startSpan, undefined);\n\n      this._pushElement(el);\n\n      if (selfClosing) {\n        // Elements that are self-closed have their `endSourceSpan` set to the full span, as the\n        // element start tag also represents the end tag.\n        this._popElement(fullName, span);\n      } else if (startTagToken.type === TokenType.INCOMPLETE_TAG_OPEN) {\n        // We already know the opening tag is not complete, so it is unlikely it has a corresponding\n        // close tag. Let's optimistically parse it as a full element and emit an error.\n        this._popElement(fullName, null);\n\n        this.errors.push(TreeError.create(fullName, span, \"Opening tag \\\"\".concat(fullName, \"\\\" not terminated.\")));\n      }\n    }\n  }, {\n    key: \"_pushElement\",\n    value: function _pushElement(el) {\n      var parentEl = this._getParentElement();\n\n      if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n        this._elementStack.pop();\n      }\n\n      this._addToParent(el);\n\n      this._elementStack.push(el);\n    }\n  }, {\n    key: \"_consumeEndTag\",\n    value: function _consumeEndTag(endTagToken) {\n      var fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n\n      if (this.getTagDefinition(fullName).isVoid) {\n        this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, \"Void elements do not have end tags \\\"\".concat(endTagToken.parts[1], \"\\\"\")));\n      } else if (!this._popElement(fullName, endTagToken.sourceSpan)) {\n        var errMsg = \"Unexpected closing tag \\\"\".concat(fullName, \"\\\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags\");\n        this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n      }\n    }\n    /**\r\n     * Closes the nearest element with the tag name `fullName` in the parse tree.\r\n     * `endSourceSpan` is the span of the closing tag, or null if the element does\r\n     * not have a closing tag (for example, this happens when an incomplete\r\n     * opening tag is recovered).\r\n     */\n\n  }, {\n    key: \"_popElement\",\n    value: function _popElement(fullName, endSourceSpan) {\n      var unexpectedCloseTagDetected = false;\n\n      for (var stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n        var el = this._elementStack[stackIndex];\n\n        if (el.name == fullName) {\n          // Record the parse span with the element that is being closed. Any elements that are\n          // removed from the element stack at this point are closed implicitly, so they won't get\n          // an end source span (as there is no explicit closing element).\n          el.endSourceSpan = endSourceSpan;\n          el.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : el.sourceSpan.end;\n\n          this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n\n          return !unexpectedCloseTagDetected;\n        }\n\n        if (!this.getTagDefinition(el.name).closedByParent) {\n          // Note that we encountered an unexpected close tag but continue processing the element\n          // stack so we can assign an `endSourceSpan` if there is a corresponding start tag for this\n          // end tag in the stack.\n          unexpectedCloseTagDetected = true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_consumeAttr\",\n    value: function _consumeAttr(attrName) {\n      var fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n      var end = attrName.sourceSpan.end;\n      var value = '';\n      var valueSpan = undefined;\n\n      if (this._peek.type === TokenType.ATTR_QUOTE) {\n        this._advance();\n      }\n\n      if (this._peek.type === TokenType.ATTR_VALUE) {\n        var valueToken = this._advance();\n\n        value = valueToken.parts[0];\n        end = valueToken.sourceSpan.end;\n        valueSpan = valueToken.sourceSpan;\n      }\n\n      if (this._peek.type === TokenType.ATTR_QUOTE) {\n        var quoteToken = this._advance();\n\n        end = quoteToken.sourceSpan.end;\n      }\n\n      var keySpan = new ParseSourceSpan(attrName.sourceSpan.start, attrName.sourceSpan.end);\n      return new Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end, attrName.sourceSpan.fullStart), keySpan, valueSpan);\n    }\n  }, {\n    key: \"_getParentElement\",\n    value: function _getParentElement() {\n      return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n    }\n  }, {\n    key: \"_addToParent\",\n    value: function _addToParent(node) {\n      var parent = this._getParentElement();\n\n      if (parent != null) {\n        parent.children.push(node);\n      } else {\n        this.rootNodes.push(node);\n      }\n    }\n  }, {\n    key: \"_getElementFullName\",\n    value: function _getElementFullName(prefix, localName, parentElement) {\n      if (prefix === '') {\n        prefix = this.getTagDefinition(localName).implicitNamespacePrefix || '';\n\n        if (prefix === '' && parentElement != null) {\n          var parentTagName = splitNsName(parentElement.name)[1];\n          var parentTagDefinition = this.getTagDefinition(parentTagName);\n\n          if (!parentTagDefinition.preventNamespaceInheritance) {\n            prefix = getNsPrefix(parentElement.name);\n          }\n        }\n      }\n\n      return mergeNsAndName(prefix, localName);\n    }\n  }]);\n\n  return _TreeBuilder;\n}();\n\nfunction lastOnStack(stack, element) {\n  return stack.length > 0 && stack[stack.length - 1] === element;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar HtmlParser = /*#__PURE__*/function (_Parser) {\n  _inherits(HtmlParser, _Parser);\n\n  var _super90 = _createSuper(HtmlParser);\n\n  function HtmlParser() {\n    _classCallCheck(this, HtmlParser);\n\n    return _super90.call(this, getHtmlTagDefinition);\n  }\n\n  _createClass(HtmlParser, [{\n    key: \"parse\",\n    value: function parse(source, url, options) {\n      return _get(_getPrototypeOf(HtmlParser.prototype), \"parse\", this).call(this, source, url, options);\n    }\n  }]);\n\n  return HtmlParser;\n}(Parser);\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';\nvar SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']); // Equivalent to \\s with \\u00a0 (non-breaking space) excluded.\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n\nvar WS_CHARS = \" \\f\\n\\r\\t\\x0B\\u1680\\u180E\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF\";\nvar NO_WS_REGEXP = new RegExp(\"[^\".concat(WS_CHARS, \"]\"));\nvar WS_REPLACE_REGEXP = new RegExp(\"[\".concat(WS_CHARS, \"]{2,}\"), 'g');\n\nfunction hasPreserveWhitespacesAttr(attrs) {\n  return attrs.some(function (attr) {\n    return attr.name === PRESERVE_WS_ATTR_NAME;\n  });\n}\n/**\r\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\r\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\r\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\r\n * and later on replaced by a space. We are re-implementing the same idea here.\r\n */\n\n\nfunction replaceNgsp(value) {\n  // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE\n  return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');\n}\n/**\r\n * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:\r\n * - consider spaces, tabs and new lines as whitespace characters;\r\n * - drop text nodes consisting of whitespace characters only;\r\n * - for all other text nodes replace consecutive whitespace characters with one space;\r\n * - convert &ngsp; pseudo-entity to a single space;\r\n *\r\n * Removal and trimming of whitespaces have positive performance impact (less code to generate\r\n * while compiling templates, faster view creation). At the same time it can be \"destructive\"\r\n * in some cases (whitespaces can influence layout). Because of the potential of breaking layout\r\n * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for\r\n * whitespace removal. The default option for whitespace removal will be revisited in Angular 6\r\n * and might be changed to \"on\" by default.\r\n */\n\n\nvar WhitespaceVisitor = /*#__PURE__*/function () {\n  function WhitespaceVisitor() {\n    _classCallCheck(this, WhitespaceVisitor);\n  }\n\n  _createClass(WhitespaceVisitor, [{\n    key: \"visitElement\",\n    value: function visitElement(element, context) {\n      if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {\n        // don't descent into elements where we need to preserve whitespaces\n        // but still visit all attributes to eliminate one used as a market to preserve WS\n        return new Element$1(element.name, visitAll$1(this, element.attrs), element.children, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n      }\n\n      return new Element$1(element.name, element.attrs, visitAllWithSiblings(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute, context) {\n      return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      var isNotBlank = text.value.match(NO_WS_REGEXP);\n      var hasExpansionSibling = context && (context.prev instanceof Expansion || context.next instanceof Expansion);\n\n      if (isNotBlank || hasExpansionSibling) {\n        return new Text$3(replaceNgsp(text.value).replace(WS_REPLACE_REGEXP, ' '), text.sourceSpan, text.i18n);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment, context) {\n      return comment;\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(expansion, context) {\n      return expansion;\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(expansionCase, context) {\n      return expansionCase;\n    }\n  }]);\n\n  return WhitespaceVisitor;\n}();\n\nfunction removeWhitespaces(htmlAstWithErrors) {\n  return new ParseTreeResult(visitAll$1(new WhitespaceVisitor(), htmlAstWithErrors.rootNodes), htmlAstWithErrors.errors);\n}\n\nfunction visitAllWithSiblings(visitor, nodes) {\n  var result = [];\n  nodes.forEach(function (ast, i) {\n    var context = {\n      prev: nodes[i - 1],\n      next: nodes[i + 1]\n    };\n    var astResult = ast.visit(visitor, context);\n\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n// http://cldr.unicode.org/index/cldr-spec/plural-rules\n\n\nvar PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];\n/**\r\n * Expands special forms into elements.\r\n *\r\n * For example,\r\n *\r\n * ```\r\n * { messages.length, plural,\r\n *   =0 {zero}\r\n *   =1 {one}\r\n *   other {more than one}\r\n * }\r\n * ```\r\n *\r\n * will be expanded into\r\n *\r\n * ```\r\n * <ng-container [ngPlural]=\"messages.length\">\r\n *   <ng-template ngPluralCase=\"=0\">zero</ng-template>\r\n *   <ng-template ngPluralCase=\"=1\">one</ng-template>\r\n *   <ng-template ngPluralCase=\"other\">more than one</ng-template>\r\n * </ng-container>\r\n * ```\r\n */\n\nfunction expandNodes(nodes) {\n  var expander = new _Expander();\n  return new ExpansionResult(visitAll$1(expander, nodes), expander.isExpanded, expander.errors);\n}\n\nvar ExpansionResult = function ExpansionResult(nodes, expanded, errors) {\n  _classCallCheck(this, ExpansionResult);\n\n  this.nodes = nodes;\n  this.expanded = expanded;\n  this.errors = errors;\n};\n\nvar ExpansionError = /*#__PURE__*/function (_ParseError3) {\n  _inherits(ExpansionError, _ParseError3);\n\n  var _super91 = _createSuper(ExpansionError);\n\n  function ExpansionError(span, errorMsg) {\n    _classCallCheck(this, ExpansionError);\n\n    return _super91.call(this, span, errorMsg);\n  }\n\n  return ExpansionError;\n}(ParseError);\n/**\r\n * Expand expansion forms (plural, select) to directives\r\n *\r\n * @internal\r\n */\n\n\nvar _Expander = /*#__PURE__*/function () {\n  function _Expander() {\n    _classCallCheck(this, _Expander);\n\n    this.isExpanded = false;\n    this.errors = [];\n  }\n\n  _createClass(_Expander, [{\n    key: \"visitElement\",\n    value: function visitElement(element, context) {\n      return new Element$1(element.name, element.attrs, visitAll$1(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute, context) {\n      return attribute;\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      return text;\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment, context) {\n      return comment;\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(icu, context) {\n      this.isExpanded = true;\n      return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) : _expandDefaultForm(icu, this.errors);\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(icuCase, context) {\n      throw new Error('Should not be reached');\n    }\n  }]);\n\n  return _Expander;\n}(); // Plural forms are expanded to `NgPlural` and `NgPluralCase`s\n\n\nfunction _expandPluralForm(ast, errors) {\n  var children = ast.cases.map(function (c) {\n    if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\\d+$/)) {\n      errors.push(new ExpansionError(c.valueSourceSpan, \"Plural cases should be \\\"=<number>\\\" or one of \".concat(PLURAL_CASES.join(', '))));\n    }\n\n    var expansionResult = expandNodes(c.expression);\n    errors.push.apply(errors, _toConsumableArray(expansionResult.errors));\n    return new Element$1(\"ng-template\", [new Attribute('ngPluralCase', \"\".concat(c.value), c.valueSourceSpan, undefined\n    /* keySpan */\n    , undefined\n    /* valueSpan */\n    , undefined\n    /* i18n */\n    )], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n  });\n  var switchAttr = new Attribute('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan, undefined\n  /* keySpan */\n  , undefined\n  /* valueSpan */\n  , undefined\n  /* i18n */\n  );\n  return new Element$1('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n} // ICU messages (excluding plural form) are expanded to `NgSwitch`  and `NgSwitchCase`s\n\n\nfunction _expandDefaultForm(ast, errors) {\n  var children = ast.cases.map(function (c) {\n    var expansionResult = expandNodes(c.expression);\n    errors.push.apply(errors, _toConsumableArray(expansionResult.errors));\n\n    if (c.value === 'other') {\n      // other is the default case when no values match\n      return new Element$1(\"ng-template\", [new Attribute('ngSwitchDefault', '', c.valueSourceSpan, undefined\n      /* keySpan */\n      , undefined\n      /* valueSpan */\n      , undefined\n      /* i18n */\n      )], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n    }\n\n    return new Element$1(\"ng-template\", [new Attribute('ngSwitchCase', \"\".concat(c.value), c.valueSourceSpan, undefined\n    /* keySpan */\n    , undefined\n    /* valueSpan */\n    , undefined\n    /* i18n */\n    )], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n  });\n  var switchAttr = new Attribute('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan, undefined\n  /* keySpan */\n  , undefined\n  /* valueSpan */\n  , undefined\n  /* i18n */\n  );\n  return new Element$1('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * A segment of text within the template.\r\n */\n\n\nvar TextAst = /*#__PURE__*/function () {\n  function TextAst(value, ngContentIndex, sourceSpan) {\n    _classCallCheck(this, TextAst);\n\n    this.value = value;\n    this.ngContentIndex = ngContentIndex;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(TextAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitText(this, context);\n    }\n  }]);\n\n  return TextAst;\n}();\n/**\r\n * A bound expression within the text of a template.\r\n */\n\n\nvar BoundTextAst = /*#__PURE__*/function () {\n  function BoundTextAst(value, ngContentIndex, sourceSpan) {\n    _classCallCheck(this, BoundTextAst);\n\n    this.value = value;\n    this.ngContentIndex = ngContentIndex;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(BoundTextAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitBoundText(this, context);\n    }\n  }]);\n\n  return BoundTextAst;\n}();\n/**\r\n * A plain attribute on an element.\r\n */\n\n\nvar AttrAst = /*#__PURE__*/function () {\n  function AttrAst(name, value, sourceSpan) {\n    _classCallCheck(this, AttrAst);\n\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(AttrAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitAttr(this, context);\n    }\n  }]);\n\n  return AttrAst;\n}();\n\nvar BoundPropertyMapping = (_BoundPropertyMapping = {}, _defineProperty(_BoundPropertyMapping, 4\n/* Animation */\n, 4), _defineProperty(_BoundPropertyMapping, 1\n/* Attribute */\n,\n/* Animation */\n1), _defineProperty(_BoundPropertyMapping, 2\n/* Class */\n,\n/* Attribute */\n2), _defineProperty(_BoundPropertyMapping, 0\n/* Property */\n,\n/* Class */\n0), _defineProperty(_BoundPropertyMapping, 3\n/* Style */\n,\n/* Property */\n3), _BoundPropertyMapping);\n/**\r\n * A binding for an element property (e.g. `[property]=\"expression\"`) or an animation trigger (e.g.\r\n * `[@trigger]=\"stateExp\"`)\r\n */\n\nvar BoundElementPropertyAst = /*#__PURE__*/function () {\n  function BoundElementPropertyAst(name, type, securityContext, value, unit, sourceSpan) {\n    _classCallCheck(this, BoundElementPropertyAst);\n\n    this.name = name;\n    this.type = type;\n    this.securityContext = securityContext;\n    this.value = value;\n    this.unit = unit;\n    this.sourceSpan = sourceSpan;\n    this.isAnimation = this.type === 4\n    /* Animation */\n    ;\n  }\n\n  _createClass(BoundElementPropertyAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitElementProperty(this, context);\n    }\n  }], [{\n    key: \"fromBoundProperty\",\n    value: function fromBoundProperty(prop) {\n      var type = BoundPropertyMapping[prop.type];\n      return new BoundElementPropertyAst(prop.name, type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan);\n    }\n  }]);\n\n  return BoundElementPropertyAst;\n}();\n/**\r\n * A binding for an element event (e.g. `(event)=\"handler()\"`) or an animation trigger event (e.g.\r\n * `(@trigger.phase)=\"callback($event)\"`).\r\n */\n\n\nvar BoundEventAst = /*#__PURE__*/function () {\n  function BoundEventAst(name, target, phase, handler, sourceSpan, handlerSpan) {\n    _classCallCheck(this, BoundEventAst);\n\n    this.name = name;\n    this.target = target;\n    this.phase = phase;\n    this.handler = handler;\n    this.sourceSpan = sourceSpan;\n    this.handlerSpan = handlerSpan;\n    this.fullName = BoundEventAst.calcFullName(this.name, this.target, this.phase);\n    this.isAnimation = !!this.phase;\n  }\n\n  _createClass(BoundEventAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitEvent(this, context);\n    }\n  }], [{\n    key: \"calcFullName\",\n    value: function calcFullName(name, target, phase) {\n      if (target) {\n        return \"\".concat(target, \":\").concat(name);\n      }\n\n      if (phase) {\n        return \"@\".concat(name, \".\").concat(phase);\n      }\n\n      return name;\n    }\n  }, {\n    key: \"fromParsedEvent\",\n    value: function fromParsedEvent(event) {\n      var target = event.type === 0\n      /* Regular */\n      ? event.targetOrPhase : null;\n      var phase = event.type === 1\n      /* Animation */\n      ? event.targetOrPhase : null;\n      return new BoundEventAst(event.name, target, phase, event.handler, event.sourceSpan, event.handlerSpan);\n    }\n  }]);\n\n  return BoundEventAst;\n}();\n/**\r\n * A reference declaration on an element (e.g. `let someName=\"expression\"`).\r\n */\n\n\nvar ReferenceAst = /*#__PURE__*/function () {\n  function ReferenceAst(name, value, originalValue, sourceSpan) {\n    _classCallCheck(this, ReferenceAst);\n\n    this.name = name;\n    this.value = value;\n    this.originalValue = originalValue;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(ReferenceAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitReference(this, context);\n    }\n  }]);\n\n  return ReferenceAst;\n}();\n/**\r\n * A variable declaration on a <ng-template> (e.g. `var-someName=\"someLocalName\"`).\r\n */\n\n\nvar VariableAst = /*#__PURE__*/function () {\n  function VariableAst(name, value, sourceSpan, valueSpan) {\n    _classCallCheck(this, VariableAst);\n\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.valueSpan = valueSpan;\n  }\n\n  _createClass(VariableAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitVariable(this, context);\n    }\n  }], [{\n    key: \"fromParsedVariable\",\n    value: function fromParsedVariable(v) {\n      return new VariableAst(v.name, v.value, v.sourceSpan, v.valueSpan);\n    }\n  }]);\n\n  return VariableAst;\n}();\n/**\r\n * An element declaration in a template.\r\n */\n\n\nvar ElementAst = /*#__PURE__*/function () {\n  function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan, endSourceSpan) {\n    _classCallCheck(this, ElementAst);\n\n    this.name = name;\n    this.attrs = attrs;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.references = references;\n    this.directives = directives;\n    this.providers = providers;\n    this.hasViewContainer = hasViewContainer;\n    this.queryMatches = queryMatches;\n    this.children = children;\n    this.ngContentIndex = ngContentIndex;\n    this.sourceSpan = sourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n\n  _createClass(ElementAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitElement(this, context);\n    }\n  }]);\n\n  return ElementAst;\n}();\n/**\r\n * A `<ng-template>` element included in an Angular template.\r\n */\n\n\nvar EmbeddedTemplateAst = /*#__PURE__*/function () {\n  function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan) {\n    _classCallCheck(this, EmbeddedTemplateAst);\n\n    this.attrs = attrs;\n    this.outputs = outputs;\n    this.references = references;\n    this.variables = variables;\n    this.directives = directives;\n    this.providers = providers;\n    this.hasViewContainer = hasViewContainer;\n    this.queryMatches = queryMatches;\n    this.children = children;\n    this.ngContentIndex = ngContentIndex;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(EmbeddedTemplateAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitEmbeddedTemplate(this, context);\n    }\n  }]);\n\n  return EmbeddedTemplateAst;\n}();\n/**\r\n * A directive property with a bound value (e.g. `*ngIf=\"condition\").\r\n */\n\n\nvar BoundDirectivePropertyAst = /*#__PURE__*/function () {\n  function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {\n    _classCallCheck(this, BoundDirectivePropertyAst);\n\n    this.directiveName = directiveName;\n    this.templateName = templateName;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(BoundDirectivePropertyAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitDirectiveProperty(this, context);\n    }\n  }]);\n\n  return BoundDirectivePropertyAst;\n}();\n/**\r\n * A directive declared on an element.\r\n */\n\n\nvar DirectiveAst = /*#__PURE__*/function () {\n  function DirectiveAst(directive, inputs, hostProperties, hostEvents, contentQueryStartId, sourceSpan) {\n    _classCallCheck(this, DirectiveAst);\n\n    this.directive = directive;\n    this.inputs = inputs;\n    this.hostProperties = hostProperties;\n    this.hostEvents = hostEvents;\n    this.contentQueryStartId = contentQueryStartId;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(DirectiveAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitDirective(this, context);\n    }\n  }]);\n\n  return DirectiveAst;\n}();\n/**\r\n * A provider declared on an element\r\n */\n\n\nvar ProviderAst = /*#__PURE__*/function () {\n  function ProviderAst(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan, isModule) {\n    _classCallCheck(this, ProviderAst);\n\n    this.token = token;\n    this.multiProvider = multiProvider;\n    this.eager = eager;\n    this.providers = providers;\n    this.providerType = providerType;\n    this.lifecycleHooks = lifecycleHooks;\n    this.sourceSpan = sourceSpan;\n    this.isModule = isModule;\n  }\n\n  _createClass(ProviderAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      // No visit method in the visitor for now...\n      return null;\n    }\n  }]);\n\n  return ProviderAst;\n}();\n\nvar ProviderAstType;\n\n(function (ProviderAstType) {\n  ProviderAstType[ProviderAstType[\"PublicService\"] = 0] = \"PublicService\";\n  ProviderAstType[ProviderAstType[\"PrivateService\"] = 1] = \"PrivateService\";\n  ProviderAstType[ProviderAstType[\"Component\"] = 2] = \"Component\";\n  ProviderAstType[ProviderAstType[\"Directive\"] = 3] = \"Directive\";\n  ProviderAstType[ProviderAstType[\"Builtin\"] = 4] = \"Builtin\";\n})(ProviderAstType || (ProviderAstType = {}));\n/**\r\n * Position where content is to be projected (instance of `<ng-content>` in a template).\r\n */\n\n\nvar NgContentAst = /*#__PURE__*/function () {\n  function NgContentAst(index, ngContentIndex, sourceSpan) {\n    _classCallCheck(this, NgContentAst);\n\n    this.index = index;\n    this.ngContentIndex = ngContentIndex;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(NgContentAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitNgContent(this, context);\n    }\n  }]);\n\n  return NgContentAst;\n}();\n/**\r\n * A visitor that accepts each node but doesn't do anything. It is intended to be used\r\n * as the base class for a visitor that is only interested in a subset of the node types.\r\n */\n\n\nvar NullTemplateVisitor = /*#__PURE__*/function () {\n  function NullTemplateVisitor() {\n    _classCallCheck(this, NullTemplateVisitor);\n  }\n\n  _createClass(NullTemplateVisitor, [{\n    key: \"visitNgContent\",\n    value: function visitNgContent(ast, context) {}\n  }, {\n    key: \"visitEmbeddedTemplate\",\n    value: function visitEmbeddedTemplate(ast, context) {}\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(ast, context) {}\n  }, {\n    key: \"visitReference\",\n    value: function visitReference(ast, context) {}\n  }, {\n    key: \"visitVariable\",\n    value: function visitVariable(ast, context) {}\n  }, {\n    key: \"visitEvent\",\n    value: function visitEvent(ast, context) {}\n  }, {\n    key: \"visitElementProperty\",\n    value: function visitElementProperty(ast, context) {}\n  }, {\n    key: \"visitAttr\",\n    value: function visitAttr(ast, context) {}\n  }, {\n    key: \"visitBoundText\",\n    value: function visitBoundText(ast, context) {}\n  }, {\n    key: \"visitText\",\n    value: function visitText(ast, context) {}\n  }, {\n    key: \"visitDirective\",\n    value: function visitDirective(ast, context) {}\n  }, {\n    key: \"visitDirectiveProperty\",\n    value: function visitDirectiveProperty(ast, context) {}\n  }]);\n\n  return NullTemplateVisitor;\n}();\n/**\r\n * Base class that can be used to build a visitor that visits each node\r\n * in an template ast recursively.\r\n */\n\n\nvar RecursiveTemplateAstVisitor = /*#__PURE__*/function (_NullTemplateVisitor) {\n  _inherits(RecursiveTemplateAstVisitor, _NullTemplateVisitor);\n\n  var _super92 = _createSuper(RecursiveTemplateAstVisitor);\n\n  function RecursiveTemplateAstVisitor() {\n    _classCallCheck(this, RecursiveTemplateAstVisitor);\n\n    return _super92.call(this);\n  } // Nodes with children\n\n\n  _createClass(RecursiveTemplateAstVisitor, [{\n    key: \"visitEmbeddedTemplate\",\n    value: function visitEmbeddedTemplate(ast, context) {\n      return this.visitChildren(context, function (visit) {\n        visit(ast.attrs);\n        visit(ast.references);\n        visit(ast.variables);\n        visit(ast.directives);\n        visit(ast.providers);\n        visit(ast.children);\n      });\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(ast, context) {\n      return this.visitChildren(context, function (visit) {\n        visit(ast.attrs);\n        visit(ast.inputs);\n        visit(ast.outputs);\n        visit(ast.references);\n        visit(ast.directives);\n        visit(ast.providers);\n        visit(ast.children);\n      });\n    }\n  }, {\n    key: \"visitDirective\",\n    value: function visitDirective(ast, context) {\n      return this.visitChildren(context, function (visit) {\n        visit(ast.inputs);\n        visit(ast.hostProperties);\n        visit(ast.hostEvents);\n      });\n    }\n  }, {\n    key: \"visitChildren\",\n    value: function visitChildren(context, cb) {\n      var results = [];\n      var t = this;\n\n      function visit(children) {\n        if (children && children.length) results.push(templateVisitAll(t, children, context));\n      }\n\n      cb(visit);\n      return Array.prototype.concat.apply([], results);\n    }\n  }]);\n\n  return RecursiveTemplateAstVisitor;\n}(NullTemplateVisitor);\n/**\r\n * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.\r\n */\n\n\nfunction templateVisitAll(visitor, asts) {\n  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var result = [];\n  var visit = visitor.visit ? function (ast) {\n    return visitor.visit(ast, context) || ast.visit(visitor, context);\n  } : function (ast) {\n    return ast.visit(visitor, context);\n  };\n  asts.forEach(function (ast) {\n    var astResult = visit(ast);\n\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar ProviderError = /*#__PURE__*/function (_ParseError4) {\n  _inherits(ProviderError, _ParseError4);\n\n  var _super93 = _createSuper(ProviderError);\n\n  function ProviderError(message, span) {\n    _classCallCheck(this, ProviderError);\n\n    return _super93.call(this, span, message);\n  }\n\n  return ProviderError;\n}(ParseError);\n\nvar ProviderViewContext = function ProviderViewContext(reflector, component) {\n  var _this138 = this;\n\n  _classCallCheck(this, ProviderViewContext);\n\n  this.reflector = reflector;\n  this.component = component;\n  this.errors = [];\n  this.viewQueries = _getViewQueries(component);\n  this.viewProviders = new Map();\n  component.viewProviders.forEach(function (provider) {\n    if (_this138.viewProviders.get(tokenReference(provider.token)) == null) {\n      _this138.viewProviders.set(tokenReference(provider.token), true);\n    }\n  });\n};\n\nvar ProviderElementContext = /*#__PURE__*/function () {\n  function ProviderElementContext(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, isTemplate, contentQueryStartId, _sourceSpan) {\n    var _this139 = this;\n\n    _classCallCheck(this, ProviderElementContext);\n\n    this.viewContext = viewContext;\n    this._parent = _parent;\n    this._isViewRoot = _isViewRoot;\n    this._directiveAsts = _directiveAsts;\n    this._sourceSpan = _sourceSpan;\n    this._transformedProviders = new Map();\n    this._seenProviders = new Map();\n    this._queriedTokens = new Map();\n    this.transformedHasViewContainer = false;\n    this._attrs = {};\n    attrs.forEach(function (attrAst) {\n      return _this139._attrs[attrAst.name] = attrAst.value;\n    });\n\n    var directivesMeta = _directiveAsts.map(function (directiveAst) {\n      return directiveAst.directive;\n    });\n\n    this._allProviders = _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);\n    this._contentQueries = _getContentQueries(contentQueryStartId, directivesMeta);\n    Array.from(this._allProviders.values()).forEach(function (provider) {\n      _this139._addQueryReadsTo(provider.token, provider.token, _this139._queriedTokens);\n    });\n\n    if (isTemplate) {\n      var templateRefId = createTokenForExternalReference(this.viewContext.reflector, Identifiers$1.TemplateRef);\n\n      this._addQueryReadsTo(templateRefId, templateRefId, this._queriedTokens);\n    }\n\n    refs.forEach(function (refAst) {\n      var defaultQueryValue = refAst.value || createTokenForExternalReference(_this139.viewContext.reflector, Identifiers$1.ElementRef);\n\n      _this139._addQueryReadsTo({\n        value: refAst.name\n      }, defaultQueryValue, _this139._queriedTokens);\n    });\n\n    if (this._queriedTokens.get(this.viewContext.reflector.resolveExternalReference(Identifiers$1.ViewContainerRef))) {\n      this.transformedHasViewContainer = true;\n    } // create the providers that we know are eager first\n\n\n    Array.from(this._allProviders.values()).forEach(function (provider) {\n      var eager = provider.eager || _this139._queriedTokens.get(tokenReference(provider.token));\n\n      if (eager) {\n        _this139._getOrCreateLocalProvider(provider.providerType, provider.token, true);\n      }\n    });\n  }\n\n  _createClass(ProviderElementContext, [{\n    key: \"afterElement\",\n    value: function afterElement() {\n      var _this140 = this;\n\n      // collect lazy providers\n      Array.from(this._allProviders.values()).forEach(function (provider) {\n        _this140._getOrCreateLocalProvider(provider.providerType, provider.token, false);\n      });\n    }\n  }, {\n    key: \"transformProviders\",\n    get: function get() {\n      // Note: Maps keep their insertion order.\n      var lazyProviders = [];\n      var eagerProviders = [];\n\n      this._transformedProviders.forEach(function (provider) {\n        if (provider.eager) {\n          eagerProviders.push(provider);\n        } else {\n          lazyProviders.push(provider);\n        }\n      });\n\n      return lazyProviders.concat(eagerProviders);\n    }\n  }, {\n    key: \"transformedDirectiveAsts\",\n    get: function get() {\n      var sortedProviderTypes = this.transformProviders.map(function (provider) {\n        return provider.token.identifier;\n      });\n\n      var sortedDirectives = this._directiveAsts.slice();\n\n      sortedDirectives.sort(function (dir1, dir2) {\n        return sortedProviderTypes.indexOf(dir1.directive.type) - sortedProviderTypes.indexOf(dir2.directive.type);\n      });\n      return sortedDirectives;\n    }\n  }, {\n    key: \"queryMatches\",\n    get: function get() {\n      var allMatches = [];\n\n      this._queriedTokens.forEach(function (matches) {\n        allMatches.push.apply(allMatches, _toConsumableArray(matches));\n      });\n\n      return allMatches;\n    }\n  }, {\n    key: \"_addQueryReadsTo\",\n    value: function _addQueryReadsTo(token, defaultValue, queryReadTokens) {\n      this._getQueriesFor(token).forEach(function (query) {\n        var queryValue = query.meta.read || defaultValue;\n        var tokenRef = tokenReference(queryValue);\n        var queryMatches = queryReadTokens.get(tokenRef);\n\n        if (!queryMatches) {\n          queryMatches = [];\n          queryReadTokens.set(tokenRef, queryMatches);\n        }\n\n        queryMatches.push({\n          queryId: query.queryId,\n          value: queryValue\n        });\n      });\n    }\n  }, {\n    key: \"_getQueriesFor\",\n    value: function _getQueriesFor(token) {\n      var result = [];\n      var currentEl = this;\n      var distance = 0;\n      var queries;\n\n      while (currentEl !== null) {\n        queries = currentEl._contentQueries.get(tokenReference(token));\n\n        if (queries) {\n          result.push.apply(result, _toConsumableArray(queries.filter(function (query) {\n            return query.meta.descendants || distance <= 1;\n          })));\n        }\n\n        if (currentEl._directiveAsts.length > 0) {\n          distance++;\n        }\n\n        currentEl = currentEl._parent;\n      }\n\n      queries = this.viewContext.viewQueries.get(tokenReference(token));\n\n      if (queries) {\n        result.push.apply(result, _toConsumableArray(queries));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getOrCreateLocalProvider\",\n    value: function _getOrCreateLocalProvider(requestingProviderType, token, eager) {\n      var _this141 = this;\n\n      var resolvedProvider = this._allProviders.get(tokenReference(token));\n\n      if (!resolvedProvider || (requestingProviderType === ProviderAstType.Directive || requestingProviderType === ProviderAstType.PublicService) && resolvedProvider.providerType === ProviderAstType.PrivateService || (requestingProviderType === ProviderAstType.PrivateService || requestingProviderType === ProviderAstType.PublicService) && resolvedProvider.providerType === ProviderAstType.Builtin) {\n        return null;\n      }\n\n      var transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n\n      if (transformedProviderAst) {\n        return transformedProviderAst;\n      }\n\n      if (this._seenProviders.get(tokenReference(token)) != null) {\n        this.viewContext.errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \".concat(tokenName(token)), this._sourceSpan));\n        return null;\n      }\n\n      this._seenProviders.set(tokenReference(token), true);\n\n      var transformedProviders = resolvedProvider.providers.map(function (provider) {\n        var transformedUseValue = provider.useValue;\n        var transformedUseExisting = provider.useExisting;\n        var transformedDeps = undefined;\n\n        if (provider.useExisting != null) {\n          var existingDiDep = _this141._getDependency(resolvedProvider.providerType, {\n            token: provider.useExisting\n          }, eager);\n\n          if (existingDiDep.token != null) {\n            transformedUseExisting = existingDiDep.token;\n          } else {\n            transformedUseExisting = null;\n            transformedUseValue = existingDiDep.value;\n          }\n        } else if (provider.useFactory) {\n          var deps = provider.deps || provider.useFactory.diDeps;\n          transformedDeps = deps.map(function (dep) {\n            return _this141._getDependency(resolvedProvider.providerType, dep, eager);\n          });\n        } else if (provider.useClass) {\n          var _deps = provider.deps || provider.useClass.diDeps;\n\n          transformedDeps = _deps.map(function (dep) {\n            return _this141._getDependency(resolvedProvider.providerType, dep, eager);\n          });\n        }\n\n        return _transformProvider(provider, {\n          useExisting: transformedUseExisting,\n          useValue: transformedUseValue,\n          deps: transformedDeps\n        });\n      });\n      transformedProviderAst = _transformProviderAst(resolvedProvider, {\n        eager: eager,\n        providers: transformedProviders\n      });\n\n      this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n\n      return transformedProviderAst;\n    }\n  }, {\n    key: \"_getLocalDependency\",\n    value: function _getLocalDependency(requestingProviderType, dep) {\n      var eager = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (dep.isAttribute) {\n        var attrValue = this._attrs[dep.token.value];\n        return {\n          isValue: true,\n          value: attrValue == null ? null : attrValue\n        };\n      }\n\n      if (dep.token != null) {\n        // access builtints\n        if (requestingProviderType === ProviderAstType.Directive || requestingProviderType === ProviderAstType.Component) {\n          if (tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers$1.Renderer) || tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers$1.ElementRef) || tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers$1.ChangeDetectorRef) || tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers$1.TemplateRef)) {\n            return dep;\n          }\n\n          if (tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers$1.ViewContainerRef)) {\n            this.transformedHasViewContainer = true;\n          }\n        } // access the injector\n\n\n        if (tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers$1.Injector)) {\n          return dep;\n        } // access providers\n\n\n        if (this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager) != null) {\n          return dep;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_getDependency\",\n    value: function _getDependency(requestingProviderType, dep) {\n      var eager = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var currElement = this;\n      var currEager = eager;\n      var result = null;\n\n      if (!dep.isSkipSelf) {\n        result = this._getLocalDependency(requestingProviderType, dep, eager);\n      }\n\n      if (dep.isSelf) {\n        if (!result && dep.isOptional) {\n          result = {\n            isValue: true,\n            value: null\n          };\n        }\n      } else {\n        // check parent elements\n        while (!result && currElement._parent) {\n          var prevElement = currElement;\n          currElement = currElement._parent;\n\n          if (prevElement._isViewRoot) {\n            currEager = false;\n          }\n\n          result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);\n        } // check @Host restriction\n\n\n        if (!result) {\n          if (!dep.isHost || this.viewContext.component.isHost || this.viewContext.component.type.reference === tokenReference(dep.token) || this.viewContext.viewProviders.get(tokenReference(dep.token)) != null) {\n            result = dep;\n          } else {\n            result = dep.isOptional ? {\n              isValue: true,\n              value: null\n            } : null;\n          }\n        }\n      }\n\n      if (!result) {\n        this.viewContext.errors.push(new ProviderError(\"No provider for \".concat(tokenName(dep.token)), this._sourceSpan));\n      }\n\n      return result;\n    }\n  }]);\n\n  return ProviderElementContext;\n}();\n\nvar NgModuleProviderAnalyzer = /*#__PURE__*/function () {\n  function NgModuleProviderAnalyzer(reflector, ngModule, extraProviders, sourceSpan) {\n    var _this142 = this;\n\n    _classCallCheck(this, NgModuleProviderAnalyzer);\n\n    this.reflector = reflector;\n    this._transformedProviders = new Map();\n    this._seenProviders = new Map();\n    this._errors = [];\n    this._allProviders = new Map();\n    ngModule.transitiveModule.modules.forEach(function (ngModuleType) {\n      var ngModuleProvider = {\n        token: {\n          identifier: ngModuleType\n        },\n        useClass: ngModuleType\n      };\n\n      _resolveProviders([ngModuleProvider], ProviderAstType.PublicService, true, sourceSpan, _this142._errors, _this142._allProviders,\n      /* isModule */\n      true);\n    });\n\n    _resolveProviders(ngModule.transitiveModule.providers.map(function (entry) {\n      return entry.provider;\n    }).concat(extraProviders), ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders,\n    /* isModule */\n    false);\n  }\n\n  _createClass(NgModuleProviderAnalyzer, [{\n    key: \"parse\",\n    value: function parse() {\n      var _this143 = this;\n\n      Array.from(this._allProviders.values()).forEach(function (provider) {\n        _this143._getOrCreateLocalProvider(provider.token, provider.eager);\n      });\n\n      if (this._errors.length > 0) {\n        var errorString = this._errors.join('\\n');\n\n        throw new Error(\"Provider parse errors:\\n\".concat(errorString));\n      } // Note: Maps keep their insertion order.\n\n\n      var lazyProviders = [];\n      var eagerProviders = [];\n\n      this._transformedProviders.forEach(function (provider) {\n        if (provider.eager) {\n          eagerProviders.push(provider);\n        } else {\n          lazyProviders.push(provider);\n        }\n      });\n\n      return lazyProviders.concat(eagerProviders);\n    }\n  }, {\n    key: \"_getOrCreateLocalProvider\",\n    value: function _getOrCreateLocalProvider(token, eager) {\n      var _this144 = this;\n\n      var resolvedProvider = this._allProviders.get(tokenReference(token));\n\n      if (!resolvedProvider) {\n        return null;\n      }\n\n      var transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n\n      if (transformedProviderAst) {\n        return transformedProviderAst;\n      }\n\n      if (this._seenProviders.get(tokenReference(token)) != null) {\n        this._errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \".concat(tokenName(token)), resolvedProvider.sourceSpan));\n\n        return null;\n      }\n\n      this._seenProviders.set(tokenReference(token), true);\n\n      var transformedProviders = resolvedProvider.providers.map(function (provider) {\n        var transformedUseValue = provider.useValue;\n        var transformedUseExisting = provider.useExisting;\n        var transformedDeps = undefined;\n\n        if (provider.useExisting != null) {\n          var existingDiDep = _this144._getDependency({\n            token: provider.useExisting\n          }, eager, resolvedProvider.sourceSpan);\n\n          if (existingDiDep.token != null) {\n            transformedUseExisting = existingDiDep.token;\n          } else {\n            transformedUseExisting = null;\n            transformedUseValue = existingDiDep.value;\n          }\n        } else if (provider.useFactory) {\n          var deps = provider.deps || provider.useFactory.diDeps;\n          transformedDeps = deps.map(function (dep) {\n            return _this144._getDependency(dep, eager, resolvedProvider.sourceSpan);\n          });\n        } else if (provider.useClass) {\n          var _deps2 = provider.deps || provider.useClass.diDeps;\n\n          transformedDeps = _deps2.map(function (dep) {\n            return _this144._getDependency(dep, eager, resolvedProvider.sourceSpan);\n          });\n        }\n\n        return _transformProvider(provider, {\n          useExisting: transformedUseExisting,\n          useValue: transformedUseValue,\n          deps: transformedDeps\n        });\n      });\n      transformedProviderAst = _transformProviderAst(resolvedProvider, {\n        eager: eager,\n        providers: transformedProviders\n      });\n\n      this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n\n      return transformedProviderAst;\n    }\n  }, {\n    key: \"_getDependency\",\n    value: function _getDependency(dep) {\n      var eager = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var requestorSourceSpan = arguments.length > 2 ? arguments[2] : undefined;\n      var foundLocal = false;\n\n      if (!dep.isSkipSelf && dep.token != null) {\n        // access the injector\n        if (tokenReference(dep.token) === this.reflector.resolveExternalReference(Identifiers$1.Injector) || tokenReference(dep.token) === this.reflector.resolveExternalReference(Identifiers$1.ComponentFactoryResolver)) {\n          foundLocal = true; // access providers\n        } else if (this._getOrCreateLocalProvider(dep.token, eager) != null) {\n          foundLocal = true;\n        }\n      }\n\n      return dep;\n    }\n  }]);\n\n  return NgModuleProviderAnalyzer;\n}();\n\nfunction _transformProvider(provider, _ref12) {\n  var useExisting = _ref12.useExisting,\n      useValue = _ref12.useValue,\n      deps = _ref12.deps;\n  return {\n    token: provider.token,\n    useClass: provider.useClass,\n    useExisting: useExisting,\n    useFactory: provider.useFactory,\n    useValue: useValue,\n    deps: deps,\n    multi: provider.multi\n  };\n}\n\nfunction _transformProviderAst(provider, _ref13) {\n  var eager = _ref13.eager,\n      providers = _ref13.providers;\n  return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan, provider.isModule);\n}\n\nfunction _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {\n  var providersByToken = new Map();\n  directives.forEach(function (directive) {\n    var dirProvider = {\n      token: {\n        identifier: directive.type\n      },\n      useClass: directive.type\n    };\n\n    _resolveProviders([dirProvider], directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken,\n    /* isModule */\n    false);\n  }); // Note: directives need to be able to overwrite providers of a component!\n\n  var directivesWithComponentFirst = directives.filter(function (dir) {\n    return dir.isComponent;\n  }).concat(directives.filter(function (dir) {\n    return !dir.isComponent;\n  }));\n  directivesWithComponentFirst.forEach(function (directive) {\n    _resolveProviders(directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken,\n    /* isModule */\n    false);\n\n    _resolveProviders(directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken,\n    /* isModule */\n    false);\n  });\n  return providersByToken;\n}\n\nfunction _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken, isModule) {\n  providers.forEach(function (provider) {\n    var resolvedProvider = targetProvidersByToken.get(tokenReference(provider.token));\n\n    if (resolvedProvider != null && !!resolvedProvider.multiProvider !== !!provider.multi) {\n      targetErrors.push(new ProviderError(\"Mixing multi and non multi provider is not possible for token \".concat(tokenName(resolvedProvider.token)), sourceSpan));\n    }\n\n    if (!resolvedProvider) {\n      var lifecycleHooks = provider.token.identifier && provider.token.identifier.lifecycleHooks ? provider.token.identifier.lifecycleHooks : [];\n      var isUseValue = !(provider.useClass || provider.useExisting || provider.useFactory);\n      resolvedProvider = new ProviderAst(provider.token, !!provider.multi, eager || isUseValue, [provider], providerType, lifecycleHooks, sourceSpan, isModule);\n      targetProvidersByToken.set(tokenReference(provider.token), resolvedProvider);\n    } else {\n      if (!provider.multi) {\n        resolvedProvider.providers.length = 0;\n      }\n\n      resolvedProvider.providers.push(provider);\n    }\n  });\n}\n\nfunction _getViewQueries(component) {\n  // Note: queries start with id 1 so we can use the number in a Bloom filter!\n  var viewQueryId = 1;\n  var viewQueries = new Map();\n\n  if (component.viewQueries) {\n    component.viewQueries.forEach(function (query) {\n      return _addQueryToTokenMap(viewQueries, {\n        meta: query,\n        queryId: viewQueryId++\n      });\n    });\n  }\n\n  return viewQueries;\n}\n\nfunction _getContentQueries(contentQueryStartId, directives) {\n  var contentQueryId = contentQueryStartId;\n  var contentQueries = new Map();\n  directives.forEach(function (directive, directiveIndex) {\n    if (directive.queries) {\n      directive.queries.forEach(function (query) {\n        return _addQueryToTokenMap(contentQueries, {\n          meta: query,\n          queryId: contentQueryId++\n        });\n      });\n    }\n  });\n  return contentQueries;\n}\n\nfunction _addQueryToTokenMap(map, query) {\n  query.meta.selectors.forEach(function (token) {\n    var entry = map.get(tokenReference(token));\n\n    if (!entry) {\n      entry = [];\n      map.set(tokenReference(token), entry);\n    }\n\n    entry.push(query);\n  });\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar StyleWithImports = function StyleWithImports(style, styleUrls) {\n  _classCallCheck(this, StyleWithImports);\n\n  this.style = style;\n  this.styleUrls = styleUrls;\n};\n\nfunction isStyleUrlResolvable(url) {\n  if (url == null || url.length === 0 || url[0] == '/') return false;\n  var schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n  return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\n/**\r\n * Rewrites stylesheets by resolving and removing the @import urls that\r\n * are either relative or don't have a `package:` scheme\r\n */\n\n\nfunction extractStyleUrls(resolver, baseUrl, cssText) {\n  var foundUrls = [];\n  var modifiedCssText = cssText.replace(CSS_STRIPPABLE_COMMENT_REGEXP, '').replace(CSS_IMPORT_REGEXP, function () {\n    var url = (arguments.length <= 1 ? undefined : arguments[1]) || (arguments.length <= 2 ? undefined : arguments[2]);\n\n    if (!isStyleUrlResolvable(url)) {\n      // Do not attempt to resolve non-package absolute URLs with URI\n      // scheme\n      return arguments.length <= 0 ? undefined : arguments[0];\n    }\n\n    foundUrls.push(resolver.resolve(baseUrl, url));\n    return '';\n  });\n  return new StyleWithImports(modifiedCssText, foundUrls);\n}\n\nvar CSS_IMPORT_REGEXP = /@import\\s+(?:url\\()?\\s*(?:(?:['\"]([^'\"]*))|([^;\\)\\s]*))[^;]*;?/g;\nvar CSS_STRIPPABLE_COMMENT_REGEXP = /\\/\\*(?!#\\s*(?:sourceURL|sourceMappingURL)=)[\\s\\S]+?\\*\\//g;\nvar URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\nvar PROPERTY_PARTS_SEPARATOR = '.';\nvar ATTRIBUTE_PREFIX = 'attr';\nvar CLASS_PREFIX = 'class';\nvar STYLE_PREFIX = 'style';\nvar TEMPLATE_ATTR_PREFIX = '*';\nvar ANIMATE_PROP_PREFIX = 'animate-';\n/**\r\n * Parses bindings in templates and in the directive host area.\r\n */\n\nvar BindingParser = /*#__PURE__*/function () {\n  function BindingParser(_exprParser, _interpolationConfig, _schemaRegistry, pipes, errors) {\n    _classCallCheck(this, BindingParser);\n\n    this._exprParser = _exprParser;\n    this._interpolationConfig = _interpolationConfig;\n    this._schemaRegistry = _schemaRegistry;\n    this.errors = errors;\n    this.pipesByName = null;\n    this._usedPipes = new Map(); // When the `pipes` parameter is `null`, do not check for used pipes\n    // This is used in IVY when we might not know the available pipes at compile time\n\n    if (pipes) {\n      var pipesByName = new Map();\n      pipes.forEach(function (pipe) {\n        return pipesByName.set(pipe.name, pipe);\n      });\n      this.pipesByName = pipesByName;\n    }\n  }\n\n  _createClass(BindingParser, [{\n    key: \"interpolationConfig\",\n    get: function get() {\n      return this._interpolationConfig;\n    }\n  }, {\n    key: \"getUsedPipes\",\n    value: function getUsedPipes() {\n      return Array.from(this._usedPipes.values());\n    }\n  }, {\n    key: \"createBoundHostProperties\",\n    value: function createBoundHostProperties(dirMeta, sourceSpan) {\n      var _this145 = this;\n\n      if (dirMeta.hostProperties) {\n        var boundProps = [];\n        Object.keys(dirMeta.hostProperties).forEach(function (propName) {\n          var expression = dirMeta.hostProperties[propName];\n\n          if (typeof expression === 'string') {\n            _this145.parsePropertyBinding(propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [], // Use the `sourceSpan` for  `keySpan`. This isn't really accurate, but neither is the\n            // sourceSpan, as it represents the sourceSpan of the host itself rather than the\n            // source of the host binding (which doesn't exist in the template). Regardless,\n            // neither of these values are used in Ivy but are only here to satisfy the function\n            // signature. This should likely be refactored in the future so that `sourceSpan`\n            // isn't being used inaccurately.\n            boundProps, sourceSpan);\n          } else {\n            _this145._reportError(\"Value of the host property binding \\\"\".concat(propName, \"\\\" needs to be a string representing an expression but got \\\"\").concat(expression, \"\\\" (\").concat(typeof expression, \")\"), sourceSpan);\n          }\n        });\n        return boundProps;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"createDirectiveHostPropertyAsts\",\n    value: function createDirectiveHostPropertyAsts(dirMeta, elementSelector, sourceSpan) {\n      var _this146 = this;\n\n      var boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);\n      return boundProps && boundProps.map(function (prop) {\n        return _this146.createBoundElementProperty(elementSelector, prop);\n      });\n    }\n  }, {\n    key: \"createDirectiveHostEventAsts\",\n    value: function createDirectiveHostEventAsts(dirMeta, sourceSpan) {\n      var _this147 = this;\n\n      if (dirMeta.hostListeners) {\n        var targetEvents = [];\n        Object.keys(dirMeta.hostListeners).forEach(function (propName) {\n          var expression = dirMeta.hostListeners[propName];\n\n          if (typeof expression === 'string') {\n            // Use the `sourceSpan` for  `keySpan` and `handlerSpan`. This isn't really accurate, but\n            // neither is the `sourceSpan`, as it represents the `sourceSpan` of the host itself\n            // rather than the source of the host binding (which doesn't exist in the template).\n            // Regardless, neither of these values are used in Ivy but are only here to satisfy the\n            // function signature. This should likely be refactored in the future so that `sourceSpan`\n            // isn't being used inaccurately.\n            _this147.parseEvent(propName, expression, sourceSpan, sourceSpan, [], targetEvents, sourceSpan);\n          } else {\n            _this147._reportError(\"Value of the host listener \\\"\".concat(propName, \"\\\" needs to be a string representing an expression but got \\\"\").concat(expression, \"\\\" (\").concat(typeof expression, \")\"), sourceSpan);\n          }\n        });\n        return targetEvents;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"parseInterpolation\",\n    value: function parseInterpolation(value, sourceSpan) {\n      var sourceInfo = sourceSpan.start.toString();\n      var absoluteOffset = sourceSpan.fullStart.offset;\n\n      try {\n        var ast = this._exprParser.parseInterpolation(value, sourceInfo, absoluteOffset, this._interpolationConfig);\n\n        if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n\n        this._checkPipes(ast, sourceSpan);\n\n        return ast;\n      } catch (e) {\n        this._reportError(\"\".concat(e), sourceSpan);\n\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n      }\n    }\n    /**\r\n     * Similar to `parseInterpolation`, but treats the provided string as a single expression\r\n     * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\r\n     * This is used for parsing the switch expression in ICUs.\r\n     */\n\n  }, {\n    key: \"parseInterpolationExpression\",\n    value: function parseInterpolationExpression(expression, sourceSpan) {\n      var sourceInfo = sourceSpan.start.toString();\n      var absoluteOffset = sourceSpan.start.offset;\n\n      try {\n        var ast = this._exprParser.parseInterpolationExpression(expression, sourceInfo, absoluteOffset);\n\n        if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n\n        this._checkPipes(ast, sourceSpan);\n\n        return ast;\n      } catch (e) {\n        this._reportError(\"\".concat(e), sourceSpan);\n\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n      }\n    }\n    /**\r\n     * Parses the bindings in a microsyntax expression, and converts them to\r\n     * `ParsedProperty` or `ParsedVariable`.\r\n     *\r\n     * @param tplKey template binding name\r\n     * @param tplValue template binding value\r\n     * @param sourceSpan span of template binding relative to entire the template\r\n     * @param absoluteValueOffset start of the tplValue relative to the entire template\r\n     * @param targetMatchableAttrs potential attributes to match in the template\r\n     * @param targetProps target property bindings in the template\r\n     * @param targetVars target variables in the template\r\n     */\n\n  }, {\n    key: \"parseInlineTemplateBinding\",\n    value: function parseInlineTemplateBinding(tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars, isIvyAst) {\n      var absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX.length;\n\n      var bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);\n\n      var _iterator9 = _createForOfIteratorHelper(bindings),\n          _step9;\n\n      try {\n        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n          var binding = _step9.value;\n          // sourceSpan is for the entire HTML attribute. bindingSpan is for a particular\n          // binding within the microsyntax expression so it's more narrow than sourceSpan.\n          var bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);\n          var key = binding.key.source;\n          var keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);\n\n          if (binding instanceof VariableBinding) {\n            var value = binding.value ? binding.value.source : '$implicit';\n            var valueSpan = binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : undefined;\n            targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));\n          } else if (binding.value) {\n            var srcSpan = isIvyAst ? bindingSpan : sourceSpan;\n\n            var _valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);\n\n            this._parsePropertyAst(key, binding.value, srcSpan, keySpan, _valueSpan, targetMatchableAttrs, targetProps);\n          } else {\n            targetMatchableAttrs.push([key, ''\n            /* value */\n            ]); // Since this is a literal attribute with no RHS, source span should be\n            // just the key span.\n\n            this.parseLiteralAttr(key, null\n            /* value */\n            , keySpan, absoluteValueOffset, undefined\n            /* valueSpan */\n            , targetMatchableAttrs, targetProps, keySpan);\n          }\n        }\n      } catch (err) {\n        _iterator9.e(err);\n      } finally {\n        _iterator9.f();\n      }\n    }\n    /**\r\n     * Parses the bindings in a microsyntax expression, e.g.\r\n     * ```\r\n     *    <tag *tplKey=\"let value1 = prop; let value2 = localVar\">\r\n     * ```\r\n     *\r\n     * @param tplKey template binding name\r\n     * @param tplValue template binding value\r\n     * @param sourceSpan span of template binding relative to entire the template\r\n     * @param absoluteKeyOffset start of the `tplKey`\r\n     * @param absoluteValueOffset start of the `tplValue`\r\n     */\n\n  }, {\n    key: \"_parseTemplateBindings\",\n    value: function _parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset) {\n      var _this148 = this;\n\n      var sourceInfo = sourceSpan.start.toString();\n\n      try {\n        var bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);\n\n        this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n\n        bindingsResult.templateBindings.forEach(function (binding) {\n          if (binding.value instanceof ASTWithSource) {\n            _this148._checkPipes(binding.value, sourceSpan);\n          }\n        });\n        bindingsResult.warnings.forEach(function (warning) {\n          _this148._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);\n        });\n        return bindingsResult.templateBindings;\n      } catch (e) {\n        this._reportError(\"\".concat(e), sourceSpan);\n\n        return [];\n      }\n    }\n  }, {\n    key: \"parseLiteralAttr\",\n    value: function parseLiteralAttr(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, // TODO(atscott): keySpan is only optional here so VE template parser implementation does not\n    // have to change This should be required when VE is removed.\n    targetProps, keySpan) {\n      if (isAnimationLabel(name)) {\n        name = name.substring(1);\n\n        if (keySpan !== undefined) {\n          keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n        }\n\n        if (value) {\n          this._reportError(\"Assigning animation triggers via @prop=\\\"exp\\\" attributes with an expression is invalid.\" + \" Use property bindings (e.g. [@prop]=\\\"exp\\\") or use an attribute without a value (e.g. @prop) instead.\", sourceSpan, ParseErrorLevel.ERROR);\n        }\n\n        this._parseAnimation(name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n      } else {\n        targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset), ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));\n      }\n    }\n  }, {\n    key: \"parsePropertyBinding\",\n    value: function parsePropertyBinding(name, expression, isHost, sourceSpan, absoluteOffset, valueSpan, // TODO(atscott): keySpan is only optional here so VE template parser implementation does not\n    // have to change This should be required when VE is removed.\n    targetMatchableAttrs, targetProps, keySpan) {\n      if (name.length === 0) {\n        this._reportError(\"Property name is missing in binding\", sourceSpan);\n      }\n\n      var isAnimationProp = false;\n\n      if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n        isAnimationProp = true;\n        name = name.substring(ANIMATE_PROP_PREFIX.length);\n\n        if (keySpan !== undefined) {\n          keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + ANIMATE_PROP_PREFIX.length, keySpan.end.offset));\n        }\n      } else if (isAnimationLabel(name)) {\n        isAnimationProp = true;\n        name = name.substring(1);\n\n        if (keySpan !== undefined) {\n          keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n        }\n      }\n\n      if (isAnimationProp) {\n        this._parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n      } else {\n        this._parsePropertyAst(name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n      }\n    }\n  }, {\n    key: \"parsePropertyInterpolation\",\n    value: function parsePropertyInterpolation(name, value, sourceSpan, valueSpan, targetMatchableAttrs, // TODO(atscott): keySpan is only optional here so VE template parser implementation does not\n    // have to change This should be required when VE is removed.\n    targetProps, keySpan) {\n      var expr = this.parseInterpolation(value, valueSpan || sourceSpan);\n\n      if (expr) {\n        this._parsePropertyAst(name, expr, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_parsePropertyAst\",\n    value: function _parsePropertyAst(name, ast, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n      targetMatchableAttrs.push([name, ast.source]);\n      targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));\n    }\n  }, {\n    key: \"_parseAnimation\",\n    value: function _parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\n      if (name.length === 0) {\n        this._reportError('Animation trigger is missing', sourceSpan);\n      } // This will occur when a @trigger is not paired with an expression.\n      // For animations it is valid to not have an expression since */void\n      // states will be applied by angular when the element is attached/detached\n\n\n      var ast = this._parseBinding(expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);\n\n      targetMatchableAttrs.push([name, ast.source]);\n      targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));\n    }\n  }, {\n    key: \"_parseBinding\",\n    value: function _parseBinding(value, isHostBinding, sourceSpan, absoluteOffset) {\n      var sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();\n\n      try {\n        var ast = isHostBinding ? this._exprParser.parseSimpleBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig) : this._exprParser.parseBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig);\n        if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n\n        this._checkPipes(ast, sourceSpan);\n\n        return ast;\n      } catch (e) {\n        this._reportError(\"\".concat(e), sourceSpan);\n\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n      }\n    }\n  }, {\n    key: \"createBoundElementProperty\",\n    value: function createBoundElementProperty(elementSelector, boundProp) {\n      var skipValidation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var mapPropertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n      if (boundProp.isAnimation) {\n        return new BoundElementProperty(boundProp.name, 4\n        /* Animation */\n        , SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n      }\n\n      var unit = null;\n      var bindingType = undefined;\n      var boundPropertyName = null;\n      var parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n      var securityContexts = undefined; // Check for special cases (prefix style, attr, class)\n\n      if (parts.length > 1) {\n        if (parts[0] == ATTRIBUTE_PREFIX) {\n          boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);\n\n          if (!skipValidation) {\n            this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n          }\n\n          securityContexts = _calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);\n          var nsSeparatorIdx = boundPropertyName.indexOf(':');\n\n          if (nsSeparatorIdx > -1) {\n            var ns = boundPropertyName.substring(0, nsSeparatorIdx);\n            var name = boundPropertyName.substring(nsSeparatorIdx + 1);\n            boundPropertyName = mergeNsAndName(ns, name);\n          }\n\n          bindingType = 1\n          /* Attribute */\n          ;\n        } else if (parts[0] == CLASS_PREFIX) {\n          boundPropertyName = parts[1];\n          bindingType = 2\n          /* Class */\n          ;\n          securityContexts = [SecurityContext.NONE];\n        } else if (parts[0] == STYLE_PREFIX) {\n          unit = parts.length > 2 ? parts[2] : null;\n          boundPropertyName = parts[1];\n          bindingType = 3\n          /* Style */\n          ;\n          securityContexts = [SecurityContext.STYLE];\n        }\n      } // If not a special case, use the full property name\n\n\n      if (boundPropertyName === null) {\n        var mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);\n\n        boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;\n        securityContexts = _calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);\n        bindingType = 0\n        /* Property */\n        ;\n\n        if (!skipValidation) {\n          this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);\n        }\n      }\n\n      return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\n    } // TODO: keySpan should be required but was made optional to avoid changing VE parser.\n\n  }, {\n    key: \"parseEvent\",\n    value: function parseEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {\n      if (name.length === 0) {\n        this._reportError(\"Event name is missing in binding\", sourceSpan);\n      }\n\n      if (isAnimationLabel(name)) {\n        name = name.substr(1);\n\n        if (keySpan !== undefined) {\n          keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\n        }\n\n        this._parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan);\n      } else {\n        this._parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan);\n      }\n    }\n  }, {\n    key: \"calcPossibleSecurityContexts\",\n    value: function calcPossibleSecurityContexts(selector, propName, isAttribute) {\n      var prop = this._schemaRegistry.getMappedPropName(propName);\n\n      return _calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);\n    }\n  }, {\n    key: \"_parseAnimationEvent\",\n    value: function _parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan) {\n      var matches = splitAtPeriod(name, [name, '']);\n      var eventName = matches[0];\n      var phase = matches[1].toLowerCase();\n\n      var ast = this._parseAction(expression, handlerSpan);\n\n      targetEvents.push(new ParsedEvent(eventName, phase, 1\n      /* Animation */\n      , ast, sourceSpan, handlerSpan, keySpan));\n\n      if (eventName.length === 0) {\n        this._reportError(\"Animation event name is missing in binding\", sourceSpan);\n      }\n\n      if (phase) {\n        if (phase !== 'start' && phase !== 'done') {\n          this._reportError(\"The provided animation output phase value \\\"\".concat(phase, \"\\\" for \\\"@\").concat(eventName, \"\\\" is not supported (use start or done)\"), sourceSpan);\n        }\n      } else {\n        this._reportError(\"The animation trigger output event (@\".concat(eventName, \") is missing its phase value name (start or done are currently supported)\"), sourceSpan);\n      }\n    }\n  }, {\n    key: \"_parseRegularEvent\",\n    value: function _parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {\n      // long format: 'target: eventName'\n      var _splitAtColon3 = splitAtColon(name, [null, name]),\n          _splitAtColon4 = _slicedToArray(_splitAtColon3, 2),\n          target = _splitAtColon4[0],\n          eventName = _splitAtColon4[1];\n\n      var ast = this._parseAction(expression, handlerSpan);\n\n      targetMatchableAttrs.push([name, ast.source]);\n      targetEvents.push(new ParsedEvent(eventName, target, 0\n      /* Regular */\n      , ast, sourceSpan, handlerSpan, keySpan)); // Don't detect directives for event names for now,\n      // so don't add the event name to the matchableAttrs\n    }\n  }, {\n    key: \"_parseAction\",\n    value: function _parseAction(value, sourceSpan) {\n      var sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();\n      var absoluteOffset = sourceSpan && sourceSpan.start ? sourceSpan.start.offset : 0;\n\n      try {\n        var ast = this._exprParser.parseAction(value, sourceInfo, absoluteOffset, this._interpolationConfig);\n\n        if (ast) {\n          this._reportExpressionParserErrors(ast.errors, sourceSpan);\n        }\n\n        if (!ast || ast.ast instanceof EmptyExpr) {\n          this._reportError(\"Empty expressions are not allowed\", sourceSpan);\n\n          return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n\n        this._checkPipes(ast, sourceSpan);\n\n        return ast;\n      } catch (e) {\n        this._reportError(\"\".concat(e), sourceSpan);\n\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n      }\n    }\n  }, {\n    key: \"_reportError\",\n    value: function _reportError(message, sourceSpan) {\n      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ParseErrorLevel.ERROR;\n      this.errors.push(new ParseError(sourceSpan, message, level));\n    }\n  }, {\n    key: \"_reportExpressionParserErrors\",\n    value: function _reportExpressionParserErrors(errors, sourceSpan) {\n      var _iterator10 = _createForOfIteratorHelper(errors),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var _error = _step10.value;\n\n          this._reportError(_error.message, sourceSpan);\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n    } // Make sure all the used pipes are known in `this.pipesByName`\n\n  }, {\n    key: \"_checkPipes\",\n    value: function _checkPipes(ast, sourceSpan) {\n      var _this149 = this;\n\n      if (ast && this.pipesByName) {\n        var collector = new PipeCollector();\n        ast.visit(collector);\n        collector.pipes.forEach(function (ast, pipeName) {\n          var pipeMeta = _this149.pipesByName.get(pipeName);\n\n          if (!pipeMeta) {\n            _this149._reportError(\"The pipe '\".concat(pipeName, \"' could not be found\"), new ParseSourceSpan(sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n          } else {\n            _this149._usedPipes.set(pipeName, pipeMeta);\n          }\n        });\n      }\n    }\n    /**\r\n     * @param propName the name of the property / attribute\r\n     * @param sourceSpan\r\n     * @param isAttr true when binding to an attribute\r\n     */\n\n  }, {\n    key: \"_validatePropertyOrAttributeName\",\n    value: function _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {\n      var report = isAttr ? this._schemaRegistry.validateAttribute(propName) : this._schemaRegistry.validateProperty(propName);\n\n      if (report.error) {\n        this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);\n      }\n    }\n  }]);\n\n  return BindingParser;\n}();\n\nvar PipeCollector = /*#__PURE__*/function (_RecursiveAstVisitor$) {\n  _inherits(PipeCollector, _RecursiveAstVisitor$);\n\n  var _super94 = _createSuper(PipeCollector);\n\n  function PipeCollector() {\n    var _this150;\n\n    _classCallCheck(this, PipeCollector);\n\n    _this150 = _super94.apply(this, arguments);\n    _this150.pipes = new Map();\n    return _this150;\n  }\n\n  _createClass(PipeCollector, [{\n    key: \"visitPipe\",\n    value: function visitPipe(ast, context) {\n      this.pipes.set(ast.name, ast);\n      ast.exp.visit(this);\n      this.visitAll(ast.args, context);\n      return null;\n    }\n  }]);\n\n  return PipeCollector;\n}(RecursiveAstVisitor$1);\n\nfunction isAnimationLabel(name) {\n  return name[0] == '@';\n}\n\nfunction _calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {\n  var ctxs = [];\n  CssSelector.parse(selector).forEach(function (selector) {\n    var elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n    var notElementNames = new Set(selector.notSelectors.filter(function (selector) {\n      return selector.isElementSelector();\n    }).map(function (selector) {\n      return selector.element;\n    }));\n    var possibleElementNames = elementNames.filter(function (elementName) {\n      return !notElementNames.has(elementName);\n    });\n    ctxs.push.apply(ctxs, _toConsumableArray(possibleElementNames.map(function (elementName) {\n      return registry.securityContext(elementName, propName, isAttribute);\n    })));\n  });\n  return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n/**\r\n * Compute a new ParseSourceSpan based off an original `sourceSpan` by using\r\n * absolute offsets from the specified `absoluteSpan`.\r\n *\r\n * @param sourceSpan original source span\r\n * @param absoluteSpan absolute source span to move to\r\n */\n\n\nfunction moveParseSourceSpan(sourceSpan, absoluteSpan) {\n  // The difference of two absolute offsets provide the relative offset\n  var startDiff = absoluteSpan.start - sourceSpan.start.offset;\n  var endDiff = absoluteSpan.end - sourceSpan.end.offset;\n  return new ParseSourceSpan(sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff), sourceSpan.fullStart.moveBy(startDiff), sourceSpan.details);\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar NG_CONTENT_SELECT_ATTR = 'select';\nvar LINK_ELEMENT = 'link';\nvar LINK_STYLE_REL_ATTR = 'rel';\nvar LINK_STYLE_HREF_ATTR = 'href';\nvar LINK_STYLE_REL_VALUE = 'stylesheet';\nvar STYLE_ELEMENT = 'style';\nvar SCRIPT_ELEMENT = 'script';\nvar NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nvar NG_PROJECT_AS = 'ngProjectAs';\n\nfunction preparseElement(ast) {\n  var selectAttr = null;\n  var hrefAttr = null;\n  var relAttr = null;\n  var nonBindable = false;\n  var projectAs = '';\n  ast.attrs.forEach(function (attr) {\n    var lcAttrName = attr.name.toLowerCase();\n\n    if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\n      selectAttr = attr.value;\n    } else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n      hrefAttr = attr.value;\n    } else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n      relAttr = attr.value;\n    } else if (attr.name == NG_NON_BINDABLE_ATTR) {\n      nonBindable = true;\n    } else if (attr.name == NG_PROJECT_AS) {\n      if (attr.value.length > 0) {\n        projectAs = attr.value;\n      }\n    }\n  });\n  selectAttr = normalizeNgContentSelect(selectAttr);\n  var nodeName = ast.name.toLowerCase();\n  var type = PreparsedElementType.OTHER;\n\n  if (isNgContent(nodeName)) {\n    type = PreparsedElementType.NG_CONTENT;\n  } else if (nodeName == STYLE_ELEMENT) {\n    type = PreparsedElementType.STYLE;\n  } else if (nodeName == SCRIPT_ELEMENT) {\n    type = PreparsedElementType.SCRIPT;\n  } else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n    type = PreparsedElementType.STYLESHEET;\n  }\n\n  return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n}\n\nvar PreparsedElementType;\n\n(function (PreparsedElementType) {\n  PreparsedElementType[PreparsedElementType[\"NG_CONTENT\"] = 0] = \"NG_CONTENT\";\n  PreparsedElementType[PreparsedElementType[\"STYLE\"] = 1] = \"STYLE\";\n  PreparsedElementType[PreparsedElementType[\"STYLESHEET\"] = 2] = \"STYLESHEET\";\n  PreparsedElementType[PreparsedElementType[\"SCRIPT\"] = 3] = \"SCRIPT\";\n  PreparsedElementType[PreparsedElementType[\"OTHER\"] = 4] = \"OTHER\";\n})(PreparsedElementType || (PreparsedElementType = {}));\n\nvar PreparsedElement = function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {\n  _classCallCheck(this, PreparsedElement);\n\n  this.type = type;\n  this.selectAttr = selectAttr;\n  this.hrefAttr = hrefAttr;\n  this.nonBindable = nonBindable;\n  this.projectAs = projectAs;\n};\n\nfunction normalizeNgContentSelect(selectAttr) {\n  if (selectAttr === null || selectAttr.length === 0) {\n    return '*';\n  }\n\n  return selectAttr;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/; // Group 1 = \"bind-\"\n\nvar KW_BIND_IDX = 1; // Group 2 = \"let-\"\n\nvar KW_LET_IDX = 2; // Group 3 = \"ref-/#\"\n\nvar KW_REF_IDX = 3; // Group 4 = \"on-\"\n\nvar KW_ON_IDX = 4; // Group 5 = \"bindon-\"\n\nvar KW_BINDON_IDX = 5; // Group 6 = \"@\"\n\nvar KW_AT_IDX = 6; // Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\n\nvar IDENT_KW_IDX = 7; // Group 8 = identifier inside [()]\n\nvar IDENT_BANANA_BOX_IDX = 8; // Group 9 = identifier inside []\n\nvar IDENT_PROPERTY_IDX = 9; // Group 10 = identifier inside ()\n\nvar IDENT_EVENT_IDX = 10;\nvar TEMPLATE_ATTR_PREFIX$1 = '*';\nvar CLASS_ATTR = 'class';\n\nvar _TEXT_CSS_SELECTOR;\n\nfunction TEXT_CSS_SELECTOR() {\n  if (!_TEXT_CSS_SELECTOR) {\n    _TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];\n  }\n\n  return _TEXT_CSS_SELECTOR;\n}\n\nvar TemplateParseError = /*#__PURE__*/function (_ParseError5) {\n  _inherits(TemplateParseError, _ParseError5);\n\n  var _super95 = _createSuper(TemplateParseError);\n\n  function TemplateParseError(message, span, level) {\n    _classCallCheck(this, TemplateParseError);\n\n    return _super95.call(this, span, message, level);\n  }\n\n  return TemplateParseError;\n}(ParseError);\n\nvar TemplateParseResult = function TemplateParseResult(templateAst, usedPipes, errors) {\n  _classCallCheck(this, TemplateParseResult);\n\n  this.templateAst = templateAst;\n  this.usedPipes = usedPipes;\n  this.errors = errors;\n};\n\nvar TemplateParser = /*#__PURE__*/function () {\n  function TemplateParser(_config, _reflector, _exprParser, _schemaRegistry, _htmlParser, _console, transforms) {\n    _classCallCheck(this, TemplateParser);\n\n    this._config = _config;\n    this._reflector = _reflector;\n    this._exprParser = _exprParser;\n    this._schemaRegistry = _schemaRegistry;\n    this._htmlParser = _htmlParser;\n    this._console = _console;\n    this.transforms = transforms;\n  }\n\n  _createClass(TemplateParser, [{\n    key: \"expressionParser\",\n    get: function get() {\n      return this._exprParser;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {\n      var _a;\n\n      var result = this.tryParse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces);\n      var warnings = result.errors.filter(function (error) {\n        return error.level === ParseErrorLevel.WARNING;\n      });\n      var errors = result.errors.filter(function (error) {\n        return error.level === ParseErrorLevel.ERROR;\n      });\n\n      if (warnings.length > 0) {\n        (_a = this._console) === null || _a === void 0 ? void 0 : _a.warn(\"Template parse warnings:\\n\".concat(warnings.join('\\n')));\n      }\n\n      if (errors.length > 0) {\n        var errorString = errors.join('\\n');\n        throw syntaxError(\"Template parse errors:\\n\".concat(errorString), errors);\n      }\n\n      return {\n        template: result.templateAst,\n        pipes: result.usedPipes\n      };\n    }\n  }, {\n    key: \"tryParse\",\n    value: function tryParse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {\n      var htmlParseResult = typeof template === 'string' ? this._htmlParser.parse(template, templateUrl, {\n        tokenizeExpansionForms: true,\n        interpolationConfig: this.getInterpolationConfig(component)\n      }) : template;\n\n      if (!preserveWhitespaces) {\n        htmlParseResult = removeWhitespaces(htmlParseResult);\n      }\n\n      return this.tryParseHtml(this.expandHtml(htmlParseResult), component, directives, pipes, schemas);\n    }\n  }, {\n    key: \"tryParseHtml\",\n    value: function tryParseHtml(htmlAstWithErrors, component, directives, pipes, schemas) {\n      var result;\n      var errors = htmlAstWithErrors.errors;\n      var usedPipes = [];\n\n      if (htmlAstWithErrors.rootNodes.length > 0) {\n        var uniqDirectives = removeSummaryDuplicates(directives);\n        var uniqPipes = removeSummaryDuplicates(pipes);\n        var providerViewContext = new ProviderViewContext(this._reflector, component);\n        var interpolationConfig = undefined;\n\n        if (component.template && component.template.interpolation) {\n          interpolationConfig = {\n            start: component.template.interpolation[0],\n            end: component.template.interpolation[1]\n          };\n        }\n\n        var bindingParser = new BindingParser(this._exprParser, interpolationConfig, this._schemaRegistry, uniqPipes, errors);\n        var parseVisitor = new TemplateParseVisitor(this._reflector, this._config, providerViewContext, uniqDirectives, bindingParser, this._schemaRegistry, schemas, errors);\n        result = visitAll$1(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);\n        errors.push.apply(errors, _toConsumableArray(providerViewContext.errors));\n        usedPipes.push.apply(usedPipes, _toConsumableArray(bindingParser.getUsedPipes()));\n      } else {\n        result = [];\n      }\n\n      this._assertNoReferenceDuplicationOnTemplate(result, errors);\n\n      if (errors.length > 0) {\n        return new TemplateParseResult(result, usedPipes, errors);\n      }\n\n      if (this.transforms) {\n        this.transforms.forEach(function (transform) {\n          result = templateVisitAll(transform, result);\n        });\n      }\n\n      return new TemplateParseResult(result, usedPipes, errors);\n    }\n  }, {\n    key: \"expandHtml\",\n    value: function expandHtml(htmlAstWithErrors) {\n      var forced = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var errors = htmlAstWithErrors.errors;\n\n      if (errors.length == 0 || forced) {\n        // Transform ICU messages to angular directives\n        var expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);\n        errors.push.apply(errors, _toConsumableArray(expandedHtmlAst.errors));\n        htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);\n      }\n\n      return htmlAstWithErrors;\n    }\n  }, {\n    key: \"getInterpolationConfig\",\n    value: function getInterpolationConfig(component) {\n      if (component.template) {\n        return InterpolationConfig.fromArray(component.template.interpolation);\n      }\n\n      return undefined;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_assertNoReferenceDuplicationOnTemplate\",\n    value: function _assertNoReferenceDuplicationOnTemplate(result, errors) {\n      var existingReferences = [];\n      result.filter(function (element) {\n        return !!element.references;\n      }).forEach(function (element) {\n        return element.references.forEach(function (reference) {\n          var name = reference.name;\n\n          if (existingReferences.indexOf(name) < 0) {\n            existingReferences.push(name);\n          } else {\n            var _error2 = new TemplateParseError(\"Reference \\\"#\".concat(name, \"\\\" is defined several times\"), reference.sourceSpan, ParseErrorLevel.ERROR);\n\n            errors.push(_error2);\n          }\n        });\n      });\n    }\n  }]);\n\n  return TemplateParser;\n}();\n\nvar TemplateParseVisitor = /*#__PURE__*/function () {\n  function TemplateParseVisitor(reflector, config, providerViewContext, directives, _bindingParser, _schemaRegistry, _schemas, _targetErrors) {\n    var _this151 = this;\n\n    _classCallCheck(this, TemplateParseVisitor);\n\n    this.reflector = reflector;\n    this.config = config;\n    this.providerViewContext = providerViewContext;\n    this._bindingParser = _bindingParser;\n    this._schemaRegistry = _schemaRegistry;\n    this._schemas = _schemas;\n    this._targetErrors = _targetErrors;\n    this.selectorMatcher = new SelectorMatcher();\n    this.directivesIndex = new Map();\n    this.ngContentCount = 0; // Note: queries start with id 1 so we can use the number in a Bloom filter!\n\n    this.contentQueryStartId = providerViewContext.component.viewQueries.length + 1;\n    directives.forEach(function (directive, index) {\n      var selector = CssSelector.parse(directive.selector);\n\n      _this151.selectorMatcher.addSelectables(selector, directive);\n\n      _this151.directivesIndex.set(directive, index);\n    });\n  }\n\n  _createClass(TemplateParseVisitor, [{\n    key: \"visitExpansion\",\n    value: function visitExpansion(expansion, context) {\n      return null;\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(expansionCase, context) {\n      return null;\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, parent) {\n      var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());\n      var valueNoNgsp = replaceNgsp(text.value);\n\n      var expr = this._bindingParser.parseInterpolation(valueNoNgsp, text.sourceSpan);\n\n      return expr ? new BoundTextAst(expr, ngContentIndex, text.sourceSpan) : new TextAst(valueNoNgsp, ngContentIndex, text.sourceSpan);\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute, context) {\n      return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment, context) {\n      return null;\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(element, parent) {\n      var _this152 = this;\n\n      var queryStartIndex = this.contentQueryStartId;\n      var elName = element.name;\n      var preparsedElement = preparseElement(element);\n\n      if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE) {\n        // Skipping <script> for security reasons\n        // Skipping <style> as we already processed them\n        // in the StyleCompiler\n        return null;\n      }\n\n      if (preparsedElement.type === PreparsedElementType.STYLESHEET && isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n        // Skipping stylesheets with either relative urls or package scheme as we already processed\n        // them in the StyleCompiler\n        return null;\n      }\n\n      var matchableAttrs = [];\n      var elementOrDirectiveProps = [];\n      var elementOrDirectiveRefs = [];\n      var elementVars = [];\n      var events = [];\n      var templateElementOrDirectiveProps = [];\n      var templateMatchableAttrs = [];\n      var templateElementVars = [];\n      var hasInlineTemplates = false;\n      var attrs = [];\n      var isTemplateElement = isNgTemplate(element.name);\n      element.attrs.forEach(function (attr) {\n        var parsedVariables = [];\n\n        var hasBinding = _this152._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);\n\n        elementVars.push.apply(elementVars, _toConsumableArray(parsedVariables.map(function (v) {\n          return VariableAst.fromParsedVariable(v);\n        })));\n        var templateValue;\n        var templateKey;\n\n        var normalizedName = _this152._normalizeAttributeName(attr.name);\n\n        if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX$1)) {\n          templateValue = attr.value;\n          templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX$1.length);\n        }\n\n        var hasTemplateBinding = templateValue != null;\n\n        if (hasTemplateBinding) {\n          if (hasInlineTemplates) {\n            _this152._reportError(\"Can't have multiple template bindings on one element. Use only one attribute prefixed with *\", attr.sourceSpan);\n          }\n\n          hasInlineTemplates = true;\n          var _parsedVariables = [];\n          var absoluteOffset = (attr.valueSpan || attr.sourceSpan).start.offset;\n\n          _this152._bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attr.sourceSpan, absoluteOffset, templateMatchableAttrs, templateElementOrDirectiveProps, _parsedVariables, false\n          /* isIvyAst */\n          );\n\n          templateElementVars.push.apply(templateElementVars, _toConsumableArray(_parsedVariables.map(function (v) {\n            return VariableAst.fromParsedVariable(v);\n          })));\n        }\n\n        if (!hasBinding && !hasTemplateBinding) {\n          // don't include the bindings as attributes as well in the AST\n          attrs.push(_this152.visitAttribute(attr, null));\n          matchableAttrs.push([attr.name, attr.value]);\n        }\n      });\n      var elementCssSelector = createElementCssSelector(elName, matchableAttrs);\n\n      var _this$_parseDirective = this._parseDirectives(this.selectorMatcher, elementCssSelector),\n          directiveMetas = _this$_parseDirective.directives,\n          matchElement = _this$_parseDirective.matchElement;\n\n      var references = [];\n      var boundDirectivePropNames = new Set();\n\n      var directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references, boundDirectivePropNames);\n\n      var elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, boundDirectivePropNames);\n\n      var isViewRoot = parent.isTemplateElement || hasInlineTemplates;\n      var providerContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, isTemplateElement, queryStartIndex, element.sourceSpan);\n      var children = visitAll$1(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));\n      providerContext.afterElement(); // Override the actual selector when the `ngProjectAs` attribute is provided\n\n      var projectionSelector = preparsedElement.projectAs != '' ? CssSelector.parse(preparsedElement.projectAs)[0] : elementCssSelector;\n      var ngContentIndex = parent.findNgContentIndex(projectionSelector);\n      var parsedElement;\n\n      if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n        // `<ng-content>` element\n        if (element.children && !element.children.every(_isEmptyTextNode)) {\n          this._reportError(\"<ng-content> element cannot have content.\", element.sourceSpan);\n        }\n\n        parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);\n      } else if (isTemplateElement) {\n        // `<ng-template>` element\n        this._assertAllEventsPublishedByDirectives(directiveAsts, events);\n\n        this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);\n\n        parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);\n      } else {\n        // element other than `<ng-content>` and `<ng-template>`\n        this._assertElementExists(matchElement, element);\n\n        this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);\n\n        var _ngContentIndex = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);\n\n        parsedElement = new ElementAst(elName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : _ngContentIndex, element.sourceSpan, element.endSourceSpan || null);\n      }\n\n      if (hasInlineTemplates) {\n        // The element as a *-attribute\n        var templateQueryStartIndex = this.contentQueryStartId;\n        var templateSelector = createElementCssSelector('ng-template', templateMatchableAttrs);\n\n        var _this$_parseDirective2 = this._parseDirectives(this.selectorMatcher, templateSelector),\n            directives = _this$_parseDirective2.directives;\n\n        var templateBoundDirectivePropNames = new Set();\n\n        var templateDirectiveAsts = this._createDirectiveAsts(true, elName, directives, templateElementOrDirectiveProps, [], element.sourceSpan, [], templateBoundDirectivePropNames);\n\n        var templateElementProps = this._createElementPropertyAsts(elName, templateElementOrDirectiveProps, templateBoundDirectivePropNames);\n\n        this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);\n\n        var templateProviderContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], true, templateQueryStartIndex, element.sourceSpan);\n        templateProviderContext.afterElement();\n        parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, templateProviderContext.queryMatches, [parsedElement], ngContentIndex, element.sourceSpan);\n      }\n\n      return parsedElement;\n    }\n  }, {\n    key: \"_parseAttr\",\n    value: function _parseAttr(isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {\n      var name = this._normalizeAttributeName(attr.name);\n\n      var value = attr.value;\n      var srcSpan = attr.sourceSpan;\n      var absoluteOffset = attr.valueSpan ? attr.valueSpan.start.offset : srcSpan.start.offset;\n      var boundEvents = [];\n      var bindParts = name.match(BIND_NAME_REGEXP);\n      var hasBinding = false;\n\n      if (bindParts !== null) {\n        hasBinding = true;\n\n        if (bindParts[KW_BIND_IDX] != null) {\n          this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n        } else if (bindParts[KW_LET_IDX]) {\n          if (isTemplateElement) {\n            var identifier = bindParts[IDENT_KW_IDX];\n\n            this._parseVariable(identifier, value, srcSpan, targetVars);\n          } else {\n            this._reportError(\"\\\"let-\\\" is only supported on ng-template elements.\", srcSpan);\n          }\n        } else if (bindParts[KW_REF_IDX]) {\n          var _identifier = bindParts[IDENT_KW_IDX];\n\n          this._parseReference(_identifier, value, srcSpan, targetRefs);\n        } else if (bindParts[KW_ON_IDX]) {\n          this._bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n        } else if (bindParts[KW_BINDON_IDX]) {\n          this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n\n          this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n        } else if (bindParts[KW_AT_IDX]) {\n          this._bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n        } else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n          this._bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n\n          this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n        } else if (bindParts[IDENT_PROPERTY_IDX]) {\n          this._bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n        } else if (bindParts[IDENT_EVENT_IDX]) {\n          this._bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n        }\n      } else {\n        hasBinding = this._bindingParser.parsePropertyInterpolation(name, value, srcSpan, attr.valueSpan, targetMatchableAttrs, targetProps);\n      }\n\n      if (!hasBinding) {\n        this._bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n      }\n\n      targetEvents.push.apply(targetEvents, _toConsumableArray(boundEvents.map(function (e) {\n        return BoundEventAst.fromParsedEvent(e);\n      })));\n      return hasBinding;\n    }\n  }, {\n    key: \"_normalizeAttributeName\",\n    value: function _normalizeAttributeName(attrName) {\n      return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n    }\n  }, {\n    key: \"_parseVariable\",\n    value: function _parseVariable(identifier, value, sourceSpan, targetVars) {\n      if (identifier.indexOf('-') > -1) {\n        this._reportError(\"\\\"-\\\" is not allowed in variable names\", sourceSpan);\n      } else if (identifier.length === 0) {\n        this._reportError(\"Variable does not have a name\", sourceSpan);\n      }\n\n      targetVars.push(new VariableAst(identifier, value, sourceSpan));\n    }\n  }, {\n    key: \"_parseReference\",\n    value: function _parseReference(identifier, value, sourceSpan, targetRefs) {\n      if (identifier.indexOf('-') > -1) {\n        this._reportError(\"\\\"-\\\" is not allowed in reference names\", sourceSpan);\n      } else if (identifier.length === 0) {\n        this._reportError(\"Reference does not have a name\", sourceSpan);\n      }\n\n      targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));\n    }\n  }, {\n    key: \"_parseAssignmentEvent\",\n    value: function _parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, targetEvents) {\n      this._bindingParser.parseEvent(\"\".concat(name, \"Change\"), \"\".concat(expression, \"=$event\"), sourceSpan, valueSpan, targetMatchableAttrs, targetEvents);\n    }\n  }, {\n    key: \"_parseDirectives\",\n    value: function _parseDirectives(selectorMatcher, elementCssSelector) {\n      var _this153 = this;\n\n      // Need to sort the directives so that we get consistent results throughout,\n      // as selectorMatcher uses Maps inside.\n      // Also deduplicate directives as they might match more than one time!\n      var directives = newArray(this.directivesIndex.size); // Whether any directive selector matches on the element name\n\n      var matchElement = false;\n      selectorMatcher.match(elementCssSelector, function (selector, directive) {\n        directives[_this153.directivesIndex.get(directive)] = directive;\n        matchElement = matchElement || selector.hasElementSelector();\n      });\n      return {\n        directives: directives.filter(function (dir) {\n          return !!dir;\n        }),\n        matchElement: matchElement\n      };\n    }\n  }, {\n    key: \"_createDirectiveAsts\",\n    value: function _createDirectiveAsts(isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences, targetBoundDirectivePropNames) {\n      var _this154 = this;\n\n      var matchedReferences = new Set();\n      var component = null;\n      var directiveAsts = directives.map(function (directive) {\n        var sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, elementSourceSpan.fullStart, \"Directive \".concat(identifierName(directive.type)));\n\n        if (directive.isComponent) {\n          component = directive;\n        }\n\n        var directiveProperties = [];\n\n        var boundProperties = _this154._bindingParser.createDirectiveHostPropertyAsts(directive, elementName, sourceSpan);\n\n        var hostProperties = boundProperties.map(function (prop) {\n          return BoundElementPropertyAst.fromBoundProperty(prop);\n        }); // Note: We need to check the host properties here as well,\n        // as we don't know the element name in the DirectiveWrapperCompiler yet.\n\n        hostProperties = _this154._checkPropertiesInSchema(elementName, hostProperties);\n\n        var parsedEvents = _this154._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan);\n\n        _this154._createDirectivePropertyAsts(directive.inputs, props, directiveProperties, targetBoundDirectivePropNames);\n\n        elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n          if (elOrDirRef.value.length === 0 && directive.isComponent || elOrDirRef.isReferenceToDirective(directive)) {\n            targetReferences.push(new ReferenceAst(elOrDirRef.name, createTokenForReference(directive.type.reference), elOrDirRef.value, elOrDirRef.sourceSpan));\n            matchedReferences.add(elOrDirRef.name);\n          }\n        });\n        var hostEvents = parsedEvents.map(function (e) {\n          return BoundEventAst.fromParsedEvent(e);\n        });\n        var contentQueryStartId = _this154.contentQueryStartId;\n        _this154.contentQueryStartId += directive.queries.length;\n        return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, contentQueryStartId, sourceSpan);\n      });\n      elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n        if (elOrDirRef.value.length > 0) {\n          if (!matchedReferences.has(elOrDirRef.name)) {\n            _this154._reportError(\"There is no directive with \\\"exportAs\\\" set to \\\"\".concat(elOrDirRef.value, \"\\\"\"), elOrDirRef.sourceSpan);\n          }\n        } else if (!component) {\n          var refToken = null;\n\n          if (isTemplateElement) {\n            refToken = createTokenForExternalReference(_this154.reflector, Identifiers$1.TemplateRef);\n          }\n\n          targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.value, elOrDirRef.sourceSpan));\n        }\n      });\n      return directiveAsts;\n    }\n  }, {\n    key: \"_createDirectivePropertyAsts\",\n    value: function _createDirectivePropertyAsts(directiveProperties, boundProps, targetBoundDirectiveProps, targetBoundDirectivePropNames) {\n      if (directiveProperties) {\n        var boundPropsByName = new Map();\n        boundProps.forEach(function (boundProp) {\n          var prevValue = boundPropsByName.get(boundProp.name);\n\n          if (!prevValue || prevValue.isLiteral) {\n            // give [a]=\"b\" a higher precedence than a=\"b\" on the same element\n            boundPropsByName.set(boundProp.name, boundProp);\n          }\n        });\n        Object.keys(directiveProperties).forEach(function (dirProp) {\n          var elProp = directiveProperties[dirProp];\n          var boundProp = boundPropsByName.get(elProp); // Bindings are optional, so this binding only needs to be set up if an expression is given.\n\n          if (boundProp) {\n            targetBoundDirectivePropNames.add(boundProp.name);\n\n            if (!isEmptyExpression(boundProp.expression)) {\n              targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));\n            }\n          }\n        });\n      }\n    }\n  }, {\n    key: \"_createElementPropertyAsts\",\n    value: function _createElementPropertyAsts(elementName, props, boundDirectivePropNames) {\n      var _this155 = this;\n\n      var boundElementProps = [];\n      props.forEach(function (prop) {\n        if (!prop.isLiteral && !boundDirectivePropNames.has(prop.name)) {\n          var boundProp = _this155._bindingParser.createBoundElementProperty(elementName, prop);\n\n          boundElementProps.push(BoundElementPropertyAst.fromBoundProperty(boundProp));\n        }\n      });\n      return this._checkPropertiesInSchema(elementName, boundElementProps);\n    }\n  }, {\n    key: \"_findComponentDirectives\",\n    value: function _findComponentDirectives(directives) {\n      return directives.filter(function (directive) {\n        return directive.directive.isComponent;\n      });\n    }\n  }, {\n    key: \"_findComponentDirectiveNames\",\n    value: function _findComponentDirectiveNames(directives) {\n      return this._findComponentDirectives(directives).map(function (directive) {\n        return identifierName(directive.directive.type);\n      });\n    }\n  }, {\n    key: \"_assertOnlyOneComponent\",\n    value: function _assertOnlyOneComponent(directives, sourceSpan) {\n      var componentTypeNames = this._findComponentDirectiveNames(directives);\n\n      if (componentTypeNames.length > 1) {\n        this._reportError(\"More than one component matched on this element.\\n\" + \"Make sure that only one component's selector can match a given element.\\n\" + \"Conflicting components: \".concat(componentTypeNames.join(',')), sourceSpan);\n      }\n    }\n    /**\r\n     * Make sure that non-angular tags conform to the schemas.\r\n     *\r\n     * Note: An element is considered an angular tag when at least one directive selector matches the\r\n     * tag name.\r\n     *\r\n     * @param matchElement Whether any directive has matched on the tag name\r\n     * @param element the html element\r\n     */\n\n  }, {\n    key: \"_assertElementExists\",\n    value: function _assertElementExists(matchElement, element) {\n      var elName = element.name.replace(/^:xhtml:/, '');\n\n      if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {\n        var errorMsg = \"'\".concat(elName, \"' is not a known element:\\n\");\n        errorMsg += \"1. If '\".concat(elName, \"' is an Angular component, then verify that it is part of this module.\\n\");\n\n        if (elName.indexOf('-') > -1) {\n          errorMsg += \"2. If '\".concat(elName, \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\");\n        } else {\n          errorMsg += \"2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n        }\n\n        this._reportError(errorMsg, element.sourceSpan);\n      }\n    }\n  }, {\n    key: \"_assertNoComponentsNorElementBindingsOnTemplate\",\n    value: function _assertNoComponentsNorElementBindingsOnTemplate(directives, elementProps, sourceSpan) {\n      var _this156 = this;\n\n      var componentTypeNames = this._findComponentDirectiveNames(directives);\n\n      if (componentTypeNames.length > 0) {\n        this._reportError(\"Components on an embedded template: \".concat(componentTypeNames.join(',')), sourceSpan);\n      }\n\n      elementProps.forEach(function (prop) {\n        _this156._reportError(\"Property binding \".concat(prop.name, \" not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \\\"@NgModule.declarations\\\".\"), sourceSpan);\n      });\n    }\n  }, {\n    key: \"_assertAllEventsPublishedByDirectives\",\n    value: function _assertAllEventsPublishedByDirectives(directives, events) {\n      var _this157 = this;\n\n      var allDirectiveEvents = new Set();\n      directives.forEach(function (directive) {\n        Object.keys(directive.directive.outputs).forEach(function (k) {\n          var eventName = directive.directive.outputs[k];\n          allDirectiveEvents.add(eventName);\n        });\n      });\n      events.forEach(function (event) {\n        if (event.target != null || !allDirectiveEvents.has(event.name)) {\n          _this157._reportError(\"Event binding \".concat(event.fullName, \" not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \\\"@NgModule.declarations\\\".\"), event.sourceSpan);\n        }\n      });\n    }\n  }, {\n    key: \"_checkPropertiesInSchema\",\n    value: function _checkPropertiesInSchema(elementName, boundProps) {\n      var _this158 = this;\n\n      // Note: We can't filter out empty expressions before this method,\n      // as we still want to validate them!\n      return boundProps.filter(function (boundProp) {\n        if (boundProp.type === 0\n        /* Property */\n        && !_this158._schemaRegistry.hasProperty(elementName, boundProp.name, _this158._schemas)) {\n          var errorMsg = \"Can't bind to '\".concat(boundProp.name, \"' since it isn't a known property of '\").concat(elementName, \"'.\");\n\n          if (elementName.startsWith('ng-')) {\n            errorMsg += \"\\n1. If '\".concat(boundProp.name, \"' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.\") + \"\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n          } else if (elementName.indexOf('-') > -1) {\n            errorMsg += \"\\n1. If '\".concat(elementName, \"' is an Angular component and it has '\").concat(boundProp.name, \"' input, then verify that it is part of this module.\") + \"\\n2. If '\".concat(elementName, \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\") + \"\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n          }\n\n          _this158._reportError(errorMsg, boundProp.sourceSpan);\n        }\n\n        return !isEmptyExpression(boundProp.value);\n      });\n    }\n  }, {\n    key: \"_reportError\",\n    value: function _reportError(message, sourceSpan) {\n      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ParseErrorLevel.ERROR;\n\n      this._targetErrors.push(new ParseError(sourceSpan, message, level));\n    }\n  }]);\n\n  return TemplateParseVisitor;\n}();\n\nvar NonBindableVisitor = /*#__PURE__*/function () {\n  function NonBindableVisitor() {\n    _classCallCheck(this, NonBindableVisitor);\n  }\n\n  _createClass(NonBindableVisitor, [{\n    key: \"visitElement\",\n    value: function visitElement(ast, parent) {\n      var preparsedElement = preparseElement(ast);\n\n      if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE || preparsedElement.type === PreparsedElementType.STYLESHEET) {\n        // Skipping <script> for security reasons\n        // Skipping <style> and stylesheets as we already processed them\n        // in the StyleCompiler\n        return null;\n      }\n\n      var attrNameAndValues = ast.attrs.map(function (attr) {\n        return [attr.name, attr.value];\n      });\n      var selector = createElementCssSelector(ast.name, attrNameAndValues);\n      var ngContentIndex = parent.findNgContentIndex(selector);\n      var children = visitAll$1(this, ast.children, EMPTY_ELEMENT_CONTEXT);\n      return new ElementAst(ast.name, visitAll$1(this, ast.attrs), [], [], [], [], [], false, [], children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment, context) {\n      return null;\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute, context) {\n      return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, parent) {\n      var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());\n      return new TextAst(text.value, ngContentIndex, text.sourceSpan);\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(expansion, context) {\n      return expansion;\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(expansionCase, context) {\n      return expansionCase;\n    }\n  }]);\n\n  return NonBindableVisitor;\n}();\n/**\r\n * A reference to an element or directive in a template. E.g., the reference in this template:\r\n *\r\n * <div #myMenu=\"coolMenu\">\r\n *\r\n * would be {name: 'myMenu', value: 'coolMenu', sourceSpan: ...}\r\n */\n\n\nvar ElementOrDirectiveRef = /*#__PURE__*/function () {\n  function ElementOrDirectiveRef(name, value, sourceSpan) {\n    _classCallCheck(this, ElementOrDirectiveRef);\n\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n  /** Gets whether this is a reference to the given directive. */\n\n\n  _createClass(ElementOrDirectiveRef, [{\n    key: \"isReferenceToDirective\",\n    value: function isReferenceToDirective(directive) {\n      return splitExportAs(directive.exportAs).indexOf(this.value) !== -1;\n    }\n  }]);\n\n  return ElementOrDirectiveRef;\n}();\n/** Splits a raw, potentially comma-delimited `exportAs` value into an array of names. */\n\n\nfunction splitExportAs(exportAs) {\n  return exportAs ? exportAs.split(',').map(function (e) {\n    return e.trim();\n  }) : [];\n}\n\nfunction splitClasses(classAttrValue) {\n  return classAttrValue.trim().split(/\\s+/g);\n}\n\nvar ElementContext = /*#__PURE__*/function () {\n  function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {\n    _classCallCheck(this, ElementContext);\n\n    this.isTemplateElement = isTemplateElement;\n    this._ngContentIndexMatcher = _ngContentIndexMatcher;\n    this._wildcardNgContentIndex = _wildcardNgContentIndex;\n    this.providerContext = providerContext;\n  }\n\n  _createClass(ElementContext, [{\n    key: \"findNgContentIndex\",\n    value: function findNgContentIndex(selector) {\n      var ngContentIndices = [];\n\n      this._ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) {\n        ngContentIndices.push(ngContentIndex);\n      });\n\n      ngContentIndices.sort();\n\n      if (this._wildcardNgContentIndex != null) {\n        ngContentIndices.push(this._wildcardNgContentIndex);\n      }\n\n      return ngContentIndices.length > 0 ? ngContentIndices[0] : null;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(isTemplateElement, directives, providerContext) {\n      var matcher = new SelectorMatcher();\n      var wildcardNgContentIndex = null;\n      var component = directives.find(function (directive) {\n        return directive.directive.isComponent;\n      });\n\n      if (component) {\n        var ngContentSelectors = component.directive.template.ngContentSelectors;\n\n        for (var i = 0; i < ngContentSelectors.length; i++) {\n          var selector = ngContentSelectors[i];\n\n          if (selector === '*') {\n            wildcardNgContentIndex = i;\n          } else {\n            matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);\n          }\n        }\n      }\n\n      return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);\n    }\n  }]);\n\n  return ElementContext;\n}();\n\nfunction createElementCssSelector(elementName, attributes) {\n  var cssSelector = new CssSelector();\n  var elNameNoNs = splitNsName(elementName)[1];\n  cssSelector.setElement(elNameNoNs);\n\n  for (var i = 0; i < attributes.length; i++) {\n    var attrName = attributes[i][0];\n    var attrNameNoNs = splitNsName(attrName)[1];\n    var attrValue = attributes[i][1];\n    cssSelector.addAttribute(attrNameNoNs, attrValue);\n\n    if (attrName.toLowerCase() == CLASS_ATTR) {\n      var classes = splitClasses(attrValue);\n      classes.forEach(function (className) {\n        return cssSelector.addClassName(className);\n      });\n    }\n  }\n\n  return cssSelector;\n}\n\nvar EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);\nvar NON_BINDABLE_VISITOR = new NonBindableVisitor();\n\nfunction _isEmptyTextNode(node) {\n  return node instanceof Text$3 && node.value.trim().length == 0;\n}\n\nfunction removeSummaryDuplicates(items) {\n  var map = new Map();\n  items.forEach(function (item) {\n    if (!map.get(item.type.reference)) {\n      map.set(item.type.reference, item);\n    }\n  });\n  return Array.from(map.values());\n}\n\nfunction isEmptyExpression(ast) {\n  if (ast instanceof ASTWithSource) {\n    ast = ast.ast;\n  }\n\n  return ast instanceof EmptyExpr;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Parses string representation of a style and converts it into object literal.\r\n *\r\n * @param value string representation of style as used in the `style` attribute in HTML.\r\n *   Example: `color: red; height: auto`.\r\n * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',\r\n * 'auto']`\r\n */\n\n\nfunction parse(value) {\n  // we use a string array here instead of a string map\n  // because a string-map is not guaranteed to retain the\n  // order of the entries whereas a string array can be\n  // constructed in a [key, value, key, value] format.\n  var styles = [];\n  var i = 0;\n  var parenDepth = 0;\n  var quote = 0\n  /* QuoteNone */\n  ;\n  var valueStart = 0;\n  var propStart = 0;\n  var currentProp = null;\n  var valueHasQuotes = false;\n\n  while (i < value.length) {\n    var token = value.charCodeAt(i++);\n\n    switch (token) {\n      case 40\n      /* OpenParen */\n      :\n        parenDepth++;\n        break;\n\n      case 41\n      /* CloseParen */\n      :\n        parenDepth--;\n        break;\n\n      case 39\n      /* QuoteSingle */\n      :\n        // valueStart needs to be there since prop values don't\n        // have quotes in CSS\n        valueHasQuotes = valueHasQuotes || valueStart > 0;\n\n        if (quote === 0\n        /* QuoteNone */\n        ) {\n            quote = 39\n            /* QuoteSingle */\n            ;\n          } else if (quote === 39\n        /* QuoteSingle */\n        && value.charCodeAt(i - 1) !== 92\n        /* BackSlash */\n        ) {\n            quote = 0\n            /* QuoteNone */\n            ;\n          }\n\n        break;\n\n      case 34\n      /* QuoteDouble */\n      :\n        // same logic as above\n        valueHasQuotes = valueHasQuotes || valueStart > 0;\n\n        if (quote === 0\n        /* QuoteNone */\n        ) {\n            quote = 34\n            /* QuoteDouble */\n            ;\n          } else if (quote === 34\n        /* QuoteDouble */\n        && value.charCodeAt(i - 1) !== 92\n        /* BackSlash */\n        ) {\n            quote = 0\n            /* QuoteNone */\n            ;\n          }\n\n        break;\n\n      case 58\n      /* Colon */\n      :\n        if (!currentProp && parenDepth === 0 && quote === 0\n        /* QuoteNone */\n        ) {\n            currentProp = hyphenate(value.substring(propStart, i - 1).trim());\n            valueStart = i;\n          }\n\n        break;\n\n      case 59\n      /* Semicolon */\n      :\n        if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0\n        /* QuoteNone */\n        ) {\n            var styleVal = value.substring(valueStart, i - 1).trim();\n            styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\n            propStart = i;\n            valueStart = 0;\n            currentProp = null;\n            valueHasQuotes = false;\n          }\n\n        break;\n    }\n  }\n\n  if (currentProp && valueStart) {\n    var _styleVal = value.substr(valueStart).trim();\n\n    styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(_styleVal) : _styleVal);\n  }\n\n  return styles;\n}\n\nfunction stripUnnecessaryQuotes(value) {\n  var qS = value.charCodeAt(0);\n  var qE = value.charCodeAt(value.length - 1);\n\n  if (qS == qE && (qS == 39\n  /* QuoteSingle */\n  || qS == 34\n  /* QuoteDouble */\n  )) {\n    var tempValue = value.substring(1, value.length - 1); // special case to avoid using a multi-quoted string that was just chomped\n    // (e.g. `font-family: \"Verdana\", \"sans-serif\"`)\n\n    if (tempValue.indexOf('\\'') == -1 && tempValue.indexOf('\"') == -1) {\n      value = tempValue;\n    }\n  }\n\n  return value;\n}\n\nfunction hyphenate(value) {\n  return value.replace(/[a-z][A-Z]/g, function (v) {\n    return v.charAt(0) + '-' + v.charAt(1);\n  }).toLowerCase();\n}\n\nvar IMPORTANT_FLAG = '!important';\n/**\r\n * Minimum amount of binding slots required in the runtime for style/class bindings.\r\n *\r\n * Styling in Angular uses up two slots in the runtime LView/TData data structures to\r\n * record binding data, property information and metadata.\r\n *\r\n * When a binding is registered it will place the following information in the `LView`:\r\n *\r\n * slot 1) binding value\r\n * slot 2) cached value (all other values collected before it in string form)\r\n *\r\n * When a binding is registered it will place the following information in the `TData`:\r\n *\r\n * slot 1) prop name\r\n * slot 2) binding index that points to the previous style/class binding (and some extra config\r\n * values)\r\n *\r\n * Let's imagine we have a binding that looks like so:\r\n *\r\n * ```\r\n * <div [style.width]=\"x\" [style.height]=\"y\">\r\n * ```\r\n *\r\n * Our `LView` and `TData` data-structures look like so:\r\n *\r\n * ```typescript\r\n * LView = [\r\n *   // ...\r\n *   x, // value of x\r\n *   \"width: x\",\r\n *\r\n *   y, // value of y\r\n *   \"width: x; height: y\",\r\n *   // ...\r\n * ];\r\n *\r\n * TData = [\r\n *   // ...\r\n *   \"width\", // binding slot 20\r\n *   0,\r\n *\r\n *   \"height\",\r\n *   20,\r\n *   // ...\r\n * ];\r\n * ```\r\n *\r\n * */\n\nvar MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;\n/**\r\n * Produces creation/update instructions for all styling bindings (class and style)\r\n *\r\n * It also produces the creation instruction to register all initial styling values\r\n * (which are all the static class=\"...\" and style=\"...\" attribute values that exist\r\n * on an element within a template).\r\n *\r\n * The builder class below handles producing instructions for the following cases:\r\n *\r\n * - Static style/class attributes (style=\"...\" and class=\"...\")\r\n * - Dynamic style/class map bindings ([style]=\"map\" and [class]=\"map|string\")\r\n * - Dynamic style/class property bindings ([style.prop]=\"exp\" and [class.name]=\"exp\")\r\n *\r\n * Due to the complex relationship of all of these cases, the instructions generated\r\n * for these attributes/properties/bindings must be done so in the correct order. The\r\n * order which these must be generated is as follows:\r\n *\r\n * if (createMode) {\r\n *   styling(...)\r\n * }\r\n * if (updateMode) {\r\n *   styleMap(...)\r\n *   classMap(...)\r\n *   styleProp(...)\r\n *   classProp(...)\r\n * }\r\n *\r\n * The creation/update methods within the builder class produce these instructions.\r\n */\n\nvar StylingBuilder = /*#__PURE__*/function () {\n  function StylingBuilder(_directiveExpr) {\n    _classCallCheck(this, StylingBuilder);\n\n    this._directiveExpr = _directiveExpr;\n    /** Whether or not there are any static styling values present */\n\n    this._hasInitialValues = false;\n    /**\r\n     *  Whether or not there are any styling bindings present\r\n     *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)\r\n     */\n\n    this.hasBindings = false;\n    this.hasBindingsWithPipes = false;\n    /** the input for [class] (if it exists) */\n\n    this._classMapInput = null;\n    /** the input for [style] (if it exists) */\n\n    this._styleMapInput = null;\n    /** an array of each [style.prop] input */\n\n    this._singleStyleInputs = null;\n    /** an array of each [class.name] input */\n\n    this._singleClassInputs = null;\n    this._lastStylingInput = null;\n    this._firstStylingInput = null; // maps are used instead of hash maps because a Map will\n    // retain the ordering of the keys\n\n    /**\r\n     * Represents the location of each style binding in the template\r\n     * (e.g. `<div [style.width]=\"w\" [style.height]=\"h\">` implies\r\n     * that `width=0` and `height=1`)\r\n     */\n\n    this._stylesIndex = new Map();\n    /**\r\n     * Represents the location of each class binding in the template\r\n     * (e.g. `<div [class.big]=\"b\" [class.hidden]=\"h\">` implies\r\n     * that `big=0` and `hidden=1`)\r\n     */\n\n    this._classesIndex = new Map();\n    this._initialStyleValues = [];\n    this._initialClassValues = [];\n  }\n  /**\r\n   * Registers a given input to the styling builder to be later used when producing AOT code.\r\n   *\r\n   * The code below will only accept the input if it is somehow tied to styling (whether it be\r\n   * style/class bindings or static style/class attributes).\r\n   */\n\n\n  _createClass(StylingBuilder, [{\n    key: \"registerBoundInput\",\n    value: function registerBoundInput(input) {\n      // [attr.style] or [attr.class] are skipped in the code below,\n      // they should not be treated as styling-based bindings since\n      // they are intended to be written directly to the attr and\n      // will therefore skip all style/class resolution that is present\n      // with style=\"\", [style]=\"\" and [style.prop]=\"\", class=\"\",\n      // [class.prop]=\"\". [class]=\"\" assignments\n      var binding = null;\n      var name = input.name;\n\n      switch (input.type) {\n        case 0\n        /* Property */\n        :\n          binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);\n          break;\n\n        case 3\n        /* Style */\n        :\n          binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);\n          break;\n\n        case 2\n        /* Class */\n        :\n          binding = this.registerClassInput(name, false, input.value, input.sourceSpan);\n          break;\n      }\n\n      return binding ? true : false;\n    }\n  }, {\n    key: \"registerInputBasedOnName\",\n    value: function registerInputBasedOnName(name, expression, sourceSpan) {\n      var binding = null;\n      var prefix = name.substring(0, 6);\n      var isStyle = name === 'style' || prefix === 'style.' || prefix === 'style!';\n      var isClass = !isStyle && (name === 'class' || prefix === 'class.' || prefix === 'class!');\n\n      if (isStyle || isClass) {\n        var isMapBased = name.charAt(5) !== '.'; // style.prop or class.prop makes this a no\n\n        var property = name.substr(isMapBased ? 5 : 6); // the dot explains why there's a +1\n\n        if (isStyle) {\n          binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);\n        } else {\n          binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);\n        }\n      }\n\n      return binding;\n    }\n  }, {\n    key: \"registerStyleInput\",\n    value: function registerStyleInput(name, isMapBased, value, sourceSpan, suffix) {\n      if (isEmptyExpression(value)) {\n        return null;\n      } // CSS custom properties are case-sensitive so we shouldn't normalize them.\n      // See: https://www.w3.org/TR/css-variables-1/#defining-variables\n\n\n      if (!isCssCustomProperty(name)) {\n        name = hyphenate(name);\n      }\n\n      var _parseProperty = parseProperty(name),\n          property = _parseProperty.property,\n          hasOverrideFlag = _parseProperty.hasOverrideFlag,\n          bindingSuffix = _parseProperty.suffix;\n\n      suffix = typeof suffix === 'string' && suffix.length !== 0 ? suffix : bindingSuffix;\n      var entry = {\n        name: property,\n        suffix: suffix,\n        value: value,\n        sourceSpan: sourceSpan,\n        hasOverrideFlag: hasOverrideFlag\n      };\n\n      if (isMapBased) {\n        this._styleMapInput = entry;\n      } else {\n        (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);\n        registerIntoMap(this._stylesIndex, property);\n      }\n\n      this._lastStylingInput = entry;\n      this._firstStylingInput = this._firstStylingInput || entry;\n\n      this._checkForPipes(value);\n\n      this.hasBindings = true;\n      return entry;\n    }\n  }, {\n    key: \"registerClassInput\",\n    value: function registerClassInput(name, isMapBased, value, sourceSpan) {\n      if (isEmptyExpression(value)) {\n        return null;\n      }\n\n      var _parseProperty2 = parseProperty(name),\n          property = _parseProperty2.property,\n          hasOverrideFlag = _parseProperty2.hasOverrideFlag;\n\n      var entry = {\n        name: property,\n        value: value,\n        sourceSpan: sourceSpan,\n        hasOverrideFlag: hasOverrideFlag,\n        suffix: null\n      };\n\n      if (isMapBased) {\n        this._classMapInput = entry;\n      } else {\n        (this._singleClassInputs = this._singleClassInputs || []).push(entry);\n        registerIntoMap(this._classesIndex, property);\n      }\n\n      this._lastStylingInput = entry;\n      this._firstStylingInput = this._firstStylingInput || entry;\n\n      this._checkForPipes(value);\n\n      this.hasBindings = true;\n      return entry;\n    }\n  }, {\n    key: \"_checkForPipes\",\n    value: function _checkForPipes(value) {\n      if (value instanceof ASTWithSource && value.ast instanceof BindingPipe) {\n        this.hasBindingsWithPipes = true;\n      }\n    }\n    /**\r\n     * Registers the element's static style string value to the builder.\r\n     *\r\n     * @param value the style string (e.g. `width:100px; height:200px;`)\r\n     */\n\n  }, {\n    key: \"registerStyleAttr\",\n    value: function registerStyleAttr(value) {\n      this._initialStyleValues = parse(value);\n      this._hasInitialValues = true;\n    }\n    /**\r\n     * Registers the element's static class string value to the builder.\r\n     *\r\n     * @param value the className string (e.g. `disabled gold zoom`)\r\n     */\n\n  }, {\n    key: \"registerClassAttr\",\n    value: function registerClassAttr(value) {\n      this._initialClassValues = value.trim().split(/\\s+/g);\n      this._hasInitialValues = true;\n    }\n    /**\r\n     * Appends all styling-related expressions to the provided attrs array.\r\n     *\r\n     * @param attrs an existing array where each of the styling expressions\r\n     * will be inserted into.\r\n     */\n\n  }, {\n    key: \"populateInitialStylingAttrs\",\n    value: function populateInitialStylingAttrs(attrs) {\n      // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]\n      if (this._initialClassValues.length) {\n        attrs.push(literal(1\n        /* Classes */\n        ));\n\n        for (var i = 0; i < this._initialClassValues.length; i++) {\n          attrs.push(literal(this._initialClassValues[i]));\n        }\n      } // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]\n\n\n      if (this._initialStyleValues.length) {\n        attrs.push(literal(2\n        /* Styles */\n        ));\n\n        for (var _i6 = 0; _i6 < this._initialStyleValues.length; _i6 += 2) {\n          attrs.push(literal(this._initialStyleValues[_i6]), literal(this._initialStyleValues[_i6 + 1]));\n        }\n      }\n    }\n    /**\r\n     * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.\r\n     *\r\n     * The instruction generation code below is used for producing the AOT statement code which is\r\n     * responsible for registering initial styles (within a directive hostBindings' creation block),\r\n     * as well as any of the provided attribute values, to the directive host element.\r\n     */\n\n  }, {\n    key: \"assignHostAttrs\",\n    value: function assignHostAttrs(attrs, definitionMap) {\n      if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {\n        this.populateInitialStylingAttrs(attrs);\n        definitionMap.set('hostAttrs', literalArr(attrs));\n      }\n    }\n    /**\r\n     * Builds an instruction with all the expressions and parameters for `classMap`.\r\n     *\r\n     * The instruction data will contain all expressions for `classMap` to function\r\n     * which includes the `[class]` expression params.\r\n     */\n\n  }, {\n    key: \"buildClassMapInstruction\",\n    value: function buildClassMapInstruction(valueConverter) {\n      if (this._classMapInput) {\n        return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);\n      }\n\n      return null;\n    }\n    /**\r\n     * Builds an instruction with all the expressions and parameters for `styleMap`.\r\n     *\r\n     * The instruction data will contain all expressions for `styleMap` to function\r\n     * which includes the `[style]` expression params.\r\n     */\n\n  }, {\n    key: \"buildStyleMapInstruction\",\n    value: function buildStyleMapInstruction(valueConverter) {\n      if (this._styleMapInput) {\n        return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_buildMapBasedInstruction\",\n    value: function _buildMapBasedInstruction(valueConverter, isClassBased, stylingInput) {\n      // each styling binding value is stored in the LView\n      // map-based bindings allocate two slots: one for the\n      // previous binding value and another for the previous\n      // className or style attribute value.\n      var totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED; // these values must be outside of the update block so that they can\n      // be evaluated (the AST visit call) during creation time so that any\n      // pipes can be picked up in time before the template is built\n\n      var mapValue = stylingInput.value.visit(valueConverter);\n      var reference;\n\n      if (mapValue instanceof Interpolation) {\n        totalBindingSlotsRequired += mapValue.expressions.length;\n        reference = isClassBased ? getClassMapInterpolationExpression(mapValue) : getStyleMapInterpolationExpression(mapValue);\n      } else {\n        reference = isClassBased ? Identifiers.classMap : Identifiers.styleMap;\n      }\n\n      return {\n        reference: reference,\n        calls: [{\n          supportsInterpolation: true,\n          sourceSpan: stylingInput.sourceSpan,\n          allocateBindingSlots: totalBindingSlotsRequired,\n          params: function params(convertFn) {\n            var convertResult = convertFn(mapValue);\n            var params = Array.isArray(convertResult) ? convertResult : [convertResult];\n            return params;\n          }\n        }]\n      };\n    }\n  }, {\n    key: \"_buildSingleInputs\",\n    value: function _buildSingleInputs(reference, inputs, valueConverter, getInterpolationExpressionFn, isClassBased) {\n      var instructions = [];\n      inputs.forEach(function (input) {\n        var previousInstruction = instructions[instructions.length - 1];\n        var value = input.value.visit(valueConverter);\n        var referenceForCall = reference; // each styling binding value is stored in the LView\n        // but there are two values stored for each binding:\n        //   1) the value itself\n        //   2) an intermediate value (concatenation of style up to this point).\n        //      We need to store the intermediate value so that we don't allocate\n        //      the strings on each CD.\n\n        var totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\n\n        if (value instanceof Interpolation) {\n          totalBindingSlotsRequired += value.expressions.length;\n\n          if (getInterpolationExpressionFn) {\n            referenceForCall = getInterpolationExpressionFn(value);\n          }\n        }\n\n        var call = {\n          sourceSpan: input.sourceSpan,\n          allocateBindingSlots: totalBindingSlotsRequired,\n          supportsInterpolation: !!getInterpolationExpressionFn,\n          params: function params(convertFn) {\n            // params => stylingProp(propName, value, suffix)\n            var params = [];\n            params.push(literal(input.name));\n            var convertResult = convertFn(value);\n\n            if (Array.isArray(convertResult)) {\n              params.push.apply(params, _toConsumableArray(convertResult));\n            } else {\n              params.push(convertResult);\n            } // [style.prop] bindings may use suffix values (e.g. px, em, etc...), therefore,\n            // if that is detected then we need to pass that in as an optional param.\n\n\n            if (!isClassBased && input.suffix !== null) {\n              params.push(literal(input.suffix));\n            }\n\n            return params;\n          }\n        }; // If we ended up generating a call to the same instruction as the previous styling property\n        // we can chain the calls together safely to save some bytes, otherwise we have to generate\n        // a separate instruction call. This is primarily a concern with interpolation instructions\n        // where we may start off with one `reference`, but end up using another based on the\n        // number of interpolations.\n\n        if (previousInstruction && previousInstruction.reference === referenceForCall) {\n          previousInstruction.calls.push(call);\n        } else {\n          instructions.push({\n            reference: referenceForCall,\n            calls: [call]\n          });\n        }\n      });\n      return instructions;\n    }\n  }, {\n    key: \"_buildClassInputs\",\n    value: function _buildClassInputs(valueConverter) {\n      if (this._singleClassInputs) {\n        return this._buildSingleInputs(Identifiers.classProp, this._singleClassInputs, valueConverter, null, true);\n      }\n\n      return [];\n    }\n  }, {\n    key: \"_buildStyleInputs\",\n    value: function _buildStyleInputs(valueConverter) {\n      if (this._singleStyleInputs) {\n        return this._buildSingleInputs(Identifiers.styleProp, this._singleStyleInputs, valueConverter, getStylePropInterpolationExpression, false);\n      }\n\n      return [];\n    }\n    /**\r\n     * Constructs all instructions which contain the expressions that will be placed\r\n     * into the update block of a template function or a directive hostBindings function.\r\n     */\n\n  }, {\n    key: \"buildUpdateLevelInstructions\",\n    value: function buildUpdateLevelInstructions(valueConverter) {\n      var instructions = [];\n\n      if (this.hasBindings) {\n        var styleMapInstruction = this.buildStyleMapInstruction(valueConverter);\n\n        if (styleMapInstruction) {\n          instructions.push(styleMapInstruction);\n        }\n\n        var classMapInstruction = this.buildClassMapInstruction(valueConverter);\n\n        if (classMapInstruction) {\n          instructions.push(classMapInstruction);\n        }\n\n        instructions.push.apply(instructions, _toConsumableArray(this._buildStyleInputs(valueConverter)));\n        instructions.push.apply(instructions, _toConsumableArray(this._buildClassInputs(valueConverter)));\n      }\n\n      return instructions;\n    }\n  }]);\n\n  return StylingBuilder;\n}();\n\nfunction registerIntoMap(map, key) {\n  if (!map.has(key)) {\n    map.set(key, map.size);\n  }\n}\n\nfunction parseProperty(name) {\n  var hasOverrideFlag = false;\n  var overrideIndex = name.indexOf(IMPORTANT_FLAG);\n\n  if (overrideIndex !== -1) {\n    name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';\n    hasOverrideFlag = true;\n  }\n\n  var suffix = null;\n  var property = name;\n  var unitIndex = name.lastIndexOf('.');\n\n  if (unitIndex > 0) {\n    suffix = name.substr(unitIndex + 1);\n    property = name.substring(0, unitIndex);\n  }\n\n  return {\n    property: property,\n    suffix: suffix,\n    hasOverrideFlag: hasOverrideFlag\n  };\n}\n/**\r\n * Gets the instruction to generate for an interpolated class map.\r\n * @param interpolation An Interpolation AST\r\n */\n\n\nfunction getClassMapInterpolationExpression(interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return Identifiers.classMap;\n\n    case 3:\n      return Identifiers.classMapInterpolate1;\n\n    case 5:\n      return Identifiers.classMapInterpolate2;\n\n    case 7:\n      return Identifiers.classMapInterpolate3;\n\n    case 9:\n      return Identifiers.classMapInterpolate4;\n\n    case 11:\n      return Identifiers.classMapInterpolate5;\n\n    case 13:\n      return Identifiers.classMapInterpolate6;\n\n    case 15:\n      return Identifiers.classMapInterpolate7;\n\n    case 17:\n      return Identifiers.classMapInterpolate8;\n\n    default:\n      return Identifiers.classMapInterpolateV;\n  }\n}\n/**\r\n * Gets the instruction to generate for an interpolated style map.\r\n * @param interpolation An Interpolation AST\r\n */\n\n\nfunction getStyleMapInterpolationExpression(interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return Identifiers.styleMap;\n\n    case 3:\n      return Identifiers.styleMapInterpolate1;\n\n    case 5:\n      return Identifiers.styleMapInterpolate2;\n\n    case 7:\n      return Identifiers.styleMapInterpolate3;\n\n    case 9:\n      return Identifiers.styleMapInterpolate4;\n\n    case 11:\n      return Identifiers.styleMapInterpolate5;\n\n    case 13:\n      return Identifiers.styleMapInterpolate6;\n\n    case 15:\n      return Identifiers.styleMapInterpolate7;\n\n    case 17:\n      return Identifiers.styleMapInterpolate8;\n\n    default:\n      return Identifiers.styleMapInterpolateV;\n  }\n}\n/**\r\n * Gets the instruction to generate for an interpolated style prop.\r\n * @param interpolation An Interpolation AST\r\n */\n\n\nfunction getStylePropInterpolationExpression(interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return Identifiers.styleProp;\n\n    case 3:\n      return Identifiers.stylePropInterpolate1;\n\n    case 5:\n      return Identifiers.stylePropInterpolate2;\n\n    case 7:\n      return Identifiers.stylePropInterpolate3;\n\n    case 9:\n      return Identifiers.stylePropInterpolate4;\n\n    case 11:\n      return Identifiers.stylePropInterpolate5;\n\n    case 13:\n      return Identifiers.stylePropInterpolate6;\n\n    case 15:\n      return Identifiers.stylePropInterpolate7;\n\n    case 17:\n      return Identifiers.stylePropInterpolate8;\n\n    default:\n      return Identifiers.stylePropInterpolateV;\n  }\n}\n/**\r\n * Checks whether property name is a custom CSS property.\r\n * See: https://www.w3.org/TR/css-variables-1\r\n */\n\n\nfunction isCssCustomProperty(name) {\n  return name.startsWith('--');\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar TokenType$1;\n\n(function (TokenType) {\n  TokenType[TokenType[\"Character\"] = 0] = \"Character\";\n  TokenType[TokenType[\"Identifier\"] = 1] = \"Identifier\";\n  TokenType[TokenType[\"PrivateIdentifier\"] = 2] = \"PrivateIdentifier\";\n  TokenType[TokenType[\"Keyword\"] = 3] = \"Keyword\";\n  TokenType[TokenType[\"String\"] = 4] = \"String\";\n  TokenType[TokenType[\"Operator\"] = 5] = \"Operator\";\n  TokenType[TokenType[\"Number\"] = 6] = \"Number\";\n  TokenType[TokenType[\"Error\"] = 7] = \"Error\";\n})(TokenType$1 || (TokenType$1 = {}));\n\nvar KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\n\nvar Lexer = /*#__PURE__*/function () {\n  function Lexer() {\n    _classCallCheck(this, Lexer);\n  }\n\n  _createClass(Lexer, [{\n    key: \"tokenize\",\n    value: function tokenize(text) {\n      var scanner = new _Scanner(text);\n      var tokens = [];\n      var token = scanner.scanToken();\n\n      while (token != null) {\n        tokens.push(token);\n        token = scanner.scanToken();\n      }\n\n      return tokens;\n    }\n  }]);\n\n  return Lexer;\n}();\n\nvar Token$1 = /*#__PURE__*/function () {\n  function Token$1(index, end, type, numValue, strValue) {\n    _classCallCheck(this, Token$1);\n\n    this.index = index;\n    this.end = end;\n    this.type = type;\n    this.numValue = numValue;\n    this.strValue = strValue;\n  }\n\n  _createClass(Token$1, [{\n    key: \"isCharacter\",\n    value: function isCharacter(code) {\n      return this.type == TokenType$1.Character && this.numValue == code;\n    }\n  }, {\n    key: \"isNumber\",\n    value: function isNumber() {\n      return this.type == TokenType$1.Number;\n    }\n  }, {\n    key: \"isString\",\n    value: function isString() {\n      return this.type == TokenType$1.String;\n    }\n  }, {\n    key: \"isOperator\",\n    value: function isOperator(operator) {\n      return this.type == TokenType$1.Operator && this.strValue == operator;\n    }\n  }, {\n    key: \"isIdentifier\",\n    value: function isIdentifier() {\n      return this.type == TokenType$1.Identifier;\n    }\n  }, {\n    key: \"isPrivateIdentifier\",\n    value: function isPrivateIdentifier() {\n      return this.type == TokenType$1.PrivateIdentifier;\n    }\n  }, {\n    key: \"isKeyword\",\n    value: function isKeyword() {\n      return this.type == TokenType$1.Keyword;\n    }\n  }, {\n    key: \"isKeywordLet\",\n    value: function isKeywordLet() {\n      return this.type == TokenType$1.Keyword && this.strValue == 'let';\n    }\n  }, {\n    key: \"isKeywordAs\",\n    value: function isKeywordAs() {\n      return this.type == TokenType$1.Keyword && this.strValue == 'as';\n    }\n  }, {\n    key: \"isKeywordNull\",\n    value: function isKeywordNull() {\n      return this.type == TokenType$1.Keyword && this.strValue == 'null';\n    }\n  }, {\n    key: \"isKeywordUndefined\",\n    value: function isKeywordUndefined() {\n      return this.type == TokenType$1.Keyword && this.strValue == 'undefined';\n    }\n  }, {\n    key: \"isKeywordTrue\",\n    value: function isKeywordTrue() {\n      return this.type == TokenType$1.Keyword && this.strValue == 'true';\n    }\n  }, {\n    key: \"isKeywordFalse\",\n    value: function isKeywordFalse() {\n      return this.type == TokenType$1.Keyword && this.strValue == 'false';\n    }\n  }, {\n    key: \"isKeywordThis\",\n    value: function isKeywordThis() {\n      return this.type == TokenType$1.Keyword && this.strValue == 'this';\n    }\n  }, {\n    key: \"isError\",\n    value: function isError() {\n      return this.type == TokenType$1.Error;\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.type == TokenType$1.Number ? this.numValue : -1;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      switch (this.type) {\n        case TokenType$1.Character:\n        case TokenType$1.Identifier:\n        case TokenType$1.Keyword:\n        case TokenType$1.Operator:\n        case TokenType$1.PrivateIdentifier:\n        case TokenType$1.String:\n        case TokenType$1.Error:\n          return this.strValue;\n\n        case TokenType$1.Number:\n          return this.numValue.toString();\n\n        default:\n          return null;\n      }\n    }\n  }]);\n\n  return Token$1;\n}();\n\nfunction newCharacterToken(index, end, code) {\n  return new Token$1(index, end, TokenType$1.Character, code, String.fromCharCode(code));\n}\n\nfunction newIdentifierToken(index, end, text) {\n  return new Token$1(index, end, TokenType$1.Identifier, 0, text);\n}\n\nfunction newPrivateIdentifierToken(index, end, text) {\n  return new Token$1(index, end, TokenType$1.PrivateIdentifier, 0, text);\n}\n\nfunction newKeywordToken(index, end, text) {\n  return new Token$1(index, end, TokenType$1.Keyword, 0, text);\n}\n\nfunction newOperatorToken(index, end, text) {\n  return new Token$1(index, end, TokenType$1.Operator, 0, text);\n}\n\nfunction newStringToken(index, end, text) {\n  return new Token$1(index, end, TokenType$1.String, 0, text);\n}\n\nfunction newNumberToken(index, end, n) {\n  return new Token$1(index, end, TokenType$1.Number, n, '');\n}\n\nfunction newErrorToken(index, end, message) {\n  return new Token$1(index, end, TokenType$1.Error, 0, message);\n}\n\nvar EOF = new Token$1(-1, -1, TokenType$1.Character, 0, '');\n\nvar _Scanner = /*#__PURE__*/function () {\n  function _Scanner(input) {\n    _classCallCheck(this, _Scanner);\n\n    this.input = input;\n    this.peek = 0;\n    this.index = -1;\n    this.length = input.length;\n    this.advance();\n  }\n\n  _createClass(_Scanner, [{\n    key: \"advance\",\n    value: function advance() {\n      this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);\n    }\n  }, {\n    key: \"scanToken\",\n    value: function scanToken() {\n      var input = this.input,\n          length = this.length;\n      var peek = this.peek,\n          index = this.index; // Skip whitespace.\n\n      while (peek <= $SPACE) {\n        if (++index >= length) {\n          peek = $EOF;\n          break;\n        } else {\n          peek = input.charCodeAt(index);\n        }\n      }\n\n      this.peek = peek;\n      this.index = index;\n\n      if (index >= length) {\n        return null;\n      } // Handle identifiers and numbers.\n\n\n      if (isIdentifierStart(peek)) return this.scanIdentifier();\n      if (isDigit(peek)) return this.scanNumber(index);\n      var start = index;\n\n      switch (peek) {\n        case $PERIOD:\n          this.advance();\n          return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, this.index, $PERIOD);\n\n        case $LPAREN:\n        case $RPAREN:\n        case $LBRACE:\n        case $RBRACE:\n        case $LBRACKET:\n        case $RBRACKET:\n        case $COMMA:\n        case $COLON:\n        case $SEMICOLON:\n          return this.scanCharacter(start, peek);\n\n        case $SQ:\n        case $DQ:\n          return this.scanString();\n\n        case $HASH:\n          return this.scanPrivateIdentifier();\n\n        case $PLUS:\n        case $MINUS:\n        case $STAR:\n        case $SLASH:\n        case $PERCENT:\n        case $CARET:\n          return this.scanOperator(start, String.fromCharCode(peek));\n\n        case $QUESTION:\n          return this.scanQuestion(start);\n\n        case $LT:\n        case $GT:\n          return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');\n\n        case $BANG:\n        case $EQ:\n          return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');\n\n        case $AMPERSAND:\n          return this.scanComplexOperator(start, '&', $AMPERSAND, '&');\n\n        case $BAR:\n          return this.scanComplexOperator(start, '|', $BAR, '|');\n\n        case $NBSP:\n          while (isWhitespace(this.peek)) {\n            this.advance();\n          }\n\n          return this.scanToken();\n      }\n\n      this.advance();\n      return this.error(\"Unexpected character [\".concat(String.fromCharCode(peek), \"]\"), 0);\n    }\n  }, {\n    key: \"scanCharacter\",\n    value: function scanCharacter(start, code) {\n      this.advance();\n      return newCharacterToken(start, this.index, code);\n    }\n  }, {\n    key: \"scanOperator\",\n    value: function scanOperator(start, str) {\n      this.advance();\n      return newOperatorToken(start, this.index, str);\n    }\n    /**\r\n     * Tokenize a 2/3 char long operator\r\n     *\r\n     * @param start start index in the expression\r\n     * @param one first symbol (always part of the operator)\r\n     * @param twoCode code point for the second symbol\r\n     * @param two second symbol (part of the operator when the second code point matches)\r\n     * @param threeCode code point for the third symbol\r\n     * @param three third symbol (part of the operator when provided and matches source expression)\r\n     */\n\n  }, {\n    key: \"scanComplexOperator\",\n    value: function scanComplexOperator(start, one, twoCode, two, threeCode, three) {\n      this.advance();\n      var str = one;\n\n      if (this.peek == twoCode) {\n        this.advance();\n        str += two;\n      }\n\n      if (threeCode != null && this.peek == threeCode) {\n        this.advance();\n        str += three;\n      }\n\n      return newOperatorToken(start, this.index, str);\n    }\n  }, {\n    key: \"scanIdentifier\",\n    value: function scanIdentifier() {\n      var start = this.index;\n      this.advance();\n\n      while (isIdentifierPart(this.peek)) {\n        this.advance();\n      }\n\n      var str = this.input.substring(start, this.index);\n      return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) : newIdentifierToken(start, this.index, str);\n    }\n    /** Scans an ECMAScript private identifier. */\n\n  }, {\n    key: \"scanPrivateIdentifier\",\n    value: function scanPrivateIdentifier() {\n      var start = this.index;\n      this.advance();\n\n      if (!isIdentifierStart(this.peek)) {\n        return this.error('Invalid character [#]', -1);\n      }\n\n      while (isIdentifierPart(this.peek)) {\n        this.advance();\n      }\n\n      var identifierName = this.input.substring(start, this.index);\n      return newPrivateIdentifierToken(start, this.index, identifierName);\n    }\n  }, {\n    key: \"scanNumber\",\n    value: function scanNumber(start) {\n      var simple = this.index === start;\n      this.advance(); // Skip initial digit.\n\n      while (true) {\n        if (isDigit(this.peek)) {// Do nothing.\n        } else if (this.peek == $PERIOD) {\n          simple = false;\n        } else if (isExponentStart(this.peek)) {\n          this.advance();\n          if (isExponentSign(this.peek)) this.advance();\n          if (!isDigit(this.peek)) return this.error('Invalid exponent', -1);\n          simple = false;\n        } else {\n          break;\n        }\n\n        this.advance();\n      }\n\n      var str = this.input.substring(start, this.index);\n      var value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n      return newNumberToken(start, this.index, value);\n    }\n  }, {\n    key: \"scanString\",\n    value: function scanString() {\n      var start = this.index;\n      var quote = this.peek;\n      this.advance(); // Skip initial quote.\n\n      var buffer = '';\n      var marker = this.index;\n      var input = this.input;\n\n      while (this.peek != quote) {\n        if (this.peek == $BACKSLASH) {\n          buffer += input.substring(marker, this.index);\n          this.advance();\n          var unescapedCode = void 0; // Workaround for TS2.1-introduced type strictness\n\n          this.peek = this.peek;\n\n          if (this.peek == $u) {\n            // 4 character hex code for unicode character.\n            var hex = input.substring(this.index + 1, this.index + 5);\n\n            if (/^[0-9a-f]+$/i.test(hex)) {\n              unescapedCode = parseInt(hex, 16);\n            } else {\n              return this.error(\"Invalid unicode escape [\\\\u\".concat(hex, \"]\"), 0);\n            }\n\n            for (var i = 0; i < 5; i++) {\n              this.advance();\n            }\n          } else {\n            unescapedCode = unescape(this.peek);\n            this.advance();\n          }\n\n          buffer += String.fromCharCode(unescapedCode);\n          marker = this.index;\n        } else if (this.peek == $EOF) {\n          return this.error('Unterminated quote', 0);\n        } else {\n          this.advance();\n        }\n      }\n\n      var last = input.substring(marker, this.index);\n      this.advance(); // Skip terminating quote.\n\n      return newStringToken(start, this.index, buffer + last);\n    }\n  }, {\n    key: \"scanQuestion\",\n    value: function scanQuestion(start) {\n      this.advance();\n      var str = '?'; // Either `a ?? b` or 'a?.b'.\n\n      if (this.peek === $QUESTION || this.peek === $PERIOD) {\n        str += this.peek === $PERIOD ? '.' : '?';\n        this.advance();\n      }\n\n      return newOperatorToken(start, this.index, str);\n    }\n  }, {\n    key: \"error\",\n    value: function error(message, offset) {\n      var position = this.index + offset;\n      return newErrorToken(position, this.index, \"Lexer Error: \".concat(message, \" at column \").concat(position, \" in expression [\").concat(this.input, \"]\"));\n    }\n  }]);\n\n  return _Scanner;\n}();\n\nfunction isIdentifierStart(code) {\n  return $a <= code && code <= $z || $A <= code && code <= $Z || code == $_ || code == $$;\n}\n\nfunction isIdentifier(input) {\n  if (input.length == 0) return false;\n  var scanner = new _Scanner(input);\n  if (!isIdentifierStart(scanner.peek)) return false;\n  scanner.advance();\n\n  while (scanner.peek !== $EOF) {\n    if (!isIdentifierPart(scanner.peek)) return false;\n    scanner.advance();\n  }\n\n  return true;\n}\n\nfunction isIdentifierPart(code) {\n  return isAsciiLetter(code) || isDigit(code) || code == $_ || code == $$;\n}\n\nfunction isExponentStart(code) {\n  return code == $e || code == $E;\n}\n\nfunction isExponentSign(code) {\n  return code == $MINUS || code == $PLUS;\n}\n\nfunction isQuote(code) {\n  return code === $SQ || code === $DQ || code === $BT;\n}\n\nfunction unescape(code) {\n  switch (code) {\n    case $n:\n      return $LF;\n\n    case $f:\n      return $FF;\n\n    case $r:\n      return $CR;\n\n    case $t:\n      return $TAB;\n\n    case $v:\n      return $VTAB;\n\n    default:\n      return code;\n  }\n}\n\nfunction parseIntAutoRadix(text) {\n  var result = parseInt(text);\n\n  if (isNaN(result)) {\n    throw new Error('Invalid integer literal when parsing ' + text);\n  }\n\n  return result;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar SplitInterpolation = function SplitInterpolation(strings, expressions, offsets) {\n  _classCallCheck(this, SplitInterpolation);\n\n  this.strings = strings;\n  this.expressions = expressions;\n  this.offsets = offsets;\n};\n\nvar TemplateBindingParseResult = function TemplateBindingParseResult(templateBindings, warnings, errors) {\n  _classCallCheck(this, TemplateBindingParseResult);\n\n  this.templateBindings = templateBindings;\n  this.warnings = warnings;\n  this.errors = errors;\n};\n\nvar Parser$1 = /*#__PURE__*/function () {\n  function Parser$1(_lexer) {\n    _classCallCheck(this, Parser$1);\n\n    this._lexer = _lexer;\n    this.errors = [];\n    this.simpleExpressionChecker = SimpleExpressionChecker;\n  }\n\n  _createClass(Parser$1, [{\n    key: \"parseAction\",\n    value: function parseAction(input, location, absoluteOffset) {\n      var interpolationConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_INTERPOLATION_CONFIG;\n\n      this._checkNoInterpolation(input, location, interpolationConfig);\n\n      var sourceToLex = this._stripComments(input);\n\n      var tokens = this._lexer.tokenize(this._stripComments(input));\n\n      var ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length).parseChain();\n      return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    }\n  }, {\n    key: \"parseBinding\",\n    value: function parseBinding(input, location, absoluteOffset) {\n      var interpolationConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_INTERPOLATION_CONFIG;\n\n      var ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n\n      return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    }\n  }, {\n    key: \"checkSimpleExpression\",\n    value: function checkSimpleExpression(ast) {\n      var checker = new this.simpleExpressionChecker();\n      ast.visit(checker);\n      return checker.errors;\n    }\n  }, {\n    key: \"parseSimpleBinding\",\n    value: function parseSimpleBinding(input, location, absoluteOffset) {\n      var interpolationConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_INTERPOLATION_CONFIG;\n\n      var ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n\n      var errors = this.checkSimpleExpression(ast);\n\n      if (errors.length > 0) {\n        this._reportError(\"Host binding expression cannot contain \".concat(errors.join(' ')), input, location);\n      }\n\n      return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    }\n  }, {\n    key: \"_reportError\",\n    value: function _reportError(message, input, errLocation, ctxLocation) {\n      this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n    }\n  }, {\n    key: \"_parseBindingAst\",\n    value: function _parseBindingAst(input, location, absoluteOffset, interpolationConfig) {\n      // Quotes expressions use 3rd-party expression language. We don't want to use\n      // our lexer or parser for that, so we check for that ahead of time.\n      var quote = this._parseQuote(input, location, absoluteOffset);\n\n      if (quote != null) {\n        return quote;\n      }\n\n      this._checkNoInterpolation(input, location, interpolationConfig);\n\n      var sourceToLex = this._stripComments(input);\n\n      var tokens = this._lexer.tokenize(sourceToLex);\n\n      return new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length).parseChain();\n    }\n  }, {\n    key: \"_parseQuote\",\n    value: function _parseQuote(input, location, absoluteOffset) {\n      if (input == null) return null;\n      var prefixSeparatorIndex = input.indexOf(':');\n      if (prefixSeparatorIndex == -1) return null;\n      var prefix = input.substring(0, prefixSeparatorIndex).trim();\n      if (!isIdentifier(prefix)) return null;\n      var uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n      var span = new ParseSpan(0, input.length);\n      return new Quote(span, span.toAbsolute(absoluteOffset), prefix, uninterpretedExpression, location);\n    }\n    /**\r\n     * Parse microsyntax template expression and return a list of bindings or\r\n     * parsing errors in case the given expression is invalid.\r\n     *\r\n     * For example,\r\n     * ```\r\n     *   <div *ngFor=\"let item of items\">\r\n     *         ^      ^ absoluteValueOffset for `templateValue`\r\n     *         absoluteKeyOffset for `templateKey`\r\n     * ```\r\n     * contains three bindings:\r\n     * 1. ngFor -> null\r\n     * 2. item -> NgForOfContext.$implicit\r\n     * 3. ngForOf -> items\r\n     *\r\n     * This is apparent from the de-sugared template:\r\n     * ```\r\n     *   <ng-template ngFor let-item [ngForOf]=\"items\">\r\n     * ```\r\n     *\r\n     * @param templateKey name of directive, without the * prefix. For example: ngIf, ngFor\r\n     * @param templateValue RHS of the microsyntax attribute\r\n     * @param templateUrl template filename if it's external, component filename if it's inline\r\n     * @param absoluteKeyOffset start of the `templateKey`\r\n     * @param absoluteValueOffset start of the `templateValue`\r\n     */\n\n  }, {\n    key: \"parseTemplateBindings\",\n    value: function parseTemplateBindings(templateKey, templateValue, templateUrl, absoluteKeyOffset, absoluteValueOffset) {\n      var tokens = this._lexer.tokenize(templateValue);\n\n      var parser = new _ParseAST(templateValue, templateUrl, absoluteValueOffset, tokens, templateValue.length, false\n      /* parseAction */\n      , this.errors, 0\n      /* relative offset */\n      );\n      return parser.parseTemplateBindings({\n        source: templateKey,\n        span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length)\n      });\n    }\n  }, {\n    key: \"parseInterpolation\",\n    value: function parseInterpolation(input, location, absoluteOffset) {\n      var interpolationConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_INTERPOLATION_CONFIG;\n\n      var _this$splitInterpolat = this.splitInterpolation(input, location, interpolationConfig),\n          strings = _this$splitInterpolat.strings,\n          expressions = _this$splitInterpolat.expressions,\n          offsets = _this$splitInterpolat.offsets;\n\n      if (expressions.length === 0) return null;\n      var expressionNodes = [];\n\n      for (var i = 0; i < expressions.length; ++i) {\n        var expressionText = expressions[i].text;\n\n        var sourceToLex = this._stripComments(expressionText);\n\n        var tokens = this._lexer.tokenize(sourceToLex);\n\n        var ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, offsets[i] + (expressionText.length - sourceToLex.length)).parseChain();\n        expressionNodes.push(ast);\n      }\n\n      return this.createInterpolationAst(strings.map(function (s) {\n        return s.text;\n      }), expressionNodes, input, location, absoluteOffset);\n    }\n    /**\r\n     * Similar to `parseInterpolation`, but treats the provided string as a single expression\r\n     * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\r\n     * This is used for parsing the switch expression in ICUs.\r\n     */\n\n  }, {\n    key: \"parseInterpolationExpression\",\n    value: function parseInterpolationExpression(expression, location, absoluteOffset) {\n      var sourceToLex = this._stripComments(expression);\n\n      var tokens = this._lexer.tokenize(sourceToLex);\n\n      var ast = new _ParseAST(expression, location, absoluteOffset, tokens, sourceToLex.length,\n      /* parseAction */\n      false, this.errors, 0).parseChain();\n      var strings = ['', '']; // The prefix and suffix strings are both empty\n\n      return this.createInterpolationAst(strings, [ast], expression, location, absoluteOffset);\n    }\n  }, {\n    key: \"createInterpolationAst\",\n    value: function createInterpolationAst(strings, expressions, input, location, absoluteOffset) {\n      var span = new ParseSpan(0, input.length);\n      var interpolation = new Interpolation(span, span.toAbsolute(absoluteOffset), strings, expressions);\n      return new ASTWithSource(interpolation, input, location, absoluteOffset, this.errors);\n    }\n    /**\r\n     * Splits a string of text into \"raw\" text segments and expressions present in interpolations in\r\n     * the string.\r\n     * Returns `null` if there are no interpolations, otherwise a\r\n     * `SplitInterpolation` with splits that look like\r\n     *   <raw text> <expression> <raw text> ... <raw text> <expression> <raw text>\r\n     */\n\n  }, {\n    key: \"splitInterpolation\",\n    value: function splitInterpolation(input, location) {\n      var interpolationConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_INTERPOLATION_CONFIG;\n      var strings = [];\n      var expressions = [];\n      var offsets = [];\n      var i = 0;\n      var atInterpolation = false;\n      var extendLastString = false;\n      var interpStart = interpolationConfig.start,\n          interpEnd = interpolationConfig.end;\n\n      while (i < input.length) {\n        if (!atInterpolation) {\n          // parse until starting {{\n          var _start4 = i;\n          i = input.indexOf(interpStart, i);\n\n          if (i === -1) {\n            i = input.length;\n          }\n\n          var text = input.substring(_start4, i);\n          strings.push({\n            text: text,\n            start: _start4,\n            end: i\n          });\n          atInterpolation = true;\n        } else {\n          // parse from starting {{ to ending }} while ignoring content inside quotes.\n          var fullStart = i;\n          var exprStart = fullStart + interpStart.length;\n\n          var exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);\n\n          if (exprEnd === -1) {\n            // Could not find the end of the interpolation; do not parse an expression.\n            // Instead we should extend the content on the last raw string.\n            atInterpolation = false;\n            extendLastString = true;\n            break;\n          }\n\n          var fullEnd = exprEnd + interpEnd.length;\n\n          var _text = input.substring(exprStart, exprEnd);\n\n          if (_text.trim().length === 0) {\n            this._reportError('Blank expressions are not allowed in interpolated strings', input, \"at column \".concat(i, \" in\"), location);\n          }\n\n          expressions.push({\n            text: _text,\n            start: fullStart,\n            end: fullEnd\n          });\n          offsets.push(exprStart);\n          i = fullEnd;\n          atInterpolation = false;\n        }\n      }\n\n      if (!atInterpolation) {\n        // If we are now at a text section, add the remaining content as a raw string.\n        if (extendLastString) {\n          var piece = strings[strings.length - 1];\n          piece.text += input.substring(i);\n          piece.end = input.length;\n        } else {\n          strings.push({\n            text: input.substring(i),\n            start: i,\n            end: input.length\n          });\n        }\n      }\n\n      return new SplitInterpolation(strings, expressions, offsets);\n    }\n  }, {\n    key: \"wrapLiteralPrimitive\",\n    value: function wrapLiteralPrimitive(input, location, absoluteOffset) {\n      var span = new ParseSpan(0, input == null ? 0 : input.length);\n      return new ASTWithSource(new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location, absoluteOffset, this.errors);\n    }\n  }, {\n    key: \"_stripComments\",\n    value: function _stripComments(input) {\n      var i = this._commentStart(input);\n\n      return i != null ? input.substring(0, i).trim() : input;\n    }\n  }, {\n    key: \"_commentStart\",\n    value: function _commentStart(input) {\n      var outerQuote = null;\n\n      for (var i = 0; i < input.length - 1; i++) {\n        var char = input.charCodeAt(i);\n        var nextChar = input.charCodeAt(i + 1);\n        if (char === $SLASH && nextChar == $SLASH && outerQuote == null) return i;\n\n        if (outerQuote === char) {\n          outerQuote = null;\n        } else if (outerQuote == null && isQuote(char)) {\n          outerQuote = char;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_checkNoInterpolation\",\n    value: function _checkNoInterpolation(input, location, _ref14) {\n      var start = _ref14.start,\n          end = _ref14.end;\n      var startIndex = -1;\n      var endIndex = -1;\n\n      var _iterator11 = _createForOfIteratorHelper(this._forEachUnquotedChar(input, 0)),\n          _step11;\n\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var charIndex = _step11.value;\n\n          if (startIndex === -1) {\n            if (input.startsWith(start)) {\n              startIndex = charIndex;\n            }\n          } else {\n            endIndex = this._getInterpolationEndIndex(input, end, charIndex);\n\n            if (endIndex > -1) {\n              break;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n\n      if (startIndex > -1 && endIndex > -1) {\n        this._reportError(\"Got interpolation (\".concat(start).concat(end, \") where expression was expected\"), input, \"at column \".concat(startIndex, \" in\"), location);\n      }\n    }\n    /**\r\n     * Finds the index of the end of an interpolation expression\r\n     * while ignoring comments and quoted content.\r\n     */\n\n  }, {\n    key: \"_getInterpolationEndIndex\",\n    value: function _getInterpolationEndIndex(input, expressionEnd, start) {\n      var _iterator12 = _createForOfIteratorHelper(this._forEachUnquotedChar(input, start)),\n          _step12;\n\n      try {\n        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n          var charIndex = _step12.value;\n\n          if (input.startsWith(expressionEnd, charIndex)) {\n            return charIndex;\n          } // Nothing else in the expression matters after we've\n          // hit a comment so look directly for the end token.\n\n\n          if (input.startsWith('//', charIndex)) {\n            return input.indexOf(expressionEnd, charIndex);\n          }\n        }\n      } catch (err) {\n        _iterator12.e(err);\n      } finally {\n        _iterator12.f();\n      }\n\n      return -1;\n    }\n    /**\r\n     * Generator used to iterate over the character indexes of a string that are outside of quotes.\r\n     * @param input String to loop through.\r\n     * @param start Index within the string at which to start.\r\n     */\n\n  }, {\n    key: \"_forEachUnquotedChar\",\n    value:\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _forEachUnquotedChar(input, start) {\n      var currentQuote, escapeCount, i, char;\n      return _regeneratorRuntime.wrap(function _forEachUnquotedChar$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              currentQuote = null;\n              escapeCount = 0;\n              i = start;\n\n            case 3:\n              if (!(i < input.length)) {\n                _context2.next = 16;\n                break;\n              }\n\n              char = input[i]; // Skip the characters inside quotes. Note that we only care about the outer-most\n              // quotes matching up and we need to account for escape characters.\n\n              if (!(isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) && escapeCount % 2 === 0)) {\n                _context2.next = 9;\n                break;\n              }\n\n              currentQuote = currentQuote === null ? char : null;\n              _context2.next = 12;\n              break;\n\n            case 9:\n              if (!(currentQuote === null)) {\n                _context2.next = 12;\n                break;\n              }\n\n              _context2.next = 12;\n              return i;\n\n            case 12:\n              escapeCount = char === '\\\\' ? escapeCount + 1 : 0;\n\n            case 13:\n              i++;\n              _context2.next = 3;\n              break;\n\n            case 16:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _forEachUnquotedChar);\n    })\n  }]);\n\n  return Parser$1;\n}();\n\nvar IvyParser = /*#__PURE__*/function (_Parser$) {\n  _inherits(IvyParser, _Parser$);\n\n  var _super96 = _createSuper(IvyParser);\n\n  function IvyParser() {\n    var _this159;\n\n    _classCallCheck(this, IvyParser);\n\n    _this159 = _super96.apply(this, arguments);\n    _this159.simpleExpressionChecker = IvySimpleExpressionChecker;\n    return _this159;\n  }\n\n  return IvyParser;\n}(Parser$1);\n/** Describes a stateful context an expression parser is in. */\n\n\nvar ParseContextFlags;\n\n(function (ParseContextFlags) {\n  ParseContextFlags[ParseContextFlags[\"None\"] = 0] = \"None\";\n  /**\r\n   * A Writable context is one in which a value may be written to an lvalue.\r\n   * For example, after we see a property access, we may expect a write to the\r\n   * property via the \"=\" operator.\r\n   *   prop\r\n   *        ^ possible \"=\" after\r\n   */\n\n  ParseContextFlags[ParseContextFlags[\"Writable\"] = 1] = \"Writable\";\n})(ParseContextFlags || (ParseContextFlags = {}));\n\nvar _ParseAST = /*#__PURE__*/function () {\n  function _ParseAST(input, location, absoluteOffset, tokens, inputLength, parseAction, errors, offset) {\n    _classCallCheck(this, _ParseAST);\n\n    this.input = input;\n    this.location = location;\n    this.absoluteOffset = absoluteOffset;\n    this.tokens = tokens;\n    this.inputLength = inputLength;\n    this.parseAction = parseAction;\n    this.errors = errors;\n    this.offset = offset;\n    this.rparensExpected = 0;\n    this.rbracketsExpected = 0;\n    this.rbracesExpected = 0;\n    this.context = ParseContextFlags.None; // Cache of expression start and input indeces to the absolute source span they map to, used to\n    // prevent creating superfluous source spans in `sourceSpan`.\n    // A serial of the expression start and input index is used for mapping because both are stateful\n    // and may change for subsequent expressions visited by the parser.\n\n    this.sourceSpanCache = new Map();\n    this.index = 0;\n  }\n\n  _createClass(_ParseAST, [{\n    key: \"peek\",\n    value: function peek(offset) {\n      var i = this.index + offset;\n      return i < this.tokens.length ? this.tokens[i] : EOF;\n    }\n  }, {\n    key: \"next\",\n    get: function get() {\n      return this.peek(0);\n    }\n    /** Whether all the parser input has been processed. */\n\n  }, {\n    key: \"atEOF\",\n    get: function get() {\n      return this.index >= this.tokens.length;\n    }\n    /**\r\n     * Index of the next token to be processed, or the end of the last token if all have been\r\n     * processed.\r\n     */\n\n  }, {\n    key: \"inputIndex\",\n    get: function get() {\n      return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;\n    }\n    /**\r\n     * End index of the last processed token, or the start of the first token if none have been\r\n     * processed.\r\n     */\n\n  }, {\n    key: \"currentEndIndex\",\n    get: function get() {\n      if (this.index > 0) {\n        var curToken = this.peek(-1);\n        return curToken.end + this.offset;\n      } // No tokens have been processed yet; return the next token's start or the length of the input\n      // if there is no token.\n\n\n      if (this.tokens.length === 0) {\n        return this.inputLength + this.offset;\n      }\n\n      return this.next.index + this.offset;\n    }\n    /**\r\n     * Returns the absolute offset of the start of the current token.\r\n     */\n\n  }, {\n    key: \"currentAbsoluteOffset\",\n    get: function get() {\n      return this.absoluteOffset + this.inputIndex;\n    }\n    /**\r\n     * Retrieve a `ParseSpan` from `start` to the current position (or to `artificialEndIndex` if\r\n     * provided).\r\n     *\r\n     * @param start Position from which the `ParseSpan` will start.\r\n     * @param artificialEndIndex Optional ending index to be used if provided (and if greater than the\r\n     *     natural ending index)\r\n     */\n\n  }, {\n    key: \"span\",\n    value: function span(start, artificialEndIndex) {\n      var endIndex = this.currentEndIndex;\n\n      if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {\n        endIndex = artificialEndIndex;\n      } // In some unusual parsing scenarios (like when certain tokens are missing and an `EmptyExpr` is\n      // being created), the current token may already be advanced beyond the `currentEndIndex`. This\n      // appears to be a deep-seated parser bug.\n      //\n      // As a workaround for now, swap the start and end indices to ensure a valid `ParseSpan`.\n      // TODO(alxhub): fix the bug upstream in the parser state, and remove this workaround.\n\n\n      if (start > endIndex) {\n        var tmp = endIndex;\n        endIndex = start;\n        start = tmp;\n      }\n\n      return new ParseSpan(start, endIndex);\n    }\n  }, {\n    key: \"sourceSpan\",\n    value: function sourceSpan(start, artificialEndIndex) {\n      var serial = \"\".concat(start, \"@\").concat(this.inputIndex, \":\").concat(artificialEndIndex);\n\n      if (!this.sourceSpanCache.has(serial)) {\n        this.sourceSpanCache.set(serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));\n      }\n\n      return this.sourceSpanCache.get(serial);\n    }\n  }, {\n    key: \"advance\",\n    value: function advance() {\n      this.index++;\n    }\n    /**\r\n     * Executes a callback in the provided context.\r\n     */\n\n  }, {\n    key: \"withContext\",\n    value: function withContext(context, cb) {\n      this.context |= context;\n      var ret = cb();\n      this.context ^= context;\n      return ret;\n    }\n  }, {\n    key: \"consumeOptionalCharacter\",\n    value: function consumeOptionalCharacter(code) {\n      if (this.next.isCharacter(code)) {\n        this.advance();\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"peekKeywordLet\",\n    value: function peekKeywordLet() {\n      return this.next.isKeywordLet();\n    }\n  }, {\n    key: \"peekKeywordAs\",\n    value: function peekKeywordAs() {\n      return this.next.isKeywordAs();\n    }\n    /**\r\n     * Consumes an expected character, otherwise emits an error about the missing expected character\r\n     * and skips over the token stream until reaching a recoverable point.\r\n     *\r\n     * See `this.error` and `this.skip` for more details.\r\n     */\n\n  }, {\n    key: \"expectCharacter\",\n    value: function expectCharacter(code) {\n      if (this.consumeOptionalCharacter(code)) return;\n      this.error(\"Missing expected \".concat(String.fromCharCode(code)));\n    }\n  }, {\n    key: \"consumeOptionalOperator\",\n    value: function consumeOptionalOperator(op) {\n      if (this.next.isOperator(op)) {\n        this.advance();\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"expectOperator\",\n    value: function expectOperator(operator) {\n      if (this.consumeOptionalOperator(operator)) return;\n      this.error(\"Missing expected operator \".concat(operator));\n    }\n  }, {\n    key: \"prettyPrintToken\",\n    value: function prettyPrintToken(tok) {\n      return tok === EOF ? 'end of input' : \"token \".concat(tok);\n    }\n  }, {\n    key: \"expectIdentifierOrKeyword\",\n    value: function expectIdentifierOrKeyword() {\n      var n = this.next;\n\n      if (!n.isIdentifier() && !n.isKeyword()) {\n        if (n.isPrivateIdentifier()) {\n          this._reportErrorForPrivateIdentifier(n, 'expected identifier or keyword');\n        } else {\n          this.error(\"Unexpected \".concat(this.prettyPrintToken(n), \", expected identifier or keyword\"));\n        }\n\n        return null;\n      }\n\n      this.advance();\n      return n.toString();\n    }\n  }, {\n    key: \"expectIdentifierOrKeywordOrString\",\n    value: function expectIdentifierOrKeywordOrString() {\n      var n = this.next;\n\n      if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n        if (n.isPrivateIdentifier()) {\n          this._reportErrorForPrivateIdentifier(n, 'expected identifier, keyword or string');\n        } else {\n          this.error(\"Unexpected \".concat(this.prettyPrintToken(n), \", expected identifier, keyword, or string\"));\n        }\n\n        return '';\n      }\n\n      this.advance();\n      return n.toString();\n    }\n  }, {\n    key: \"parseChain\",\n    value: function parseChain() {\n      var exprs = [];\n      var start = this.inputIndex;\n\n      while (this.index < this.tokens.length) {\n        var expr = this.parsePipe();\n        exprs.push(expr);\n\n        if (this.consumeOptionalCharacter($SEMICOLON)) {\n          if (!this.parseAction) {\n            this.error('Binding expression cannot contain chained expression');\n          }\n\n          while (this.consumeOptionalCharacter($SEMICOLON)) {} // read all semicolons\n\n        } else if (this.index < this.tokens.length) {\n          this.error(\"Unexpected token '\".concat(this.next, \"'\"));\n        }\n      }\n\n      if (exprs.length == 0) {\n        // We have no expressions so create an empty expression that spans the entire input length\n        var artificialStart = this.offset;\n        var artificialEnd = this.offset + this.inputLength;\n        return new EmptyExpr(this.span(artificialStart, artificialEnd), this.sourceSpan(artificialStart, artificialEnd));\n      }\n\n      if (exprs.length == 1) return exprs[0];\n      return new Chain(this.span(start), this.sourceSpan(start), exprs);\n    }\n  }, {\n    key: \"parsePipe\",\n    value: function parsePipe() {\n      var start = this.inputIndex;\n      var result = this.parseExpression();\n\n      if (this.consumeOptionalOperator('|')) {\n        if (this.parseAction) {\n          this.error('Cannot have a pipe in an action expression');\n        }\n\n        do {\n          var nameStart = this.inputIndex;\n          var nameId = this.expectIdentifierOrKeyword();\n          var nameSpan = void 0;\n          var fullSpanEnd = undefined;\n\n          if (nameId !== null) {\n            nameSpan = this.sourceSpan(nameStart);\n          } else {\n            // No valid identifier was found, so we'll assume an empty pipe name ('').\n            nameId = ''; // However, there may have been whitespace present between the pipe character and the next\n            // token in the sequence (or the end of input). We want to track this whitespace so that\n            // the `BindingPipe` we produce covers not just the pipe character, but any trailing\n            // whitespace beyond it. Another way of thinking about this is that the zero-length name\n            // is assumed to be at the end of any whitespace beyond the pipe character.\n            //\n            // Therefore, we push the end of the `ParseSpan` for this pipe all the way up to the\n            // beginning of the next token, or until the end of input if the next token is EOF.\n\n            fullSpanEnd = this.next.index !== -1 ? this.next.index : this.inputLength + this.offset; // The `nameSpan` for an empty pipe name is zero-length at the end of any whitespace\n            // beyond the pipe character.\n\n            nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);\n          }\n\n          var args = [];\n\n          while (this.consumeOptionalCharacter($COLON)) {\n            args.push(this.parseExpression()); // If there are additional expressions beyond the name, then the artificial end for the\n            // name is no longer relevant.\n          }\n\n          result = new BindingPipe(this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);\n        } while (this.consumeOptionalOperator('|'));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"parseExpression\",\n    value: function parseExpression() {\n      return this.parseConditional();\n    }\n  }, {\n    key: \"parseConditional\",\n    value: function parseConditional() {\n      var start = this.inputIndex;\n      var result = this.parseLogicalOr();\n\n      if (this.consumeOptionalOperator('?')) {\n        var yes = this.parsePipe();\n        var no;\n\n        if (!this.consumeOptionalCharacter($COLON)) {\n          var end = this.inputIndex;\n          var expression = this.input.substring(start, end);\n          this.error(\"Conditional expression \".concat(expression, \" requires all 3 expressions\"));\n          no = new EmptyExpr(this.span(start), this.sourceSpan(start));\n        } else {\n          no = this.parsePipe();\n        }\n\n        return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);\n      } else {\n        return result;\n      }\n    }\n  }, {\n    key: \"parseLogicalOr\",\n    value: function parseLogicalOr() {\n      // '||'\n      var start = this.inputIndex;\n      var result = this.parseLogicalAnd();\n\n      while (this.consumeOptionalOperator('||')) {\n        var right = this.parseLogicalAnd();\n        result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"parseLogicalAnd\",\n    value: function parseLogicalAnd() {\n      // '&&'\n      var start = this.inputIndex;\n      var result = this.parseNullishCoalescing();\n\n      while (this.consumeOptionalOperator('&&')) {\n        var right = this.parseNullishCoalescing();\n        result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"parseNullishCoalescing\",\n    value: function parseNullishCoalescing() {\n      // '??'\n      var start = this.inputIndex;\n      var result = this.parseEquality();\n\n      while (this.consumeOptionalOperator('??')) {\n        var right = this.parseEquality();\n        result = new Binary(this.span(start), this.sourceSpan(start), '??', result, right);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"parseEquality\",\n    value: function parseEquality() {\n      // '==','!=','===','!=='\n      var start = this.inputIndex;\n      var result = this.parseRelational();\n\n      while (this.next.type == TokenType$1.Operator) {\n        var operator = this.next.strValue;\n\n        switch (operator) {\n          case '==':\n          case '===':\n          case '!=':\n          case '!==':\n            this.advance();\n            var right = this.parseRelational();\n            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n            continue;\n        }\n\n        break;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"parseRelational\",\n    value: function parseRelational() {\n      // '<', '>', '<=', '>='\n      var start = this.inputIndex;\n      var result = this.parseAdditive();\n\n      while (this.next.type == TokenType$1.Operator) {\n        var operator = this.next.strValue;\n\n        switch (operator) {\n          case '<':\n          case '>':\n          case '<=':\n          case '>=':\n            this.advance();\n            var right = this.parseAdditive();\n            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n            continue;\n        }\n\n        break;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"parseAdditive\",\n    value: function parseAdditive() {\n      // '+', '-'\n      var start = this.inputIndex;\n      var result = this.parseMultiplicative();\n\n      while (this.next.type == TokenType$1.Operator) {\n        var operator = this.next.strValue;\n\n        switch (operator) {\n          case '+':\n          case '-':\n            this.advance();\n            var right = this.parseMultiplicative();\n            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n            continue;\n        }\n\n        break;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"parseMultiplicative\",\n    value: function parseMultiplicative() {\n      // '*', '%', '/'\n      var start = this.inputIndex;\n      var result = this.parsePrefix();\n\n      while (this.next.type == TokenType$1.Operator) {\n        var operator = this.next.strValue;\n\n        switch (operator) {\n          case '*':\n          case '%':\n          case '/':\n            this.advance();\n            var right = this.parsePrefix();\n            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n            continue;\n        }\n\n        break;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"parsePrefix\",\n    value: function parsePrefix() {\n      if (this.next.type == TokenType$1.Operator) {\n        var _start5 = this.inputIndex;\n        var operator = this.next.strValue;\n        var result;\n\n        switch (operator) {\n          case '+':\n            this.advance();\n            result = this.parsePrefix();\n            return Unary.createPlus(this.span(_start5), this.sourceSpan(_start5), result);\n\n          case '-':\n            this.advance();\n            result = this.parsePrefix();\n            return Unary.createMinus(this.span(_start5), this.sourceSpan(_start5), result);\n\n          case '!':\n            this.advance();\n            result = this.parsePrefix();\n            return new PrefixNot(this.span(_start5), this.sourceSpan(_start5), result);\n        }\n      }\n\n      return this.parseCallChain();\n    }\n  }, {\n    key: \"parseCallChain\",\n    value: function parseCallChain() {\n      var start = this.inputIndex;\n      var result = this.parsePrimary();\n\n      while (true) {\n        if (this.consumeOptionalCharacter($PERIOD)) {\n          result = this.parseAccessMemberOrMethodCall(result, start, false);\n        } else if (this.consumeOptionalOperator('?.')) {\n          result = this.consumeOptionalCharacter($LBRACKET) ? this.parseKeyedReadOrWrite(result, start, true) : this.parseAccessMemberOrMethodCall(result, start, true);\n        } else if (this.consumeOptionalCharacter($LBRACKET)) {\n          result = this.parseKeyedReadOrWrite(result, start, false);\n        } else if (this.consumeOptionalCharacter($LPAREN)) {\n          this.rparensExpected++;\n          var args = this.parseCallArguments();\n          this.rparensExpected--;\n          this.expectCharacter($RPAREN);\n          result = new FunctionCall(this.span(start), this.sourceSpan(start), result, args);\n        } else if (this.consumeOptionalOperator('!')) {\n          result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);\n        } else {\n          return result;\n        }\n      }\n    }\n  }, {\n    key: \"parsePrimary\",\n    value: function parsePrimary() {\n      var start = this.inputIndex;\n\n      if (this.consumeOptionalCharacter($LPAREN)) {\n        this.rparensExpected++;\n        var result = this.parsePipe();\n        this.rparensExpected--;\n        this.expectCharacter($RPAREN);\n        return result;\n      } else if (this.next.isKeywordNull()) {\n        this.advance();\n        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);\n      } else if (this.next.isKeywordUndefined()) {\n        this.advance();\n        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);\n      } else if (this.next.isKeywordTrue()) {\n        this.advance();\n        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);\n      } else if (this.next.isKeywordFalse()) {\n        this.advance();\n        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);\n      } else if (this.next.isKeywordThis()) {\n        this.advance();\n        return new ThisReceiver(this.span(start), this.sourceSpan(start));\n      } else if (this.consumeOptionalCharacter($LBRACKET)) {\n        this.rbracketsExpected++;\n        var elements = this.parseExpressionList($RBRACKET);\n        this.rbracketsExpected--;\n        this.expectCharacter($RBRACKET);\n        return new LiteralArray(this.span(start), this.sourceSpan(start), elements);\n      } else if (this.next.isCharacter($LBRACE)) {\n        return this.parseLiteralMap();\n      } else if (this.next.isIdentifier()) {\n        return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);\n      } else if (this.next.isNumber()) {\n        var value = this.next.toNumber();\n        this.advance();\n        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);\n      } else if (this.next.isString()) {\n        var literalValue = this.next.toString();\n        this.advance();\n        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);\n      } else if (this.next.isPrivateIdentifier()) {\n        this._reportErrorForPrivateIdentifier(this.next, null);\n\n        return new EmptyExpr(this.span(start), this.sourceSpan(start));\n      } else if (this.index >= this.tokens.length) {\n        this.error(\"Unexpected end of expression: \".concat(this.input));\n        return new EmptyExpr(this.span(start), this.sourceSpan(start));\n      } else {\n        this.error(\"Unexpected token \".concat(this.next));\n        return new EmptyExpr(this.span(start), this.sourceSpan(start));\n      }\n    }\n  }, {\n    key: \"parseExpressionList\",\n    value: function parseExpressionList(terminator) {\n      var result = [];\n\n      do {\n        if (!this.next.isCharacter(terminator)) {\n          result.push(this.parsePipe());\n        } else {\n          break;\n        }\n      } while (this.consumeOptionalCharacter($COMMA));\n\n      return result;\n    }\n  }, {\n    key: \"parseLiteralMap\",\n    value: function parseLiteralMap() {\n      var keys = [];\n      var values = [];\n      var start = this.inputIndex;\n      this.expectCharacter($LBRACE);\n\n      if (!this.consumeOptionalCharacter($RBRACE)) {\n        this.rbracesExpected++;\n\n        do {\n          var keyStart = this.inputIndex;\n          var quoted = this.next.isString();\n          var key = this.expectIdentifierOrKeywordOrString();\n          keys.push({\n            key: key,\n            quoted: quoted\n          }); // Properties with quoted keys can't use the shorthand syntax.\n\n          if (quoted) {\n            this.expectCharacter($COLON);\n            values.push(this.parsePipe());\n          } else if (this.consumeOptionalCharacter($COLON)) {\n            values.push(this.parsePipe());\n          } else {\n            var span = this.span(keyStart);\n            var sourceSpan = this.sourceSpan(keyStart);\n            values.push(new PropertyRead(span, sourceSpan, sourceSpan, new ImplicitReceiver(span, sourceSpan), key));\n          }\n        } while (this.consumeOptionalCharacter($COMMA));\n\n        this.rbracesExpected--;\n        this.expectCharacter($RBRACE);\n      }\n\n      return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\n    }\n  }, {\n    key: \"parseAccessMemberOrMethodCall\",\n    value: function parseAccessMemberOrMethodCall(receiver, start, isSafe) {\n      var _this160 = this;\n\n      var nameStart = this.inputIndex;\n      var id = this.withContext(ParseContextFlags.Writable, function () {\n        var _a;\n\n        var id = (_a = _this160.expectIdentifierOrKeyword()) !== null && _a !== void 0 ? _a : '';\n\n        if (id.length === 0) {\n          _this160.error(\"Expected identifier for property access\", receiver.span.end);\n        }\n\n        return id;\n      });\n      var nameSpan = this.sourceSpan(nameStart);\n\n      if (this.consumeOptionalCharacter($LPAREN)) {\n        var argumentStart = this.inputIndex;\n        this.rparensExpected++;\n        var args = this.parseCallArguments();\n        var argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);\n        this.expectCharacter($RPAREN);\n        this.rparensExpected--;\n        var span = this.span(start);\n        var sourceSpan = this.sourceSpan(start);\n        return isSafe ? new SafeMethodCall(span, sourceSpan, nameSpan, receiver, id, args, argumentSpan) : new MethodCall(span, sourceSpan, nameSpan, receiver, id, args, argumentSpan);\n      } else {\n        if (isSafe) {\n          if (this.consumeOptionalOperator('=')) {\n            this.error('The \\'?.\\' operator cannot be used in the assignment');\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n          } else {\n            return new SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, receiver, id);\n          }\n        } else {\n          if (this.consumeOptionalOperator('=')) {\n            if (!this.parseAction) {\n              this.error('Bindings cannot contain assignments');\n              return new EmptyExpr(this.span(start), this.sourceSpan(start));\n            }\n\n            var value = this.parseConditional();\n            return new PropertyWrite(this.span(start), this.sourceSpan(start), nameSpan, receiver, id, value);\n          } else {\n            return new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, receiver, id);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"parseCallArguments\",\n    value: function parseCallArguments() {\n      if (this.next.isCharacter($RPAREN)) return [];\n      var positionals = [];\n\n      do {\n        positionals.push(this.parsePipe());\n      } while (this.consumeOptionalCharacter($COMMA));\n\n      return positionals;\n    }\n    /**\r\n     * Parses an identifier, a keyword, a string with an optional `-` in between,\r\n     * and returns the string along with its absolute source span.\r\n     */\n\n  }, {\n    key: \"expectTemplateBindingKey\",\n    value: function expectTemplateBindingKey() {\n      var result = '';\n      var operatorFound = false;\n      var start = this.currentAbsoluteOffset;\n\n      do {\n        result += this.expectIdentifierOrKeywordOrString();\n        operatorFound = this.consumeOptionalOperator('-');\n\n        if (operatorFound) {\n          result += '-';\n        }\n      } while (operatorFound);\n\n      return {\n        source: result,\n        span: new AbsoluteSourceSpan(start, start + result.length)\n      };\n    }\n    /**\r\n     * Parse microsyntax template expression and return a list of bindings or\r\n     * parsing errors in case the given expression is invalid.\r\n     *\r\n     * For example,\r\n     * ```\r\n     *   <div *ngFor=\"let item of items; index as i; trackBy: func\">\r\n     * ```\r\n     * contains five bindings:\r\n     * 1. ngFor -> null\r\n     * 2. item -> NgForOfContext.$implicit\r\n     * 3. ngForOf -> items\r\n     * 4. i -> NgForOfContext.index\r\n     * 5. ngForTrackBy -> func\r\n     *\r\n     * For a full description of the microsyntax grammar, see\r\n     * https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855\r\n     *\r\n     * @param templateKey name of the microsyntax directive, like ngIf, ngFor,\r\n     * without the *, along with its absolute span.\r\n     */\n\n  }, {\n    key: \"parseTemplateBindings\",\n    value: function parseTemplateBindings(templateKey) {\n      var bindings = []; // The first binding is for the template key itself\n      // In *ngFor=\"let item of items\", key = \"ngFor\", value = null\n      // In *ngIf=\"cond | pipe\", key = \"ngIf\", value = \"cond | pipe\"\n\n      bindings.push.apply(bindings, _toConsumableArray(this.parseDirectiveKeywordBindings(templateKey)));\n\n      while (this.index < this.tokens.length) {\n        // If it starts with 'let', then this must be variable declaration\n        var letBinding = this.parseLetBinding();\n\n        if (letBinding) {\n          bindings.push(letBinding);\n        } else {\n          // Two possible cases here, either `value \"as\" key` or\n          // \"directive-keyword expression\". We don't know which case, but both\n          // \"value\" and \"directive-keyword\" are template binding key, so consume\n          // the key first.\n          var key = this.expectTemplateBindingKey(); // Peek at the next token, if it is \"as\" then this must be variable\n          // declaration.\n\n          var binding = this.parseAsBinding(key);\n\n          if (binding) {\n            bindings.push(binding);\n          } else {\n            // Otherwise the key must be a directive keyword, like \"of\". Transform\n            // the key to actual key. Eg. of -> ngForOf, trackBy -> ngForTrackBy\n            key.source = templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);\n            bindings.push.apply(bindings, _toConsumableArray(this.parseDirectiveKeywordBindings(key)));\n          }\n        }\n\n        this.consumeStatementTerminator();\n      }\n\n      return new TemplateBindingParseResult(bindings, []\n      /* warnings */\n      , this.errors);\n    }\n  }, {\n    key: \"parseKeyedReadOrWrite\",\n    value: function parseKeyedReadOrWrite(receiver, start, isSafe) {\n      var _this161 = this;\n\n      return this.withContext(ParseContextFlags.Writable, function () {\n        _this161.rbracketsExpected++;\n\n        var key = _this161.parsePipe();\n\n        if (key instanceof EmptyExpr) {\n          _this161.error(\"Key access cannot be empty\");\n        }\n\n        _this161.rbracketsExpected--;\n\n        _this161.expectCharacter($RBRACKET);\n\n        if (_this161.consumeOptionalOperator('=')) {\n          if (isSafe) {\n            _this161.error('The \\'?.\\' operator cannot be used in the assignment');\n          } else {\n            var value = _this161.parseConditional();\n\n            return new KeyedWrite(_this161.span(start), _this161.sourceSpan(start), receiver, key, value);\n          }\n        } else {\n          return isSafe ? new SafeKeyedRead(_this161.span(start), _this161.sourceSpan(start), receiver, key) : new KeyedRead(_this161.span(start), _this161.sourceSpan(start), receiver, key);\n        }\n\n        return new EmptyExpr(_this161.span(start), _this161.sourceSpan(start));\n      });\n    }\n    /**\r\n     * Parse a directive keyword, followed by a mandatory expression.\r\n     * For example, \"of items\", \"trackBy: func\".\r\n     * The bindings are: ngForOf -> items, ngForTrackBy -> func\r\n     * There could be an optional \"as\" binding that follows the expression.\r\n     * For example,\r\n     * ```\r\n     *   *ngFor=\"let item of items | slice:0:1 as collection\".\r\n     *                    ^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^\r\n     *               keyword    bound target   optional 'as' binding\r\n     * ```\r\n     *\r\n     * @param key binding key, for example, ngFor, ngIf, ngForOf, along with its\r\n     * absolute span.\r\n     */\n\n  }, {\n    key: \"parseDirectiveKeywordBindings\",\n    value: function parseDirectiveKeywordBindings(key) {\n      var bindings = [];\n      this.consumeOptionalCharacter($COLON); // trackBy: trackByFunction\n\n      var value = this.getDirectiveBoundTarget();\n      var spanEnd = this.currentAbsoluteOffset; // The binding could optionally be followed by \"as\". For example,\n      // *ngIf=\"cond | pipe as x\". In this case, the key in the \"as\" binding\n      // is \"x\" and the value is the template key itself (\"ngIf\"). Note that the\n      // 'key' in the current context now becomes the \"value\" in the next binding.\n\n      var asBinding = this.parseAsBinding(key);\n\n      if (!asBinding) {\n        this.consumeStatementTerminator();\n        spanEnd = this.currentAbsoluteOffset;\n      }\n\n      var sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);\n      bindings.push(new ExpressionBinding(sourceSpan, key, value));\n\n      if (asBinding) {\n        bindings.push(asBinding);\n      }\n\n      return bindings;\n    }\n    /**\r\n     * Return the expression AST for the bound target of a directive keyword\r\n     * binding. For example,\r\n     * ```\r\n     *   *ngIf=\"condition | pipe\"\r\n     *          ^^^^^^^^^^^^^^^^ bound target for \"ngIf\"\r\n     *   *ngFor=\"let item of items\"\r\n     *                       ^^^^^ bound target for \"ngForOf\"\r\n     * ```\r\n     */\n\n  }, {\n    key: \"getDirectiveBoundTarget\",\n    value: function getDirectiveBoundTarget() {\n      if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {\n        return null;\n      }\n\n      var ast = this.parsePipe(); // example: \"condition | async\"\n\n      var _ast$span = ast.span,\n          start = _ast$span.start,\n          end = _ast$span.end;\n      var value = this.input.substring(start, end);\n      return new ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);\n    }\n    /**\r\n     * Return the binding for a variable declared using `as`. Note that the order\r\n     * of the key-value pair in this declaration is reversed. For example,\r\n     * ```\r\n     *   *ngFor=\"let item of items; index as i\"\r\n     *                              ^^^^^    ^\r\n     *                              value    key\r\n     * ```\r\n     *\r\n     * @param value name of the value in the declaration, \"ngIf\" in the example\r\n     * above, along with its absolute span.\r\n     */\n\n  }, {\n    key: \"parseAsBinding\",\n    value: function parseAsBinding(value) {\n      if (!this.peekKeywordAs()) {\n        return null;\n      }\n\n      this.advance(); // consume the 'as' keyword\n\n      var key = this.expectTemplateBindingKey();\n      this.consumeStatementTerminator();\n      var sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);\n      return new VariableBinding(sourceSpan, key, value);\n    }\n    /**\r\n     * Return the binding for a variable declared using `let`. For example,\r\n     * ```\r\n     *   *ngFor=\"let item of items; let i=index;\"\r\n     *           ^^^^^^^^           ^^^^^^^^^^^\r\n     * ```\r\n     * In the first binding, `item` is bound to `NgForOfContext.$implicit`.\r\n     * In the second binding, `i` is bound to `NgForOfContext.index`.\r\n     */\n\n  }, {\n    key: \"parseLetBinding\",\n    value: function parseLetBinding() {\n      if (!this.peekKeywordLet()) {\n        return null;\n      }\n\n      var spanStart = this.currentAbsoluteOffset;\n      this.advance(); // consume the 'let' keyword\n\n      var key = this.expectTemplateBindingKey();\n      var value = null;\n\n      if (this.consumeOptionalOperator('=')) {\n        value = this.expectTemplateBindingKey();\n      }\n\n      this.consumeStatementTerminator();\n      var sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);\n      return new VariableBinding(sourceSpan, key, value);\n    }\n    /**\r\n     * Consume the optional statement terminator: semicolon or comma.\r\n     */\n\n  }, {\n    key: \"consumeStatementTerminator\",\n    value: function consumeStatementTerminator() {\n      this.consumeOptionalCharacter($SEMICOLON) || this.consumeOptionalCharacter($COMMA);\n    }\n    /**\r\n     * Records an error and skips over the token stream until reaching a recoverable point. See\r\n     * `this.skip` for more details on token skipping.\r\n     */\n\n  }, {\n    key: \"error\",\n    value: function error(message) {\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n      this.skip();\n    }\n  }, {\n    key: \"locationText\",\n    value: function locationText() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (index == null) index = this.index;\n      return index < this.tokens.length ? \"at column \".concat(this.tokens[index].index + 1, \" in\") : \"at the end of the expression\";\n    }\n    /**\r\n     * Records an error for an unexpected private identifier being discovered.\r\n     * @param token Token representing a private identifier.\r\n     * @param extraMessage Optional additional message being appended to the error.\r\n     */\n\n  }, {\n    key: \"_reportErrorForPrivateIdentifier\",\n    value: function _reportErrorForPrivateIdentifier(token, extraMessage) {\n      var errorMessage = \"Private identifiers are not supported. Unexpected private identifier: \".concat(token);\n\n      if (extraMessage !== null) {\n        errorMessage += \", \".concat(extraMessage);\n      }\n\n      this.error(errorMessage);\n    }\n    /**\r\n     * Error recovery should skip tokens until it encounters a recovery point.\r\n     *\r\n     * The following are treated as unconditional recovery points:\r\n     *   - end of input\r\n     *   - ';' (parseChain() is always the root production, and it expects a ';')\r\n     *   - '|' (since pipes may be chained and each pipe expression may be treated independently)\r\n     *\r\n     * The following are conditional recovery points:\r\n     *   - ')', '}', ']' if one of calling productions is expecting one of these symbols\r\n     *     - This allows skip() to recover from errors such as '(a.) + 1' allowing more of the AST to\r\n     *       be retained (it doesn't skip any tokens as the ')' is retained because of the '(' begins\r\n     *       an '(' <expr> ')' production).\r\n     *       The recovery points of grouping symbols must be conditional as they must be skipped if\r\n     *       none of the calling productions are not expecting the closing token else we will never\r\n     *       make progress in the case of an extraneous group closing symbol (such as a stray ')').\r\n     *       That is, we skip a closing symbol if we are not in a grouping production.\r\n     *   - '=' in a `Writable` context\r\n     *     - In this context, we are able to recover after seeing the `=` operator, which\r\n     *       signals the presence of an independent rvalue expression following the `=` operator.\r\n     *\r\n     * If a production expects one of these token it increments the corresponding nesting count,\r\n     * and then decrements it just prior to checking if the token is in the input.\r\n     */\n\n  }, {\n    key: \"skip\",\n    value: function skip() {\n      var n = this.next;\n\n      while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) && !n.isOperator('|') && (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) && (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) && (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET)) && (!(this.context & ParseContextFlags.Writable) || !n.isOperator('='))) {\n        if (this.next.isError()) {\n          this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));\n        }\n\n        this.advance();\n        n = this.next;\n      }\n    }\n  }]);\n\n  return _ParseAST;\n}();\n\nvar SimpleExpressionChecker = /*#__PURE__*/function () {\n  function SimpleExpressionChecker() {\n    _classCallCheck(this, SimpleExpressionChecker);\n\n    this.errors = [];\n  }\n\n  _createClass(SimpleExpressionChecker, [{\n    key: \"visitImplicitReceiver\",\n    value: function visitImplicitReceiver(ast, context) {}\n  }, {\n    key: \"visitThisReceiver\",\n    value: function visitThisReceiver(ast, context) {}\n  }, {\n    key: \"visitInterpolation\",\n    value: function visitInterpolation(ast, context) {}\n  }, {\n    key: \"visitLiteralPrimitive\",\n    value: function visitLiteralPrimitive(ast, context) {}\n  }, {\n    key: \"visitPropertyRead\",\n    value: function visitPropertyRead(ast, context) {}\n  }, {\n    key: \"visitPropertyWrite\",\n    value: function visitPropertyWrite(ast, context) {}\n  }, {\n    key: \"visitSafePropertyRead\",\n    value: function visitSafePropertyRead(ast, context) {}\n  }, {\n    key: \"visitMethodCall\",\n    value: function visitMethodCall(ast, context) {}\n  }, {\n    key: \"visitSafeMethodCall\",\n    value: function visitSafeMethodCall(ast, context) {}\n  }, {\n    key: \"visitFunctionCall\",\n    value: function visitFunctionCall(ast, context) {}\n  }, {\n    key: \"visitLiteralArray\",\n    value: function visitLiteralArray(ast, context) {\n      this.visitAll(ast.expressions, context);\n    }\n  }, {\n    key: \"visitLiteralMap\",\n    value: function visitLiteralMap(ast, context) {\n      this.visitAll(ast.values, context);\n    }\n  }, {\n    key: \"visitUnary\",\n    value: function visitUnary(ast, context) {}\n  }, {\n    key: \"visitBinary\",\n    value: function visitBinary(ast, context) {}\n  }, {\n    key: \"visitPrefixNot\",\n    value: function visitPrefixNot(ast, context) {}\n  }, {\n    key: \"visitNonNullAssert\",\n    value: function visitNonNullAssert(ast, context) {}\n  }, {\n    key: \"visitConditional\",\n    value: function visitConditional(ast, context) {}\n  }, {\n    key: \"visitPipe\",\n    value: function visitPipe(ast, context) {\n      this.errors.push('pipes');\n    }\n  }, {\n    key: \"visitKeyedRead\",\n    value: function visitKeyedRead(ast, context) {}\n  }, {\n    key: \"visitKeyedWrite\",\n    value: function visitKeyedWrite(ast, context) {}\n  }, {\n    key: \"visitAll\",\n    value: function visitAll(asts, context) {\n      var _this162 = this;\n\n      return asts.map(function (node) {\n        return node.visit(_this162, context);\n      });\n    }\n  }, {\n    key: \"visitChain\",\n    value: function visitChain(ast, context) {}\n  }, {\n    key: \"visitQuote\",\n    value: function visitQuote(ast, context) {}\n  }, {\n    key: \"visitSafeKeyedRead\",\n    value: function visitSafeKeyedRead(ast, context) {}\n  }]);\n\n  return SimpleExpressionChecker;\n}();\n/**\r\n * This class implements SimpleExpressionChecker used in View Engine and performs more strict checks\r\n * to make sure host bindings do not contain pipes. In View Engine, having pipes in host bindings is\r\n * not supported as well, but in some cases (like `!(value | async)`) the error is not triggered at\r\n * compile time. In order to preserve View Engine behavior, more strict checks are introduced for\r\n * Ivy mode only.\r\n */\n\n\nvar IvySimpleExpressionChecker = /*#__PURE__*/function (_RecursiveAstVisitor$2) {\n  _inherits(IvySimpleExpressionChecker, _RecursiveAstVisitor$2);\n\n  var _super97 = _createSuper(IvySimpleExpressionChecker);\n\n  function IvySimpleExpressionChecker() {\n    var _this163;\n\n    _classCallCheck(this, IvySimpleExpressionChecker);\n\n    _this163 = _super97.apply(this, arguments);\n    _this163.errors = [];\n    return _this163;\n  }\n\n  _createClass(IvySimpleExpressionChecker, [{\n    key: \"visitPipe\",\n    value: function visitPipe() {\n      this.errors.push('pipes');\n    }\n  }]);\n\n  return IvySimpleExpressionChecker;\n}(RecursiveAstVisitor$1);\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nfunction mapEntry(key, value) {\n  return {\n    key: key,\n    value: value,\n    quoted: false\n  };\n}\n\nfunction mapLiteral(obj) {\n  var quoted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return literalMap(Object.keys(obj).map(function (key) {\n    return {\n      key: key,\n      quoted: quoted,\n      value: obj[key]\n    };\n  }));\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!\n//                               Reach out to mprobst for details.\n//\n// =================================================================================================\n\n/** Map from tagName|propertyName to SecurityContext. Properties applying to all tags use '*'. */\n\n\nvar _SECURITY_SCHEMA;\n\nfunction SECURITY_SCHEMA() {\n  if (!_SECURITY_SCHEMA) {\n    _SECURITY_SCHEMA = {}; // Case is insignificant below, all element and attribute names are lower-cased for lookup.\n\n    registerContext(SecurityContext.HTML, ['iframe|srcdoc', '*|innerHTML', '*|outerHTML']);\n    registerContext(SecurityContext.STYLE, ['*|style']); // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.\n\n    registerContext(SecurityContext.URL, ['*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href', 'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action', 'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite', 'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src']);\n    registerContext(SecurityContext.RESOURCE_URL, ['applet|code', 'applet|codebase', 'base|href', 'embed|src', 'frame|src', 'head|profile', 'html|manifest', 'iframe|src', 'link|href', 'media|src', 'object|codebase', 'object|data', 'script|src']);\n  }\n\n  return _SECURITY_SCHEMA;\n}\n\nfunction registerContext(ctx, specs) {\n  var _iterator13 = _createForOfIteratorHelper(specs),\n      _step13;\n\n  try {\n    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n      var spec = _step13.value;\n      _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n    }\n  } catch (err) {\n    _iterator13.e(err);\n  } finally {\n    _iterator13.f();\n  }\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar ElementSchemaRegistry = function ElementSchemaRegistry() {\n  _classCallCheck(this, ElementSchemaRegistry);\n};\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar BOOLEAN = 'boolean';\nvar NUMBER = 'number';\nvar STRING = 'string';\nvar OBJECT = 'object';\n/**\r\n * This array represents the DOM schema. It encodes inheritance, properties, and events.\r\n *\r\n * ## Overview\r\n *\r\n * Each line represents one kind of element. The `element_inheritance` and properties are joined\r\n * using `element_inheritance|properties` syntax.\r\n *\r\n * ## Element Inheritance\r\n *\r\n * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.\r\n * Here the individual elements are separated by `,` (commas). Every element in the list\r\n * has identical properties.\r\n *\r\n * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is\r\n * specified then `\"\"` (blank) element is assumed.\r\n *\r\n * NOTE: The blank element inherits from root `[Element]` element, the super element of all\r\n * elements.\r\n *\r\n * NOTE an element prefix such as `:svg:` has no special meaning to the schema.\r\n *\r\n * ## Properties\r\n *\r\n * Each element has a set of properties separated by `,` (commas). Each property can be prefixed\r\n * by a special character designating its type:\r\n *\r\n * - (no prefix): property is a string.\r\n * - `*`: property represents an event.\r\n * - `!`: property is a boolean.\r\n * - `#`: property is a number.\r\n * - `%`: property is an object.\r\n *\r\n * ## Query\r\n *\r\n * The class creates an internal squas representation which allows to easily answer the query of\r\n * if a given property exist on a given element.\r\n *\r\n * NOTE: We don't yet support querying for types or events.\r\n * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,\r\n *       see dom_element_schema_registry_spec.ts\r\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!\n//\n// Newly added properties must be security reviewed and assigned an appropriate SecurityContext in\n// dom_security_schema.ts. Reach out to mprobst & rjamet for details.\n//\n// =================================================================================================\n\nvar SCHEMA = ['[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot' +\n/* added manually to avoid breaking changes */\n',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored', '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate', 'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate', 'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume', ':svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex', ':svg:graphics^:svg:|', ':svg:animation^:svg:|*begin,*end,*repeat', ':svg:geometry^:svg:|', ':svg:componentTransferFunction^:svg:|', ':svg:gradient^:svg:|', ':svg:textContent^:svg:graphics|', ':svg:textPositioning^:svg:textContent|', 'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username', 'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username', 'audio^media|', 'br^[HTMLElement]|clear', 'base^[HTMLElement]|href,target', 'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink', 'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value', 'canvas^[HTMLElement]|#height,#width', 'content^[HTMLElement]|select', 'dl^[HTMLElement]|!compact', 'datalist^[HTMLElement]|', 'details^[HTMLElement]|!open', 'dialog^[HTMLElement]|!open,returnValue', 'dir^[HTMLElement]|!compact', 'div^[HTMLElement]|align', 'embed^[HTMLElement]|align,height,name,src,type,width', 'fieldset^[HTMLElement]|!disabled,name', 'font^[HTMLElement]|color,face,size', 'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target', 'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src', 'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows', 'hr^[HTMLElement]|align,color,!noShade,size,width', 'head^[HTMLElement]|', 'h1,h2,h3,h4,h5,h6^[HTMLElement]|align', 'html^[HTMLElement]|version', 'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width', 'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width', 'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width', 'li^[HTMLElement]|type,#value', 'label^[HTMLElement]|htmlFor', 'legend^[HTMLElement]|align', 'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type', 'map^[HTMLElement]|name', 'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width', 'menu^[HTMLElement]|!compact', 'meta^[HTMLElement]|content,httpEquiv,name,scheme', 'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value', 'ins,del^[HTMLElement]|cite,dateTime', 'ol^[HTMLElement]|!compact,!reversed,#start,type', 'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width', 'optgroup^[HTMLElement]|!disabled,label', 'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value', 'output^[HTMLElement]|defaultValue,%htmlFor,name,value', 'p^[HTMLElement]|align', 'param^[HTMLElement]|name,type,value,valueType', 'picture^[HTMLElement]|', 'pre^[HTMLElement]|#width', 'progress^[HTMLElement]|#max,#value', 'q,blockquote,cite^[HTMLElement]|', 'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type', 'select^[HTMLElement]|autocomplete,!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value', 'shadow^[HTMLElement]|', 'slot^[HTMLElement]|name', 'source^[HTMLElement]|media,sizes,src,srcset,type', 'span^[HTMLElement]|', 'style^[HTMLElement]|!disabled,media,type', 'caption^[HTMLElement]|align', 'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width', 'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width', 'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width', 'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign', 'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign', 'template^[HTMLElement]|', 'textarea^[HTMLElement]|autocapitalize,autocomplete,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap', 'title^[HTMLElement]|text', 'track^[HTMLElement]|!default,kind,label,src,srclang', 'ul^[HTMLElement]|!compact,type', 'unknown^[HTMLElement]|', 'video^media|#height,poster,#width', ':svg:a^:svg:graphics|', ':svg:animate^:svg:animation|', ':svg:animateMotion^:svg:animation|', ':svg:animateTransform^:svg:animation|', ':svg:circle^:svg:geometry|', ':svg:clipPath^:svg:graphics|', ':svg:defs^:svg:graphics|', ':svg:desc^:svg:|', ':svg:discard^:svg:|', ':svg:ellipse^:svg:geometry|', ':svg:feBlend^:svg:|', ':svg:feColorMatrix^:svg:|', ':svg:feComponentTransfer^:svg:|', ':svg:feComposite^:svg:|', ':svg:feConvolveMatrix^:svg:|', ':svg:feDiffuseLighting^:svg:|', ':svg:feDisplacementMap^:svg:|', ':svg:feDistantLight^:svg:|', ':svg:feDropShadow^:svg:|', ':svg:feFlood^:svg:|', ':svg:feFuncA^:svg:componentTransferFunction|', ':svg:feFuncB^:svg:componentTransferFunction|', ':svg:feFuncG^:svg:componentTransferFunction|', ':svg:feFuncR^:svg:componentTransferFunction|', ':svg:feGaussianBlur^:svg:|', ':svg:feImage^:svg:|', ':svg:feMerge^:svg:|', ':svg:feMergeNode^:svg:|', ':svg:feMorphology^:svg:|', ':svg:feOffset^:svg:|', ':svg:fePointLight^:svg:|', ':svg:feSpecularLighting^:svg:|', ':svg:feSpotLight^:svg:|', ':svg:feTile^:svg:|', ':svg:feTurbulence^:svg:|', ':svg:filter^:svg:|', ':svg:foreignObject^:svg:graphics|', ':svg:g^:svg:graphics|', ':svg:image^:svg:graphics|', ':svg:line^:svg:geometry|', ':svg:linearGradient^:svg:gradient|', ':svg:mpath^:svg:|', ':svg:marker^:svg:|', ':svg:mask^:svg:|', ':svg:metadata^:svg:|', ':svg:path^:svg:geometry|', ':svg:pattern^:svg:|', ':svg:polygon^:svg:geometry|', ':svg:polyline^:svg:geometry|', ':svg:radialGradient^:svg:gradient|', ':svg:rect^:svg:geometry|', ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan', ':svg:script^:svg:|type', ':svg:set^:svg:animation|', ':svg:stop^:svg:|', ':svg:style^:svg:|!disabled,media,title,type', ':svg:switch^:svg:graphics|', ':svg:symbol^:svg:|', ':svg:tspan^:svg:textPositioning|', ':svg:text^:svg:textPositioning|', ':svg:textPath^:svg:textContent|', ':svg:title^:svg:|', ':svg:use^:svg:graphics|', ':svg:view^:svg:|#zoomAndPan', 'data^[HTMLElement]|value', 'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name', 'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default', 'summary^[HTMLElement]|', 'time^[HTMLElement]|dateTime', ':svg:cursor^:svg:|'];\nvar _ATTR_TO_PROP = {\n  'class': 'className',\n  'for': 'htmlFor',\n  'formaction': 'formAction',\n  'innerHtml': 'innerHTML',\n  'readonly': 'readOnly',\n  'tabindex': 'tabIndex'\n}; // Invert _ATTR_TO_PROP.\n\nvar _PROP_TO_ATTR = Object.keys(_ATTR_TO_PROP).reduce(function (inverted, attr) {\n  inverted[_ATTR_TO_PROP[attr]] = attr;\n  return inverted;\n}, {});\n\nvar DomElementSchemaRegistry = /*#__PURE__*/function (_ElementSchemaRegistr) {\n  _inherits(DomElementSchemaRegistry, _ElementSchemaRegistr);\n\n  var _super98 = _createSuper(DomElementSchemaRegistry);\n\n  function DomElementSchemaRegistry() {\n    var _this164;\n\n    _classCallCheck(this, DomElementSchemaRegistry);\n\n    _this164 = _super98.call(this);\n    _this164._schema = {};\n    SCHEMA.forEach(function (encodedType) {\n      var type = {};\n\n      var _encodedType$split = encodedType.split('|'),\n          _encodedType$split2 = _slicedToArray(_encodedType$split, 2),\n          strType = _encodedType$split2[0],\n          strProperties = _encodedType$split2[1];\n\n      var properties = strProperties.split(',');\n\n      var _strType$split = strType.split('^'),\n          _strType$split2 = _slicedToArray(_strType$split, 2),\n          typeNames = _strType$split2[0],\n          superName = _strType$split2[1];\n\n      typeNames.split(',').forEach(function (tag) {\n        return _this164._schema[tag.toLowerCase()] = type;\n      });\n\n      var superType = superName && _this164._schema[superName.toLowerCase()];\n\n      if (superType) {\n        Object.keys(superType).forEach(function (prop) {\n          type[prop] = superType[prop];\n        });\n      }\n\n      properties.forEach(function (property) {\n        if (property.length > 0) {\n          switch (property[0]) {\n            case '*':\n              // We don't yet support events.\n              // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events\n              // will\n              // almost certainly introduce bad XSS vulnerabilities.\n              // type[property.substring(1)] = EVENT;\n              break;\n\n            case '!':\n              type[property.substring(1)] = BOOLEAN;\n              break;\n\n            case '#':\n              type[property.substring(1)] = NUMBER;\n              break;\n\n            case '%':\n              type[property.substring(1)] = OBJECT;\n              break;\n\n            default:\n              type[property] = STRING;\n          }\n        }\n      });\n    });\n    return _this164;\n  }\n\n  _createClass(DomElementSchemaRegistry, [{\n    key: \"hasProperty\",\n    value: function hasProperty(tagName, propName, schemaMetas) {\n      if (schemaMetas.some(function (schema) {\n        return schema.name === NO_ERRORS_SCHEMA.name;\n      })) {\n        return true;\n      }\n\n      if (tagName.indexOf('-') > -1) {\n        if (isNgContainer(tagName) || isNgContent(tagName)) {\n          return false;\n        }\n\n        if (schemaMetas.some(function (schema) {\n          return schema.name === CUSTOM_ELEMENTS_SCHEMA.name;\n        })) {\n          // Can't tell now as we don't know which properties a custom element will get\n          // once it is instantiated\n          return true;\n        }\n      }\n\n      var elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];\n\n      return !!elementProperties[propName];\n    }\n  }, {\n    key: \"hasElement\",\n    value: function hasElement(tagName, schemaMetas) {\n      if (schemaMetas.some(function (schema) {\n        return schema.name === NO_ERRORS_SCHEMA.name;\n      })) {\n        return true;\n      }\n\n      if (tagName.indexOf('-') > -1) {\n        if (isNgContainer(tagName) || isNgContent(tagName)) {\n          return true;\n        }\n\n        if (schemaMetas.some(function (schema) {\n          return schema.name === CUSTOM_ELEMENTS_SCHEMA.name;\n        })) {\n          // Allow any custom elements\n          return true;\n        }\n      }\n\n      return !!this._schema[tagName.toLowerCase()];\n    }\n    /**\r\n     * securityContext returns the security context for the given property on the given DOM tag.\r\n     *\r\n     * Tag and property name are statically known and cannot change at runtime, i.e. it is not\r\n     * possible to bind a value into a changing attribute or tag name.\r\n     *\r\n     * The filtering is based on a list of allowed tags|attributes. All attributes in the schema\r\n     * above are assumed to have the 'NONE' security context, i.e. that they are safe inert\r\n     * string values. Only specific well known attack vectors are assigned their appropriate context.\r\n     */\n\n  }, {\n    key: \"securityContext\",\n    value: function securityContext(tagName, propName, isAttribute) {\n      if (isAttribute) {\n        // NB: For security purposes, use the mapped property name, not the attribute name.\n        propName = this.getMappedPropName(propName);\n      } // Make sure comparisons are case insensitive, so that case differences between attribute and\n      // property names do not have a security impact.\n\n\n      tagName = tagName.toLowerCase();\n      propName = propName.toLowerCase();\n      var ctx = SECURITY_SCHEMA()[tagName + '|' + propName];\n\n      if (ctx) {\n        return ctx;\n      }\n\n      ctx = SECURITY_SCHEMA()['*|' + propName];\n      return ctx ? ctx : SecurityContext.NONE;\n    }\n  }, {\n    key: \"getMappedPropName\",\n    value: function getMappedPropName(propName) {\n      return _ATTR_TO_PROP[propName] || propName;\n    }\n  }, {\n    key: \"getDefaultComponentElementName\",\n    value: function getDefaultComponentElementName() {\n      return 'ng-component';\n    }\n  }, {\n    key: \"validateProperty\",\n    value: function validateProperty(name) {\n      if (name.toLowerCase().startsWith('on')) {\n        var msg = \"Binding to event property '\".concat(name, \"' is disallowed for security reasons, \") + \"please use (\".concat(name.slice(2), \")=...\") + \"\\nIf '\".concat(name, \"' is a directive input, make sure the directive is imported by the\") + \" current module.\";\n        return {\n          error: true,\n          msg: msg\n        };\n      } else {\n        return {\n          error: false\n        };\n      }\n    }\n  }, {\n    key: \"validateAttribute\",\n    value: function validateAttribute(name) {\n      if (name.toLowerCase().startsWith('on')) {\n        var msg = \"Binding to event attribute '\".concat(name, \"' is disallowed for security reasons, \") + \"please use (\".concat(name.slice(2), \")=...\");\n        return {\n          error: true,\n          msg: msg\n        };\n      } else {\n        return {\n          error: false\n        };\n      }\n    }\n  }, {\n    key: \"allKnownElementNames\",\n    value: function allKnownElementNames() {\n      return Object.keys(this._schema);\n    }\n  }, {\n    key: \"allKnownAttributesOfElement\",\n    value: function allKnownAttributesOfElement(tagName) {\n      var elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown']; // Convert properties to attributes.\n\n\n      return Object.keys(elementProperties).map(function (prop) {\n        var _a;\n\n        return (_a = _PROP_TO_ATTR[prop]) !== null && _a !== void 0 ? _a : prop;\n      });\n    }\n  }, {\n    key: \"normalizeAnimationStyleProperty\",\n    value: function normalizeAnimationStyleProperty(propName) {\n      return dashCaseToCamelCase(propName);\n    }\n  }, {\n    key: \"normalizeAnimationStyleValue\",\n    value: function normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {\n      var unit = '';\n      var strVal = val.toString().trim();\n      var errorMsg = null;\n\n      if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n        if (typeof val === 'number') {\n          unit = 'px';\n        } else {\n          var valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n\n          if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n            errorMsg = \"Please provide a CSS unit value for \".concat(userProvidedProp, \":\").concat(val);\n          }\n        }\n      }\n\n      return {\n        error: errorMsg,\n        value: strVal + unit\n      };\n    }\n  }]);\n\n  return DomElementSchemaRegistry;\n}(ElementSchemaRegistry);\n\nfunction _isPixelDimensionStyle(prop) {\n  switch (prop) {\n    case 'width':\n    case 'height':\n    case 'minWidth':\n    case 'minHeight':\n    case 'maxWidth':\n    case 'maxHeight':\n    case 'left':\n    case 'top':\n    case 'bottom':\n    case 'right':\n    case 'fontSize':\n    case 'outlineWidth':\n    case 'outlineOffset':\n    case 'paddingTop':\n    case 'paddingLeft':\n    case 'paddingBottom':\n    case 'paddingRight':\n    case 'marginTop':\n    case 'marginLeft':\n    case 'marginBottom':\n    case 'marginRight':\n    case 'borderRadius':\n    case 'borderWidth':\n    case 'borderTopWidth':\n    case 'borderLeftWidth':\n    case 'borderRightWidth':\n    case 'borderBottomWidth':\n    case 'textIndent':\n      return true;\n\n    default:\n      return false;\n  }\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Set of tagName|propertyName corresponding to Trusted Types sinks. Properties applying to all\r\n * tags use '*'.\r\n *\r\n * Extracted from, and should be kept in sync with\r\n * https://w3c.github.io/webappsec-trusted-types/dist/spec/#integrations\r\n */\n\n\nvar TRUSTED_TYPES_SINKS = new Set([// NOTE: All strings in this set *must* be lowercase!\n// TrustedHTML\n'iframe|srcdoc', '*|innerhtml', '*|outerhtml', // NB: no TrustedScript here, as the corresponding tags are stripped by the compiler.\n// TrustedScriptURL\n'embed|src', 'object|codebase', 'object|data']);\n/**\r\n * isTrustedTypesSink returns true if the given property on the given DOM tag is a Trusted Types\r\n * sink. In that case, use `ElementSchemaRegistry.securityContext` to determine which particular\r\n * Trusted Type is required for values passed to the sink:\r\n * - SecurityContext.HTML corresponds to TrustedHTML\r\n * - SecurityContext.RESOURCE_URL corresponds to TrustedScriptURL\r\n */\n\nfunction isTrustedTypesSink(tagName, propName) {\n  // Make sure comparisons are case insensitive, so that case differences between attribute and\n  // property names do not have a security impact.\n  tagName = tagName.toLowerCase();\n  propName = propName.toLowerCase();\n  return TRUSTED_TYPES_SINKS.has(tagName + '|' + propName) || TRUSTED_TYPES_SINKS.has('*|' + propName);\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar BIND_NAME_REGEXP$1 = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/; // Group 1 = \"bind-\"\n\nvar KW_BIND_IDX$1 = 1; // Group 2 = \"let-\"\n\nvar KW_LET_IDX$1 = 2; // Group 3 = \"ref-/#\"\n\nvar KW_REF_IDX$1 = 3; // Group 4 = \"on-\"\n\nvar KW_ON_IDX$1 = 4; // Group 5 = \"bindon-\"\n\nvar KW_BINDON_IDX$1 = 5; // Group 6 = \"@\"\n\nvar KW_AT_IDX$1 = 6; // Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\n\nvar IDENT_KW_IDX$1 = 7;\nvar BINDING_DELIMS = {\n  BANANA_BOX: {\n    start: '[(',\n    end: ')]'\n  },\n  PROPERTY: {\n    start: '[',\n    end: ']'\n  },\n  EVENT: {\n    start: '(',\n    end: ')'\n  }\n};\nvar TEMPLATE_ATTR_PREFIX$2 = '*';\n\nfunction htmlAstToRender3Ast(htmlNodes, bindingParser, options) {\n  var transformer = new HtmlAstToIvyAst(bindingParser, options);\n  var ivyNodes = visitAll$1(transformer, htmlNodes); // Errors might originate in either the binding parser or the html to ivy transformer\n\n  var allErrors = bindingParser.errors.concat(transformer.errors);\n  var result = {\n    nodes: ivyNodes,\n    errors: allErrors,\n    styleUrls: transformer.styleUrls,\n    styles: transformer.styles,\n    ngContentSelectors: transformer.ngContentSelectors\n  };\n\n  if (options.collectCommentNodes) {\n    result.commentNodes = transformer.commentNodes;\n  }\n\n  return result;\n}\n\nvar HtmlAstToIvyAst = /*#__PURE__*/function () {\n  function HtmlAstToIvyAst(bindingParser, options) {\n    _classCallCheck(this, HtmlAstToIvyAst);\n\n    this.bindingParser = bindingParser;\n    this.options = options;\n    this.errors = [];\n    this.styles = [];\n    this.styleUrls = [];\n    this.ngContentSelectors = []; // This array will be populated if `Render3ParseOptions['collectCommentNodes']` is true\n\n    this.commentNodes = [];\n    this.inI18nBlock = false;\n  } // HTML visitor\n\n\n  _createClass(HtmlAstToIvyAst, [{\n    key: \"visitElement\",\n    value: function visitElement(element) {\n      var _this165 = this;\n\n      var isI18nRootElement = isI18nRootNode(element.i18n);\n\n      if (isI18nRootElement) {\n        if (this.inI18nBlock) {\n          this.reportError('Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.', element.sourceSpan);\n        }\n\n        this.inI18nBlock = true;\n      }\n\n      var preparsedElement = preparseElement(element);\n\n      if (preparsedElement.type === PreparsedElementType.SCRIPT) {\n        return null;\n      } else if (preparsedElement.type === PreparsedElementType.STYLE) {\n        var contents = textContents(element);\n\n        if (contents !== null) {\n          this.styles.push(contents);\n        }\n\n        return null;\n      } else if (preparsedElement.type === PreparsedElementType.STYLESHEET && isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n        this.styleUrls.push(preparsedElement.hrefAttr);\n        return null;\n      } // Whether the element is a `<ng-template>`\n\n\n      var isTemplateElement = isNgTemplate(element.name);\n      var parsedProperties = [];\n      var boundEvents = [];\n      var variables = [];\n      var references = [];\n      var attributes = [];\n      var i18nAttrsMeta = {};\n      var templateParsedProperties = [];\n      var templateVariables = []; // Whether the element has any *-attribute\n\n      var elementHasInlineTemplate = false;\n\n      var _iterator14 = _createForOfIteratorHelper(element.attrs),\n          _step14;\n\n      try {\n        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n          var attribute = _step14.value;\n          var hasBinding = false;\n          var normalizedName = normalizeAttributeName(attribute.name); // `*attr` defines template bindings\n\n          var isTemplateBinding = false;\n\n          if (attribute.i18n) {\n            i18nAttrsMeta[attribute.name] = attribute.i18n;\n          }\n\n          if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX$2)) {\n            // *-attributes\n            if (elementHasInlineTemplate) {\n              this.reportError(\"Can't have multiple template bindings on one element. Use only one attribute prefixed with *\", attribute.sourceSpan);\n            }\n\n            isTemplateBinding = true;\n            elementHasInlineTemplate = true;\n            var templateValue = attribute.value;\n            var templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX$2.length);\n            var parsedVariables = [];\n            var absoluteValueOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : // If there is no value span the attribute does not have a value, like `attr` in\n            //`<div attr></div>`. In this case, point to one character beyond the last character of\n            // the attribute name.\n            attribute.sourceSpan.start.offset + attribute.name.length;\n            this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables, true\n            /* isIvyAst */\n            );\n            templateVariables.push.apply(templateVariables, _toConsumableArray(parsedVariables.map(function (v) {\n              return new Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan);\n            })));\n          } else {\n            // Check for variables, events, property bindings, interpolation\n            hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);\n          }\n\n          if (!hasBinding && !isTemplateBinding) {\n            // don't include the bindings as attributes as well in the AST\n            attributes.push(this.visitAttribute(attribute));\n          }\n        }\n      } catch (err) {\n        _iterator14.e(err);\n      } finally {\n        _iterator14.f();\n      }\n\n      var children = visitAll$1(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR$1 : this, element.children);\n      var parsedElement;\n\n      if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n        // `<ng-content>`\n        if (element.children && !element.children.every(function (node) {\n          return isEmptyTextNode(node) || isCommentNode(node);\n        })) {\n          this.reportError(\"<ng-content> element cannot have content.\", element.sourceSpan);\n        }\n\n        var selector = preparsedElement.selectAttr;\n        var attrs = element.attrs.map(function (attr) {\n          return _this165.visitAttribute(attr);\n        });\n        parsedElement = new Content(selector, attrs, element.sourceSpan, element.i18n);\n        this.ngContentSelectors.push(selector);\n      } else if (isTemplateElement) {\n        // `<ng-template>`\n        var _attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n\n        parsedElement = new Template(element.name, attributes, _attrs.bound, boundEvents, [\n          /* no template attributes */\n        ], children, references, variables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n      } else {\n        var _attrs2 = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n\n        parsedElement = new Element(element.name, attributes, _attrs2.bound, boundEvents, children, references, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n      }\n\n      if (elementHasInlineTemplate) {\n        // If this node is an inline-template (e.g. has *ngFor) then we need to create a template\n        // node that contains this node.\n        // Moreover, if the node is an element, then we need to hoist its attributes to the template\n        // node for matching against content projection selectors.\n        var _attrs3 = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);\n\n        var templateAttrs = [];\n\n        _attrs3.literal.forEach(function (attr) {\n          return templateAttrs.push(attr);\n        });\n\n        _attrs3.bound.forEach(function (attr) {\n          return templateAttrs.push(attr);\n        });\n\n        var hoistedAttrs = parsedElement instanceof Element ? {\n          attributes: parsedElement.attributes,\n          inputs: parsedElement.inputs,\n          outputs: parsedElement.outputs\n        } : {\n          attributes: [],\n          inputs: [],\n          outputs: []\n        }; // For <ng-template>s with structural directives on them, avoid passing i18n information to\n        // the wrapping template to prevent unnecessary i18n instructions from being generated. The\n        // necessary i18n meta information will be extracted from child elements.\n\n        var i18n = isTemplateElement && isI18nRootElement ? undefined : element.i18n; // TODO(pk): test for this case\n\n        parsedElement = new Template(parsedElement.name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs, [parsedElement], [\n          /* no references */\n        ], templateVariables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, i18n);\n      }\n\n      if (isI18nRootElement) {\n        this.inI18nBlock = false;\n      }\n\n      return parsedElement;\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute) {\n      return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {\n      return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.i18n);\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(expansion) {\n      var _this166 = this;\n\n      if (!expansion.i18n) {\n        // do not generate Icu in case it was created\n        // outside of i18n block in a template\n        return null;\n      }\n\n      if (!isI18nRootNode(expansion.i18n)) {\n        throw new Error(\"Invalid type \\\"\".concat(expansion.i18n.constructor, \"\\\" for \\\"i18n\\\" property of \").concat(expansion.sourceSpan.toString(), \". Expected a \\\"Message\\\"\"));\n      }\n\n      var message = expansion.i18n;\n      var vars = {};\n      var placeholders = {}; // extract VARs from ICUs - we process them separately while\n      // assembling resulting message via goog.getMsg function, since\n      // we need to pass them to top-level goog.getMsg call\n\n      Object.keys(message.placeholders).forEach(function (key) {\n        var value = message.placeholders[key];\n\n        if (key.startsWith(I18N_ICU_VAR_PREFIX)) {\n          // Currently when the `plural` or `select` keywords in an ICU contain trailing spaces (e.g.\n          // `{count, select , ...}`), these spaces are also included into the key names in ICU vars\n          // (e.g. \"VAR_SELECT \"). These trailing spaces are not desirable, since they will later be\n          // converted into `_` symbols while normalizing placeholder names, which might lead to\n          // mismatches at runtime (i.e. placeholder will not be replaced with the correct value).\n          var formattedKey = key.trim();\n\n          var ast = _this166.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);\n\n          vars[formattedKey] = new BoundText(ast, value.sourceSpan);\n        } else {\n          placeholders[key] = _this166._visitTextWithInterpolation(value.text, value.sourceSpan);\n        }\n      });\n      return new Icu(vars, placeholders, expansion.sourceSpan, message);\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(expansionCase) {\n      return null;\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment) {\n      if (this.options.collectCommentNodes) {\n        this.commentNodes.push(new Comment(comment.value || '', comment.sourceSpan));\n      }\n\n      return null;\n    } // convert view engine `ParsedProperty` to a format suitable for IVY\n\n  }, {\n    key: \"extractAttributes\",\n    value: function extractAttributes(elementName, properties, i18nPropsMeta) {\n      var _this167 = this;\n\n      var bound = [];\n      var literal = [];\n      properties.forEach(function (prop) {\n        var i18n = i18nPropsMeta[prop.name];\n\n        if (prop.isLiteral) {\n          literal.push(new TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n));\n        } else {\n          // Note that validation is skipped and property mapping is disabled\n          // due to the fact that we need to make sure a given prop is not an\n          // input of a directive and directive matching happens at runtime.\n          var bep = _this167.bindingParser.createBoundElementProperty(elementName, prop,\n          /* skipValidation */\n          true,\n          /* mapPropertyName */\n          false);\n\n          bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));\n        }\n      });\n      return {\n        bound: bound,\n        literal: literal\n      };\n    }\n  }, {\n    key: \"parseAttribute\",\n    value: function parseAttribute(isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {\n      var name = normalizeAttributeName(attribute.name);\n      var value = attribute.value;\n      var srcSpan = attribute.sourceSpan;\n      var absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;\n\n      function createKeySpan(srcSpan, prefix, identifier) {\n        // We need to adjust the start location for the keySpan to account for the removed 'data-'\n        // prefix from `normalizeAttributeName`.\n        var normalizationAdjustment = attribute.name.length - name.length;\n        var keySpanStart = srcSpan.start.moveBy(prefix.length + normalizationAdjustment);\n        var keySpanEnd = keySpanStart.moveBy(identifier.length);\n        return new ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);\n      }\n\n      var bindParts = name.match(BIND_NAME_REGEXP$1);\n\n      if (bindParts) {\n        if (bindParts[KW_BIND_IDX$1] != null) {\n          var identifier = bindParts[IDENT_KW_IDX$1];\n\n          var _keySpan = createKeySpan(srcSpan, bindParts[KW_BIND_IDX$1], identifier);\n\n          this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, _keySpan);\n        } else if (bindParts[KW_LET_IDX$1]) {\n          if (isTemplateElement) {\n            var _identifier2 = bindParts[IDENT_KW_IDX$1];\n\n            var _keySpan2 = createKeySpan(srcSpan, bindParts[KW_LET_IDX$1], _identifier2);\n\n            this.parseVariable(_identifier2, value, srcSpan, _keySpan2, attribute.valueSpan, variables);\n          } else {\n            this.reportError(\"\\\"let-\\\" is only supported on ng-template elements.\", srcSpan);\n          }\n        } else if (bindParts[KW_REF_IDX$1]) {\n          var _identifier3 = bindParts[IDENT_KW_IDX$1];\n\n          var _keySpan3 = createKeySpan(srcSpan, bindParts[KW_REF_IDX$1], _identifier3);\n\n          this.parseReference(_identifier3, value, srcSpan, _keySpan3, attribute.valueSpan, references);\n        } else if (bindParts[KW_ON_IDX$1]) {\n          var events = [];\n          var _identifier4 = bindParts[IDENT_KW_IDX$1];\n\n          var _keySpan4 = createKeySpan(srcSpan, bindParts[KW_ON_IDX$1], _identifier4);\n\n          this.bindingParser.parseEvent(_identifier4, value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, _keySpan4);\n          addEvents(events, boundEvents);\n        } else if (bindParts[KW_BINDON_IDX$1]) {\n          var _identifier5 = bindParts[IDENT_KW_IDX$1];\n\n          var _keySpan5 = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX$1], _identifier5);\n\n          this.bindingParser.parsePropertyBinding(_identifier5, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, _keySpan5);\n          this.parseAssignmentEvent(_identifier5, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, _keySpan5);\n        } else if (bindParts[KW_AT_IDX$1]) {\n          var _keySpan6 = createKeySpan(srcSpan, '', name);\n\n          this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, _keySpan6);\n        }\n\n        return true;\n      } // We didn't see a kw-prefixed property binding, but we have not yet checked\n      // for the []/()/[()] syntax.\n\n\n      var delims = null;\n\n      if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {\n        delims = BINDING_DELIMS.BANANA_BOX;\n      } else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {\n        delims = BINDING_DELIMS.PROPERTY;\n      } else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {\n        delims = BINDING_DELIMS.EVENT;\n      }\n\n      if (delims !== null && // NOTE: older versions of the parser would match a start/end delimited\n      // binding iff the property name was terminated by the ending delimiter\n      // and the identifier in the binding was non-empty.\n      // TODO(ayazhafiz): update this to handle malformed bindings.\n      name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {\n        var _identifier6 = name.substring(delims.start.length, name.length - delims.end.length);\n\n        var _keySpan7 = createKeySpan(srcSpan, delims.start, _identifier6);\n\n        if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {\n          this.bindingParser.parsePropertyBinding(_identifier6, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, _keySpan7);\n          this.parseAssignmentEvent(_identifier6, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, _keySpan7);\n        } else if (delims.start === BINDING_DELIMS.PROPERTY.start) {\n          this.bindingParser.parsePropertyBinding(_identifier6, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, _keySpan7);\n        } else {\n          var _events = [];\n          this.bindingParser.parseEvent(_identifier6, value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, _events, _keySpan7);\n          addEvents(_events, boundEvents);\n        }\n\n        return true;\n      } // No explicit binding found.\n\n\n      var keySpan = createKeySpan(srcSpan, ''\n      /* prefix */\n      , name);\n      var hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\n      return hasBinding;\n    }\n  }, {\n    key: \"_visitTextWithInterpolation\",\n    value: function _visitTextWithInterpolation(value, sourceSpan, i18n) {\n      var valueNoNgsp = replaceNgsp(value);\n      var expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan);\n      return expr ? new BoundText(expr, sourceSpan, i18n) : new Text(valueNoNgsp, sourceSpan);\n    }\n  }, {\n    key: \"parseVariable\",\n    value: function parseVariable(identifier, value, sourceSpan, keySpan, valueSpan, variables) {\n      if (identifier.indexOf('-') > -1) {\n        this.reportError(\"\\\"-\\\" is not allowed in variable names\", sourceSpan);\n      } else if (identifier.length === 0) {\n        this.reportError(\"Variable does not have a name\", sourceSpan);\n      }\n\n      variables.push(new Variable(identifier, value, sourceSpan, keySpan, valueSpan));\n    }\n  }, {\n    key: \"parseReference\",\n    value: function parseReference(identifier, value, sourceSpan, keySpan, valueSpan, references) {\n      if (identifier.indexOf('-') > -1) {\n        this.reportError(\"\\\"-\\\" is not allowed in reference names\", sourceSpan);\n      } else if (identifier.length === 0) {\n        this.reportError(\"Reference does not have a name\", sourceSpan);\n      } else if (references.some(function (reference) {\n        return reference.name === identifier;\n      })) {\n        this.reportError(\"Reference \\\"#\".concat(identifier, \"\\\" is defined more than once\"), sourceSpan);\n      }\n\n      references.push(new Reference(identifier, value, sourceSpan, keySpan, valueSpan));\n    }\n  }, {\n    key: \"parseAssignmentEvent\",\n    value: function parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents, keySpan) {\n      var events = [];\n      this.bindingParser.parseEvent(\"\".concat(name, \"Change\"), \"\".concat(expression, \"=$event\"), sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events, keySpan);\n      addEvents(events, boundEvents);\n    }\n  }, {\n    key: \"reportError\",\n    value: function reportError(message, sourceSpan) {\n      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ParseErrorLevel.ERROR;\n      this.errors.push(new ParseError(sourceSpan, message, level));\n    }\n  }]);\n\n  return HtmlAstToIvyAst;\n}();\n\nvar NonBindableVisitor$1 = /*#__PURE__*/function () {\n  function NonBindableVisitor$1() {\n    _classCallCheck(this, NonBindableVisitor$1);\n  }\n\n  _createClass(NonBindableVisitor$1, [{\n    key: \"visitElement\",\n    value: function visitElement(ast) {\n      var preparsedElement = preparseElement(ast);\n\n      if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE || preparsedElement.type === PreparsedElementType.STYLESHEET) {\n        // Skipping <script> for security reasons\n        // Skipping <style> and stylesheets as we already processed them\n        // in the StyleCompiler\n        return null;\n      }\n\n      var children = visitAll$1(this, ast.children, null);\n      return new Element(ast.name, visitAll$1(this, ast.attrs),\n      /* inputs */\n      [],\n      /* outputs */\n      [], children,\n      /* references */\n      [], ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment) {\n      return null;\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute) {\n      return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {\n      return new Text(text.value, text.sourceSpan);\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(expansion) {\n      return null;\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(expansionCase) {\n      return null;\n    }\n  }]);\n\n  return NonBindableVisitor$1;\n}();\n\nvar NON_BINDABLE_VISITOR$1 = new NonBindableVisitor$1();\n\nfunction normalizeAttributeName(attrName) {\n  return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n}\n\nfunction addEvents(events, boundEvents) {\n  boundEvents.push.apply(boundEvents, _toConsumableArray(events.map(function (e) {\n    return BoundEvent.fromParsedEvent(e);\n  })));\n}\n\nfunction isEmptyTextNode(node) {\n  return node instanceof Text$3 && node.value.trim().length == 0;\n}\n\nfunction isCommentNode(node) {\n  return node instanceof Comment$1;\n}\n\nfunction textContents(node) {\n  if (node.children.length !== 1 || !(node.children[0] instanceof Text$3)) {\n    return null;\n  } else {\n    return node.children[0].value;\n  }\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar TagType;\n\n(function (TagType) {\n  TagType[TagType[\"ELEMENT\"] = 0] = \"ELEMENT\";\n  TagType[TagType[\"TEMPLATE\"] = 1] = \"TEMPLATE\";\n})(TagType || (TagType = {}));\n/**\r\n * Generates an object that is used as a shared state between parent and all child contexts.\r\n */\n\n\nfunction setupRegistry() {\n  return {\n    getUniqueId: getSeqNumberGenerator(),\n    icus: new Map()\n  };\n}\n/**\r\n * I18nContext is a helper class which keeps track of all i18n-related aspects\r\n * (accumulates placeholders, bindings, etc) between i18nStart and i18nEnd instructions.\r\n *\r\n * When we enter a nested template, the top-level context is being passed down\r\n * to the nested component, which uses this context to generate a child instance\r\n * of I18nContext class (to handle nested template) and at the end, reconciles it back\r\n * with the parent context.\r\n *\r\n * @param index Instruction index of i18nStart, which initiates this context\r\n * @param ref Reference to a translation const that represents the content if thus context\r\n * @param level Nestng level defined for child contexts\r\n * @param templateIndex Instruction index of a template which this context belongs to\r\n * @param meta Meta information (id, meaning, description, etc) associated with this context\r\n */\n\n\nvar I18nContext = /*#__PURE__*/function () {\n  function I18nContext(index, ref) {\n    var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var templateIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var meta = arguments.length > 4 ? arguments[4] : undefined;\n    var registry = arguments.length > 5 ? arguments[5] : undefined;\n\n    _classCallCheck(this, I18nContext);\n\n    this.index = index;\n    this.ref = ref;\n    this.level = level;\n    this.templateIndex = templateIndex;\n    this.meta = meta;\n    this.registry = registry;\n    this.bindings = new Set();\n    this.placeholders = new Map();\n    this.isEmitted = false;\n    this._unresolvedCtxCount = 0;\n    this._registry = registry || setupRegistry();\n    this.id = this._registry.getUniqueId();\n  }\n\n  _createClass(I18nContext, [{\n    key: \"appendTag\",\n    value: function appendTag(type, node, index, closed) {\n      if (node.isVoid && closed) {\n        return; // ignore \"close\" for void tags\n      }\n\n      var ph = node.isVoid || !closed ? node.startName : node.closeName;\n      var content = {\n        type: type,\n        index: index,\n        ctx: this.id,\n        isVoid: node.isVoid,\n        closed: closed\n      };\n      updatePlaceholderMap(this.placeholders, ph, content);\n    }\n  }, {\n    key: \"icus\",\n    get: function get() {\n      return this._registry.icus;\n    }\n  }, {\n    key: \"isRoot\",\n    get: function get() {\n      return this.level === 0;\n    }\n  }, {\n    key: \"isResolved\",\n    get: function get() {\n      return this._unresolvedCtxCount === 0;\n    }\n  }, {\n    key: \"getSerializedPlaceholders\",\n    value: function getSerializedPlaceholders() {\n      var result = new Map();\n      this.placeholders.forEach(function (values, key) {\n        return result.set(key, values.map(serializePlaceholderValue));\n      });\n      return result;\n    } // public API to accumulate i18n-related content\n\n  }, {\n    key: \"appendBinding\",\n    value: function appendBinding(binding) {\n      this.bindings.add(binding);\n    }\n  }, {\n    key: \"appendIcu\",\n    value: function appendIcu(name, ref) {\n      updatePlaceholderMap(this._registry.icus, name, ref);\n    }\n  }, {\n    key: \"appendBoundText\",\n    value: function appendBoundText(node) {\n      var _this168 = this;\n\n      var phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);\n      phs.forEach(function (values, key) {\n        return updatePlaceholderMap.apply(void 0, [_this168.placeholders, key].concat(_toConsumableArray(values)));\n      });\n    }\n  }, {\n    key: \"appendTemplate\",\n    value: function appendTemplate(node, index) {\n      // add open and close tags at the same time,\n      // since we process nested templates separately\n      this.appendTag(TagType.TEMPLATE, node, index, false);\n      this.appendTag(TagType.TEMPLATE, node, index, true);\n      this._unresolvedCtxCount++;\n    }\n  }, {\n    key: \"appendElement\",\n    value: function appendElement(node, index, closed) {\n      this.appendTag(TagType.ELEMENT, node, index, closed);\n    }\n  }, {\n    key: \"appendProjection\",\n    value: function appendProjection(node, index) {\n      // Add open and close tags at the same time, since `<ng-content>` has no content,\n      // so when we come across `<ng-content>` we can register both open and close tags.\n      // Note: runtime i18n logic doesn't distinguish `<ng-content>` tag placeholders and\n      // regular element tag placeholders, so we generate element placeholders for both types.\n      this.appendTag(TagType.ELEMENT, node, index, false);\n      this.appendTag(TagType.ELEMENT, node, index, true);\n    }\n    /**\r\n     * Generates an instance of a child context based on the root one,\r\n     * when we enter a nested template within I18n section.\r\n     *\r\n     * @param index Instruction index of corresponding i18nStart, which initiates this context\r\n     * @param templateIndex Instruction index of a template which this context belongs to\r\n     * @param meta Meta information (id, meaning, description, etc) associated with this context\r\n     *\r\n     * @returns I18nContext instance\r\n     */\n\n  }, {\n    key: \"forkChildContext\",\n    value: function forkChildContext(index, templateIndex, meta) {\n      return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);\n    }\n    /**\r\n     * Reconciles child context into parent one once the end of the i18n block is reached (i18nEnd).\r\n     *\r\n     * @param context Child I18nContext instance to be reconciled with parent context.\r\n     */\n\n  }, {\n    key: \"reconcileChildContext\",\n    value: function reconcileChildContext(context) {\n      var _this169 = this;\n\n      // set the right context id for open and close\n      // template tags, so we can use it as sub-block ids\n      ['start', 'close'].forEach(function (op) {\n        var key = context.meta[\"\".concat(op, \"Name\")];\n        var phs = _this169.placeholders.get(key) || [];\n        var tag = phs.find(findTemplateFn(_this169.id, context.templateIndex));\n\n        if (tag) {\n          tag.ctx = context.id;\n        }\n      }); // reconcile placeholders\n\n      var childPhs = context.placeholders;\n      childPhs.forEach(function (values, key) {\n        var phs = _this169.placeholders.get(key);\n\n        if (!phs) {\n          _this169.placeholders.set(key, values);\n\n          return;\n        } // try to find matching template...\n\n\n        var tmplIdx = phs.findIndex(findTemplateFn(context.id, context.templateIndex));\n\n        if (tmplIdx >= 0) {\n          // ... if found - replace it with nested template content\n          var isCloseTag = key.startsWith('CLOSE');\n          var isTemplateTag = key.endsWith('NG-TEMPLATE');\n\n          if (isTemplateTag) {\n            // current template's content is placed before or after\n            // parent template tag, depending on the open/close atrribute\n            phs.splice.apply(phs, [tmplIdx + (isCloseTag ? 0 : 1), 0].concat(_toConsumableArray(values)));\n          } else {\n            var idx = isCloseTag ? values.length - 1 : 0;\n            values[idx].tmpl = phs[tmplIdx];\n            phs.splice.apply(phs, [tmplIdx, 1].concat(_toConsumableArray(values)));\n          }\n        } else {\n          // ... otherwise just append content to placeholder value\n          phs.push.apply(phs, _toConsumableArray(values));\n        }\n\n        _this169.placeholders.set(key, phs);\n      });\n      this._unresolvedCtxCount--;\n    }\n  }]);\n\n  return I18nContext;\n}(); //\n// Helper methods\n//\n\n\nfunction wrap(symbol, index, contextId, closed) {\n  var state = closed ? '/' : '';\n  return wrapI18nPlaceholder(\"\".concat(state).concat(symbol).concat(index), contextId);\n}\n\nfunction wrapTag(symbol, _ref15, closed) {\n  var index = _ref15.index,\n      ctx = _ref15.ctx,\n      isVoid = _ref15.isVoid;\n  return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) : wrap(symbol, index, ctx, closed);\n}\n\nfunction findTemplateFn(ctx, templateIndex) {\n  return function (token) {\n    return typeof token === 'object' && token.type === TagType.TEMPLATE && token.index === templateIndex && token.ctx === ctx;\n  };\n}\n\nfunction serializePlaceholderValue(value) {\n  var element = function element(data, closed) {\n    return wrapTag('#', data, closed);\n  };\n\n  var template = function template(data, closed) {\n    return wrapTag('*', data, closed);\n  };\n\n  var projection = function projection(data, closed) {\n    return wrapTag('!', data, closed);\n  };\n\n  switch (value.type) {\n    case TagType.ELEMENT:\n      // close element tag\n      if (value.closed) {\n        return element(value, true) + (value.tmpl ? template(value.tmpl, true) : '');\n      } // open element tag that also initiates a template\n\n\n      if (value.tmpl) {\n        return template(value.tmpl) + element(value) + (value.isVoid ? template(value.tmpl, true) : '');\n      }\n\n      return element(value);\n\n    case TagType.TEMPLATE:\n      return template(value, value.closed);\n\n    default:\n      return value;\n  }\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar IcuSerializerVisitor = /*#__PURE__*/function () {\n  function IcuSerializerVisitor() {\n    _classCallCheck(this, IcuSerializerVisitor);\n  }\n\n  _createClass(IcuSerializerVisitor, [{\n    key: \"visitText\",\n    value: function visitText(text) {\n      return text.value;\n    }\n  }, {\n    key: \"visitContainer\",\n    value: function visitContainer(container) {\n      var _this170 = this;\n\n      return container.children.map(function (child) {\n        return child.visit(_this170);\n      }).join('');\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu) {\n      var _this171 = this;\n\n      var strCases = Object.keys(icu.cases).map(function (k) {\n        return \"\".concat(k, \" {\").concat(icu.cases[k].visit(_this171), \"}\");\n      });\n      var result = \"{\".concat(icu.expressionPlaceholder, \", \").concat(icu.type, \", \").concat(strCases.join(' '), \"}\");\n      return result;\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph) {\n      var _this172 = this;\n\n      return ph.isVoid ? this.formatPh(ph.startName) : \"\".concat(this.formatPh(ph.startName)).concat(ph.children.map(function (child) {\n        return child.visit(_this172);\n      }).join('')).concat(this.formatPh(ph.closeName));\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph) {\n      return this.formatPh(ph.name);\n    }\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {\n      return this.formatPh(ph.name);\n    }\n  }, {\n    key: \"formatPh\",\n    value: function formatPh(value) {\n      return \"{\".concat(formatI18nPlaceholderName(value,\n      /* useCamelCase */\n      false), \"}\");\n    }\n  }]);\n\n  return IcuSerializerVisitor;\n}();\n\nvar serializer = new IcuSerializerVisitor();\n\nfunction serializeIcuNode(icu) {\n  return icu.visit(serializer);\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar TAG_TO_PLACEHOLDER_NAMES = {\n  'A': 'LINK',\n  'B': 'BOLD_TEXT',\n  'BR': 'LINE_BREAK',\n  'EM': 'EMPHASISED_TEXT',\n  'H1': 'HEADING_LEVEL1',\n  'H2': 'HEADING_LEVEL2',\n  'H3': 'HEADING_LEVEL3',\n  'H4': 'HEADING_LEVEL4',\n  'H5': 'HEADING_LEVEL5',\n  'H6': 'HEADING_LEVEL6',\n  'HR': 'HORIZONTAL_RULE',\n  'I': 'ITALIC_TEXT',\n  'LI': 'LIST_ITEM',\n  'LINK': 'MEDIA_LINK',\n  'OL': 'ORDERED_LIST',\n  'P': 'PARAGRAPH',\n  'Q': 'QUOTATION',\n  'S': 'STRIKETHROUGH_TEXT',\n  'SMALL': 'SMALL_TEXT',\n  'SUB': 'SUBSTRIPT',\n  'SUP': 'SUPERSCRIPT',\n  'TBODY': 'TABLE_BODY',\n  'TD': 'TABLE_CELL',\n  'TFOOT': 'TABLE_FOOTER',\n  'TH': 'TABLE_HEADER_CELL',\n  'THEAD': 'TABLE_HEADER',\n  'TR': 'TABLE_ROW',\n  'TT': 'MONOSPACED_TEXT',\n  'U': 'UNDERLINED_TEXT',\n  'UL': 'UNORDERED_LIST'\n};\n/**\r\n * Creates unique names for placeholder with different content.\r\n *\r\n * Returns the same placeholder name when the content is identical.\r\n */\n\nvar PlaceholderRegistry = /*#__PURE__*/function () {\n  function PlaceholderRegistry() {\n    _classCallCheck(this, PlaceholderRegistry);\n\n    // Count the occurrence of the base name top generate a unique name\n    this._placeHolderNameCounts = {}; // Maps signature to placeholder names\n\n    this._signatureToName = {};\n  }\n\n  _createClass(PlaceholderRegistry, [{\n    key: \"getStartTagPlaceholderName\",\n    value: function getStartTagPlaceholderName(tag, attrs, isVoid) {\n      var signature = this._hashTag(tag, attrs, isVoid);\n\n      if (this._signatureToName[signature]) {\n        return this._signatureToName[signature];\n      }\n\n      var upperTag = tag.toUpperCase();\n      var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || \"TAG_\".concat(upperTag);\n\n      var name = this._generateUniqueName(isVoid ? baseName : \"START_\".concat(baseName));\n\n      this._signatureToName[signature] = name;\n      return name;\n    }\n  }, {\n    key: \"getCloseTagPlaceholderName\",\n    value: function getCloseTagPlaceholderName(tag) {\n      var signature = this._hashClosingTag(tag);\n\n      if (this._signatureToName[signature]) {\n        return this._signatureToName[signature];\n      }\n\n      var upperTag = tag.toUpperCase();\n      var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || \"TAG_\".concat(upperTag);\n\n      var name = this._generateUniqueName(\"CLOSE_\".concat(baseName));\n\n      this._signatureToName[signature] = name;\n      return name;\n    }\n  }, {\n    key: \"getPlaceholderName\",\n    value: function getPlaceholderName(name, content) {\n      var upperName = name.toUpperCase();\n      var signature = \"PH: \".concat(upperName, \"=\").concat(content);\n\n      if (this._signatureToName[signature]) {\n        return this._signatureToName[signature];\n      }\n\n      var uniqueName = this._generateUniqueName(upperName);\n\n      this._signatureToName[signature] = uniqueName;\n      return uniqueName;\n    }\n  }, {\n    key: \"getUniquePlaceholder\",\n    value: function getUniquePlaceholder(name) {\n      return this._generateUniqueName(name.toUpperCase());\n    } // Generate a hash for a tag - does not take attribute order into account\n\n  }, {\n    key: \"_hashTag\",\n    value: function _hashTag(tag, attrs, isVoid) {\n      var start = \"<\".concat(tag);\n      var strAttrs = Object.keys(attrs).sort().map(function (name) {\n        return \" \".concat(name, \"=\").concat(attrs[name]);\n      }).join('');\n      var end = isVoid ? '/>' : \"></\".concat(tag, \">\");\n      return start + strAttrs + end;\n    }\n  }, {\n    key: \"_hashClosingTag\",\n    value: function _hashClosingTag(tag) {\n      return this._hashTag(\"/\".concat(tag), {}, false);\n    }\n  }, {\n    key: \"_generateUniqueName\",\n    value: function _generateUniqueName(base) {\n      var seen = this._placeHolderNameCounts.hasOwnProperty(base);\n\n      if (!seen) {\n        this._placeHolderNameCounts[base] = 1;\n        return base;\n      }\n\n      var id = this._placeHolderNameCounts[base];\n      this._placeHolderNameCounts[base] = id + 1;\n      return \"\".concat(base, \"_\").concat(id);\n    }\n  }]);\n\n  return PlaceholderRegistry;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar _expParser = new Parser$1(new Lexer());\n/**\r\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\r\n */\n\n\nfunction createI18nMessageFactory(interpolationConfig) {\n  var visitor = new _I18nVisitor(_expParser, interpolationConfig);\n  return function (nodes, meaning, description, customId, visitNodeFn) {\n    return visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n  };\n}\n\nfunction noopVisitNodeFn(_html, i18n) {\n  return i18n;\n}\n\nvar _I18nVisitor = /*#__PURE__*/function () {\n  function _I18nVisitor(_expressionParser, _interpolationConfig) {\n    _classCallCheck(this, _I18nVisitor);\n\n    this._expressionParser = _expressionParser;\n    this._interpolationConfig = _interpolationConfig;\n  }\n\n  _createClass(_I18nVisitor, [{\n    key: \"toI18nMessage\",\n    value: function toI18nMessage(nodes) {\n      var meaning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var description = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var customId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n      var visitNodeFn = arguments.length > 4 ? arguments[4] : undefined;\n      var context = {\n        isIcu: nodes.length == 1 && nodes[0] instanceof Expansion,\n        icuDepth: 0,\n        placeholderRegistry: new PlaceholderRegistry(),\n        placeholderToContent: {},\n        placeholderToMessage: {},\n        visitNodeFn: visitNodeFn || noopVisitNodeFn\n      };\n      var i18nodes = visitAll$1(this, nodes, context);\n      return new Message(i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description, customId);\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(el, context) {\n      var _a;\n\n      var children = visitAll$1(this, el.children, context);\n      var attrs = {};\n      el.attrs.forEach(function (attr) {\n        // Do not visit the attributes, translatable ones are top-level ASTs\n        attrs[attr.name] = attr.value;\n      });\n      var isVoid = getHtmlTagDefinition(el.name).isVoid;\n      var startPhName = context.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n      context.placeholderToContent[startPhName] = {\n        text: el.startSourceSpan.toString(),\n        sourceSpan: el.startSourceSpan\n      };\n      var closePhName = '';\n\n      if (!isVoid) {\n        closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(el.name);\n        context.placeholderToContent[closePhName] = {\n          text: \"</\".concat(el.name, \">\"),\n          sourceSpan: (_a = el.endSourceSpan) !== null && _a !== void 0 ? _a : el.sourceSpan\n        };\n      }\n\n      var node = new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n      return context.visitNodeFn(el, node);\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute, context) {\n      var node = this._visitTextWithInterpolation(attribute.value, attribute.valueSpan || attribute.sourceSpan, context, attribute.i18n);\n\n      return context.visitNodeFn(attribute, node);\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      var node = this._visitTextWithInterpolation(text.value, text.sourceSpan, context, text.i18n);\n\n      return context.visitNodeFn(text, node);\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment, context) {\n      return null;\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(icu, context) {\n      var _this173 = this;\n\n      context.icuDepth++;\n      var i18nIcuCases = {};\n      var i18nIcu = new Icu$1(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n      icu.cases.forEach(function (caze) {\n        i18nIcuCases[caze.value] = new Container(caze.expression.map(function (node) {\n          return node.visit(_this173, context);\n        }), caze.expSourceSpan);\n      });\n      context.icuDepth--;\n\n      if (context.isIcu || context.icuDepth > 0) {\n        // Returns an ICU node when:\n        // - the message (vs a part of the message) is an ICU message, or\n        // - the ICU message is nested.\n        var expPh = context.placeholderRegistry.getUniquePlaceholder(\"VAR_\".concat(icu.type));\n        i18nIcu.expressionPlaceholder = expPh;\n        context.placeholderToContent[expPh] = {\n          text: icu.switchValue,\n          sourceSpan: icu.switchValueSourceSpan\n        };\n        return context.visitNodeFn(icu, i18nIcu);\n      } // Else returns a placeholder\n      // ICU placeholders should not be replaced with their original content but with the their\n      // translations.\n      // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n\n\n      var phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n      context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);\n      var node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n      return context.visitNodeFn(icu, node);\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(_icuCase, _context) {\n      throw new Error('Unreachable code');\n    }\n    /**\r\n     * Split the, potentially interpolated, text up into text and placeholder pieces.\r\n     *\r\n     * @param text The potentially interpolated string to be split.\r\n     * @param sourceSpan The span of the whole of the `text` string.\r\n     * @param context The current context of the visitor, used to compute and store placeholders.\r\n     * @param previousI18n Any i18n metadata associated with this `text` from a previous pass.\r\n     */\n\n  }, {\n    key: \"_visitTextWithInterpolation\",\n    value: function _visitTextWithInterpolation(text, sourceSpan, context, previousI18n) {\n      var _this$_expressionPars = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig),\n          strings = _this$_expressionPars.strings,\n          expressions = _this$_expressionPars.expressions; // No expressions, return a single text.\n\n\n      if (expressions.length === 0) {\n        return new Text$1(text, sourceSpan);\n      } // Return a sequence of `Text` and `Placeholder` nodes grouped in a `Container`.\n\n\n      var nodes = [];\n\n      for (var i = 0; i < strings.length - 1; i++) {\n        this._addText(nodes, strings[i], sourceSpan);\n\n        this._addPlaceholder(nodes, context, expressions[i], sourceSpan);\n      } // The last index contains no expression\n\n\n      this._addText(nodes, strings[strings.length - 1], sourceSpan); // Whitespace removal may have invalidated the interpolation source-spans.\n\n\n      reusePreviousSourceSpans(nodes, previousI18n);\n      return new Container(nodes, sourceSpan);\n    }\n    /**\r\n     * Create a new `Text` node from the `textPiece` and add it to the `nodes` collection.\r\n     *\r\n     * @param nodes The nodes to which the created `Text` node should be added.\r\n     * @param textPiece The text and relative span information for this `Text` node.\r\n     * @param interpolationSpan The span of the whole interpolated text.\r\n     */\n\n  }, {\n    key: \"_addText\",\n    value: function _addText(nodes, textPiece, interpolationSpan) {\n      if (textPiece.text.length > 0) {\n        // No need to add empty strings\n        var stringSpan = getOffsetSourceSpan(interpolationSpan, textPiece);\n        nodes.push(new Text$1(textPiece.text, stringSpan));\n      }\n    }\n    /**\r\n     * Create a new `Placeholder` node from the `expression` and add it to the `nodes` collection.\r\n     *\r\n     * @param nodes The nodes to which the created `Text` node should be added.\r\n     * @param context The current context of the visitor, used to compute and store placeholders.\r\n     * @param expression The expression text and relative span information for this `Placeholder`\r\n     *     node.\r\n     * @param interpolationSpan The span of the whole interpolated text.\r\n     */\n\n  }, {\n    key: \"_addPlaceholder\",\n    value: function _addPlaceholder(nodes, context, expression, interpolationSpan) {\n      var sourceSpan = getOffsetSourceSpan(interpolationSpan, expression);\n      var baseName = extractPlaceholderName(expression.text) || 'INTERPOLATION';\n      var phName = context.placeholderRegistry.getPlaceholderName(baseName, expression.text);\n      var text = this._interpolationConfig.start + expression.text + this._interpolationConfig.end;\n      context.placeholderToContent[phName] = {\n        text: text,\n        sourceSpan: sourceSpan\n      };\n      nodes.push(new Placeholder(expression.text, phName, sourceSpan));\n    }\n  }]);\n\n  return _I18nVisitor;\n}();\n/**\r\n * Re-use the source-spans from `previousI18n` metadata for the `nodes`.\r\n *\r\n * Whitespace removal can invalidate the source-spans of interpolation nodes, so we\r\n * reuse the source-span stored from a previous pass before the whitespace was removed.\r\n *\r\n * @param nodes The `Text` and `Placeholder` nodes to be processed.\r\n * @param previousI18n Any i18n metadata for these `nodes` stored from a previous pass.\r\n */\n\n\nfunction reusePreviousSourceSpans(nodes, previousI18n) {\n  if (previousI18n instanceof Message) {\n    // The `previousI18n` is an i18n `Message`, so we are processing an `Attribute` with i18n\n    // metadata. The `Message` should consist only of a single `Container` that contains the\n    // parts (`Text` and `Placeholder`) to process.\n    assertSingleContainerMessage(previousI18n);\n    previousI18n = previousI18n.nodes[0];\n  }\n\n  if (previousI18n instanceof Container) {\n    // The `previousI18n` is a `Container`, which means that this is a second i18n extraction pass\n    // after whitespace has been removed from the AST ndoes.\n    assertEquivalentNodes(previousI18n.children, nodes); // Reuse the source-spans from the first pass.\n\n    for (var i = 0; i < nodes.length; i++) {\n      nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;\n    }\n  }\n}\n/**\r\n * Asserts that the `message` contains exactly one `Container` node.\r\n */\n\n\nfunction assertSingleContainerMessage(message) {\n  var nodes = message.nodes;\n\n  if (nodes.length !== 1 || !(nodes[0] instanceof Container)) {\n    throw new Error('Unexpected previous i18n message - expected it to consist of only a single `Container` node.');\n  }\n}\n/**\r\n * Asserts that the `previousNodes` and `node` collections have the same number of elements and\r\n * corresponding elements have the same node type.\r\n */\n\n\nfunction assertEquivalentNodes(previousNodes, nodes) {\n  if (previousNodes.length !== nodes.length) {\n    throw new Error('The number of i18n message children changed between first and second pass.');\n  }\n\n  if (previousNodes.some(function (node, i) {\n    return nodes[i].constructor !== node.constructor;\n  })) {\n    throw new Error('The types of the i18n message children changed between first and second pass.');\n  }\n}\n/**\r\n * Create a new `ParseSourceSpan` from the `sourceSpan`, offset by the `start` and `end` values.\r\n */\n\n\nfunction getOffsetSourceSpan(sourceSpan, _ref16) {\n  var start = _ref16.start,\n      end = _ref16.end;\n  return new ParseSourceSpan(sourceSpan.fullStart.moveBy(start), sourceSpan.fullStart.moveBy(end));\n}\n\nvar _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\n\nfunction extractPlaceholderName(input) {\n  return input.split(_CUSTOM_PH_EXP)[2];\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * An i18n error.\r\n */\n\n\nvar I18nError = /*#__PURE__*/function (_ParseError6) {\n  _inherits(I18nError, _ParseError6);\n\n  var _super99 = _createSuper(I18nError);\n\n  function I18nError(span, msg) {\n    _classCallCheck(this, I18nError);\n\n    return _super99.call(this, span, msg);\n  }\n\n  return I18nError;\n}(ParseError);\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar setI18nRefs = function setI18nRefs(htmlNode, i18nNode) {\n  if (htmlNode instanceof NodeWithI18n) {\n    if (i18nNode instanceof IcuPlaceholder && htmlNode.i18n instanceof Message) {\n      // This html node represents an ICU but this is a second processing pass, and the legacy id\n      // was computed in the previous pass and stored in the `i18n` property as a message.\n      // We are about to wipe out that property so capture the previous message to be reused when\n      // generating the message for this ICU later. See `_generateI18nMessage()`.\n      i18nNode.previousMessage = htmlNode.i18n;\n    }\n\n    htmlNode.i18n = i18nNode;\n  }\n\n  return i18nNode;\n};\n/**\r\n * This visitor walks over HTML parse tree and converts information stored in\r\n * i18n-related attributes (\"i18n\" and \"i18n-*\") into i18n meta object that is\r\n * stored with other element's and attribute's information.\r\n */\n\n\nvar I18nMetaVisitor = /*#__PURE__*/function () {\n  function I18nMetaVisitor() {\n    var interpolationConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_INTERPOLATION_CONFIG;\n    var keepI18nAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var enableI18nLegacyMessageIdFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    _classCallCheck(this, I18nMetaVisitor);\n\n    this.interpolationConfig = interpolationConfig;\n    this.keepI18nAttrs = keepI18nAttrs;\n    this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat; // whether visited nodes contain i18n information\n\n    this.hasI18nMeta = false;\n    this._errors = []; // i18n message generation factory\n\n    this._createI18nMessage = createI18nMessageFactory(this.interpolationConfig);\n  }\n\n  _createClass(I18nMetaVisitor, [{\n    key: \"_generateI18nMessage\",\n    value: function _generateI18nMessage(nodes) {\n      var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var visitNodeFn = arguments.length > 2 ? arguments[2] : undefined;\n\n      var _this$_parseMetadata = this._parseMetadata(meta),\n          meaning = _this$_parseMetadata.meaning,\n          description = _this$_parseMetadata.description,\n          customId = _this$_parseMetadata.customId;\n\n      var message = this._createI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n\n      this._setMessageId(message, meta);\n\n      this._setLegacyIds(message, meta);\n\n      return message;\n    }\n  }, {\n    key: \"visitAllWithErrors\",\n    value: function visitAllWithErrors(nodes) {\n      var _this174 = this;\n\n      var result = nodes.map(function (node) {\n        return node.visit(_this174, null);\n      });\n      return new ParseTreeResult(result, this._errors);\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(element) {\n      if (hasI18nAttrs(element)) {\n        this.hasI18nMeta = true;\n        var attrs = [];\n        var attrsMeta = {};\n\n        var _iterator15 = _createForOfIteratorHelper(element.attrs),\n            _step15;\n\n        try {\n          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n            var _attr = _step15.value;\n\n            if (_attr.name === I18N_ATTR) {\n              // root 'i18n' node attribute\n              var i18n = element.i18n || _attr.value;\n\n              var message = this._generateI18nMessage(element.children, i18n, setI18nRefs); // do not assign empty i18n meta\n\n\n              if (message.nodes.length) {\n                element.i18n = message;\n              }\n            } else if (_attr.name.startsWith(I18N_ATTR_PREFIX)) {\n              // 'i18n-*' attributes\n              var name = _attr.name.slice(I18N_ATTR_PREFIX.length);\n\n              if (isTrustedTypesSink(element.name, name)) {\n                this._reportError(_attr, \"Translating attribute '\".concat(name, \"' is disallowed for security reasons.\"));\n              } else {\n                attrsMeta[name] = _attr.value;\n              }\n            } else {\n              // non-i18n attributes\n              attrs.push(_attr);\n            }\n          } // set i18n meta for attributes\n\n        } catch (err) {\n          _iterator15.e(err);\n        } finally {\n          _iterator15.f();\n        }\n\n        if (Object.keys(attrsMeta).length) {\n          var _iterator16 = _createForOfIteratorHelper(attrs),\n              _step16;\n\n          try {\n            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n              var attr = _step16.value;\n              var meta = attrsMeta[attr.name]; // do not create translation for empty attributes\n\n              if (meta !== undefined && attr.value) {\n                attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);\n              }\n            }\n          } catch (err) {\n            _iterator16.e(err);\n          } finally {\n            _iterator16.f();\n          }\n        }\n\n        if (!this.keepI18nAttrs) {\n          // update element's attributes,\n          // keeping only non-i18n related ones\n          element.attrs = attrs;\n        }\n      }\n\n      visitAll$1(this, element.children, element.i18n);\n      return element;\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(expansion, currentMessage) {\n      var message;\n      var meta = expansion.i18n;\n      this.hasI18nMeta = true;\n\n      if (meta instanceof IcuPlaceholder) {\n        // set ICU placeholder name (e.g. \"ICU_1\"),\n        // generated while processing root element contents,\n        // so we can reference it when we output translation\n        var name = meta.name;\n        message = this._generateI18nMessage([expansion], meta);\n        var icu = icuFromI18nMessage(message);\n        icu.name = name;\n      } else {\n        // ICU is a top level message, try to use metadata from container element if provided via\n        // `context` argument. Note: context may not be available for standalone ICUs (without\n        // wrapping element), so fallback to ICU metadata in this case.\n        message = this._generateI18nMessage([expansion], currentMessage || meta);\n      }\n\n      expansion.i18n = message;\n      return expansion;\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {\n      return text;\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute) {\n      return attribute;\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment) {\n      return comment;\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(expansionCase) {\n      return expansionCase;\n    }\n    /**\r\n     * Parse the general form `meta` passed into extract the explicit metadata needed to create a\r\n     * `Message`.\r\n     *\r\n     * There are three possibilities for the `meta` variable\r\n     * 1) a string from an `i18n` template attribute: parse it to extract the metadata values.\r\n     * 2) a `Message` from a previous processing pass: reuse the metadata values in the message.\r\n     * 4) other: ignore this and just process the message metadata as normal\r\n     *\r\n     * @param meta the bucket that holds information about the message\r\n     * @returns the parsed metadata.\r\n     */\n\n  }, {\n    key: \"_parseMetadata\",\n    value: function _parseMetadata(meta) {\n      return typeof meta === 'string' ? parseI18nMeta(meta) : meta instanceof Message ? meta : {};\n    }\n    /**\r\n     * Generate (or restore) message id if not specified already.\r\n     */\n\n  }, {\n    key: \"_setMessageId\",\n    value: function _setMessageId(message, meta) {\n      if (!message.id) {\n        message.id = meta instanceof Message && meta.id || decimalDigest(message);\n      }\n    }\n    /**\r\n     * Update the `message` with a `legacyId` if necessary.\r\n     *\r\n     * @param message the message whose legacy id should be set\r\n     * @param meta information about the message being processed\r\n     */\n\n  }, {\n    key: \"_setLegacyIds\",\n    value: function _setLegacyIds(message, meta) {\n      if (this.enableI18nLegacyMessageIdFormat) {\n        message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];\n      } else if (typeof meta !== 'string') {\n        // This occurs if we are doing the 2nd pass after whitespace removal (see `parseTemplate()` in\n        // `packages/compiler/src/render3/view/template.ts`).\n        // In that case we want to reuse the legacy message generated in the 1st pass (see\n        // `setI18nRefs()`).\n        var previousMessage = meta instanceof Message ? meta : meta instanceof IcuPlaceholder ? meta.previousMessage : undefined;\n        message.legacyIds = previousMessage ? previousMessage.legacyIds : [];\n      }\n    }\n  }, {\n    key: \"_reportError\",\n    value: function _reportError(node, msg) {\n      this._errors.push(new I18nError(node.sourceSpan, msg));\n    }\n  }]);\n\n  return I18nMetaVisitor;\n}();\n/** I18n separators for metadata **/\n\n\nvar I18N_MEANING_SEPARATOR = '|';\nvar I18N_ID_SEPARATOR = '@@';\n/**\r\n * Parses i18n metas like:\r\n *  - \"@@id\",\r\n *  - \"description[@@id]\",\r\n *  - \"meaning|description[@@id]\"\r\n * and returns an object with parsed output.\r\n *\r\n * @param meta String that represents i18n meta\r\n * @returns Object with id, meaning and description fields\r\n */\n\nfunction parseI18nMeta() {\n  var meta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var customId;\n  var meaning;\n  var description;\n  meta = meta.trim();\n\n  if (meta) {\n    var idIndex = meta.indexOf(I18N_ID_SEPARATOR);\n    var descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);\n    var meaningAndDesc;\n\n    var _ref17 = idIndex > -1 ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];\n\n    var _ref18 = _slicedToArray(_ref17, 2);\n\n    meaningAndDesc = _ref18[0];\n    customId = _ref18[1];\n\n    var _ref19 = descIndex > -1 ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ['', meaningAndDesc];\n\n    var _ref20 = _slicedToArray(_ref19, 2);\n\n    meaning = _ref20[0];\n    description = _ref20[1];\n  }\n\n  return {\n    customId: customId,\n    meaning: meaning,\n    description: description\n  };\n} // Converts i18n meta information for a message (id, description, meaning)\n// to a JsDoc statement formatted as expected by the Closure compiler.\n\n\nfunction i18nMetaToJSDoc(meta) {\n  var tags = [];\n\n  if (meta.description) {\n    tags.push({\n      tagName: \"desc\"\n      /* Desc */\n      ,\n      text: meta.description\n    });\n  }\n\n  if (meta.meaning) {\n    tags.push({\n      tagName: \"meaning\"\n      /* Meaning */\n      ,\n      text: meta.meaning\n    });\n  }\n\n  return tags.length == 0 ? null : jsDocComment(tags);\n}\n/** Closure uses `goog.getMsg(message)` to lookup translations */\n\n\nvar GOOG_GET_MSG = 'goog.getMsg';\n\nfunction createGoogleGetMsgStatements(variable$1, message, closureVar, params) {\n  var messageString = serializeI18nMessageForGetMsg(message);\n  var args = [literal(messageString)];\n\n  if (Object.keys(params).length) {\n    args.push(mapLiteral(params, true));\n  } // /**\n  //  * @desc description of message\n  //  * @meaning meaning of message\n  //  */\n  // const MSG_... = goog.getMsg(..);\n  // I18N_X = MSG_...;\n\n\n  var googGetMsgStmt = closureVar.set(variable(GOOG_GET_MSG).callFn(args)).toConstDecl();\n  var metaComment = i18nMetaToJSDoc(message);\n\n  if (metaComment !== null) {\n    googGetMsgStmt.addLeadingComment(metaComment);\n  }\n\n  var i18nAssignmentStmt = new ExpressionStatement(variable$1.set(closureVar));\n  return [googGetMsgStmt, i18nAssignmentStmt];\n}\n/**\r\n * This visitor walks over i18n tree and generates its string representation, including ICUs and\r\n * placeholders in `{$placeholder}` (for plain messages) or `{PLACEHOLDER}` (inside ICUs) format.\r\n */\n\n\nvar GetMsgSerializerVisitor = /*#__PURE__*/function () {\n  function GetMsgSerializerVisitor() {\n    _classCallCheck(this, GetMsgSerializerVisitor);\n  }\n\n  _createClass(GetMsgSerializerVisitor, [{\n    key: \"formatPh\",\n    value: function formatPh(value) {\n      return \"{$\".concat(formatI18nPlaceholderName(value), \"}\");\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {\n      return text.value;\n    }\n  }, {\n    key: \"visitContainer\",\n    value: function visitContainer(container) {\n      var _this175 = this;\n\n      return container.children.map(function (child) {\n        return child.visit(_this175);\n      }).join('');\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu) {\n      return serializeIcuNode(icu);\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph) {\n      var _this176 = this;\n\n      return ph.isVoid ? this.formatPh(ph.startName) : \"\".concat(this.formatPh(ph.startName)).concat(ph.children.map(function (child) {\n        return child.visit(_this176);\n      }).join('')).concat(this.formatPh(ph.closeName));\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph) {\n      return this.formatPh(ph.name);\n    }\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {\n      return this.formatPh(ph.name);\n    }\n  }]);\n\n  return GetMsgSerializerVisitor;\n}();\n\nvar serializerVisitor$1 = new GetMsgSerializerVisitor();\n\nfunction serializeI18nMessageForGetMsg(message) {\n  return message.nodes.map(function (node) {\n    return node.visit(serializerVisitor$1, null);\n  }).join('');\n}\n\nfunction createLocalizeStatements(variable, message, params) {\n  var _serializeI18nMessage = serializeI18nMessageForLocalize(message),\n      messageParts = _serializeI18nMessage.messageParts,\n      placeHolders = _serializeI18nMessage.placeHolders;\n\n  var sourceSpan = getSourceSpan(message);\n  var expressions = placeHolders.map(function (ph) {\n    return params[ph.text];\n  });\n  var localizedString$1 = localizedString(message, messageParts, placeHolders, expressions, sourceSpan);\n  var variableInitialization = variable.set(localizedString$1);\n  return [new ExpressionStatement(variableInitialization)];\n}\n/**\r\n * This visitor walks over an i18n tree, capturing literal strings and placeholders.\r\n *\r\n * The result can be used for generating the `$localize` tagged template literals.\r\n */\n\n\nvar LocalizeSerializerVisitor = /*#__PURE__*/function () {\n  function LocalizeSerializerVisitor() {\n    _classCallCheck(this, LocalizeSerializerVisitor);\n  }\n\n  _createClass(LocalizeSerializerVisitor, [{\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      if (context[context.length - 1] instanceof LiteralPiece) {\n        // Two literal pieces in a row means that there was some comment node in-between.\n        context[context.length - 1].text += text.value;\n      } else {\n        context.push(new LiteralPiece(text.value, text.sourceSpan));\n      }\n    }\n  }, {\n    key: \"visitContainer\",\n    value: function visitContainer(container, context) {\n      var _this177 = this;\n\n      container.children.forEach(function (child) {\n        return child.visit(_this177, context);\n      });\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu, context) {\n      context.push(new LiteralPiece(serializeIcuNode(icu), icu.sourceSpan));\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph, context) {\n      var _this178 = this;\n\n      var _a, _b;\n\n      context.push(this.createPlaceholderPiece(ph.startName, (_a = ph.startSourceSpan) !== null && _a !== void 0 ? _a : ph.sourceSpan));\n\n      if (!ph.isVoid) {\n        ph.children.forEach(function (child) {\n          return child.visit(_this178, context);\n        });\n        context.push(this.createPlaceholderPiece(ph.closeName, (_b = ph.endSourceSpan) !== null && _b !== void 0 ? _b : ph.sourceSpan));\n      }\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph, context) {\n      context.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));\n    }\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {\n      context.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));\n    }\n  }, {\n    key: \"createPlaceholderPiece\",\n    value: function createPlaceholderPiece(name, sourceSpan) {\n      return new PlaceholderPiece(formatI18nPlaceholderName(name,\n      /* useCamelCase */\n      false), sourceSpan);\n    }\n  }]);\n\n  return LocalizeSerializerVisitor;\n}();\n\nvar serializerVisitor$2 = new LocalizeSerializerVisitor();\n/**\r\n * Serialize an i18n message into two arrays: messageParts and placeholders.\r\n *\r\n * These arrays will be used to generate `$localize` tagged template literals.\r\n *\r\n * @param message The message to be serialized.\r\n * @returns an object containing the messageParts and placeholders.\r\n */\n\nfunction serializeI18nMessageForLocalize(message) {\n  var pieces = [];\n  message.nodes.forEach(function (node) {\n    return node.visit(serializerVisitor$2, pieces);\n  });\n  return processMessagePieces(pieces);\n}\n\nfunction getSourceSpan(message) {\n  var startNode = message.nodes[0];\n  var endNode = message.nodes[message.nodes.length - 1];\n  return new ParseSourceSpan(startNode.sourceSpan.start, endNode.sourceSpan.end, startNode.sourceSpan.fullStart, startNode.sourceSpan.details);\n}\n/**\r\n * Convert the list of serialized MessagePieces into two arrays.\r\n *\r\n * One contains the literal string pieces and the other the placeholders that will be replaced by\r\n * expressions when rendering `$localize` tagged template literals.\r\n *\r\n * @param pieces The pieces to process.\r\n * @returns an object containing the messageParts and placeholders.\r\n */\n\n\nfunction processMessagePieces(pieces) {\n  var messageParts = [];\n  var placeHolders = [];\n\n  if (pieces[0] instanceof PlaceholderPiece) {\n    // The first piece was a placeholder so we need to add an initial empty message part.\n    messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));\n  }\n\n  for (var i = 0; i < pieces.length; i++) {\n    var part = pieces[i];\n\n    if (part instanceof LiteralPiece) {\n      messageParts.push(part);\n    } else {\n      placeHolders.push(part);\n\n      if (pieces[i - 1] instanceof PlaceholderPiece) {\n        // There were two placeholders in a row, so we need to add an empty message part.\n        messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));\n      }\n    }\n  }\n\n  if (pieces[pieces.length - 1] instanceof PlaceholderPiece) {\n    // The last piece was a placeholder so we need to add a final empty message part.\n    messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));\n  }\n\n  return {\n    messageParts: messageParts,\n    placeHolders: placeHolders\n  };\n}\n\nfunction createEmptyMessagePart(location) {\n  return new LiteralPiece('', new ParseSourceSpan(location, location));\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n// Selector attribute name of `<ng-content>`\n\n\nvar NG_CONTENT_SELECT_ATTR$1 = 'select'; // Attribute name of `ngProjectAs`.\n\nvar NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs'; // Global symbols available only inside event bindings.\n\nvar EVENT_BINDING_SCOPE_GLOBALS = new Set(['$event']); // List of supported global targets for event listeners\n\nvar GLOBAL_TARGET_RESOLVERS = new Map([['window', Identifiers.resolveWindow], ['document', Identifiers.resolveDocument], ['body', Identifiers.resolveBody]]);\nvar LEADING_TRIVIA_CHARS = [' ', '\\n', '\\r', '\\t']; //  if (rf & flags) { .. }\n\nfunction renderFlagCheckIfStmt(flags, statements) {\n  return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null, false), statements);\n}\n\nfunction prepareEventListenerParameters(eventAst) {\n  var handlerName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var type = eventAst.type,\n      name = eventAst.name,\n      target = eventAst.target,\n      phase = eventAst.phase,\n      handler = eventAst.handler;\n\n  if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {\n    throw new Error(\"Unexpected global target '\".concat(target, \"' defined for '\").concat(name, \"' event.\\n        Supported list of global targets: \").concat(Array.from(GLOBAL_TARGET_RESOLVERS.keys()), \".\"));\n  }\n\n  var eventArgumentName = '$event';\n  var implicitReceiverAccesses = new Set();\n  var implicitReceiverExpr = scope === null || scope.bindingLevel === 0 ? variable(CONTEXT_NAME) : scope.getOrCreateSharedContextVar(0);\n  var bindingExpr = convertActionBinding(scope, implicitReceiverExpr, handler, 'b', function () {\n    return error('Unexpected interpolation');\n  }, eventAst.handlerSpan, implicitReceiverAccesses, EVENT_BINDING_SCOPE_GLOBALS);\n  var statements = [];\n\n  if (scope) {\n    // `variableDeclarations` needs to run first, because\n    // `restoreViewStatement` depends on the result.\n    statements.push.apply(statements, _toConsumableArray(scope.variableDeclarations()));\n    statements.unshift.apply(statements, _toConsumableArray(scope.restoreViewStatement()));\n  }\n\n  statements.push.apply(statements, _toConsumableArray(bindingExpr.render3Stmts));\n  var eventName = type === 1\n  /* Animation */\n  ? prepareSyntheticListenerName(name, phase) : name;\n  var fnName = handlerName && sanitizeIdentifier(handlerName);\n  var fnArgs = [];\n\n  if (implicitReceiverAccesses.has(eventArgumentName)) {\n    fnArgs.push(new FnParam(eventArgumentName, DYNAMIC_TYPE));\n  }\n\n  var handlerFn = fn(fnArgs, statements, INFERRED_TYPE, null, fnName);\n  var params = [literal(eventName), handlerFn];\n\n  if (target) {\n    params.push(literal(false), // `useCapture` flag, defaults to `false`\n    importExpr(GLOBAL_TARGET_RESOLVERS.get(target)));\n  }\n\n  return params;\n}\n\nfunction createComponentDefConsts() {\n  return {\n    prepareStatements: [],\n    constExpressions: [],\n    i18nVarRefsCache: new Map()\n  };\n}\n\nvar TemplateDefinitionBuilder = /*#__PURE__*/function () {\n  function TemplateDefinitionBuilder(constantPool, parentBindingScope) {\n    var _this179 = this;\n\n    var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var contextName = arguments.length > 3 ? arguments[3] : undefined;\n    var i18nContext = arguments.length > 4 ? arguments[4] : undefined;\n    var templateIndex = arguments.length > 5 ? arguments[5] : undefined;\n    var templateName = arguments.length > 6 ? arguments[6] : undefined;\n    var directiveMatcher = arguments.length > 7 ? arguments[7] : undefined;\n    var directives = arguments.length > 8 ? arguments[8] : undefined;\n    var pipeTypeByName = arguments.length > 9 ? arguments[9] : undefined;\n    var pipes = arguments.length > 10 ? arguments[10] : undefined;\n\n    var _namespace = arguments.length > 11 ? arguments[11] : undefined;\n\n    var relativeContextFilePath = arguments.length > 12 ? arguments[12] : undefined;\n    var i18nUseExternalIds = arguments.length > 13 ? arguments[13] : undefined;\n\n    var _constants = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : createComponentDefConsts();\n\n    _classCallCheck(this, TemplateDefinitionBuilder);\n\n    this.constantPool = constantPool;\n    this.level = level;\n    this.contextName = contextName;\n    this.i18nContext = i18nContext;\n    this.templateIndex = templateIndex;\n    this.templateName = templateName;\n    this.directiveMatcher = directiveMatcher;\n    this.directives = directives;\n    this.pipeTypeByName = pipeTypeByName;\n    this.pipes = pipes;\n    this._namespace = _namespace;\n    this.i18nUseExternalIds = i18nUseExternalIds;\n    this._constants = _constants;\n    this._dataIndex = 0;\n    this._bindingContext = 0;\n    this._prefixCode = [];\n    /**\r\n     * List of callbacks to generate creation mode instructions. We store them here as we process\r\n     * the template so bindings in listeners are resolved only once all nodes have been visited.\r\n     * This ensures all local refs and context variables are available for matching.\r\n     */\n\n    this._creationCodeFns = [];\n    /**\r\n     * List of callbacks to generate update mode instructions. We store them here as we process\r\n     * the template so bindings are resolved only once all nodes have been visited. This ensures\r\n     * all local refs and context variables are available for matching.\r\n     */\n\n    this._updateCodeFns = [];\n    /** Index of the currently-selected node. */\n\n    this._currentIndex = 0;\n    /** Temporary variable declarations generated from visiting pipes, literals, etc. */\n\n    this._tempVariables = [];\n    /**\r\n     * List of callbacks to build nested templates. Nested templates must not be visited until\r\n     * after the parent template has finished visiting all of its nodes. This ensures that all\r\n     * local ref bindings in nested templates are able to find local ref values if the refs\r\n     * are defined after the template declaration.\r\n     */\n\n    this._nestedTemplateFns = [];\n    this._unsupported = unsupported; // i18n context local to this template\n\n    this.i18n = null; // Number of slots to reserve for pureFunctions\n\n    this._pureFunctionSlots = 0; // Number of binding slots\n\n    this._bindingSlots = 0; // Projection slots found in the template. Projection slots can distribute projected\n    // nodes based on a selector, or can just use the wildcard selector to match\n    // all nodes which aren't matching any selector.\n\n    this._ngContentReservedSlots = []; // Number of non-default selectors found in all parent templates of this template. We need to\n    // track it to properly adjust projection slot index in the `projection` instruction.\n\n    this._ngContentSelectorsOffset = 0; // Expression that should be used as implicit receiver when converting template\n    // expressions to output AST.\n\n    this._implicitReceiverExpr = null; // These should be handled in the template or element directly.\n\n    this.visitReference = invalid$1;\n    this.visitVariable = invalid$1;\n    this.visitTextAttribute = invalid$1;\n    this.visitBoundAttribute = invalid$1;\n    this.visitBoundEvent = invalid$1;\n    this._bindingScope = parentBindingScope.nestedScope(level); // Turn the relative context file path into an identifier by replacing non-alphanumeric\n    // characters with underscores.\n\n    this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';\n    this._valueConverter = new ValueConverter(constantPool, function () {\n      return _this179.allocateDataSlot();\n    }, function (numSlots) {\n      return _this179.allocatePureFunctionSlots(numSlots);\n    }, function (name, localName, slot, value) {\n      var pipeType = pipeTypeByName.get(name);\n\n      if (pipeType) {\n        _this179.pipes.add(pipeType);\n      }\n\n      _this179._bindingScope.set(_this179.level, localName, value);\n\n      _this179.creationInstruction(null, Identifiers.pipe, [literal(slot), literal(name)]);\n    });\n  }\n\n  _createClass(TemplateDefinitionBuilder, [{\n    key: \"buildTemplateFunction\",\n    value: function buildTemplateFunction(nodes, variables) {\n      var _this180 = this;\n\n      var ngContentSelectorsOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var i18n = arguments.length > 3 ? arguments[3] : undefined;\n      this._ngContentSelectorsOffset = ngContentSelectorsOffset;\n\n      if (this._namespace !== Identifiers.namespaceHTML) {\n        this.creationInstruction(null, this._namespace);\n      } // Create variable bindings\n\n\n      variables.forEach(function (v) {\n        return _this180.registerContextVariables(v);\n      }); // Initiate i18n context in case:\n      // - this template has parent i18n context\n      // - or the template has i18n meta associated with it,\n      //   but it's not initiated by the Element (e.g. <ng-template i18n>)\n\n      var initI18nContext = this.i18nContext || isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) && !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n);\n      var selfClosingI18nInstruction = hasTextChildrenOnly(nodes);\n\n      if (initI18nContext) {\n        this.i18nStart(null, i18n, selfClosingI18nInstruction);\n      } // This is the initial pass through the nodes of this template. In this pass, we\n      // queue all creation mode and update mode instructions for generation in the second\n      // pass. It's necessary to separate the passes to ensure local refs are defined before\n      // resolving bindings. We also count bindings in this pass as we walk bound expressions.\n\n\n      visitAll(this, nodes); // Add total binding count to pure function count so pure function instructions are\n      // generated with the correct slot offset when update instructions are processed.\n\n      this._pureFunctionSlots += this._bindingSlots; // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and\n      // `pipeBind` update instructions), so we have to update the slot offsets manually\n      // to account for bindings.\n\n      this._valueConverter.updatePipeSlotOffsets(this._bindingSlots); // Nested templates must be processed before creation instructions so template()\n      // instructions can be generated with the correct internal const count.\n\n\n      this._nestedTemplateFns.forEach(function (buildTemplateFn) {\n        return buildTemplateFn();\n      }); // Output the `projectionDef` instruction when some `<ng-content>` tags are present.\n      // The `projectionDef` instruction is only emitted for the component template and\n      // is skipped for nested templates (<ng-template> tags).\n\n\n      if (this.level === 0 && this._ngContentReservedSlots.length) {\n        var parameters = []; // By default the `projectionDef` instructions creates one slot for the wildcard\n        // selector if no parameters are passed. Therefore we only want to allocate a new\n        // array for the projection slots if the default projection slot is not sufficient.\n\n        if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== '*') {\n          var r3ReservedSlots = this._ngContentReservedSlots.map(function (s) {\n            return s !== '*' ? parseSelectorToR3Selector(s) : s;\n          });\n\n          parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));\n        } // Since we accumulate ngContent selectors while processing template elements,\n        // we *prepend* `projectionDef` to creation instructions block, to put it before\n        // any `projection` instructions\n\n\n        this.creationInstruction(null, Identifiers.projectionDef, parameters,\n        /* prepend */\n        true);\n      }\n\n      if (initI18nContext) {\n        this.i18nEnd(null, selfClosingI18nInstruction);\n      } // Generate all the creation mode instructions (e.g. resolve bindings in listeners)\n\n\n      var creationStatements = this._creationCodeFns.map(function (fn) {\n        return fn();\n      }); // Generate all the update mode instructions (e.g. resolve property or text bindings)\n\n\n      var updateStatements = this._updateCodeFns.map(function (fn) {\n        return fn();\n      }); //  Variable declaration must occur after binding resolution so we can generate context\n      //  instructions that build on each other.\n      // e.g. const b = nextContext().$implicit(); const b = nextContext();\n\n\n      var creationVariables = this._bindingScope.viewSnapshotStatements();\n\n      var updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);\n\n      var creationBlock = creationStatements.length > 0 ? [renderFlagCheckIfStmt(1\n      /* Create */\n      , creationVariables.concat(creationStatements))] : [];\n      var updateBlock = updateStatements.length > 0 ? [renderFlagCheckIfStmt(2\n      /* Update */\n      , updateVariables.concat(updateStatements))] : [];\n      return fn( // i.e. (rf: RenderFlags, ctx: any)\n      [new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [].concat(_toConsumableArray(this._prefixCode), creationBlock, updateBlock), INFERRED_TYPE, null, this.templateName);\n    } // LocalResolver\n\n  }, {\n    key: \"getLocal\",\n    value: function getLocal(name) {\n      return this._bindingScope.get(name);\n    } // LocalResolver\n\n  }, {\n    key: \"notifyImplicitReceiverUse\",\n    value: function notifyImplicitReceiverUse() {\n      this._bindingScope.notifyImplicitReceiverUse();\n    } // LocalResolver\n\n  }, {\n    key: \"maybeRestoreView\",\n    value: function maybeRestoreView(retrievalLevel, localRefLookup) {\n      this._bindingScope.maybeRestoreView(retrievalLevel, localRefLookup);\n    }\n  }, {\n    key: \"i18nTranslate\",\n    value: function i18nTranslate(message) {\n      var _this$_constants$prep;\n\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var ref = arguments.length > 2 ? arguments[2] : undefined;\n      var transformFn = arguments.length > 3 ? arguments[3] : undefined;\n\n      var _ref = ref || this.i18nGenerateMainBlockVar(); // Closure Compiler requires const names to start with `MSG_` but disallows any other const to\n      // start with `MSG_`. We define a variable starting with `MSG_` just for the `goog.getMsg` call\n\n\n      var closureVar = this.i18nGenerateClosureVar(message.id);\n      var statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);\n\n      (_this$_constants$prep = this._constants.prepareStatements).push.apply(_this$_constants$prep, _toConsumableArray(statements));\n\n      return _ref;\n    }\n  }, {\n    key: \"registerContextVariables\",\n    value: function registerContextVariables(variable$1) {\n      var scopedName = this._bindingScope.freshReferenceName();\n\n      var retrievalLevel = this.level;\n      var lhs = variable(variable$1.name + scopedName);\n\n      this._bindingScope.set(retrievalLevel, variable$1.name, lhs, 1\n      /* CONTEXT */\n      , function (scope, relativeLevel) {\n        var rhs;\n\n        if (scope.bindingLevel === retrievalLevel) {\n          if (scope.isListenerScope() && scope.hasRestoreViewVariable()) {\n            // e.g. restoredCtx.\n            // We have to get the context from a view reference, if one is available, because\n            // the context that was passed in during creation may not be correct anymore.\n            // For more information see: https://github.com/angular/angular/pull/40360.\n            rhs = variable(RESTORED_VIEW_CONTEXT_NAME);\n            scope.notifyRestoredViewContextUse();\n          } else {\n            // e.g. ctx\n            rhs = variable(CONTEXT_NAME);\n          }\n        } else {\n          var sharedCtxVar = scope.getSharedContextName(retrievalLevel); // e.g. ctx_r0   OR  x(2);\n\n          rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);\n        } // e.g. const $item$ = x(2).$implicit;\n\n\n        return [lhs.set(rhs.prop(variable$1.value || IMPLICIT_REFERENCE)).toConstDecl()];\n      });\n    }\n  }, {\n    key: \"i18nAppendBindings\",\n    value: function i18nAppendBindings(expressions) {\n      var _this181 = this;\n\n      if (expressions.length > 0) {\n        expressions.forEach(function (expression) {\n          return _this181.i18n.appendBinding(expression);\n        });\n      }\n    }\n  }, {\n    key: \"i18nBindProps\",\n    value: function i18nBindProps(props) {\n      var _this182 = this;\n\n      var bound = {};\n      Object.keys(props).forEach(function (key) {\n        var prop = props[key];\n\n        if (prop instanceof Text) {\n          bound[key] = literal(prop.value);\n        } else {\n          var value = prop.value.visit(_this182._valueConverter);\n\n          _this182.allocateBindingSlots(value);\n\n          if (value instanceof Interpolation) {\n            var strings = value.strings,\n                expressions = value.expressions;\n            var _this182$i18n = _this182.i18n,\n                id = _this182$i18n.id,\n                bindings = _this182$i18n.bindings;\n            var label = assembleI18nBoundString(strings, bindings.size, id);\n\n            _this182.i18nAppendBindings(expressions);\n\n            bound[key] = literal(label);\n          }\n        }\n      });\n      return bound;\n    } // Generates top level vars for i18n blocks (i.e. `i18n_N`).\n\n  }, {\n    key: \"i18nGenerateMainBlockVar\",\n    value: function i18nGenerateMainBlockVar() {\n      return variable(this.constantPool.uniqueName(TRANSLATION_VAR_PREFIX));\n    } // Generates vars with Closure-specific names for i18n blocks (i.e. `MSG_XXX`).\n\n  }, {\n    key: \"i18nGenerateClosureVar\",\n    value: function i18nGenerateClosureVar(messageId) {\n      var name;\n      var suffix = this.fileBasedI18nSuffix.toUpperCase();\n\n      if (this.i18nUseExternalIds) {\n        var prefix = getTranslationConstPrefix(\"EXTERNAL_\");\n        var uniqueSuffix = this.constantPool.uniqueName(suffix);\n        name = \"\".concat(prefix).concat(sanitizeIdentifier(messageId), \"$$\").concat(uniqueSuffix);\n      } else {\n        var _prefix = getTranslationConstPrefix(suffix);\n\n        name = this.constantPool.uniqueName(_prefix);\n      }\n\n      return variable(name);\n    }\n  }, {\n    key: \"i18nUpdateRef\",\n    value: function i18nUpdateRef(context) {\n      var icus = context.icus,\n          meta = context.meta,\n          isRoot = context.isRoot,\n          isResolved = context.isResolved,\n          isEmitted = context.isEmitted;\n\n      if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {\n        context.isEmitted = true;\n        var placeholders = context.getSerializedPlaceholders();\n        var icuMapping = {};\n        var params = placeholders.size ? placeholdersToParams(placeholders) : {};\n\n        if (icus.size) {\n          icus.forEach(function (refs, key) {\n            if (refs.length === 1) {\n              // if we have one ICU defined for a given\n              // placeholder - just output its reference\n              params[key] = refs[0];\n            } else {\n              // ... otherwise we need to activate post-processing\n              // to replace ICU placeholders with proper values\n              var placeholder = wrapI18nPlaceholder(\"\".concat(I18N_ICU_MAPPING_PREFIX).concat(key));\n              params[key] = literal(placeholder);\n              icuMapping[key] = literalArr(refs);\n            }\n          });\n        } // translation requires post processing in 2 cases:\n        // - if we have placeholders with multiple values (ex. `START_DIV`: [�#1�, �#2�, ...])\n        // - if we have multiple ICUs that refer to the same placeholder name\n\n\n        var needsPostprocessing = Array.from(placeholders.values()).some(function (value) {\n          return value.length > 1;\n        }) || Object.keys(icuMapping).length;\n        var transformFn;\n\n        if (needsPostprocessing) {\n          transformFn = function transformFn(raw) {\n            var args = [raw];\n\n            if (Object.keys(icuMapping).length) {\n              args.push(mapLiteral(icuMapping, true));\n            }\n\n            return instruction(null, Identifiers.i18nPostprocess, args);\n          };\n        }\n\n        this.i18nTranslate(meta, params, context.ref, transformFn);\n      }\n    }\n  }, {\n    key: \"i18nStart\",\n    value: function i18nStart() {\n      var span = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var meta = arguments.length > 1 ? arguments[1] : undefined;\n      var selfClosing = arguments.length > 2 ? arguments[2] : undefined;\n      var index = this.allocateDataSlot();\n      this.i18n = this.i18nContext ? this.i18nContext.forkChildContext(index, this.templateIndex, meta) : new I18nContext(index, this.i18nGenerateMainBlockVar(), 0, this.templateIndex, meta); // generate i18nStart instruction\n\n      var _this$i18n = this.i18n,\n          id = _this$i18n.id,\n          ref = _this$i18n.ref;\n      var params = [literal(index), this.addToConsts(ref)];\n\n      if (id > 0) {\n        // do not push 3rd argument (sub-block id)\n        // into i18nStart call for top level i18n context\n        params.push(literal(id));\n      }\n\n      this.creationInstruction(span, selfClosing ? Identifiers.i18n : Identifiers.i18nStart, params);\n    }\n  }, {\n    key: \"i18nEnd\",\n    value: function i18nEnd() {\n      var _this183 = this;\n\n      var span = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var selfClosing = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (!this.i18n) {\n        throw new Error('i18nEnd is executed with no i18n context present');\n      }\n\n      if (this.i18nContext) {\n        this.i18nContext.reconcileChildContext(this.i18n);\n        this.i18nUpdateRef(this.i18nContext);\n      } else {\n        this.i18nUpdateRef(this.i18n);\n      } // setup accumulated bindings\n\n\n      var _this$i18n2 = this.i18n,\n          index = _this$i18n2.index,\n          bindings = _this$i18n2.bindings;\n\n      if (bindings.size) {\n        var chainBindings = [];\n        bindings.forEach(function (binding) {\n          chainBindings.push({\n            sourceSpan: span,\n            value: function value() {\n              return _this183.convertPropertyBinding(binding);\n            }\n          });\n        }); // for i18n block, advance to the most recent element index (by taking the current number of\n        // elements and subtracting one) before invoking `i18nExp` instructions, to make sure the\n        // necessary lifecycle hooks of components/directives are properly flushed.\n\n        this.updateInstructionChainWithAdvance(this.getConstCount() - 1, Identifiers.i18nExp, chainBindings);\n        this.updateInstruction(span, Identifiers.i18nApply, [literal(index)]);\n      }\n\n      if (!selfClosing) {\n        this.creationInstruction(span, Identifiers.i18nEnd);\n      }\n\n      this.i18n = null; // reset local i18n context\n    }\n  }, {\n    key: \"i18nAttributesInstruction\",\n    value: function i18nAttributesInstruction(nodeIndex, attrs, sourceSpan) {\n      var _this184 = this;\n\n      var hasBindings = false;\n      var i18nAttrArgs = [];\n      var bindings = [];\n      attrs.forEach(function (attr) {\n        var message = attr.i18n;\n        var converted = attr.value.visit(_this184._valueConverter);\n\n        _this184.allocateBindingSlots(converted);\n\n        if (converted instanceof Interpolation) {\n          var placeholders = assembleBoundTextPlaceholders(message);\n          var params = placeholdersToParams(placeholders);\n          i18nAttrArgs.push(literal(attr.name), _this184.i18nTranslate(message, params));\n          converted.expressions.forEach(function (expression) {\n            hasBindings = true;\n            bindings.push({\n              sourceSpan: sourceSpan,\n              value: function value() {\n                return _this184.convertPropertyBinding(expression);\n              }\n            });\n          });\n        }\n      });\n\n      if (bindings.length > 0) {\n        this.updateInstructionChainWithAdvance(nodeIndex, Identifiers.i18nExp, bindings);\n      }\n\n      if (i18nAttrArgs.length > 0) {\n        var index = literal(this.allocateDataSlot());\n        var constIndex = this.addToConsts(literalArr(i18nAttrArgs));\n        this.creationInstruction(sourceSpan, Identifiers.i18nAttributes, [index, constIndex]);\n\n        if (hasBindings) {\n          this.updateInstruction(sourceSpan, Identifiers.i18nApply, [index]);\n        }\n      }\n    }\n  }, {\n    key: \"getNamespaceInstruction\",\n    value: function getNamespaceInstruction(namespaceKey) {\n      switch (namespaceKey) {\n        case 'math':\n          return Identifiers.namespaceMathML;\n\n        case 'svg':\n          return Identifiers.namespaceSVG;\n\n        default:\n          return Identifiers.namespaceHTML;\n      }\n    }\n  }, {\n    key: \"addNamespaceInstruction\",\n    value: function addNamespaceInstruction(nsInstruction, element) {\n      this._namespace = nsInstruction;\n      this.creationInstruction(element.startSourceSpan, nsInstruction);\n    }\n    /**\r\n     * Adds an update instruction for an interpolated property or attribute, such as\r\n     * `prop=\"{{value}}\"` or `attr.title=\"{{value}}\"`\r\n     */\n\n  }, {\n    key: \"interpolatedUpdateInstruction\",\n    value: function interpolatedUpdateInstruction(instruction, elementIndex, attrName, input, value, params) {\n      var _this185 = this;\n\n      this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, instruction, function () {\n        return [literal(attrName)].concat(_toConsumableArray(_this185.getUpdateInstructionArguments(value)), _toConsumableArray(params));\n      });\n    }\n  }, {\n    key: \"visitContent\",\n    value: function visitContent(ngContent) {\n      var slot = this.allocateDataSlot();\n      var projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;\n      var parameters = [literal(slot)];\n\n      this._ngContentReservedSlots.push(ngContent.selector);\n\n      var nonContentSelectAttributes = ngContent.attributes.filter(function (attr) {\n        return attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR$1;\n      });\n      var attributes = this.getAttributeExpressions(ngContent.name, nonContentSelectAttributes, [], []);\n\n      if (attributes.length > 0) {\n        parameters.push(literal(projectionSlotIdx), literalArr(attributes));\n      } else if (projectionSlotIdx !== 0) {\n        parameters.push(literal(projectionSlotIdx));\n      }\n\n      this.creationInstruction(ngContent.sourceSpan, Identifiers.projection, parameters);\n\n      if (this.i18n) {\n        this.i18n.appendProjection(ngContent.i18n, slot);\n      }\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(element) {\n      var _this186 = this;\n\n      var _a, _b;\n\n      var elementIndex = this.allocateDataSlot();\n      var stylingBuilder = new StylingBuilder(null);\n      var isNonBindableMode = false;\n      var isI18nRootElement = isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);\n      var outputAttrs = [];\n\n      var _splitNsName = splitNsName(element.name),\n          _splitNsName2 = _slicedToArray(_splitNsName, 2),\n          namespaceKey = _splitNsName2[0],\n          elementName = _splitNsName2[1];\n\n      var isNgContainer$1 = isNgContainer(element.name); // Handle styling, i18n, ngNonBindable attributes\n\n      var _iterator17 = _createForOfIteratorHelper(element.attributes),\n          _step17;\n\n      try {\n        for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {\n          var attr = _step17.value;\n          var name = attr.name,\n              value = attr.value;\n\n          if (name === NON_BINDABLE_ATTR) {\n            isNonBindableMode = true;\n          } else if (name === 'style') {\n            stylingBuilder.registerStyleAttr(value);\n          } else if (name === 'class') {\n            stylingBuilder.registerClassAttr(value);\n          } else {\n            outputAttrs.push(attr);\n          }\n        } // Match directives on non i18n attributes\n\n      } catch (err) {\n        _iterator17.e(err);\n      } finally {\n        _iterator17.f();\n      }\n\n      this.matchDirectives(element.name, element); // Regular element or ng-container creation mode\n\n      var parameters = [literal(elementIndex)];\n\n      if (!isNgContainer$1) {\n        parameters.push(literal(elementName));\n      } // Add the attributes\n\n\n      var allOtherInputs = [];\n      var boundI18nAttrs = [];\n      element.inputs.forEach(function (input) {\n        var stylingInputWasSet = stylingBuilder.registerBoundInput(input);\n\n        if (!stylingInputWasSet) {\n          if (input.type === 0\n          /* Property */\n          && input.i18n) {\n            boundI18nAttrs.push(input);\n          } else {\n            allOtherInputs.push(input);\n          }\n        }\n      }); // add attributes for directive and projection matching purposes\n\n      var attributes = this.getAttributeExpressions(element.name, outputAttrs, allOtherInputs, element.outputs, stylingBuilder, [], boundI18nAttrs);\n      parameters.push(this.addAttrsToConsts(attributes)); // local refs (ex.: <div #foo #bar=\"baz\">)\n\n      var refs = this.prepareRefsArray(element.references);\n      parameters.push(this.addToConsts(refs));\n      var wasInNamespace = this._namespace;\n      var currentNamespace = this.getNamespaceInstruction(namespaceKey); // If the namespace is changing now, include an instruction to change it\n      // during element creation.\n\n      if (currentNamespace !== wasInNamespace) {\n        this.addNamespaceInstruction(currentNamespace, element);\n      }\n\n      if (this.i18n) {\n        this.i18n.appendElement(element.i18n, elementIndex);\n      } // Note that we do not append text node instructions and ICUs inside i18n section,\n      // so we exclude them while calculating whether current element has children\n\n\n      var hasChildren = !isI18nRootElement && this.i18n ? !hasTextChildrenOnly(element.children) : element.children.length > 0;\n      var createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes && element.outputs.length === 0 && boundI18nAttrs.length === 0 && !hasChildren;\n      var createSelfClosingI18nInstruction = !createSelfClosingInstruction && hasTextChildrenOnly(element.children);\n\n      if (createSelfClosingInstruction) {\n        this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers.elementContainer : Identifiers.element, trimTrailingNulls(parameters));\n      } else {\n        this.creationInstruction(element.startSourceSpan, isNgContainer$1 ? Identifiers.elementContainerStart : Identifiers.elementStart, trimTrailingNulls(parameters));\n\n        if (isNonBindableMode) {\n          this.creationInstruction(element.startSourceSpan, Identifiers.disableBindings);\n        }\n\n        if (boundI18nAttrs.length > 0) {\n          this.i18nAttributesInstruction(elementIndex, boundI18nAttrs, (_a = element.startSourceSpan) !== null && _a !== void 0 ? _a : element.sourceSpan);\n        } // Generate Listeners (outputs)\n\n\n        if (element.outputs.length > 0) {\n          var listeners = element.outputs.map(function (outputAst) {\n            return {\n              sourceSpan: outputAst.sourceSpan,\n              params: _this186.prepareListenerParameter(element.name, outputAst, elementIndex)\n            };\n          });\n          this.creationInstructionChain(Identifiers.listener, listeners);\n        } // Note: it's important to keep i18n/i18nStart instructions after i18nAttributes and\n        // listeners, to make sure i18nAttributes instruction targets current element at runtime.\n\n\n        if (isI18nRootElement) {\n          this.i18nStart(element.startSourceSpan, element.i18n, createSelfClosingI18nInstruction);\n        }\n      } // the code here will collect all update-level styling instructions and add them to the\n      // update block of the template function AOT code. Instructions like `styleProp`,\n      // `styleMap`, `classMap`, `classProp`\n      // are all generated and assigned in the code below.\n\n\n      var stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);\n      var limit = stylingInstructions.length - 1;\n\n      for (var i = 0; i <= limit; i++) {\n        var _instruction = stylingInstructions[i];\n        this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, _instruction);\n      } // the reason why `undefined` is used is because the renderer understands this as a\n      // special value to symbolize that there is no RHS to this binding\n      // TODO (matsko): revisit this once FW-959 is approached\n\n\n      var emptyValueBindInstruction = literal(undefined);\n      var propertyBindings = [];\n      var attributeBindings = []; // Generate element input bindings\n\n      allOtherInputs.forEach(function (input) {\n        var inputType = input.type;\n\n        if (inputType === 4\n        /* Animation */\n        ) {\n            var _value2 = input.value.visit(_this186._valueConverter); // animation bindings can be presented in the following formats:\n            // 1. [@binding]=\"fooExp\"\n            // 2. [@binding]=\"{value:fooExp, params:{...}}\"\n            // 3. [@binding]\n            // 4. @binding\n            // All formats will be valid for when a synthetic binding is created.\n            // The reasoning for this is because the renderer should get each\n            // synthetic binding value in the order of the array that they are\n            // defined in...\n\n\n            var hasValue = _value2 instanceof LiteralPrimitive ? !!_value2.value : true;\n\n            _this186.allocateBindingSlots(_value2);\n\n            propertyBindings.push({\n              name: prepareSyntheticPropertyName(input.name),\n              sourceSpan: input.sourceSpan,\n              value: function value() {\n                return hasValue ? _this186.convertPropertyBinding(_value2) : emptyValueBindInstruction;\n              }\n            });\n          } else {\n          // we must skip attributes with associated i18n context, since these attributes are handled\n          // separately and corresponding `i18nExp` and `i18nApply` instructions will be generated\n          if (input.i18n) return;\n\n          var _value3 = input.value.visit(_this186._valueConverter);\n\n          if (_value3 !== undefined) {\n            var params = [];\n\n            var _splitNsName3 = splitNsName(input.name),\n                _splitNsName4 = _slicedToArray(_splitNsName3, 2),\n                attrNamespace = _splitNsName4[0],\n                attrName = _splitNsName4[1];\n\n            var isAttributeBinding = inputType === 1\n            /* Attribute */\n            ;\n            var sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);\n            if (sanitizationRef) params.push(sanitizationRef);\n\n            if (attrNamespace) {\n              var namespaceLiteral = literal(attrNamespace);\n\n              if (sanitizationRef) {\n                params.push(namespaceLiteral);\n              } else {\n                // If there wasn't a sanitization ref, we need to add\n                // an extra param so that we can pass in the namespace.\n                params.push(literal(null), namespaceLiteral);\n              }\n            }\n\n            _this186.allocateBindingSlots(_value3);\n\n            if (inputType === 0\n            /* Property */\n            ) {\n                if (_value3 instanceof Interpolation) {\n                  // prop=\"{{value}}\" and friends\n                  _this186.interpolatedUpdateInstruction(getPropertyInterpolationExpression(_value3), elementIndex, attrName, input, _value3, params);\n                } else {\n                  // [prop]=\"value\"\n                  // Collect all the properties so that we can chain into a single function at the end.\n                  propertyBindings.push({\n                    name: attrName,\n                    sourceSpan: input.sourceSpan,\n                    value: function value() {\n                      return _this186.convertPropertyBinding(_value3);\n                    },\n                    params: params\n                  });\n                }\n              } else if (inputType === 1\n            /* Attribute */\n            ) {\n                if (_value3 instanceof Interpolation && getInterpolationArgsLength(_value3) > 1) {\n                  // attr.name=\"text{{value}}\" and friends\n                  _this186.interpolatedUpdateInstruction(getAttributeInterpolationExpression(_value3), elementIndex, attrName, input, _value3, params);\n                } else {\n                  var boundValue = _value3 instanceof Interpolation ? _value3.expressions[0] : _value3; // [attr.name]=\"value\" or attr.name=\"{{value}}\"\n                  // Collect the attribute bindings so that they can be chained at the end.\n\n                  attributeBindings.push({\n                    name: attrName,\n                    sourceSpan: input.sourceSpan,\n                    value: function value() {\n                      return _this186.convertPropertyBinding(boundValue);\n                    },\n                    params: params\n                  });\n                }\n              } else {\n              // class prop\n              _this186.updateInstructionWithAdvance(elementIndex, input.sourceSpan, Identifiers.classProp, function () {\n                return [literal(elementIndex), literal(attrName), _this186.convertPropertyBinding(_value3)].concat(params);\n              });\n            }\n          }\n        }\n      });\n\n      if (propertyBindings.length > 0) {\n        this.updateInstructionChainWithAdvance(elementIndex, Identifiers.property, propertyBindings);\n      }\n\n      if (attributeBindings.length > 0) {\n        this.updateInstructionChainWithAdvance(elementIndex, Identifiers.attribute, attributeBindings);\n      } // Traverse element child nodes\n\n\n      visitAll(this, element.children);\n\n      if (!isI18nRootElement && this.i18n) {\n        this.i18n.appendElement(element.i18n, elementIndex, true);\n      }\n\n      if (!createSelfClosingInstruction) {\n        // Finish element construction mode.\n        var span = (_b = element.endSourceSpan) !== null && _b !== void 0 ? _b : element.sourceSpan;\n\n        if (isI18nRootElement) {\n          this.i18nEnd(span, createSelfClosingI18nInstruction);\n        }\n\n        if (isNonBindableMode) {\n          this.creationInstruction(span, Identifiers.enableBindings);\n        }\n\n        this.creationInstruction(span, isNgContainer$1 ? Identifiers.elementContainerEnd : Identifiers.elementEnd);\n      }\n    }\n  }, {\n    key: \"visitTemplate\",\n    value: function visitTemplate(template) {\n      var _this187 = this;\n\n      var _a;\n\n      var NG_TEMPLATE_TAG_NAME = 'ng-template';\n      var templateIndex = this.allocateDataSlot();\n\n      if (this.i18n) {\n        this.i18n.appendTemplate(template.i18n, templateIndex);\n      }\n\n      var tagNameWithoutNamespace = template.tagName ? splitNsName(template.tagName)[1] : template.tagName;\n      var contextName = \"\".concat(this.contextName).concat(template.tagName ? '_' + sanitizeIdentifier(template.tagName) : '', \"_\").concat(templateIndex);\n      var templateName = \"\".concat(contextName, \"_Template\");\n      var parameters = [literal(templateIndex), variable(templateName), // We don't care about the tag's namespace here, because we infer\n      // it based on the parent nodes inside the template instruction.\n      literal(tagNameWithoutNamespace)]; // find directives matching on a given <ng-template> node\n\n      this.matchDirectives(NG_TEMPLATE_TAG_NAME, template); // prepare attributes parameter (including attributes used for directive matching)\n\n      var attrsExprs = this.getAttributeExpressions(NG_TEMPLATE_TAG_NAME, template.attributes, template.inputs, template.outputs, undefined\n      /* styles */\n      , template.templateAttrs);\n      parameters.push(this.addAttrsToConsts(attrsExprs)); // local refs (ex.: <ng-template #foo>)\n\n      if (template.references && template.references.length) {\n        var refs = this.prepareRefsArray(template.references);\n        parameters.push(this.addToConsts(refs));\n        parameters.push(importExpr(Identifiers.templateRefExtractor));\n      } // Create the template function\n\n\n      var templateVisitor = new TemplateDefinitionBuilder(this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n, templateIndex, templateName, this.directiveMatcher, this.directives, this.pipeTypeByName, this.pipes, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds, this._constants); // Nested templates must not be visited until after their parent templates have completed\n      // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't\n      // be able to support bindings in nested templates to local refs that occur after the\n      // template definition. e.g. <div *ngIf=\"showing\">{{ foo }}</div>  <div #foo></div>\n\n      this._nestedTemplateFns.push(function () {\n        var templateFunctionExpr = templateVisitor.buildTemplateFunction(template.children, template.variables, _this187._ngContentReservedSlots.length + _this187._ngContentSelectorsOffset, template.i18n);\n\n        _this187.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName));\n\n        if (templateVisitor._ngContentReservedSlots.length) {\n          var _this187$_ngContentRe;\n\n          (_this187$_ngContentRe = _this187._ngContentReservedSlots).push.apply(_this187$_ngContentRe, _toConsumableArray(templateVisitor._ngContentReservedSlots));\n        }\n      }); // e.g. template(1, MyComp_Template_1)\n\n\n      this.creationInstruction(template.sourceSpan, Identifiers.templateCreate, function () {\n        parameters.splice(2, 0, literal(templateVisitor.getConstCount()), literal(templateVisitor.getVarCount()));\n        return trimTrailingNulls(parameters);\n      }); // handle property bindings e.g. ɵɵproperty('ngForOf', ctx.items), et al;\n\n      this.templatePropertyBindings(templateIndex, template.templateAttrs); // Only add normal input/output binding instructions on explicit <ng-template> elements.\n\n      if (tagNameWithoutNamespace === NG_TEMPLATE_TAG_NAME) {\n        var _partitionArray = partitionArray(template.inputs, hasI18nMeta),\n            _partitionArray2 = _slicedToArray(_partitionArray, 2),\n            i18nInputs = _partitionArray2[0],\n            inputs = _partitionArray2[1]; // Add i18n attributes that may act as inputs to directives. If such attributes are present,\n        // generate `i18nAttributes` instruction. Note: we generate it only for explicit <ng-template>\n        // elements, in case of inline templates, corresponding instructions will be generated in the\n        // nested template function.\n\n\n        if (i18nInputs.length > 0) {\n          this.i18nAttributesInstruction(templateIndex, i18nInputs, (_a = template.startSourceSpan) !== null && _a !== void 0 ? _a : template.sourceSpan);\n        } // Add the input bindings\n\n\n        if (inputs.length > 0) {\n          this.templatePropertyBindings(templateIndex, inputs);\n        } // Generate listeners for directive output\n\n\n        if (template.outputs.length > 0) {\n          var listeners = template.outputs.map(function (outputAst) {\n            return {\n              sourceSpan: outputAst.sourceSpan,\n              params: _this187.prepareListenerParameter('ng_template', outputAst, templateIndex)\n            };\n          });\n          this.creationInstructionChain(Identifiers.listener, listeners);\n        }\n      }\n    }\n  }, {\n    key: \"visitBoundText\",\n    value: function visitBoundText(text) {\n      var _this188 = this;\n\n      if (this.i18n) {\n        var _value4 = text.value.visit(this._valueConverter);\n\n        this.allocateBindingSlots(_value4);\n\n        if (_value4 instanceof Interpolation) {\n          this.i18n.appendBoundText(text.i18n);\n          this.i18nAppendBindings(_value4.expressions);\n        }\n\n        return;\n      }\n\n      var nodeIndex = this.allocateDataSlot();\n      this.creationInstruction(text.sourceSpan, Identifiers.text, [literal(nodeIndex)]);\n      var value = text.value.visit(this._valueConverter);\n      this.allocateBindingSlots(value);\n\n      if (value instanceof Interpolation) {\n        this.updateInstructionWithAdvance(nodeIndex, text.sourceSpan, getTextInterpolationExpression(value), function () {\n          return _this188.getUpdateInstructionArguments(value);\n        });\n      } else {\n        error('Text nodes should be interpolated and never bound directly.');\n      }\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {\n      // when a text element is located within a translatable\n      // block, we exclude this text element from instructions set,\n      // since it will be captured in i18n content and processed at runtime\n      if (!this.i18n) {\n        this.creationInstruction(text.sourceSpan, Identifiers.text, [literal(this.allocateDataSlot()), literal(text.value)]);\n      }\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu) {\n      var initWasInvoked = false; // if an ICU was created outside of i18n block, we still treat\n      // it as a translatable entity and invoke i18nStart and i18nEnd\n      // to generate i18n context and the necessary instructions\n\n      if (!this.i18n) {\n        initWasInvoked = true;\n        this.i18nStart(null, icu.i18n, true);\n      }\n\n      var i18n = this.i18n;\n      var vars = this.i18nBindProps(icu.vars);\n      var placeholders = this.i18nBindProps(icu.placeholders); // output ICU directly and keep ICU reference in context\n\n      var message = icu.i18n; // we always need post-processing function for ICUs, to make sure that:\n      // - all placeholders in a form of {PLACEHOLDER} are replaced with actual values (note:\n      // `goog.getMsg` does not process ICUs and uses the `{PLACEHOLDER}` format for placeholders\n      // inside ICUs)\n      // - all ICU vars (such as `VAR_SELECT` or `VAR_PLURAL`) are replaced with correct values\n\n      var transformFn = function transformFn(raw) {\n        var params = Object.assign(Object.assign({}, vars), placeholders);\n        var formatted = i18nFormatPlaceholderNames(params,\n        /* useCamelCase */\n        false);\n        return instruction(null, Identifiers.i18nPostprocess, [raw, mapLiteral(formatted, true)]);\n      }; // in case the whole i18n message is a single ICU - we do not need to\n      // create a separate top-level translation, we can use the root ref instead\n      // and make this ICU a top-level translation\n      // note: ICU placeholders are replaced with actual values in `i18nPostprocess` function\n      // separately, so we do not pass placeholders into `i18nTranslate` function.\n\n\n      if (isSingleI18nIcu(i18n.meta)) {\n        this.i18nTranslate(message,\n        /* placeholders */\n        {}, i18n.ref, transformFn);\n      } else {\n        // output ICU directly and keep ICU reference in context\n        var ref = this.i18nTranslate(message,\n        /* placeholders */\n        {},\n        /* ref */\n        undefined, transformFn);\n        i18n.appendIcu(icuFromI18nMessage(message).name, ref);\n      }\n\n      if (initWasInvoked) {\n        this.i18nEnd(null, true);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"allocateDataSlot\",\n    value: function allocateDataSlot() {\n      return this._dataIndex++;\n    }\n  }, {\n    key: \"getConstCount\",\n    value: function getConstCount() {\n      return this._dataIndex;\n    }\n  }, {\n    key: \"getVarCount\",\n    value: function getVarCount() {\n      return this._pureFunctionSlots;\n    }\n  }, {\n    key: \"getConsts\",\n    value: function getConsts() {\n      return this._constants;\n    }\n  }, {\n    key: \"getNgContentSelectors\",\n    value: function getNgContentSelectors() {\n      return this._ngContentReservedSlots.length ? this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) : null;\n    }\n  }, {\n    key: \"bindingContext\",\n    value: function bindingContext() {\n      return \"\".concat(this._bindingContext++);\n    }\n  }, {\n    key: \"templatePropertyBindings\",\n    value: function templatePropertyBindings(templateIndex, attrs) {\n      var _this189 = this;\n\n      var propertyBindings = [];\n      attrs.forEach(function (input) {\n        if (input instanceof BoundAttribute) {\n          var _value5 = input.value.visit(_this189._valueConverter);\n\n          if (_value5 !== undefined) {\n            _this189.allocateBindingSlots(_value5);\n\n            if (_value5 instanceof Interpolation) {\n              // Params typically contain attribute namespace and value sanitizer, which is applicable\n              // for regular HTML elements, but not applicable for <ng-template> (since props act as\n              // inputs to directives), so keep params array empty.\n              var params = []; // prop=\"{{value}}\" case\n\n              _this189.interpolatedUpdateInstruction(getPropertyInterpolationExpression(_value5), templateIndex, input.name, input, _value5, params);\n            } else {\n              // [prop]=\"value\" case\n              propertyBindings.push({\n                name: input.name,\n                sourceSpan: input.sourceSpan,\n                value: function value() {\n                  return _this189.convertPropertyBinding(_value5);\n                }\n              });\n            }\n          }\n        }\n      });\n\n      if (propertyBindings.length > 0) {\n        this.updateInstructionChainWithAdvance(templateIndex, Identifiers.property, propertyBindings);\n      }\n    } // Bindings must only be resolved after all local refs have been visited, so all\n    // instructions are queued in callbacks that execute once the initial pass has completed.\n    // Otherwise, we wouldn't be able to support local refs that are defined after their\n    // bindings. e.g. {{ foo }} <div #foo></div>\n\n  }, {\n    key: \"instructionFn\",\n    value: function instructionFn(fns, span, reference, paramsOrFn) {\n      var prepend = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      fns[prepend ? 'unshift' : 'push'](function () {\n        var params = Array.isArray(paramsOrFn) ? paramsOrFn : paramsOrFn();\n        return instruction(span, reference, params).toStmt();\n      });\n    }\n  }, {\n    key: \"processStylingUpdateInstruction\",\n    value: function processStylingUpdateInstruction(elementIndex, instruction) {\n      var _this190 = this;\n\n      var allocateBindingSlots = 0;\n\n      if (instruction) {\n        var calls = [];\n        instruction.calls.forEach(function (call) {\n          allocateBindingSlots += call.allocateBindingSlots;\n          calls.push({\n            sourceSpan: call.sourceSpan,\n            value: function value() {\n              return call.params(function (value) {\n                return call.supportsInterpolation && value instanceof Interpolation ? _this190.getUpdateInstructionArguments(value) : _this190.convertPropertyBinding(value);\n              });\n            }\n          });\n        });\n        this.updateInstructionChainWithAdvance(elementIndex, instruction.reference, calls);\n      }\n\n      return allocateBindingSlots;\n    }\n  }, {\n    key: \"creationInstruction\",\n    value: function creationInstruction(span, reference, paramsOrFn, prepend) {\n      this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);\n    }\n  }, {\n    key: \"creationInstructionChain\",\n    value: function creationInstructionChain(reference, calls) {\n      var span = calls.length ? calls[0].sourceSpan : null;\n\n      this._creationCodeFns.push(function () {\n        return chainedInstruction(reference, calls.map(function (call) {\n          return call.params();\n        }), span).toStmt();\n      });\n    }\n  }, {\n    key: \"updateInstructionWithAdvance\",\n    value: function updateInstructionWithAdvance(nodeIndex, span, reference, paramsOrFn) {\n      this.addAdvanceInstructionIfNecessary(nodeIndex, span);\n      this.updateInstruction(span, reference, paramsOrFn);\n    }\n  }, {\n    key: \"updateInstruction\",\n    value: function updateInstruction(span, reference, paramsOrFn) {\n      this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);\n    }\n  }, {\n    key: \"updateInstructionChain\",\n    value: function updateInstructionChain(reference, bindings) {\n      var span = bindings.length ? bindings[0].sourceSpan : null;\n\n      this._updateCodeFns.push(function () {\n        var calls = bindings.map(function (property) {\n          var value = property.value();\n          var fnParams = Array.isArray(value) ? value : [value];\n\n          if (property.params) {\n            fnParams.push.apply(fnParams, _toConsumableArray(property.params));\n          }\n\n          if (property.name) {\n            // We want the property name to always be the first function parameter.\n            fnParams.unshift(literal(property.name));\n          }\n\n          return fnParams;\n        });\n        return chainedInstruction(reference, calls, span).toStmt();\n      });\n    }\n  }, {\n    key: \"updateInstructionChainWithAdvance\",\n    value: function updateInstructionChainWithAdvance(nodeIndex, reference, bindings) {\n      this.addAdvanceInstructionIfNecessary(nodeIndex, bindings.length ? bindings[0].sourceSpan : null);\n      this.updateInstructionChain(reference, bindings);\n    }\n  }, {\n    key: \"addAdvanceInstructionIfNecessary\",\n    value: function addAdvanceInstructionIfNecessary(nodeIndex, span) {\n      if (nodeIndex !== this._currentIndex) {\n        var delta = nodeIndex - this._currentIndex;\n\n        if (delta < 1) {\n          throw new Error('advance instruction can only go forwards');\n        }\n\n        this.instructionFn(this._updateCodeFns, span, Identifiers.advance, [literal(delta)]);\n        this._currentIndex = nodeIndex;\n      }\n    }\n  }, {\n    key: \"allocatePureFunctionSlots\",\n    value: function allocatePureFunctionSlots(numSlots) {\n      var originalSlots = this._pureFunctionSlots;\n      this._pureFunctionSlots += numSlots;\n      return originalSlots;\n    }\n  }, {\n    key: \"allocateBindingSlots\",\n    value: function allocateBindingSlots(value) {\n      this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;\n    }\n    /**\r\n     * Gets an expression that refers to the implicit receiver. The implicit\r\n     * receiver is always the root level context.\r\n     */\n\n  }, {\n    key: \"getImplicitReceiverExpr\",\n    value: function getImplicitReceiverExpr() {\n      if (this._implicitReceiverExpr) {\n        return this._implicitReceiverExpr;\n      }\n\n      return this._implicitReceiverExpr = this.level === 0 ? variable(CONTEXT_NAME) : this._bindingScope.getOrCreateSharedContextVar(0);\n    }\n  }, {\n    key: \"convertPropertyBinding\",\n    value: function convertPropertyBinding(value) {\n      var _this$_tempVariables;\n\n      var convertedPropertyBinding = _convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext(), BindingForm.Expression, function () {\n        return error('Unexpected interpolation');\n      });\n\n      var valExpr = convertedPropertyBinding.currValExpr;\n\n      (_this$_tempVariables = this._tempVariables).push.apply(_this$_tempVariables, _toConsumableArray(convertedPropertyBinding.stmts));\n\n      return valExpr;\n    }\n    /**\r\n     * Gets a list of argument expressions to pass to an update instruction expression. Also updates\r\n     * the temp variables state with temp variables that were identified as needing to be created\r\n     * while visiting the arguments.\r\n     * @param value The original expression we will be resolving an arguments list from.\r\n     */\n\n  }, {\n    key: \"getUpdateInstructionArguments\",\n    value: function getUpdateInstructionArguments(value) {\n      var _this$_tempVariables2;\n\n      var _convertUpdateArgumen = convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext()),\n          args = _convertUpdateArgumen.args,\n          stmts = _convertUpdateArgumen.stmts;\n\n      (_this$_tempVariables2 = this._tempVariables).push.apply(_this$_tempVariables2, _toConsumableArray(stmts));\n\n      return args;\n    }\n  }, {\n    key: \"matchDirectives\",\n    value: function matchDirectives(elementName, elOrTpl) {\n      var _this191 = this;\n\n      if (this.directiveMatcher) {\n        var selector = createCssSelector(elementName, getAttrsForDirectiveMatching(elOrTpl));\n        this.directiveMatcher.match(selector, function (cssSelector, staticType) {\n          _this191.directives.add(staticType);\n        });\n      }\n    }\n    /**\r\n     * Prepares all attribute expression values for the `TAttributes` array.\r\n     *\r\n     * The purpose of this function is to properly construct an attributes array that\r\n     * is passed into the `elementStart` (or just `element`) functions. Because there\r\n     * are many different types of attributes, the array needs to be constructed in a\r\n     * special way so that `elementStart` can properly evaluate them.\r\n     *\r\n     * The format looks like this:\r\n     *\r\n     * ```\r\n     * attrs = [prop, value, prop2, value2,\r\n     *   PROJECT_AS, selector,\r\n     *   CLASSES, class1, class2,\r\n     *   STYLES, style1, value1, style2, value2,\r\n     *   BINDINGS, name1, name2, name3,\r\n     *   TEMPLATE, name4, name5, name6,\r\n     *   I18N, name7, name8, ...]\r\n     * ```\r\n     *\r\n     * Note that this function will fully ignore all synthetic (@foo) attribute values\r\n     * because those values are intended to always be generated as property instructions.\r\n     */\n\n  }, {\n    key: \"getAttributeExpressions\",\n    value: function getAttributeExpressions(elementName, renderAttributes, inputs, outputs, styles) {\n      var templateAttrs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n      var boundI18nAttrs = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [];\n      var alreadySeen = new Set();\n      var attrExprs = [];\n      var ngProjectAsAttr;\n\n      var _iterator18 = _createForOfIteratorHelper(renderAttributes),\n          _step18;\n\n      try {\n        for (_iterator18.s(); !(_step18 = _iterator18.n()).done;) {\n          var attr = _step18.value;\n\n          if (attr.name === NG_PROJECT_AS_ATTR_NAME) {\n            ngProjectAsAttr = attr;\n          } // Note that static i18n attributes aren't in the i18n array,\n          // because they're treated in the same way as regular attributes.\n\n\n          if (attr.i18n) {\n            // When i18n attributes are present on elements with structural directives\n            // (e.g. `<div *ngIf title=\"Hello\" i18n-title>`), we want to avoid generating\n            // duplicate i18n translation blocks for `ɵɵtemplate` and `ɵɵelement` instruction\n            // attributes. So we do a cache lookup to see if suitable i18n translation block\n            // already exists.\n            var i18nVarRefsCache = this._constants.i18nVarRefsCache;\n            var i18nVarRef = void 0;\n\n            if (i18nVarRefsCache.has(attr.i18n)) {\n              i18nVarRef = i18nVarRefsCache.get(attr.i18n);\n            } else {\n              i18nVarRef = this.i18nTranslate(attr.i18n);\n              i18nVarRefsCache.set(attr.i18n, i18nVarRef);\n            }\n\n            attrExprs.push(literal(attr.name), i18nVarRef);\n          } else {\n            attrExprs.push.apply(attrExprs, _toConsumableArray(getAttributeNameLiterals(attr.name)).concat([trustedConstAttribute(elementName, attr)]));\n          }\n        } // Keep ngProjectAs next to the other name, value pairs so we can verify that we match\n        // ngProjectAs marker in the attribute name slot.\n\n      } catch (err) {\n        _iterator18.e(err);\n      } finally {\n        _iterator18.f();\n      }\n\n      if (ngProjectAsAttr) {\n        attrExprs.push.apply(attrExprs, _toConsumableArray(getNgProjectAsLiteral(ngProjectAsAttr)));\n      }\n\n      function addAttrExpr(key, value) {\n        if (typeof key === 'string') {\n          if (!alreadySeen.has(key)) {\n            attrExprs.push.apply(attrExprs, _toConsumableArray(getAttributeNameLiterals(key)));\n            value !== undefined && attrExprs.push(value);\n            alreadySeen.add(key);\n          }\n        } else {\n          attrExprs.push(literal(key));\n        }\n      } // it's important that this occurs before BINDINGS and TEMPLATE because once `elementStart`\n      // comes across the BINDINGS or TEMPLATE markers then it will continue reading each value as\n      // as single property value cell by cell.\n\n\n      if (styles) {\n        styles.populateInitialStylingAttrs(attrExprs);\n      }\n\n      if (inputs.length || outputs.length) {\n        var attrsLengthBeforeInputs = attrExprs.length;\n\n        for (var i = 0; i < inputs.length; i++) {\n          var input = inputs[i]; // We don't want the animation and attribute bindings in the\n          // attributes array since they aren't used for directive matching.\n\n          if (input.type !== 4\n          /* Animation */\n          && input.type !== 1\n          /* Attribute */\n          ) {\n              addAttrExpr(input.name);\n            }\n        }\n\n        for (var _i7 = 0; _i7 < outputs.length; _i7++) {\n          var output = outputs[_i7];\n\n          if (output.type !== 1\n          /* Animation */\n          ) {\n              addAttrExpr(output.name);\n            }\n        } // this is a cheap way of adding the marker only after all the input/output\n        // values have been filtered (by not including the animation ones) and added\n        // to the expressions. The marker is important because it tells the runtime\n        // code that this is where attributes without values start...\n\n\n        if (attrExprs.length !== attrsLengthBeforeInputs) {\n          attrExprs.splice(attrsLengthBeforeInputs, 0, literal(3\n          /* Bindings */\n          ));\n        }\n      }\n\n      if (templateAttrs.length) {\n        attrExprs.push(literal(4\n        /* Template */\n        ));\n        templateAttrs.forEach(function (attr) {\n          return addAttrExpr(attr.name);\n        });\n      }\n\n      if (boundI18nAttrs.length) {\n        attrExprs.push(literal(6\n        /* I18n */\n        ));\n        boundI18nAttrs.forEach(function (attr) {\n          return addAttrExpr(attr.name);\n        });\n      }\n\n      return attrExprs;\n    }\n  }, {\n    key: \"addToConsts\",\n    value: function addToConsts(expression) {\n      if (isNull(expression)) {\n        return TYPED_NULL_EXPR;\n      }\n\n      var consts = this._constants.constExpressions; // Try to reuse a literal that's already in the array, if possible.\n\n      for (var i = 0; i < consts.length; i++) {\n        if (consts[i].isEquivalent(expression)) {\n          return literal(i);\n        }\n      }\n\n      return literal(consts.push(expression) - 1);\n    }\n  }, {\n    key: \"addAttrsToConsts\",\n    value: function addAttrsToConsts(attrs) {\n      return attrs.length > 0 ? this.addToConsts(literalArr(attrs)) : TYPED_NULL_EXPR;\n    }\n  }, {\n    key: \"prepareRefsArray\",\n    value: function prepareRefsArray(references) {\n      var _this192 = this;\n\n      if (!references || references.length === 0) {\n        return TYPED_NULL_EXPR;\n      }\n\n      var refsParam = flatten(references.map(function (reference) {\n        var slot = _this192.allocateDataSlot(); // Generate the update temporary.\n\n\n        var variableName = _this192._bindingScope.freshReferenceName();\n\n        var retrievalLevel = _this192.level;\n        var lhs = variable(variableName);\n\n        _this192._bindingScope.set(retrievalLevel, reference.name, lhs, 0\n        /* DEFAULT */\n        , function (scope, relativeLevel) {\n          // e.g. nextContext(2);\n          var nextContextStmt = relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : []; // e.g. const $foo$ = reference(1);\n\n          var refExpr = lhs.set(importExpr(Identifiers.reference).callFn([literal(slot)]));\n          return nextContextStmt.concat(refExpr.toConstDecl());\n        }, true);\n\n        return [reference.name, reference.value];\n      }));\n      return asLiteral(refsParam);\n    }\n  }, {\n    key: \"prepareListenerParameter\",\n    value: function prepareListenerParameter(tagName, outputAst, index) {\n      var _this193 = this;\n\n      return function () {\n        var eventName = outputAst.name;\n        var bindingFnName = outputAst.type === 1\n        /* Animation */\n        ? // synthetic @listener.foo values are treated the exact same as are standard listeners\n        prepareSyntheticListenerFunctionName(eventName, outputAst.phase) : sanitizeIdentifier(eventName);\n        var handlerName = \"\".concat(_this193.templateName, \"_\").concat(tagName, \"_\").concat(bindingFnName, \"_\").concat(index, \"_listener\");\n\n        var scope = _this193._bindingScope.nestedScope(_this193._bindingScope.bindingLevel, EVENT_BINDING_SCOPE_GLOBALS);\n\n        return prepareEventListenerParameters(outputAst, handlerName, scope);\n      };\n    }\n  }]);\n\n  return TemplateDefinitionBuilder;\n}();\n\nvar ValueConverter = /*#__PURE__*/function (_AstMemoryEfficientTr) {\n  _inherits(ValueConverter, _AstMemoryEfficientTr);\n\n  var _super100 = _createSuper(ValueConverter);\n\n  function ValueConverter(constantPool, allocateSlot, allocatePureFunctionSlots, definePipe) {\n    var _this194;\n\n    _classCallCheck(this, ValueConverter);\n\n    _this194 = _super100.call(this);\n    _this194.constantPool = constantPool;\n    _this194.allocateSlot = allocateSlot;\n    _this194.allocatePureFunctionSlots = allocatePureFunctionSlots;\n    _this194.definePipe = definePipe;\n    _this194._pipeBindExprs = [];\n    return _this194;\n  } // AstMemoryEfficientTransformer\n\n\n  _createClass(ValueConverter, [{\n    key: \"visitPipe\",\n    value: function visitPipe(pipe, context) {\n      // Allocate a slot to create the pipe\n      var slot = this.allocateSlot();\n      var slotPseudoLocal = \"PIPE:\".concat(slot); // Allocate one slot for the result plus one slot per pipe argument\n\n      var pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);\n      var target = new PropertyRead(pipe.span, pipe.sourceSpan, pipe.nameSpan, new ImplicitReceiver(pipe.span, pipe.sourceSpan), slotPseudoLocal);\n\n      var _pipeBindingCallInfo = pipeBindingCallInfo(pipe.args),\n          identifier = _pipeBindingCallInfo.identifier,\n          isVarLength = _pipeBindingCallInfo.isVarLength;\n\n      this.definePipe(pipe.name, slotPseudoLocal, slot, importExpr(identifier));\n      var args = [pipe.exp].concat(_toConsumableArray(pipe.args));\n      var convertedArgs = isVarLength ? this.visitAll([new LiteralArray(pipe.span, pipe.sourceSpan, args)]) : this.visitAll(args);\n      var pipeBindExpr = new FunctionCall(pipe.span, pipe.sourceSpan, target, [new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot), new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot)].concat(_toConsumableArray(convertedArgs)));\n\n      this._pipeBindExprs.push(pipeBindExpr);\n\n      return pipeBindExpr;\n    }\n  }, {\n    key: \"updatePipeSlotOffsets\",\n    value: function updatePipeSlotOffsets(bindingSlots) {\n      this._pipeBindExprs.forEach(function (pipe) {\n        // update the slot offset arg (index 1) to account for binding slots\n        var slotOffset = pipe.args[1];\n        slotOffset.value += bindingSlots;\n      });\n    }\n  }, {\n    key: \"visitLiteralArray\",\n    value: function visitLiteralArray(array, context) {\n      var _this195 = this;\n\n      return new BuiltinFunctionCall(array.span, array.sourceSpan, this.visitAll(array.expressions), function (values) {\n        // If the literal has calculated (non-literal) elements transform it into\n        // calls to literal factories that compose the literal and will cache intermediate\n        // values.\n        var literal = literalArr(values);\n        return getLiteralFactory(_this195.constantPool, literal, _this195.allocatePureFunctionSlots);\n      });\n    }\n  }, {\n    key: \"visitLiteralMap\",\n    value: function visitLiteralMap(map, context) {\n      var _this196 = this;\n\n      return new BuiltinFunctionCall(map.span, map.sourceSpan, this.visitAll(map.values), function (values) {\n        // If the literal has calculated (non-literal) elements  transform it into\n        // calls to literal factories that compose the literal and will cache intermediate\n        // values.\n        var literal = literalMap(values.map(function (value, index) {\n          return {\n            key: map.keys[index].key,\n            value: value,\n            quoted: map.keys[index].quoted\n          };\n        }));\n        return getLiteralFactory(_this196.constantPool, literal, _this196.allocatePureFunctionSlots);\n      });\n    }\n  }]);\n\n  return ValueConverter;\n}(AstMemoryEfficientTransformer); // Pipes always have at least one parameter, the value they operate on\n\n\nvar pipeBindingIdentifiers = [Identifiers.pipeBind1, Identifiers.pipeBind2, Identifiers.pipeBind3, Identifiers.pipeBind4];\n\nfunction pipeBindingCallInfo(args) {\n  var identifier = pipeBindingIdentifiers[args.length];\n  return {\n    identifier: identifier || Identifiers.pipeBindV,\n    isVarLength: !identifier\n  };\n}\n\nvar pureFunctionIdentifiers = [Identifiers.pureFunction0, Identifiers.pureFunction1, Identifiers.pureFunction2, Identifiers.pureFunction3, Identifiers.pureFunction4, Identifiers.pureFunction5, Identifiers.pureFunction6, Identifiers.pureFunction7, Identifiers.pureFunction8];\n\nfunction pureFunctionCallInfo(args) {\n  var identifier = pureFunctionIdentifiers[args.length];\n  return {\n    identifier: identifier || Identifiers.pureFunctionV,\n    isVarLength: !identifier\n  };\n}\n\nfunction instruction(span, reference, params) {\n  return importExpr(reference, null, span).callFn(params, span);\n} // e.g. x(2);\n\n\nfunction generateNextContextExpr(relativeLevelDiff) {\n  return importExpr(Identifiers.nextContext).callFn(relativeLevelDiff > 1 ? [literal(relativeLevelDiff)] : []);\n}\n\nfunction getLiteralFactory(constantPool, literal$1, allocateSlots) {\n  var _constantPool$getLite = constantPool.getLiteralFactory(literal$1),\n      literalFactory = _constantPool$getLite.literalFactory,\n      literalFactoryArguments = _constantPool$getLite.literalFactoryArguments; // Allocate 1 slot for the result plus 1 per argument\n\n\n  var startSlot = allocateSlots(1 + literalFactoryArguments.length);\n\n  var _pureFunctionCallInfo = pureFunctionCallInfo(literalFactoryArguments),\n      identifier = _pureFunctionCallInfo.identifier,\n      isVarLength = _pureFunctionCallInfo.isVarLength; // Literal factories are pure functions that only need to be re-invoked when the parameters\n  // change.\n\n\n  var args = [literal(startSlot), literalFactory];\n\n  if (isVarLength) {\n    args.push(literalArr(literalFactoryArguments));\n  } else {\n    args.push.apply(args, _toConsumableArray(literalFactoryArguments));\n  }\n\n  return importExpr(identifier).callFn(args);\n}\n/**\r\n * Gets an array of literals that can be added to an expression\r\n * to represent the name and namespace of an attribute. E.g.\r\n * `:xlink:href` turns into `[AttributeMarker.NamespaceURI, 'xlink', 'href']`.\r\n *\r\n * @param name Name of the attribute, including the namespace.\r\n */\n\n\nfunction getAttributeNameLiterals(name) {\n  var _splitNsName5 = splitNsName(name),\n      _splitNsName6 = _slicedToArray(_splitNsName5, 2),\n      attributeNamespace = _splitNsName6[0],\n      attributeName = _splitNsName6[1];\n\n  var nameLiteral = literal(attributeName);\n\n  if (attributeNamespace) {\n    return [literal(0\n    /* NamespaceURI */\n    ), literal(attributeNamespace), nameLiteral];\n  }\n\n  return [nameLiteral];\n}\n/** The prefix used to get a shared context in BindingScope's map. */\n\n\nvar SHARED_CONTEXT_KEY = '$$shared_ctx$$';\n\nvar BindingScope = /*#__PURE__*/function () {\n  function BindingScope() {\n    var bindingLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var globals = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, BindingScope);\n\n    this.bindingLevel = bindingLevel;\n    this.parent = parent;\n    this.globals = globals;\n    /** Keeps a map from local variables to their BindingData. */\n\n    this.map = new Map();\n    this.referenceNameIndex = 0;\n    this.restoreViewVariable = null;\n    this.usesRestoredViewContext = false;\n\n    if (globals !== undefined) {\n      var _iterator19 = _createForOfIteratorHelper(globals),\n          _step19;\n\n      try {\n        for (_iterator19.s(); !(_step19 = _iterator19.n()).done;) {\n          var name = _step19.value;\n          this.set(0, name, variable(name));\n        }\n      } catch (err) {\n        _iterator19.e(err);\n      } finally {\n        _iterator19.f();\n      }\n    }\n  }\n\n  _createClass(BindingScope, [{\n    key: \"get\",\n    value: function get(name) {\n      var current = this;\n\n      while (current) {\n        var value = current.map.get(name);\n\n        if (value != null) {\n          if (current !== this) {\n            // make a local copy and reset the `declare` state\n            value = {\n              retrievalLevel: value.retrievalLevel,\n              lhs: value.lhs,\n              declareLocalCallback: value.declareLocalCallback,\n              declare: false,\n              priority: value.priority,\n              localRef: value.localRef\n            }; // Cache the value locally.\n\n            this.map.set(name, value); // Possibly generate a shared context var\n\n            this.maybeGenerateSharedContextVar(value);\n            this.maybeRestoreView(value.retrievalLevel, value.localRef);\n          }\n\n          if (value.declareLocalCallback && !value.declare) {\n            value.declare = true;\n          }\n\n          return value.lhs;\n        }\n\n        current = current.parent;\n      } // If we get to this point, we are looking for a property on the top level component\n      // - If level === 0, we are on the top and don't need to re-declare `ctx`.\n      // - If level > 0, we are in an embedded view. We need to retrieve the name of the\n      // local var we used to store the component context, e.g. const $comp$ = x();\n\n\n      return this.bindingLevel === 0 ? null : this.getComponentProperty(name);\n    }\n    /**\r\n     * Create a local variable for later reference.\r\n     *\r\n     * @param retrievalLevel The level from which this value can be retrieved\r\n     * @param name Name of the variable.\r\n     * @param lhs AST representing the left hand side of the `let lhs = rhs;`.\r\n     * @param priority The sorting priority of this var\r\n     * @param declareLocalCallback The callback to invoke when declaring this local var\r\n     * @param localRef Whether or not this is a local ref\r\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(retrievalLevel, name, lhs) {\n      var priority = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var\n      /* DEFAULT */\n      declareLocalCallback = arguments.length > 4 ? arguments[4] : undefined;\n      var localRef = arguments.length > 5 ? arguments[5] : undefined;\n\n      if (this.map.has(name)) {\n        if (localRef) {\n          // Do not throw an error if it's a local ref and do not update existing value,\n          // so the first defined ref is always returned.\n          return this;\n        }\n\n        error(\"The name \".concat(name, \" is already defined in scope to be \").concat(this.map.get(name)));\n      }\n\n      this.map.set(name, {\n        retrievalLevel: retrievalLevel,\n        lhs: lhs,\n        declare: false,\n        declareLocalCallback: declareLocalCallback,\n        priority: priority,\n        localRef: localRef || false\n      });\n      return this;\n    } // Implemented as part of LocalResolver.\n\n  }, {\n    key: \"getLocal\",\n    value: function getLocal(name) {\n      return this.get(name);\n    } // Implemented as part of LocalResolver.\n\n  }, {\n    key: \"notifyImplicitReceiverUse\",\n    value: function notifyImplicitReceiverUse() {\n      if (this.bindingLevel !== 0) {\n        // Since the implicit receiver is accessed in an embedded view, we need to\n        // ensure that we declare a shared context variable for the current template\n        // in the update variables.\n        this.map.get(SHARED_CONTEXT_KEY + 0).declare = true;\n      }\n    }\n  }, {\n    key: \"nestedScope\",\n    value: function nestedScope(level, globals) {\n      var newScope = new BindingScope(level, this, globals);\n      if (level > 0) newScope.generateSharedContextVar(0);\n      return newScope;\n    }\n    /**\r\n     * Gets or creates a shared context variable and returns its expression. Note that\r\n     * this does not mean that the shared variable will be declared. Variables in the\r\n     * binding scope will be only declared if they are used.\r\n     */\n\n  }, {\n    key: \"getOrCreateSharedContextVar\",\n    value: function getOrCreateSharedContextVar(retrievalLevel) {\n      var bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;\n\n      if (!this.map.has(bindingKey)) {\n        this.generateSharedContextVar(retrievalLevel);\n      } // Shared context variables are always generated as \"ReadVarExpr\".\n\n\n      return this.map.get(bindingKey).lhs;\n    }\n  }, {\n    key: \"getSharedContextName\",\n    value: function getSharedContextName(retrievalLevel) {\n      var sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel); // Shared context variables are always generated as \"ReadVarExpr\".\n\n      return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs : null;\n    }\n  }, {\n    key: \"maybeGenerateSharedContextVar\",\n    value: function maybeGenerateSharedContextVar(value) {\n      if (value.priority === 1\n      /* CONTEXT */\n      && value.retrievalLevel < this.bindingLevel) {\n        var sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);\n\n        if (sharedCtxObj) {\n          sharedCtxObj.declare = true;\n        } else {\n          this.generateSharedContextVar(value.retrievalLevel);\n        }\n      }\n    }\n  }, {\n    key: \"generateSharedContextVar\",\n    value: function generateSharedContextVar(retrievalLevel) {\n      var lhs = variable(CONTEXT_NAME + this.freshReferenceName());\n      this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {\n        retrievalLevel: retrievalLevel,\n        lhs: lhs,\n        declareLocalCallback: function declareLocalCallback(scope, relativeLevel) {\n          // const ctx_r0 = nextContext(2);\n          return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];\n        },\n        declare: false,\n        priority: 2\n        /* SHARED_CONTEXT */\n        ,\n        localRef: false\n      });\n    }\n  }, {\n    key: \"getComponentProperty\",\n    value: function getComponentProperty(name) {\n      var componentValue = this.map.get(SHARED_CONTEXT_KEY + 0);\n      componentValue.declare = true;\n      this.maybeRestoreView(0, false);\n      return componentValue.lhs.prop(name);\n    }\n  }, {\n    key: \"maybeRestoreView\",\n    value: function maybeRestoreView(retrievalLevel, localRefLookup) {\n      // We want to restore the current view in listener fns if:\n      // 1 - we are accessing a value in a parent view, which requires walking the view tree rather\n      // than using the ctx arg. In this case, the retrieval and binding level will be different.\n      // 2 - we are looking up a local ref, which requires restoring the view where the local\n      // ref is stored\n      if (this.isListenerScope() && (retrievalLevel < this.bindingLevel || localRefLookup)) {\n        if (!this.parent.restoreViewVariable) {\n          // parent saves variable to generate a shared `const $s$ = getCurrentView();` instruction\n          this.parent.restoreViewVariable = variable(this.parent.freshReferenceName());\n        }\n\n        this.restoreViewVariable = this.parent.restoreViewVariable;\n      }\n    }\n  }, {\n    key: \"restoreViewStatement\",\n    value: function restoreViewStatement() {\n      var statements = [];\n\n      if (this.restoreViewVariable) {\n        var restoreCall = instruction(null, Identifiers.restoreView, [this.restoreViewVariable]); // Either `const restoredCtx = restoreView($state$);` or `restoreView($state$);`\n        // depending on whether it is being used.\n\n        statements.push(this.usesRestoredViewContext ? variable(RESTORED_VIEW_CONTEXT_NAME).set(restoreCall).toConstDecl() : restoreCall.toStmt());\n      }\n\n      return statements;\n    }\n  }, {\n    key: \"viewSnapshotStatements\",\n    value: function viewSnapshotStatements() {\n      // const $state$ = getCurrentView();\n      return this.restoreViewVariable ? [this.restoreViewVariable.set(instruction(null, Identifiers.getCurrentView, [])).toConstDecl()] : [];\n    }\n  }, {\n    key: \"isListenerScope\",\n    value: function isListenerScope() {\n      return this.parent && this.parent.bindingLevel === this.bindingLevel;\n    }\n  }, {\n    key: \"variableDeclarations\",\n    value: function variableDeclarations() {\n      var _this197 = this;\n\n      var currentContextLevel = 0;\n      return Array.from(this.map.values()).filter(function (value) {\n        return value.declare;\n      }).sort(function (a, b) {\n        return b.retrievalLevel - a.retrievalLevel || b.priority - a.priority;\n      }).reduce(function (stmts, value) {\n        var levelDiff = _this197.bindingLevel - value.retrievalLevel;\n        var currStmts = value.declareLocalCallback(_this197, levelDiff - currentContextLevel);\n        currentContextLevel = levelDiff;\n        return stmts.concat(currStmts);\n      }, []);\n    }\n  }, {\n    key: \"freshReferenceName\",\n    value: function freshReferenceName() {\n      var current = this; // Find the top scope as it maintains the global reference count\n\n      while (current.parent) {\n        current = current.parent;\n      }\n\n      var ref = \"\".concat(REFERENCE_PREFIX).concat(current.referenceNameIndex++);\n      return ref;\n    }\n  }, {\n    key: \"hasRestoreViewVariable\",\n    value: function hasRestoreViewVariable() {\n      return !!this.restoreViewVariable;\n    }\n  }, {\n    key: \"notifyRestoredViewContextUse\",\n    value: function notifyRestoredViewContextUse() {\n      this.usesRestoredViewContext = true;\n    }\n  }], [{\n    key: \"createRootScope\",\n    value: function createRootScope() {\n      return new BindingScope();\n    }\n  }]);\n\n  return BindingScope;\n}();\n/**\r\n * Creates a `CssSelector` given a tag name and a map of attributes\r\n */\n\n\nfunction createCssSelector(elementName, attributes) {\n  var cssSelector = new CssSelector();\n  var elementNameNoNs = splitNsName(elementName)[1];\n  cssSelector.setElement(elementNameNoNs);\n  Object.getOwnPropertyNames(attributes).forEach(function (name) {\n    var nameNoNs = splitNsName(name)[1];\n    var value = attributes[name];\n    cssSelector.addAttribute(nameNoNs, value);\n\n    if (name.toLowerCase() === 'class') {\n      var classes = value.trim().split(/\\s+/);\n      classes.forEach(function (className) {\n        return cssSelector.addClassName(className);\n      });\n    }\n  });\n  return cssSelector;\n}\n/**\r\n * Creates an array of expressions out of an `ngProjectAs` attributes\r\n * which can be added to the instruction parameters.\r\n */\n\n\nfunction getNgProjectAsLiteral(attribute) {\n  // Parse the attribute value into a CssSelectorList. Note that we only take the\n  // first selector, because we don't support multiple selectors in ngProjectAs.\n  var parsedR3Selector = parseSelectorToR3Selector(attribute.value)[0];\n  return [literal(5\n  /* ProjectAs */\n  ), asLiteral(parsedR3Selector)];\n}\n/**\r\n * Gets the instruction to generate for an interpolated property\r\n * @param interpolation An Interpolation AST\r\n */\n\n\nfunction getPropertyInterpolationExpression(interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return Identifiers.propertyInterpolate;\n\n    case 3:\n      return Identifiers.propertyInterpolate1;\n\n    case 5:\n      return Identifiers.propertyInterpolate2;\n\n    case 7:\n      return Identifiers.propertyInterpolate3;\n\n    case 9:\n      return Identifiers.propertyInterpolate4;\n\n    case 11:\n      return Identifiers.propertyInterpolate5;\n\n    case 13:\n      return Identifiers.propertyInterpolate6;\n\n    case 15:\n      return Identifiers.propertyInterpolate7;\n\n    case 17:\n      return Identifiers.propertyInterpolate8;\n\n    default:\n      return Identifiers.propertyInterpolateV;\n  }\n}\n/**\r\n * Gets the instruction to generate for an interpolated attribute\r\n * @param interpolation An Interpolation AST\r\n */\n\n\nfunction getAttributeInterpolationExpression(interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 3:\n      return Identifiers.attributeInterpolate1;\n\n    case 5:\n      return Identifiers.attributeInterpolate2;\n\n    case 7:\n      return Identifiers.attributeInterpolate3;\n\n    case 9:\n      return Identifiers.attributeInterpolate4;\n\n    case 11:\n      return Identifiers.attributeInterpolate5;\n\n    case 13:\n      return Identifiers.attributeInterpolate6;\n\n    case 15:\n      return Identifiers.attributeInterpolate7;\n\n    case 17:\n      return Identifiers.attributeInterpolate8;\n\n    default:\n      return Identifiers.attributeInterpolateV;\n  }\n}\n/**\r\n * Gets the instruction to generate for interpolated text.\r\n * @param interpolation An Interpolation AST\r\n */\n\n\nfunction getTextInterpolationExpression(interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return Identifiers.textInterpolate;\n\n    case 3:\n      return Identifiers.textInterpolate1;\n\n    case 5:\n      return Identifiers.textInterpolate2;\n\n    case 7:\n      return Identifiers.textInterpolate3;\n\n    case 9:\n      return Identifiers.textInterpolate4;\n\n    case 11:\n      return Identifiers.textInterpolate5;\n\n    case 13:\n      return Identifiers.textInterpolate6;\n\n    case 15:\n      return Identifiers.textInterpolate7;\n\n    case 17:\n      return Identifiers.textInterpolate8;\n\n    default:\n      return Identifiers.textInterpolateV;\n  }\n}\n/**\r\n * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.\r\n *\r\n * @param template text of the template to parse\r\n * @param templateUrl URL to use for source mapping of the parsed template\r\n * @param options options to modify how the template is parsed\r\n */\n\n\nfunction parseTemplate(template, templateUrl) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var interpolationConfig = options.interpolationConfig,\n      preserveWhitespaces = options.preserveWhitespaces,\n      enableI18nLegacyMessageIdFormat = options.enableI18nLegacyMessageIdFormat;\n  var bindingParser = makeBindingParser(interpolationConfig);\n  var htmlParser = new HtmlParser();\n  var parseResult = htmlParser.parse(template, templateUrl, Object.assign(Object.assign({\n    leadingTriviaChars: LEADING_TRIVIA_CHARS\n  }, options), {\n    tokenizeExpansionForms: true\n  }));\n\n  if (!options.alwaysAttemptHtmlToR3AstConversion && parseResult.errors && parseResult.errors.length > 0) {\n    var _parsedTemplate = {\n      interpolationConfig: interpolationConfig,\n      preserveWhitespaces: preserveWhitespaces,\n      errors: parseResult.errors,\n      nodes: [],\n      styleUrls: [],\n      styles: [],\n      ngContentSelectors: []\n    };\n\n    if (options.collectCommentNodes) {\n      _parsedTemplate.commentNodes = [];\n    }\n\n    return _parsedTemplate;\n  }\n\n  var rootNodes = parseResult.rootNodes; // process i18n meta information (scan attributes, generate ids)\n  // before we run whitespace removal process, because existing i18n\n  // extraction process (ng extract-i18n) relies on a raw content to generate\n  // message ids\n\n  var i18nMetaVisitor = new I18nMetaVisitor(interpolationConfig,\n  /* keepI18nAttrs */\n  !preserveWhitespaces, enableI18nLegacyMessageIdFormat);\n  var i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);\n\n  if (!options.alwaysAttemptHtmlToR3AstConversion && i18nMetaResult.errors && i18nMetaResult.errors.length > 0) {\n    var _parsedTemplate2 = {\n      interpolationConfig: interpolationConfig,\n      preserveWhitespaces: preserveWhitespaces,\n      errors: i18nMetaResult.errors,\n      nodes: [],\n      styleUrls: [],\n      styles: [],\n      ngContentSelectors: []\n    };\n\n    if (options.collectCommentNodes) {\n      _parsedTemplate2.commentNodes = [];\n    }\n\n    return _parsedTemplate2;\n  }\n\n  rootNodes = i18nMetaResult.rootNodes;\n\n  if (!preserveWhitespaces) {\n    rootNodes = visitAll$1(new WhitespaceVisitor(), rootNodes); // run i18n meta visitor again in case whitespaces are removed (because that might affect\n    // generated i18n message content) and first pass indicated that i18n content is present in a\n    // template. During this pass i18n IDs generated at the first pass will be preserved, so we can\n    // mimic existing extraction process (ng extract-i18n)\n\n    if (i18nMetaVisitor.hasI18nMeta) {\n      rootNodes = visitAll$1(new I18nMetaVisitor(interpolationConfig,\n      /* keepI18nAttrs */\n      false), rootNodes);\n    }\n  }\n\n  var _htmlAstToRender3Ast = htmlAstToRender3Ast(rootNodes, bindingParser, {\n    collectCommentNodes: !!options.collectCommentNodes\n  }),\n      nodes = _htmlAstToRender3Ast.nodes,\n      errors = _htmlAstToRender3Ast.errors,\n      styleUrls = _htmlAstToRender3Ast.styleUrls,\n      styles = _htmlAstToRender3Ast.styles,\n      ngContentSelectors = _htmlAstToRender3Ast.ngContentSelectors,\n      commentNodes = _htmlAstToRender3Ast.commentNodes;\n\n  errors.push.apply(errors, _toConsumableArray(parseResult.errors).concat(_toConsumableArray(i18nMetaResult.errors)));\n  var parsedTemplate = {\n    interpolationConfig: interpolationConfig,\n    preserveWhitespaces: preserveWhitespaces,\n    errors: errors.length > 0 ? errors : null,\n    nodes: nodes,\n    styleUrls: styleUrls,\n    styles: styles,\n    ngContentSelectors: ngContentSelectors\n  };\n\n  if (options.collectCommentNodes) {\n    parsedTemplate.commentNodes = commentNodes;\n  }\n\n  return parsedTemplate;\n}\n\nvar elementRegistry = new DomElementSchemaRegistry();\n/**\r\n * Construct a `BindingParser` with a default configuration.\r\n */\n\nfunction makeBindingParser() {\n  var interpolationConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_INTERPOLATION_CONFIG;\n  return new BindingParser(new IvyParser(new Lexer()), interpolationConfig, elementRegistry, null, []);\n}\n\nfunction resolveSanitizationFn(context, isAttribute) {\n  switch (context) {\n    case SecurityContext.HTML:\n      return importExpr(Identifiers.sanitizeHtml);\n\n    case SecurityContext.SCRIPT:\n      return importExpr(Identifiers.sanitizeScript);\n\n    case SecurityContext.STYLE:\n      // the compiler does not fill in an instruction for [style.prop?] binding\n      // values because the style algorithm knows internally what props are subject\n      // to sanitization (only [attr.style] values are explicitly sanitized)\n      return isAttribute ? importExpr(Identifiers.sanitizeStyle) : null;\n\n    case SecurityContext.URL:\n      return importExpr(Identifiers.sanitizeUrl);\n\n    case SecurityContext.RESOURCE_URL:\n      return importExpr(Identifiers.sanitizeResourceUrl);\n\n    default:\n      return null;\n  }\n}\n\nfunction trustedConstAttribute(tagName, attr) {\n  var value = asLiteral(attr.value);\n\n  if (isTrustedTypesSink(tagName, attr.name)) {\n    switch (elementRegistry.securityContext(tagName, attr.name,\n    /* isAttribute */\n    true)) {\n      case SecurityContext.HTML:\n        return taggedTemplate(importExpr(Identifiers.trustConstantHtml), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), undefined, attr.valueSpan);\n      // NB: no SecurityContext.SCRIPT here, as the corresponding tags are stripped by the compiler.\n\n      case SecurityContext.RESOURCE_URL:\n        return taggedTemplate(importExpr(Identifiers.trustConstantResourceUrl), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), undefined, attr.valueSpan);\n\n      default:\n        return value;\n    }\n  } else {\n    return value;\n  }\n}\n\nfunction isSingleElementTemplate(children) {\n  return children.length === 1 && children[0] instanceof Element;\n}\n\nfunction isTextNode(node) {\n  return node instanceof Text || node instanceof BoundText || node instanceof Icu;\n}\n\nfunction hasTextChildrenOnly(children) {\n  return children.every(isTextNode);\n}\n/** Name of the global variable that is used to determine if we use Closure translations or not */\n\n\nvar NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';\n/**\r\n * Generate statements that define a given translation message.\r\n *\r\n * ```\r\n * var I18N_1;\r\n * if (typeof ngI18nClosureMode !== undefined && ngI18nClosureMode) {\r\n *     var MSG_EXTERNAL_XXX = goog.getMsg(\r\n *          \"Some message with {$interpolation}!\",\r\n *          { \"interpolation\": \"\\uFFFD0\\uFFFD\" }\r\n *     );\r\n *     I18N_1 = MSG_EXTERNAL_XXX;\r\n * }\r\n * else {\r\n *     I18N_1 = $localize`Some message with ${'\\uFFFD0\\uFFFD'}!`;\r\n * }\r\n * ```\r\n *\r\n * @param message The original i18n AST message node\r\n * @param variable The variable that will be assigned the translation, e.g. `I18N_1`.\r\n * @param closureVar The variable for Closure `goog.getMsg` calls, e.g. `MSG_EXTERNAL_XXX`.\r\n * @param params Object mapping placeholder names to their values (e.g.\r\n * `{ \"interpolation\": \"\\uFFFD0\\uFFFD\" }`).\r\n * @param transformFn Optional transformation function that will be applied to the translation (e.g.\r\n * post-processing).\r\n * @returns An array of statements that defined a given translation.\r\n */\n\nfunction getTranslationDeclStmts(message, variable, closureVar) {\n  var params = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var transformFn = arguments.length > 4 ? arguments[4] : undefined;\n  var statements = [declareI18nVariable(variable), ifStmt(createClosureModeGuard(), createGoogleGetMsgStatements(variable, message, closureVar, i18nFormatPlaceholderNames(params,\n  /* useCamelCase */\n  true)), createLocalizeStatements(variable, message, i18nFormatPlaceholderNames(params,\n  /* useCamelCase */\n  false)))];\n\n  if (transformFn) {\n    statements.push(new ExpressionStatement(variable.set(transformFn(variable))));\n  }\n\n  return statements;\n}\n/**\r\n * Create the expression that will be used to guard the closure mode block\r\n * It is equivalent to:\r\n *\r\n * ```\r\n * typeof ngI18nClosureMode !== undefined && ngI18nClosureMode\r\n * ```\r\n */\n\n\nfunction createClosureModeGuard() {\n  return typeofExpr(variable(NG_I18N_CLOSURE_MODE)).notIdentical(literal('undefined', STRING_TYPE)).and(variable(NG_I18N_CLOSURE_MODE));\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n// This regex matches any binding names that contain the \"attr.\" prefix, e.g. \"attr.required\"\n// If there is a match, the first matching group will contain the attribute name to bind.\n\n\nvar ATTR_REGEX = /attr\\.([^\\]]+)/;\n\nfunction baseDirectiveFields(meta, constantPool, bindingParser) {\n  var definitionMap = new DefinitionMap();\n  var selectors = parseSelectorToR3Selector(meta.selector); // e.g. `type: MyDirective`\n\n  definitionMap.set('type', meta.internalType); // e.g. `selectors: [['', 'someDir', '']]`\n\n  if (selectors.length > 0) {\n    definitionMap.set('selectors', asLiteral(selectors));\n  }\n\n  if (meta.queries.length > 0) {\n    // e.g. `contentQueries: (rf, ctx, dirIndex) => { ... }\n    definitionMap.set('contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));\n  }\n\n  if (meta.viewQueries.length) {\n    definitionMap.set('viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));\n  } // e.g. `hostBindings: (rf, ctx) => { ... }\n\n\n  definitionMap.set('hostBindings', createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '', meta.name, definitionMap)); // e.g 'inputs: {a: 'a'}`\n\n  definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true)); // e.g 'outputs: {a: 'a'}`\n\n  definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));\n\n  if (meta.exportAs !== null) {\n    definitionMap.set('exportAs', literalArr(meta.exportAs.map(function (e) {\n      return literal(e);\n    })));\n  }\n\n  return definitionMap;\n}\n/**\r\n * Add features to the definition map.\r\n */\n\n\nfunction addFeatures(definitionMap, meta) {\n  // e.g. `features: [NgOnChangesFeature]`\n  var features = [];\n  var providers = meta.providers;\n  var viewProviders = meta.viewProviders;\n\n  if (providers || viewProviders) {\n    var args = [providers || new LiteralArrayExpr([])];\n\n    if (viewProviders) {\n      args.push(viewProviders);\n    }\n\n    features.push(importExpr(Identifiers.ProvidersFeature).callFn(args));\n  }\n\n  if (meta.usesInheritance) {\n    features.push(importExpr(Identifiers.InheritDefinitionFeature));\n  }\n\n  if (meta.fullInheritance) {\n    features.push(importExpr(Identifiers.CopyDefinitionFeature));\n  }\n\n  if (meta.lifecycle.usesOnChanges) {\n    features.push(importExpr(Identifiers.NgOnChangesFeature));\n  }\n\n  if (features.length) {\n    definitionMap.set('features', literalArr(features));\n  }\n}\n/**\r\n * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.\r\n */\n\n\nfunction compileDirectiveFromMetadata(meta, constantPool, bindingParser) {\n  var definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n  addFeatures(definitionMap, meta);\n  var expression = importExpr(Identifiers.defineDirective).callFn([definitionMap.toLiteralMap()], undefined, true);\n  var type = createDirectiveType(meta);\n  return {\n    expression: expression,\n    type: type,\n    statements: []\n  };\n}\n/**\r\n * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.\r\n */\n\n\nfunction compileComponentFromMetadata(meta, constantPool, bindingParser) {\n  var definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\n  addFeatures(definitionMap, meta);\n  var selector = meta.selector && CssSelector.parse(meta.selector);\n  var firstSelector = selector && selector[0]; // e.g. `attr: [\"class\", \".my.app\"]`\n  // This is optional an only included if the first selector of a component specifies attributes.\n\n  if (firstSelector) {\n    var selectorAttributes = firstSelector.getAttrs();\n\n    if (selectorAttributes.length) {\n      definitionMap.set('attrs', constantPool.getConstLiteral(literalArr(selectorAttributes.map(function (value) {\n        return value != null ? literal(value) : literal(undefined);\n      })),\n      /* forceShared */\n      true));\n    }\n  } // Generate the CSS matcher that recognize directive\n\n\n  var directiveMatcher = null;\n\n  if (meta.directives.length > 0) {\n    var matcher = new SelectorMatcher();\n\n    var _iterator20 = _createForOfIteratorHelper(meta.directives),\n        _step20;\n\n    try {\n      for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n        var _step20$value = _step20.value,\n            _selector = _step20$value.selector,\n            _type = _step20$value.type;\n        matcher.addSelectables(CssSelector.parse(_selector), _type);\n      }\n    } catch (err) {\n      _iterator20.e(err);\n    } finally {\n      _iterator20.f();\n    }\n\n    directiveMatcher = matcher;\n  } // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`\n\n\n  var templateTypeName = meta.name;\n  var templateName = templateTypeName ? \"\".concat(templateTypeName, \"_Template\") : null;\n  var directivesUsed = new Set();\n  var pipesUsed = new Set();\n  var changeDetection = meta.changeDetection;\n  var template = meta.template;\n  var templateBuilder = new TemplateDefinitionBuilder(constantPool, BindingScope.createRootScope(), 0, templateTypeName, null, null, templateName, directiveMatcher, directivesUsed, meta.pipes, pipesUsed, Identifiers.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);\n  var templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []); // We need to provide this so that dynamically generated components know what\n  // projected content blocks to pass through to the component when it is instantiated.\n\n  var ngContentSelectors = templateBuilder.getNgContentSelectors();\n\n  if (ngContentSelectors) {\n    definitionMap.set('ngContentSelectors', ngContentSelectors);\n  } // e.g. `decls: 2`\n\n\n  definitionMap.set('decls', literal(templateBuilder.getConstCount())); // e.g. `vars: 2`\n\n  definitionMap.set('vars', literal(templateBuilder.getVarCount())); // Generate `consts` section of ComponentDef:\n  // - either as an array:\n  //   `consts: [['one', 'two'], ['three', 'four']]`\n  // - or as a factory function in case additional statements are present (to support i18n):\n  //   `consts: function() { var i18n_0; if (ngI18nClosureMode) {...} else {...} return [i18n_0]; }`\n\n  var _templateBuilder$getC = templateBuilder.getConsts(),\n      constExpressions = _templateBuilder$getC.constExpressions,\n      prepareStatements = _templateBuilder$getC.prepareStatements;\n\n  if (constExpressions.length > 0) {\n    var constsExpr = literalArr(constExpressions); // Prepare statements are present - turn `consts` into a function.\n\n    if (prepareStatements.length > 0) {\n      constsExpr = fn([], [].concat(_toConsumableArray(prepareStatements), [new ReturnStatement(constsExpr)]));\n    }\n\n    definitionMap.set('consts', constsExpr);\n  }\n\n  definitionMap.set('template', templateFunctionExpression); // e.g. `directives: [MyDirective]`\n\n  if (directivesUsed.size) {\n    var directivesList = literalArr(Array.from(directivesUsed));\n    var directivesExpr = compileDeclarationList(directivesList, meta.declarationListEmitMode);\n    definitionMap.set('directives', directivesExpr);\n  } // e.g. `pipes: [MyPipe]`\n\n\n  if (pipesUsed.size) {\n    var pipesList = literalArr(Array.from(pipesUsed));\n    var pipesExpr = compileDeclarationList(pipesList, meta.declarationListEmitMode);\n    definitionMap.set('pipes', pipesExpr);\n  }\n\n  if (meta.encapsulation === null) {\n    meta.encapsulation = ViewEncapsulation.Emulated;\n  } // e.g. `styles: [str1, str2]`\n\n\n  if (meta.styles && meta.styles.length) {\n    var styleValues = meta.encapsulation == ViewEncapsulation.Emulated ? compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) : meta.styles;\n    var strings = styleValues.map(function (str) {\n      return constantPool.getConstLiteral(literal(str));\n    });\n    definitionMap.set('styles', literalArr(strings));\n  } else if (meta.encapsulation === ViewEncapsulation.Emulated) {\n    // If there is no style, don't generate css selectors on elements\n    meta.encapsulation = ViewEncapsulation.None;\n  } // Only set view encapsulation if it's not the default value\n\n\n  if (meta.encapsulation !== ViewEncapsulation.Emulated) {\n    definitionMap.set('encapsulation', literal(meta.encapsulation));\n  } // e.g. `animation: [trigger('123', [])]`\n\n\n  if (meta.animations !== null) {\n    definitionMap.set('data', literalMap([{\n      key: 'animation',\n      value: meta.animations,\n      quoted: false\n    }]));\n  } // Only set the change detection flag if it's defined and it's not the default.\n\n\n  if (changeDetection != null && changeDetection !== ChangeDetectionStrategy.Default) {\n    definitionMap.set('changeDetection', literal(changeDetection));\n  }\n\n  var expression = importExpr(Identifiers.defineComponent).callFn([definitionMap.toLiteralMap()], undefined, true);\n  var type = createComponentType(meta);\n  return {\n    expression: expression,\n    type: type,\n    statements: []\n  };\n}\n/**\r\n * Creates the type specification from the component meta. This type is inserted into .d.ts files\r\n * to be consumed by upstream compilations.\r\n */\n\n\nfunction createComponentType(meta) {\n  var typeParams = createDirectiveTypeParams(meta);\n  typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));\n  return expressionType(importExpr(Identifiers.ComponentDeclaration, typeParams));\n}\n/**\r\n * Compiles the array literal of declarations into an expression according to the provided emit\r\n * mode.\r\n */\n\n\nfunction compileDeclarationList(list, mode) {\n  switch (mode) {\n    case 0\n    /* Direct */\n    :\n      // directives: [MyDir],\n      return list;\n\n    case 1\n    /* Closure */\n    :\n      // directives: function () { return [MyDir]; }\n      return fn([], [new ReturnStatement(list)]);\n\n    case 2\n    /* ClosureResolved */\n    :\n      // directives: function () { return [MyDir].map(ng.resolveForwardRef); }\n      var resolvedList = list.callMethod('map', [importExpr(Identifiers.resolveForwardRef)]);\n      return fn([], [new ReturnStatement(resolvedList)]);\n  }\n}\n\nfunction prepareQueryParams(query, constantPool) {\n  var parameters = [getQueryPredicate(query, constantPool), literal(toQueryFlags(query))];\n\n  if (query.read) {\n    parameters.push(query.read);\n  }\n\n  return parameters;\n}\n/**\r\n * Translates query flags into `TQueryFlags` type in packages/core/src/render3/interfaces/query.ts\r\n * @param query\r\n */\n\n\nfunction toQueryFlags(query) {\n  return (query.descendants ? 1\n  /* descendants */\n  : 0\n  /* none */\n  ) | (query.static ? 2\n  /* isStatic */\n  : 0\n  /* none */\n  ) | (query.emitDistinctChangesOnly ? 4\n  /* emitDistinctChangesOnly */\n  : 0\n  /* none */\n  );\n}\n\nfunction convertAttributesToExpressions(attributes) {\n  var values = [];\n\n  var _iterator21 = _createForOfIteratorHelper(Object.getOwnPropertyNames(attributes)),\n      _step21;\n\n  try {\n    for (_iterator21.s(); !(_step21 = _iterator21.n()).done;) {\n      var key = _step21.value;\n      var value = attributes[key];\n      values.push(literal(key), value);\n    }\n  } catch (err) {\n    _iterator21.e(err);\n  } finally {\n    _iterator21.f();\n  }\n\n  return values;\n} // Define and update any content queries\n\n\nfunction createContentQueriesFunction(queries, constantPool, name) {\n  var createStatements = [];\n  var updateStatements = [];\n  var tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\n\n  var _iterator22 = _createForOfIteratorHelper(queries),\n      _step22;\n\n  try {\n    for (_iterator22.s(); !(_step22 = _iterator22.n()).done;) {\n      var query = _step22.value;\n      // creation, e.g. r3.contentQuery(dirIndex, somePredicate, true, null);\n      createStatements.push(importExpr(Identifiers.contentQuery).callFn([variable('dirIndex')].concat(_toConsumableArray(prepareQueryParams(query, constantPool)))).toStmt()); // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n\n      var temporary = tempAllocator();\n      var getQueryList = importExpr(Identifiers.loadQuery).callFn([]);\n      var refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);\n      var updateDirective = variable(CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop('first') : temporary);\n      updateStatements.push(refresh.and(updateDirective).toStmt());\n    }\n  } catch (err) {\n    _iterator22.e(err);\n  } finally {\n    _iterator22.f();\n  }\n\n  var contentQueriesFnName = name ? \"\".concat(name, \"_ContentQueries\") : null;\n  return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null), new FnParam('dirIndex', null)], [renderFlagCheckIfStmt(1\n  /* Create */\n  , createStatements), renderFlagCheckIfStmt(2\n  /* Update */\n  , updateStatements)], INFERRED_TYPE, null, contentQueriesFnName);\n}\n\nfunction stringAsType(str) {\n  return expressionType(literal(str));\n}\n\nfunction stringMapAsType(map) {\n  var mapValues = Object.keys(map).map(function (key) {\n    var value = Array.isArray(map[key]) ? map[key][0] : map[key];\n    return {\n      key: key,\n      value: literal(value),\n      quoted: true\n    };\n  });\n  return expressionType(literalMap(mapValues));\n}\n\nfunction stringArrayAsType(arr) {\n  return arr.length > 0 ? expressionType(literalArr(arr.map(function (value) {\n    return literal(value);\n  }))) : NONE_TYPE;\n}\n\nfunction createDirectiveTypeParams(meta) {\n  // On the type side, remove newlines from the selector as it will need to fit into a TypeScript\n  // string literal, which must be on one line.\n  var selectorForType = meta.selector !== null ? meta.selector.replace(/\\n/g, '') : null;\n  return [typeWithParameters(meta.type.type, meta.typeArgumentCount), selectorForType !== null ? stringAsType(selectorForType) : NONE_TYPE, meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : NONE_TYPE, stringMapAsType(meta.inputs), stringMapAsType(meta.outputs), stringArrayAsType(meta.queries.map(function (q) {\n    return q.propertyName;\n  }))];\n}\n/**\r\n * Creates the type specification from the directive meta. This type is inserted into .d.ts files\r\n * to be consumed by upstream compilations.\r\n */\n\n\nfunction createDirectiveType(meta) {\n  var typeParams = createDirectiveTypeParams(meta);\n  return expressionType(importExpr(Identifiers.DirectiveDeclaration, typeParams));\n} // Define and update any view queries\n\n\nfunction createViewQueriesFunction(viewQueries, constantPool, name) {\n  var createStatements = [];\n  var updateStatements = [];\n  var tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\n  viewQueries.forEach(function (query) {\n    // creation, e.g. r3.viewQuery(somePredicate, true);\n    var queryDefinition = importExpr(Identifiers.viewQuery).callFn(prepareQueryParams(query, constantPool));\n    createStatements.push(queryDefinition.toStmt()); // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\n\n    var temporary = tempAllocator();\n    var getQueryList = importExpr(Identifiers.loadQuery).callFn([]);\n    var refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);\n    var updateDirective = variable(CONTEXT_NAME).prop(query.propertyName).set(query.first ? temporary.prop('first') : temporary);\n    updateStatements.push(refresh.and(updateDirective).toStmt());\n  });\n  var viewQueryFnName = name ? \"\".concat(name, \"_Query\") : null;\n  return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [renderFlagCheckIfStmt(1\n  /* Create */\n  , createStatements), renderFlagCheckIfStmt(2\n  /* Update */\n  , updateStatements)], INFERRED_TYPE, null, viewQueryFnName);\n} // Return a host binding function or null if one is not necessary.\n\n\nfunction createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name, definitionMap) {\n  var bindingContext = variable(CONTEXT_NAME);\n  var styleBuilder = new StylingBuilder(bindingContext);\n  var _hostBindingsMetadata = hostBindingsMetadata.specialAttributes,\n      styleAttr = _hostBindingsMetadata.styleAttr,\n      classAttr = _hostBindingsMetadata.classAttr;\n\n  if (styleAttr !== undefined) {\n    styleBuilder.registerStyleAttr(styleAttr);\n  }\n\n  if (classAttr !== undefined) {\n    styleBuilder.registerClassAttr(classAttr);\n  }\n\n  var createStatements = [];\n  var updateStatements = [];\n  var hostBindingSourceSpan = typeSourceSpan;\n  var directiveSummary = metadataAsSummary(hostBindingsMetadata); // Calculate host event bindings\n\n  var eventBindings = bindingParser.createDirectiveHostEventAsts(directiveSummary, hostBindingSourceSpan);\n\n  if (eventBindings && eventBindings.length) {\n    var listeners = createHostListeners(eventBindings, name);\n    createStatements.push.apply(createStatements, _toConsumableArray(listeners));\n  } // Calculate the host property bindings\n\n\n  var bindings = bindingParser.createBoundHostProperties(directiveSummary, hostBindingSourceSpan);\n  var allOtherBindings = []; // We need to calculate the total amount of binding slots required by\n  // all the instructions together before any value conversions happen.\n  // Value conversions may require additional slots for interpolation and\n  // bindings with pipes. These calculates happen after this block.\n\n  var totalHostVarsCount = 0;\n  bindings && bindings.forEach(function (binding) {\n    var stylingInputWasSet = styleBuilder.registerInputBasedOnName(binding.name, binding.expression, hostBindingSourceSpan);\n\n    if (stylingInputWasSet) {\n      totalHostVarsCount += MIN_STYLING_BINDING_SLOTS_REQUIRED;\n    } else {\n      allOtherBindings.push(binding);\n      totalHostVarsCount++;\n    }\n  });\n  var valueConverter;\n\n  var getValueConverter = function getValueConverter() {\n    if (!valueConverter) {\n      var hostVarsCountFn = function hostVarsCountFn(numSlots) {\n        var originalVarsCount = totalHostVarsCount;\n        totalHostVarsCount += numSlots;\n        return originalVarsCount;\n      };\n\n      valueConverter = new ValueConverter(constantPool, function () {\n        return error('Unexpected node');\n      }, // new nodes are illegal here\n      hostVarsCountFn, function () {\n        return error('Unexpected pipe');\n      }); // pipes are illegal here\n    }\n\n    return valueConverter;\n  };\n\n  var propertyBindings = [];\n  var attributeBindings = [];\n  var syntheticHostBindings = [];\n  allOtherBindings.forEach(function (binding) {\n    // resolve literal arrays and literal objects\n    var value = binding.expression.visit(getValueConverter());\n    var bindingExpr = bindingFn(bindingContext, value);\n\n    var _getBindingNameAndIns = getBindingNameAndInstruction(binding),\n        bindingName = _getBindingNameAndIns.bindingName,\n        instruction = _getBindingNameAndIns.instruction,\n        isAttribute = _getBindingNameAndIns.isAttribute;\n\n    var securityContexts = bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute).filter(function (context) {\n      return context !== SecurityContext.NONE;\n    });\n    var sanitizerFn = null;\n\n    if (securityContexts.length) {\n      if (securityContexts.length === 2 && securityContexts.indexOf(SecurityContext.URL) > -1 && securityContexts.indexOf(SecurityContext.RESOURCE_URL) > -1) {\n        // Special case for some URL attributes (such as \"src\" and \"href\") that may be a part\n        // of different security contexts. In this case we use special sanitization function and\n        // select the actual sanitizer at runtime based on a tag name that is provided while\n        // invoking sanitization function.\n        sanitizerFn = importExpr(Identifiers.sanitizeUrlOrResourceUrl);\n      } else {\n        sanitizerFn = resolveSanitizationFn(securityContexts[0], isAttribute);\n      }\n    }\n\n    var instructionParams = [literal(bindingName), bindingExpr.currValExpr];\n\n    if (sanitizerFn) {\n      instructionParams.push(sanitizerFn);\n    }\n\n    updateStatements.push.apply(updateStatements, _toConsumableArray(bindingExpr.stmts));\n\n    if (instruction === Identifiers.hostProperty) {\n      propertyBindings.push(instructionParams);\n    } else if (instruction === Identifiers.attribute) {\n      attributeBindings.push(instructionParams);\n    } else if (instruction === Identifiers.syntheticHostProperty) {\n      syntheticHostBindings.push(instructionParams);\n    } else {\n      updateStatements.push(importExpr(instruction).callFn(instructionParams).toStmt());\n    }\n  });\n\n  if (propertyBindings.length > 0) {\n    updateStatements.push(chainedInstruction(Identifiers.hostProperty, propertyBindings).toStmt());\n  }\n\n  if (attributeBindings.length > 0) {\n    updateStatements.push(chainedInstruction(Identifiers.attribute, attributeBindings).toStmt());\n  }\n\n  if (syntheticHostBindings.length > 0) {\n    updateStatements.push(chainedInstruction(Identifiers.syntheticHostProperty, syntheticHostBindings).toStmt());\n  } // since we're dealing with directives/components and both have hostBinding\n  // functions, we need to generate a special hostAttrs instruction that deals\n  // with both the assignment of styling as well as static attributes to the host\n  // element. The instruction below will instruct all initial styling (styling\n  // that is inside of a host binding within a directive/component) to be attached\n  // to the host element alongside any of the provided host attributes that were\n  // collected earlier.\n\n\n  var hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);\n  styleBuilder.assignHostAttrs(hostAttrs, definitionMap);\n\n  if (styleBuilder.hasBindings) {\n    // finally each binding that was registered in the statement above will need to be added to\n    // the update block of a component/directive templateFn/hostBindingsFn so that the bindings\n    // are evaluated and updated for the element.\n    styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach(function (instruction) {\n      if (instruction.calls.length > 0) {\n        var calls = [];\n        instruction.calls.forEach(function (call) {\n          // we subtract a value of `1` here because the binding slot was already allocated\n          // at the top of this method when all the input bindings were counted.\n          totalHostVarsCount += Math.max(call.allocateBindingSlots - MIN_STYLING_BINDING_SLOTS_REQUIRED, 0);\n          calls.push(convertStylingCall(call, bindingContext, bindingFn));\n        });\n        updateStatements.push(chainedInstruction(instruction.reference, calls).toStmt());\n      }\n    });\n  }\n\n  if (totalHostVarsCount) {\n    definitionMap.set('hostVars', literal(totalHostVarsCount));\n  }\n\n  if (createStatements.length > 0 || updateStatements.length > 0) {\n    var hostBindingsFnName = name ? \"\".concat(name, \"_HostBindings\") : null;\n    var statements = [];\n\n    if (createStatements.length > 0) {\n      statements.push(renderFlagCheckIfStmt(1\n      /* Create */\n      , createStatements));\n    }\n\n    if (updateStatements.length > 0) {\n      statements.push(renderFlagCheckIfStmt(2\n      /* Update */\n      , updateStatements));\n    }\n\n    return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], statements, INFERRED_TYPE, null, hostBindingsFnName);\n  }\n\n  return null;\n}\n\nfunction bindingFn(implicit, value) {\n  return _convertPropertyBinding(null, implicit, value, 'b', BindingForm.Expression, function () {\n    return error('Unexpected interpolation');\n  });\n}\n\nfunction convertStylingCall(call, bindingContext, bindingFn) {\n  return call.params(function (value) {\n    return bindingFn(bindingContext, value).currValExpr;\n  });\n}\n\nfunction getBindingNameAndInstruction(binding) {\n  var bindingName = binding.name;\n  var instruction; // Check to see if this is an attr binding or a property binding\n\n  var attrMatches = bindingName.match(ATTR_REGEX);\n\n  if (attrMatches) {\n    bindingName = attrMatches[1];\n    instruction = Identifiers.attribute;\n  } else {\n    if (binding.isAnimation) {\n      bindingName = prepareSyntheticPropertyName(bindingName); // host bindings that have a synthetic property (e.g. @foo) should always be rendered\n      // in the context of the component and not the parent. Therefore there is a special\n      // compatibility instruction available for this purpose.\n\n      instruction = Identifiers.syntheticHostProperty;\n    } else {\n      instruction = Identifiers.hostProperty;\n    }\n  }\n\n  return {\n    bindingName: bindingName,\n    instruction: instruction,\n    isAttribute: !!attrMatches\n  };\n}\n\nfunction createHostListeners(eventBindings, name) {\n  var listeners = [];\n  var syntheticListeners = [];\n  var instructions = [];\n  eventBindings.forEach(function (binding) {\n    var bindingName = binding.name && sanitizeIdentifier(binding.name);\n    var bindingFnName = binding.type === 1\n    /* Animation */\n    ? prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) : bindingName;\n    var handlerName = name && bindingName ? \"\".concat(name, \"_\").concat(bindingFnName, \"_HostBindingHandler\") : null;\n    var params = prepareEventListenerParameters(BoundEvent.fromParsedEvent(binding), handlerName);\n\n    if (binding.type == 1\n    /* Animation */\n    ) {\n        syntheticListeners.push(params);\n      } else {\n      listeners.push(params);\n    }\n  });\n\n  if (syntheticListeners.length > 0) {\n    instructions.push(chainedInstruction(Identifiers.syntheticHostListener, syntheticListeners).toStmt());\n  }\n\n  if (listeners.length > 0) {\n    instructions.push(chainedInstruction(Identifiers.listener, listeners).toStmt());\n  }\n\n  return instructions;\n}\n\nfunction metadataAsSummary(meta) {\n  // clang-format off\n  return {\n    // This is used by the BindingParser, which only deals with listeners and properties. There's no\n    // need to pass attributes to it.\n    hostAttributes: {},\n    hostListeners: meta.listeners,\n    hostProperties: meta.properties\n  }; // clang-format on\n}\n\nvar HOST_REG_EXP$1 = /^(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\))$/;\n\nfunction parseHostBindings(host) {\n  var attributes = {};\n  var listeners = {};\n  var properties = {};\n  var specialAttributes = {};\n\n  for (var _i8 = 0, _Object$keys2 = Object.keys(host); _i8 < _Object$keys2.length; _i8++) {\n    var key = _Object$keys2[_i8];\n    var value = host[key];\n    var matches = key.match(HOST_REG_EXP$1);\n\n    if (matches === null) {\n      switch (key) {\n        case 'class':\n          if (typeof value !== 'string') {\n            // TODO(alxhub): make this a diagnostic.\n            throw new Error(\"Class binding must be string\");\n          }\n\n          specialAttributes.classAttr = value;\n          break;\n\n        case 'style':\n          if (typeof value !== 'string') {\n            // TODO(alxhub): make this a diagnostic.\n            throw new Error(\"Style binding must be string\");\n          }\n\n          specialAttributes.styleAttr = value;\n          break;\n\n        default:\n          if (typeof value === 'string') {\n            attributes[key] = literal(value);\n          } else {\n            attributes[key] = value;\n          }\n\n      }\n    } else if (matches[1\n    /* Binding */\n    ] != null) {\n      if (typeof value !== 'string') {\n        // TODO(alxhub): make this a diagnostic.\n        throw new Error(\"Property binding must be string\");\n      } // synthetic properties (the ones that have a `@` as a prefix)\n      // are still treated the same as regular properties. Therefore\n      // there is no point in storing them in a separate map.\n\n\n      properties[matches[1\n      /* Binding */\n      ]] = value;\n    } else if (matches[2\n    /* Event */\n    ] != null) {\n      if (typeof value !== 'string') {\n        // TODO(alxhub): make this a diagnostic.\n        throw new Error(\"Event binding must be string\");\n      }\n\n      listeners[matches[2\n      /* Event */\n      ]] = value;\n    }\n  }\n\n  return {\n    attributes: attributes,\n    listeners: listeners,\n    properties: properties,\n    specialAttributes: specialAttributes\n  };\n}\n/**\r\n * Verifies host bindings and returns the list of errors (if any). Empty array indicates that a\r\n * given set of host bindings has no errors.\r\n *\r\n * @param bindings set of host bindings to verify.\r\n * @param sourceSpan source span where host bindings were defined.\r\n * @returns array of errors associated with a given set of host bindings.\r\n */\n\n\nfunction verifyHostBindings(bindings, sourceSpan) {\n  var summary = metadataAsSummary(bindings); // TODO: abstract out host bindings verification logic and use it instead of\n  // creating events and properties ASTs to detect errors (FW-996)\n\n  var bindingParser = makeBindingParser();\n  bindingParser.createDirectiveHostEventAsts(summary, sourceSpan);\n  bindingParser.createBoundHostProperties(summary, sourceSpan);\n  return bindingParser.errors;\n}\n\nfunction compileStyles(styles, selector, hostSelector) {\n  var shadowCss = new ShadowCss();\n  return styles.map(function (style) {\n    return shadowCss.shimCssText(style, selector, hostSelector);\n  });\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * An interface for retrieving documents by URL that the compiler uses\r\n * to load templates.\r\n */\n\n\nvar ResourceLoader = /*#__PURE__*/function () {\n  function ResourceLoader() {\n    _classCallCheck(this, ResourceLoader);\n  }\n\n  _createClass(ResourceLoader, [{\n    key: \"get\",\n    value: function get(url) {\n      return '';\n    }\n  }]);\n\n  return ResourceLoader;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar CompilerFacadeImpl = /*#__PURE__*/function () {\n  function CompilerFacadeImpl() {\n    var jitEvaluator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new JitEvaluator();\n\n    _classCallCheck(this, CompilerFacadeImpl);\n\n    this.jitEvaluator = jitEvaluator;\n    this.FactoryTarget = FactoryTarget;\n    this.ResourceLoader = ResourceLoader;\n    this.elementSchemaRegistry = new DomElementSchemaRegistry();\n  }\n\n  _createClass(CompilerFacadeImpl, [{\n    key: \"compilePipe\",\n    value: function compilePipe(angularCoreEnv, sourceMapUrl, facade) {\n      var metadata = {\n        name: facade.name,\n        type: wrapReference(facade.type),\n        internalType: new WrappedNodeExpr(facade.type),\n        typeArgumentCount: 0,\n        deps: null,\n        pipeName: facade.pipeName,\n        pure: facade.pure\n      };\n      var res = compilePipeFromMetadata(metadata);\n      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n  }, {\n    key: \"compilePipeDeclaration\",\n    value: function compilePipeDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n      var meta = convertDeclarePipeFacadeToMetadata(declaration);\n      var res = compilePipeFromMetadata(meta);\n      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n  }, {\n    key: \"compileInjectable\",\n    value: function compileInjectable(angularCoreEnv, sourceMapUrl, facade) {\n      var _a;\n\n      var _compileInjectable2 = _compileInjectable({\n        name: facade.name,\n        type: wrapReference(facade.type),\n        internalType: new WrappedNodeExpr(facade.type),\n        typeArgumentCount: facade.typeArgumentCount,\n        providedIn: computeProvidedIn(facade.providedIn),\n        useClass: convertToProviderExpression(facade, USE_CLASS),\n        useFactory: wrapExpression(facade, USE_FACTORY),\n        useValue: convertToProviderExpression(facade, USE_VALUE),\n        useExisting: convertToProviderExpression(facade, USE_EXISTING),\n        deps: (_a = facade.deps) === null || _a === void 0 ? void 0 : _a.map(convertR3DependencyMetadata)\n      },\n      /* resolveForwardRefs */\n      true),\n          expression = _compileInjectable2.expression,\n          statements = _compileInjectable2.statements;\n\n      return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n    }\n  }, {\n    key: \"compileInjectableDeclaration\",\n    value: function compileInjectableDeclaration(angularCoreEnv, sourceMapUrl, facade) {\n      var _a;\n\n      var _compileInjectable3 = _compileInjectable({\n        name: facade.type.name,\n        type: wrapReference(facade.type),\n        internalType: new WrappedNodeExpr(facade.type),\n        typeArgumentCount: 0,\n        providedIn: computeProvidedIn(facade.providedIn),\n        useClass: convertToProviderExpression(facade, USE_CLASS),\n        useFactory: wrapExpression(facade, USE_FACTORY),\n        useValue: convertToProviderExpression(facade, USE_VALUE),\n        useExisting: convertToProviderExpression(facade, USE_EXISTING),\n        deps: (_a = facade.deps) === null || _a === void 0 ? void 0 : _a.map(convertR3DeclareDependencyMetadata)\n      },\n      /* resolveForwardRefs */\n      true),\n          expression = _compileInjectable3.expression,\n          statements = _compileInjectable3.statements;\n\n      return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\n    }\n  }, {\n    key: \"compileInjector\",\n    value: function compileInjector(angularCoreEnv, sourceMapUrl, facade) {\n      var meta = {\n        name: facade.name,\n        type: wrapReference(facade.type),\n        internalType: new WrappedNodeExpr(facade.type),\n        providers: new WrappedNodeExpr(facade.providers),\n        imports: facade.imports.map(function (i) {\n          return new WrappedNodeExpr(i);\n        })\n      };\n\n      var res = _compileInjector(meta);\n\n      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n  }, {\n    key: \"compileInjectorDeclaration\",\n    value: function compileInjectorDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n      var meta = convertDeclareInjectorFacadeToMetadata(declaration);\n\n      var res = _compileInjector(meta);\n\n      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n  }, {\n    key: \"compileNgModule\",\n    value: function compileNgModule(angularCoreEnv, sourceMapUrl, facade) {\n      var meta = {\n        type: wrapReference(facade.type),\n        internalType: new WrappedNodeExpr(facade.type),\n        adjacentType: new WrappedNodeExpr(facade.type),\n        bootstrap: facade.bootstrap.map(wrapReference),\n        declarations: facade.declarations.map(wrapReference),\n        imports: facade.imports.map(wrapReference),\n        exports: facade.exports.map(wrapReference),\n        emitInline: true,\n        containsForwardDecls: false,\n        schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,\n        id: facade.id ? new WrappedNodeExpr(facade.id) : null\n      };\n\n      var res = _compileNgModule(meta);\n\n      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\n    }\n  }, {\n    key: \"compileNgModuleDeclaration\",\n    value: function compileNgModuleDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n      var expression = compileNgModuleDeclarationExpression(declaration);\n      return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, []);\n    }\n  }, {\n    key: \"compileDirective\",\n    value: function compileDirective(angularCoreEnv, sourceMapUrl, facade) {\n      var meta = convertDirectiveFacadeToMetadata(facade);\n      return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n    }\n  }, {\n    key: \"compileDirectiveDeclaration\",\n    value: function compileDirectiveDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n      var typeSourceSpan = this.createParseSourceSpan('Directive', declaration.type.name, sourceMapUrl);\n      var meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);\n      return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\n    }\n  }, {\n    key: \"compileDirectiveFromMeta\",\n    value: function compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta) {\n      var constantPool = new ConstantPool();\n      var bindingParser = makeBindingParser();\n      var res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);\n      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n    }\n  }, {\n    key: \"compileComponent\",\n    value: function compileComponent(angularCoreEnv, sourceMapUrl, facade) {\n      // Parse the template and check for errors.\n      var _parseJitTemplate = parseJitTemplate(facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces, facade.interpolation),\n          template = _parseJitTemplate.template,\n          interpolation = _parseJitTemplate.interpolation; // Compile the component metadata, including template, into an expression.\n\n\n      var meta = Object.assign(Object.assign(Object.assign({}, facade), convertDirectiveFacadeToMetadata(facade)), {\n        selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(),\n        template: template,\n        declarationListEmitMode: 0\n        /* Direct */\n        ,\n        styles: [].concat(_toConsumableArray(facade.styles), _toConsumableArray(template.styles)),\n        encapsulation: facade.encapsulation,\n        interpolation: interpolation,\n        changeDetection: facade.changeDetection,\n        animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null,\n        viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) : null,\n        relativeContextFilePath: '',\n        i18nUseExternalIds: true\n      });\n      var jitExpressionSourceMap = \"ng:///\".concat(facade.name, \".js\");\n      return this.compileComponentFromMeta(angularCoreEnv, jitExpressionSourceMap, meta);\n    }\n  }, {\n    key: \"compileComponentDeclaration\",\n    value: function compileComponentDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\n      var typeSourceSpan = this.createParseSourceSpan('Component', declaration.type.name, sourceMapUrl);\n      var meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);\n      return this.compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta);\n    }\n  }, {\n    key: \"compileComponentFromMeta\",\n    value: function compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta) {\n      var constantPool = new ConstantPool();\n      var bindingParser = makeBindingParser(meta.interpolation);\n      var res = compileComponentFromMetadata(meta, constantPool, bindingParser);\n      return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\n    }\n  }, {\n    key: \"compileFactory\",\n    value: function compileFactory(angularCoreEnv, sourceMapUrl, meta) {\n      var factoryRes = compileFactoryFunction({\n        name: meta.name,\n        type: wrapReference(meta.type),\n        internalType: new WrappedNodeExpr(meta.type),\n        typeArgumentCount: meta.typeArgumentCount,\n        deps: convertR3DependencyMetadataArray(meta.deps),\n        target: meta.target\n      });\n      return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n    }\n  }, {\n    key: \"compileFactoryDeclaration\",\n    value: function compileFactoryDeclaration(angularCoreEnv, sourceMapUrl, meta) {\n      var factoryRes = compileFactoryFunction({\n        name: meta.type.name,\n        type: wrapReference(meta.type),\n        internalType: new WrappedNodeExpr(meta.type),\n        typeArgumentCount: 0,\n        deps: meta.deps && meta.deps.map(convertR3DeclareDependencyMetadata),\n        target: meta.target\n      });\n      return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\n    }\n  }, {\n    key: \"createParseSourceSpan\",\n    value: function createParseSourceSpan(kind, typeName, sourceUrl) {\n      return r3JitTypeSourceSpan(kind, typeName, sourceUrl);\n    }\n    /**\r\n     * JIT compiles an expression and returns the result of executing that expression.\r\n     *\r\n     * @param def the definition which will be compiled and executed to get the value to patch\r\n     * @param context an object map of @angular/core symbol names to symbols which will be available\r\n     * in the context of the compiled expression\r\n     * @param sourceUrl a URL to use for the source map of the compiled expression\r\n     * @param preStatements a collection of statements that should be evaluated before the expression.\r\n     */\n\n  }, {\n    key: \"jitExpression\",\n    value: function jitExpression(def, context, sourceUrl, preStatements) {\n      // The ConstantPool may contain Statements which declare variables used in the final expression.\n      // Therefore, its statements need to precede the actual JIT operation. The final statement is a\n      // declaration of $def which is set to the expression being compiled.\n      var statements = [].concat(_toConsumableArray(preStatements), [new DeclareVarStmt('$def', def, undefined, [StmtModifier.Exported])]);\n      var res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new R3JitReflector(context),\n      /* enableSourceMaps */\n      true);\n      return res['$def'];\n    }\n  }]);\n\n  return CompilerFacadeImpl;\n}();\n\nvar USE_CLASS = Object.keys({\n  useClass: null\n})[0];\nvar USE_FACTORY = Object.keys({\n  useFactory: null\n})[0];\nvar USE_VALUE = Object.keys({\n  useValue: null\n})[0];\nvar USE_EXISTING = Object.keys({\n  useExisting: null\n})[0];\n\nfunction convertToR3QueryMetadata(facade) {\n  return Object.assign(Object.assign({}, facade), {\n    predicate: Array.isArray(facade.predicate) ? facade.predicate : new WrappedNodeExpr(facade.predicate),\n    read: facade.read ? new WrappedNodeExpr(facade.read) : null,\n    static: facade.static,\n    emitDistinctChangesOnly: facade.emitDistinctChangesOnly\n  });\n}\n\nfunction convertQueryDeclarationToMetadata(declaration) {\n  var _a, _b, _c, _d;\n\n  return {\n    propertyName: declaration.propertyName,\n    first: (_a = declaration.first) !== null && _a !== void 0 ? _a : false,\n    predicate: Array.isArray(declaration.predicate) ? declaration.predicate : new WrappedNodeExpr(declaration.predicate),\n    descendants: (_b = declaration.descendants) !== null && _b !== void 0 ? _b : false,\n    read: declaration.read ? new WrappedNodeExpr(declaration.read) : null,\n    static: (_c = declaration.static) !== null && _c !== void 0 ? _c : false,\n    emitDistinctChangesOnly: (_d = declaration.emitDistinctChangesOnly) !== null && _d !== void 0 ? _d : true\n  };\n}\n\nfunction convertDirectiveFacadeToMetadata(facade) {\n  var inputsFromMetadata = parseInputOutputs(facade.inputs || []);\n  var outputsFromMetadata = parseInputOutputs(facade.outputs || []);\n  var propMetadata = facade.propMetadata;\n  var inputsFromType = {};\n  var outputsFromType = {};\n\n  var _loop = function _loop(field) {\n    if (propMetadata.hasOwnProperty(field)) {\n      propMetadata[field].forEach(function (ann) {\n        if (isInput(ann)) {\n          inputsFromType[field] = ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;\n        } else if (isOutput(ann)) {\n          outputsFromType[field] = ann.bindingPropertyName || field;\n        }\n      });\n    }\n  };\n\n  for (var field in propMetadata) {\n    _loop(field);\n  }\n\n  return Object.assign(Object.assign({}, facade), {\n    typeArgumentCount: 0,\n    typeSourceSpan: facade.typeSourceSpan,\n    type: wrapReference(facade.type),\n    internalType: new WrappedNodeExpr(facade.type),\n    deps: null,\n    host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host),\n    inputs: Object.assign(Object.assign({}, inputsFromMetadata), inputsFromType),\n    outputs: Object.assign(Object.assign({}, outputsFromMetadata), outputsFromType),\n    queries: facade.queries.map(convertToR3QueryMetadata),\n    providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null,\n    viewQueries: facade.viewQueries.map(convertToR3QueryMetadata),\n    fullInheritance: false\n  });\n}\n\nfunction convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan) {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    typeSourceSpan: typeSourceSpan,\n    internalType: new WrappedNodeExpr(declaration.type),\n    selector: (_a = declaration.selector) !== null && _a !== void 0 ? _a : null,\n    inputs: (_b = declaration.inputs) !== null && _b !== void 0 ? _b : {},\n    outputs: (_c = declaration.outputs) !== null && _c !== void 0 ? _c : {},\n    host: convertHostDeclarationToMetadata(declaration.host),\n    queries: ((_d = declaration.queries) !== null && _d !== void 0 ? _d : []).map(convertQueryDeclarationToMetadata),\n    viewQueries: ((_e = declaration.viewQueries) !== null && _e !== void 0 ? _e : []).map(convertQueryDeclarationToMetadata),\n    providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) : null,\n    exportAs: (_f = declaration.exportAs) !== null && _f !== void 0 ? _f : null,\n    usesInheritance: (_g = declaration.usesInheritance) !== null && _g !== void 0 ? _g : false,\n    lifecycle: {\n      usesOnChanges: (_h = declaration.usesOnChanges) !== null && _h !== void 0 ? _h : false\n    },\n    deps: null,\n    typeArgumentCount: 0,\n    fullInheritance: false\n  };\n}\n\nfunction convertHostDeclarationToMetadata() {\n  var host = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var _a, _b, _c;\n\n  return {\n    attributes: convertOpaqueValuesToExpressions((_a = host.attributes) !== null && _a !== void 0 ? _a : {}),\n    listeners: (_b = host.listeners) !== null && _b !== void 0 ? _b : {},\n    properties: (_c = host.properties) !== null && _c !== void 0 ? _c : {},\n    specialAttributes: {\n      classAttr: host.classAttribute,\n      styleAttr: host.styleAttribute\n    }\n  };\n}\n\nfunction convertOpaqueValuesToExpressions(obj) {\n  var result = {};\n\n  for (var _i9 = 0, _Object$keys3 = Object.keys(obj); _i9 < _Object$keys3.length; _i9++) {\n    var key = _Object$keys3[_i9];\n    result[key] = new WrappedNodeExpr(obj[key]);\n  }\n\n  return result;\n}\n\nfunction convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl) {\n  var _a, _b, _c, _d, _e, _f;\n\n  var _parseJitTemplate2 = parseJitTemplate(declaration.template, declaration.type.name, sourceMapUrl, (_a = declaration.preserveWhitespaces) !== null && _a !== void 0 ? _a : false, declaration.interpolation),\n      template = _parseJitTemplate2.template,\n      interpolation = _parseJitTemplate2.interpolation;\n\n  return Object.assign(Object.assign({}, convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan)), {\n    template: template,\n    styles: (_b = declaration.styles) !== null && _b !== void 0 ? _b : [],\n    directives: ((_c = declaration.components) !== null && _c !== void 0 ? _c : []).concat((_d = declaration.directives) !== null && _d !== void 0 ? _d : []).map(convertUsedDirectiveDeclarationToMetadata),\n    pipes: convertUsedPipesToMetadata(declaration.pipes),\n    viewProviders: declaration.viewProviders !== undefined ? new WrappedNodeExpr(declaration.viewProviders) : null,\n    animations: declaration.animations !== undefined ? new WrappedNodeExpr(declaration.animations) : null,\n    changeDetection: (_e = declaration.changeDetection) !== null && _e !== void 0 ? _e : ChangeDetectionStrategy.Default,\n    encapsulation: (_f = declaration.encapsulation) !== null && _f !== void 0 ? _f : ViewEncapsulation.Emulated,\n    interpolation: interpolation,\n    declarationListEmitMode: 2\n    /* ClosureResolved */\n    ,\n    relativeContextFilePath: '',\n    i18nUseExternalIds: true\n  });\n}\n\nfunction convertUsedDirectiveDeclarationToMetadata(declaration) {\n  var _a, _b, _c;\n\n  return {\n    selector: declaration.selector,\n    type: new WrappedNodeExpr(declaration.type),\n    inputs: (_a = declaration.inputs) !== null && _a !== void 0 ? _a : [],\n    outputs: (_b = declaration.outputs) !== null && _b !== void 0 ? _b : [],\n    exportAs: (_c = declaration.exportAs) !== null && _c !== void 0 ? _c : null\n  };\n}\n\nfunction convertUsedPipesToMetadata(declaredPipes) {\n  var pipes = new Map();\n\n  if (declaredPipes === undefined) {\n    return pipes;\n  }\n\n  for (var _i10 = 0, _Object$keys4 = Object.keys(declaredPipes); _i10 < _Object$keys4.length; _i10++) {\n    var pipeName = _Object$keys4[_i10];\n    var pipeType = declaredPipes[pipeName];\n    pipes.set(pipeName, new WrappedNodeExpr(pipeType));\n  }\n\n  return pipes;\n}\n\nfunction parseJitTemplate(template, typeName, sourceMapUrl, preserveWhitespaces, interpolation) {\n  var interpolationConfig = interpolation ? InterpolationConfig.fromArray(interpolation) : DEFAULT_INTERPOLATION_CONFIG; // Parse the template and check for errors.\n\n  var parsed = parseTemplate(template, sourceMapUrl, {\n    preserveWhitespaces: preserveWhitespaces,\n    interpolationConfig: interpolationConfig\n  });\n\n  if (parsed.errors !== null) {\n    var errors = parsed.errors.map(function (err) {\n      return err.toString();\n    }).join(', ');\n    throw new Error(\"Errors during JIT compilation of template for \".concat(typeName, \": \").concat(errors));\n  }\n\n  return {\n    template: parsed,\n    interpolation: interpolationConfig\n  };\n}\n/**\r\n * Convert the expression, if present to an `R3ProviderExpression`.\r\n *\r\n * In JIT mode we do not want the compiler to wrap the expression in a `forwardRef()` call because,\r\n * if it is referencing a type that has not yet been defined, it will have already been wrapped in\r\n * a `forwardRef()` - either by the application developer or during partial-compilation. Thus we can\r\n * set `isForwardRef` to `false`.\r\n */\n\n\nfunction convertToProviderExpression(obj, property) {\n  if (obj.hasOwnProperty(property)) {\n    return createR3ProviderExpression(new WrappedNodeExpr(obj[property]),\n    /* isForwardRef */\n    false);\n  } else {\n    return undefined;\n  }\n}\n\nfunction wrapExpression(obj, property) {\n  if (obj.hasOwnProperty(property)) {\n    return new WrappedNodeExpr(obj[property]);\n  } else {\n    return undefined;\n  }\n}\n\nfunction computeProvidedIn(providedIn) {\n  var expression = providedIn == null || typeof providedIn === 'string' ? new LiteralExpr(providedIn !== null && providedIn !== void 0 ? providedIn : null) : new WrappedNodeExpr(providedIn); // See `convertToProviderExpression()` for why `isForwardRef` is false.\n\n  return createR3ProviderExpression(expression,\n  /* isForwardRef */\n  false);\n}\n\nfunction convertR3DependencyMetadataArray(facades) {\n  return facades == null ? null : facades.map(convertR3DependencyMetadata);\n}\n\nfunction convertR3DependencyMetadata(facade) {\n  var isAttributeDep = facade.attribute != null; // both `null` and `undefined`\n\n  var rawToken = facade.token === null ? null : new WrappedNodeExpr(facade.token); // In JIT mode, if the dep is an `@Attribute()` then we use the attribute name given in\n  // `attribute` rather than the `token`.\n\n  var token = isAttributeDep ? new WrappedNodeExpr(facade.attribute) : rawToken;\n  return createR3DependencyMetadata(token, isAttributeDep, facade.host, facade.optional, facade.self, facade.skipSelf);\n}\n\nfunction convertR3DeclareDependencyMetadata(facade) {\n  var _a, _b, _c, _d, _e;\n\n  var isAttributeDep = (_a = facade.attribute) !== null && _a !== void 0 ? _a : false;\n  var token = facade.token === null ? null : new WrappedNodeExpr(facade.token);\n  return createR3DependencyMetadata(token, isAttributeDep, (_b = facade.host) !== null && _b !== void 0 ? _b : false, (_c = facade.optional) !== null && _c !== void 0 ? _c : false, (_d = facade.self) !== null && _d !== void 0 ? _d : false, (_e = facade.skipSelf) !== null && _e !== void 0 ? _e : false);\n}\n\nfunction createR3DependencyMetadata(token, isAttributeDep, host, optional, self, skipSelf) {\n  // If the dep is an `@Attribute()` the `attributeNameType` ought to be the `unknown` type.\n  // But types are not available at runtime so we just use a literal `\"<unknown>\"` string as a dummy\n  // marker.\n  var attributeNameType = isAttributeDep ? literal('unknown') : null;\n  return {\n    token: token,\n    attributeNameType: attributeNameType,\n    host: host,\n    optional: optional,\n    self: self,\n    skipSelf: skipSelf\n  };\n}\n\nfunction extractHostBindings(propMetadata, sourceSpan, host) {\n  // First parse the declarations from the metadata.\n  var bindings = parseHostBindings(host || {}); // After that check host bindings for errors\n\n  var errors = verifyHostBindings(bindings, sourceSpan);\n\n  if (errors.length) {\n    throw new Error(errors.map(function (error) {\n      return error.msg;\n    }).join('\\n'));\n  } // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.\n\n\n  var _loop2 = function _loop2(field) {\n    if (propMetadata.hasOwnProperty(field)) {\n      propMetadata[field].forEach(function (ann) {\n        if (isHostBinding(ann)) {\n          // Since this is a decorator, we know that the value is a class member. Always access it\n          // through `this` so that further down the line it can't be confused for a literal value\n          // (e.g. if there's a property called `true`).\n          bindings.properties[ann.hostPropertyName || field] = getSafePropertyAccessString('this', field);\n        } else if (isHostListener(ann)) {\n          bindings.listeners[ann.eventName || field] = \"\".concat(field, \"(\").concat((ann.args || []).join(','), \")\");\n        }\n      });\n    }\n  };\n\n  for (var field in propMetadata) {\n    _loop2(field);\n  }\n\n  return bindings;\n}\n\nfunction isHostBinding(value) {\n  return value.ngMetadataName === 'HostBinding';\n}\n\nfunction isHostListener(value) {\n  return value.ngMetadataName === 'HostListener';\n}\n\nfunction isInput(value) {\n  return value.ngMetadataName === 'Input';\n}\n\nfunction isOutput(value) {\n  return value.ngMetadataName === 'Output';\n}\n\nfunction parseInputOutputs(values) {\n  return values.reduce(function (map, value) {\n    var _value$split$map = value.split(',').map(function (piece) {\n      return piece.trim();\n    }),\n        _value$split$map2 = _slicedToArray(_value$split$map, 2),\n        field = _value$split$map2[0],\n        property = _value$split$map2[1];\n\n    map[field] = property || field;\n    return map;\n  }, {});\n}\n\nfunction convertDeclarePipeFacadeToMetadata(declaration) {\n  var _a;\n\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    internalType: new WrappedNodeExpr(declaration.type),\n    typeArgumentCount: 0,\n    pipeName: declaration.name,\n    deps: null,\n    pure: (_a = declaration.pure) !== null && _a !== void 0 ? _a : true\n  };\n}\n\nfunction convertDeclareInjectorFacadeToMetadata(declaration) {\n  return {\n    name: declaration.type.name,\n    type: wrapReference(declaration.type),\n    internalType: new WrappedNodeExpr(declaration.type),\n    providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) : null,\n    imports: declaration.imports !== undefined ? declaration.imports.map(function (i) {\n      return new WrappedNodeExpr(i);\n    }) : []\n  };\n}\n\nfunction publishFacade(global) {\n  var ng = global.ng || (global.ng = {});\n  ng.ɵcompilerFacade = new CompilerFacadeImpl();\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar VERSION$1 = new Version('12.1.0');\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\nvar CompilerConfig = function CompilerConfig() {\n  var _ref21 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref21$defaultEncapsu = _ref21.defaultEncapsulation,\n      defaultEncapsulation = _ref21$defaultEncapsu === void 0 ? ViewEncapsulation.Emulated : _ref21$defaultEncapsu,\n      _ref21$useJit = _ref21.useJit,\n      useJit = _ref21$useJit === void 0 ? true : _ref21$useJit,\n      _ref21$jitDevMode = _ref21.jitDevMode,\n      jitDevMode = _ref21$jitDevMode === void 0 ? false : _ref21$jitDevMode,\n      _ref21$missingTransla = _ref21.missingTranslation,\n      missingTranslation = _ref21$missingTransla === void 0 ? null : _ref21$missingTransla,\n      preserveWhitespaces = _ref21.preserveWhitespaces,\n      strictInjectionParameters = _ref21.strictInjectionParameters;\n\n  _classCallCheck(this, CompilerConfig);\n\n  this.defaultEncapsulation = defaultEncapsulation;\n  this.useJit = !!useJit;\n  this.jitDevMode = !!jitDevMode;\n  this.missingTranslation = missingTranslation;\n  this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));\n  this.strictInjectionParameters = strictInjectionParameters === true;\n};\n\nfunction preserveWhitespacesDefault(preserveWhitespacesOption) {\n  var defaultSetting = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar DirectiveNormalizer = /*#__PURE__*/function () {\n  function DirectiveNormalizer(_resourceLoader, _urlResolver, _htmlParser, _config) {\n    _classCallCheck(this, DirectiveNormalizer);\n\n    this._resourceLoader = _resourceLoader;\n    this._urlResolver = _urlResolver;\n    this._htmlParser = _htmlParser;\n    this._config = _config;\n    this._resourceLoaderCache = new Map();\n  }\n\n  _createClass(DirectiveNormalizer, [{\n    key: \"clearCache\",\n    value: function clearCache() {\n      this._resourceLoaderCache.clear();\n    }\n  }, {\n    key: \"clearCacheFor\",\n    value: function clearCacheFor(normalizedDirective) {\n      var _this198 = this;\n\n      if (!normalizedDirective.isComponent) {\n        return;\n      }\n\n      var template = normalizedDirective.template;\n\n      this._resourceLoaderCache.delete(template.templateUrl);\n\n      template.externalStylesheets.forEach(function (stylesheet) {\n        _this198._resourceLoaderCache.delete(stylesheet.moduleUrl);\n      });\n    }\n  }, {\n    key: \"_fetch\",\n    value: function _fetch(url) {\n      var result = this._resourceLoaderCache.get(url);\n\n      if (!result) {\n        result = this._resourceLoader.get(url);\n\n        this._resourceLoaderCache.set(url, result);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"normalizeTemplate\",\n    value: function normalizeTemplate(prenormData) {\n      var _this199 = this;\n\n      if (isDefined(prenormData.template)) {\n        if (isDefined(prenormData.templateUrl)) {\n          throw syntaxError(\"'\".concat(stringify(prenormData.componentType), \"' component cannot define both template and templateUrl\"));\n        }\n\n        if (typeof prenormData.template !== 'string') {\n          throw syntaxError(\"The template specified for component \".concat(stringify(prenormData.componentType), \" is not a string\"));\n        }\n      } else if (isDefined(prenormData.templateUrl)) {\n        if (typeof prenormData.templateUrl !== 'string') {\n          throw syntaxError(\"The templateUrl specified for component \".concat(stringify(prenormData.componentType), \" is not a string\"));\n        }\n      } else {\n        throw syntaxError(\"No template specified for component \".concat(stringify(prenormData.componentType)));\n      }\n\n      if (isDefined(prenormData.preserveWhitespaces) && typeof prenormData.preserveWhitespaces !== 'boolean') {\n        throw syntaxError(\"The preserveWhitespaces option for component \".concat(stringify(prenormData.componentType), \" must be a boolean\"));\n      }\n\n      return SyncAsync.then(this._preParseTemplate(prenormData), function (preparsedTemplate) {\n        return _this199._normalizeTemplateMetadata(prenormData, preparsedTemplate);\n      });\n    }\n  }, {\n    key: \"_preParseTemplate\",\n    value: function _preParseTemplate(prenomData) {\n      var _this200 = this;\n\n      var template;\n      var templateUrl;\n\n      if (prenomData.template != null) {\n        template = prenomData.template;\n        templateUrl = prenomData.moduleUrl;\n      } else {\n        templateUrl = this._urlResolver.resolve(prenomData.moduleUrl, prenomData.templateUrl);\n        template = this._fetch(templateUrl);\n      }\n\n      return SyncAsync.then(template, function (template) {\n        return _this200._preparseLoadedTemplate(prenomData, template, templateUrl);\n      });\n    }\n  }, {\n    key: \"_preparseLoadedTemplate\",\n    value: function _preparseLoadedTemplate(prenormData, template, templateAbsUrl) {\n      var isInline = !!prenormData.template;\n      var interpolationConfig = InterpolationConfig.fromArray(prenormData.interpolation);\n      var templateUrl = templateSourceUrl({\n        reference: prenormData.ngModuleType\n      }, {\n        type: {\n          reference: prenormData.componentType\n        }\n      }, {\n        isInline: isInline,\n        templateUrl: templateAbsUrl\n      });\n\n      var rootNodesAndErrors = this._htmlParser.parse(template, templateUrl, {\n        tokenizeExpansionForms: true,\n        interpolationConfig: interpolationConfig\n      });\n\n      if (rootNodesAndErrors.errors.length > 0) {\n        var errorString = rootNodesAndErrors.errors.join('\\n');\n        throw syntaxError(\"Template parse errors:\\n\".concat(errorString));\n      }\n\n      var templateMetadataStyles = this._normalizeStylesheet(new CompileStylesheetMetadata({\n        styles: prenormData.styles,\n        moduleUrl: prenormData.moduleUrl\n      }));\n\n      var visitor = new TemplatePreparseVisitor();\n      visitAll$1(visitor, rootNodesAndErrors.rootNodes);\n\n      var templateStyles = this._normalizeStylesheet(new CompileStylesheetMetadata({\n        styles: visitor.styles,\n        styleUrls: visitor.styleUrls,\n        moduleUrl: templateAbsUrl\n      }));\n\n      var styles = templateMetadataStyles.styles.concat(templateStyles.styles);\n      var inlineStyleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);\n\n      var styleUrls = this._normalizeStylesheet(new CompileStylesheetMetadata({\n        styleUrls: prenormData.styleUrls,\n        moduleUrl: prenormData.moduleUrl\n      })).styleUrls;\n\n      return {\n        template: template,\n        templateUrl: templateAbsUrl,\n        isInline: isInline,\n        htmlAst: rootNodesAndErrors,\n        styles: styles,\n        inlineStyleUrls: inlineStyleUrls,\n        styleUrls: styleUrls,\n        ngContentSelectors: visitor.ngContentSelectors\n      };\n    }\n  }, {\n    key: \"_normalizeTemplateMetadata\",\n    value: function _normalizeTemplateMetadata(prenormData, preparsedTemplate) {\n      var _this201 = this;\n\n      return SyncAsync.then(this._loadMissingExternalStylesheets(preparsedTemplate.styleUrls.concat(preparsedTemplate.inlineStyleUrls)), function (externalStylesheets) {\n        return _this201._normalizeLoadedTemplateMetadata(prenormData, preparsedTemplate, externalStylesheets);\n      });\n    }\n  }, {\n    key: \"_normalizeLoadedTemplateMetadata\",\n    value: function _normalizeLoadedTemplateMetadata(prenormData, preparsedTemplate, stylesheets) {\n      var _this202 = this;\n\n      // Algorithm:\n      // - produce exactly 1 entry per original styleUrl in\n      // CompileTemplateMetadata.externalStylesheets with all styles inlined\n      // - inline all styles that are referenced by the template into CompileTemplateMetadata.styles.\n      // Reason: be able to determine how many stylesheets there are even without loading\n      // the template nor the stylesheets, so we can create a stub for TypeScript always synchronously\n      // (as resource loading may be async)\n      var styles = _toConsumableArray(preparsedTemplate.styles);\n\n      this._inlineStyles(preparsedTemplate.inlineStyleUrls, stylesheets, styles);\n\n      var styleUrls = preparsedTemplate.styleUrls;\n      var externalStylesheets = styleUrls.map(function (styleUrl) {\n        var stylesheet = stylesheets.get(styleUrl);\n\n        var styles = _toConsumableArray(stylesheet.styles);\n\n        _this202._inlineStyles(stylesheet.styleUrls, stylesheets, styles);\n\n        return new CompileStylesheetMetadata({\n          moduleUrl: styleUrl,\n          styles: styles\n        });\n      });\n      var encapsulation = prenormData.encapsulation;\n\n      if (encapsulation == null) {\n        encapsulation = this._config.defaultEncapsulation;\n      }\n\n      if (encapsulation === ViewEncapsulation.Emulated && styles.length === 0 && styleUrls.length === 0) {\n        encapsulation = ViewEncapsulation.None;\n      }\n\n      return new CompileTemplateMetadata({\n        encapsulation: encapsulation,\n        template: preparsedTemplate.template,\n        templateUrl: preparsedTemplate.templateUrl,\n        htmlAst: preparsedTemplate.htmlAst,\n        styles: styles,\n        styleUrls: styleUrls,\n        ngContentSelectors: preparsedTemplate.ngContentSelectors,\n        animations: prenormData.animations,\n        interpolation: prenormData.interpolation,\n        isInline: preparsedTemplate.isInline,\n        externalStylesheets: externalStylesheets,\n        preserveWhitespaces: preserveWhitespacesDefault(prenormData.preserveWhitespaces, this._config.preserveWhitespaces)\n      });\n    }\n  }, {\n    key: \"_inlineStyles\",\n    value: function _inlineStyles(styleUrls, stylesheets, targetStyles) {\n      var _this203 = this;\n\n      styleUrls.forEach(function (styleUrl) {\n        var stylesheet = stylesheets.get(styleUrl);\n        stylesheet.styles.forEach(function (style) {\n          return targetStyles.push(style);\n        });\n\n        _this203._inlineStyles(stylesheet.styleUrls, stylesheets, targetStyles);\n      });\n    }\n  }, {\n    key: \"_loadMissingExternalStylesheets\",\n    value: function _loadMissingExternalStylesheets(styleUrls) {\n      var _this204 = this;\n\n      var loadedStylesheets = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();\n      return SyncAsync.then(SyncAsync.all(styleUrls.filter(function (styleUrl) {\n        return !loadedStylesheets.has(styleUrl);\n      }).map(function (styleUrl) {\n        return SyncAsync.then(_this204._fetch(styleUrl), function (loadedStyle) {\n          var stylesheet = _this204._normalizeStylesheet(new CompileStylesheetMetadata({\n            styles: [loadedStyle],\n            moduleUrl: styleUrl\n          }));\n\n          loadedStylesheets.set(styleUrl, stylesheet);\n          return _this204._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);\n        });\n      })), function (_) {\n        return loadedStylesheets;\n      });\n    }\n  }, {\n    key: \"_normalizeStylesheet\",\n    value: function _normalizeStylesheet(stylesheet) {\n      var _this205 = this;\n\n      var moduleUrl = stylesheet.moduleUrl;\n      var allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable).map(function (url) {\n        return _this205._urlResolver.resolve(moduleUrl, url);\n      });\n      var allStyles = stylesheet.styles.map(function (style) {\n        var styleWithImports = extractStyleUrls(_this205._urlResolver, moduleUrl, style);\n        allStyleUrls.push.apply(allStyleUrls, _toConsumableArray(styleWithImports.styleUrls));\n        return styleWithImports.style;\n      });\n      return new CompileStylesheetMetadata({\n        styles: allStyles,\n        styleUrls: allStyleUrls,\n        moduleUrl: moduleUrl\n      });\n    }\n  }]);\n\n  return DirectiveNormalizer;\n}();\n\nvar TemplatePreparseVisitor = /*#__PURE__*/function () {\n  function TemplatePreparseVisitor() {\n    _classCallCheck(this, TemplatePreparseVisitor);\n\n    this.ngContentSelectors = [];\n    this.styles = [];\n    this.styleUrls = [];\n    this.ngNonBindableStackCount = 0;\n  }\n\n  _createClass(TemplatePreparseVisitor, [{\n    key: \"visitElement\",\n    value: function visitElement(ast, context) {\n      var preparsedElement = preparseElement(ast);\n\n      switch (preparsedElement.type) {\n        case PreparsedElementType.NG_CONTENT:\n          if (this.ngNonBindableStackCount === 0) {\n            this.ngContentSelectors.push(preparsedElement.selectAttr);\n          }\n\n          break;\n\n        case PreparsedElementType.STYLE:\n          var textContent = '';\n          ast.children.forEach(function (child) {\n            if (child instanceof Text$3) {\n              textContent += child.value;\n            }\n          });\n          this.styles.push(textContent);\n          break;\n\n        case PreparsedElementType.STYLESHEET:\n          this.styleUrls.push(preparsedElement.hrefAttr);\n          break;\n\n        default:\n          break;\n      }\n\n      if (preparsedElement.nonBindable) {\n        this.ngNonBindableStackCount++;\n      }\n\n      visitAll$1(this, ast.children);\n\n      if (preparsedElement.nonBindable) {\n        this.ngNonBindableStackCount--;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(ast, context) {\n      visitAll$1(this, ast.cases);\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(ast, context) {\n      visitAll$1(this, ast.expression);\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(ast, context) {\n      return null;\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(ast, context) {\n      return null;\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(ast, context) {\n      return null;\n    }\n  }]);\n\n  return TemplatePreparseVisitor;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar QUERY_METADATA_IDENTIFIERS = [createViewChild, createViewChildren, createContentChild, createContentChildren];\n/*\r\n * Resolve a `Type` for {@link Directive}.\r\n *\r\n * This interface can be overridden by the application developer to create custom behavior.\r\n *\r\n * See {@link Compiler}\r\n */\n\nvar DirectiveResolver = /*#__PURE__*/function () {\n  function DirectiveResolver(_reflector) {\n    _classCallCheck(this, DirectiveResolver);\n\n    this._reflector = _reflector;\n  }\n\n  _createClass(DirectiveResolver, [{\n    key: \"isDirective\",\n    value: function isDirective(type) {\n      var typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n\n      return typeMetadata && typeMetadata.some(isDirectiveMetadata);\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(type) {\n      var throwIfNotFound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n\n      if (typeMetadata) {\n        var metadata = findLast(typeMetadata, isDirectiveMetadata);\n\n        if (metadata) {\n          var propertyMetadata = this._reflector.propMetadata(type);\n\n          var guards = this._reflector.guards(type);\n\n          return this._mergeWithPropertyMetadata(metadata, propertyMetadata, guards, type);\n        }\n      }\n\n      if (throwIfNotFound) {\n        throw new Error(\"No Directive annotation found on \".concat(stringify(type)));\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_mergeWithPropertyMetadata\",\n    value: function _mergeWithPropertyMetadata(dm, propertyMetadata, guards, directiveType) {\n      var inputs = [];\n      var outputs = [];\n      var host = {};\n      var queries = {};\n      Object.keys(propertyMetadata).forEach(function (propName) {\n        var input = findLast(propertyMetadata[propName], function (a) {\n          return createInput.isTypeOf(a);\n        });\n\n        if (input) {\n          if (input.bindingPropertyName) {\n            inputs.push(\"\".concat(propName, \": \").concat(input.bindingPropertyName));\n          } else {\n            inputs.push(propName);\n          }\n        }\n\n        var output = findLast(propertyMetadata[propName], function (a) {\n          return createOutput.isTypeOf(a);\n        });\n\n        if (output) {\n          if (output.bindingPropertyName) {\n            outputs.push(\"\".concat(propName, \": \").concat(output.bindingPropertyName));\n          } else {\n            outputs.push(propName);\n          }\n        }\n\n        var hostBindings = propertyMetadata[propName].filter(function (a) {\n          return createHostBinding.isTypeOf(a);\n        });\n        hostBindings.forEach(function (hostBinding) {\n          if (hostBinding.hostPropertyName) {\n            var startWith = hostBinding.hostPropertyName[0];\n\n            if (startWith === '(') {\n              throw new Error(\"@HostBinding can not bind to events. Use @HostListener instead.\");\n            } else if (startWith === '[') {\n              throw new Error(\"@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.\");\n            }\n\n            host[\"[\".concat(hostBinding.hostPropertyName, \"]\")] = propName;\n          } else {\n            host[\"[\".concat(propName, \"]\")] = propName;\n          }\n        });\n        var hostListeners = propertyMetadata[propName].filter(function (a) {\n          return createHostListener.isTypeOf(a);\n        });\n        hostListeners.forEach(function (hostListener) {\n          var args = hostListener.args || [];\n          host[\"(\".concat(hostListener.eventName, \")\")] = \"\".concat(propName, \"(\").concat(args.join(','), \")\");\n        });\n        var query = findLast(propertyMetadata[propName], function (a) {\n          return QUERY_METADATA_IDENTIFIERS.some(function (i) {\n            return i.isTypeOf(a);\n          });\n        });\n\n        if (query) {\n          queries[propName] = query;\n        }\n      });\n      return this._merge(dm, inputs, outputs, host, queries, guards, directiveType);\n    }\n  }, {\n    key: \"_extractPublicName\",\n    value: function _extractPublicName(def) {\n      return splitAtColon(def, [null, def])[1].trim();\n    }\n  }, {\n    key: \"_dedupeBindings\",\n    value: function _dedupeBindings(bindings) {\n      var names = new Set();\n      var publicNames = new Set();\n      var reversedResult = []; // go last to first to allow later entries to overwrite previous entries\n\n      for (var i = bindings.length - 1; i >= 0; i--) {\n        var binding = bindings[i];\n\n        var name = this._extractPublicName(binding);\n\n        publicNames.add(name);\n\n        if (!names.has(name)) {\n          names.add(name);\n          reversedResult.push(binding);\n        }\n      }\n\n      return reversedResult.reverse();\n    }\n  }, {\n    key: \"_merge\",\n    value: function _merge(directive, inputs, outputs, host, queries, guards, directiveType) {\n      var mergedInputs = this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);\n\n      var mergedOutputs = this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);\n\n      var mergedHost = directive.host ? Object.assign(Object.assign({}, directive.host), host) : host;\n      var mergedQueries = directive.queries ? Object.assign(Object.assign({}, directive.queries), queries) : queries;\n\n      if (createComponent.isTypeOf(directive)) {\n        var comp = directive;\n        return createComponent({\n          selector: comp.selector,\n          inputs: mergedInputs,\n          outputs: mergedOutputs,\n          host: mergedHost,\n          exportAs: comp.exportAs,\n          moduleId: comp.moduleId,\n          queries: mergedQueries,\n          changeDetection: comp.changeDetection,\n          providers: comp.providers,\n          viewProviders: comp.viewProviders,\n          entryComponents: comp.entryComponents,\n          template: comp.template,\n          templateUrl: comp.templateUrl,\n          styles: comp.styles,\n          styleUrls: comp.styleUrls,\n          encapsulation: comp.encapsulation,\n          animations: comp.animations,\n          interpolation: comp.interpolation,\n          preserveWhitespaces: directive.preserveWhitespaces\n        });\n      } else {\n        return createDirective({\n          selector: directive.selector,\n          inputs: mergedInputs,\n          outputs: mergedOutputs,\n          host: mergedHost,\n          exportAs: directive.exportAs,\n          queries: mergedQueries,\n          providers: directive.providers,\n          guards: guards\n        });\n      }\n    }\n  }]);\n\n  return DirectiveResolver;\n}();\n\nfunction isDirectiveMetadata(type) {\n  return createDirective.isTypeOf(type) || createComponent.isTypeOf(type);\n}\n\nfunction findLast(arr, condition) {\n  for (var i = arr.length - 1; i >= 0; i--) {\n    if (condition(arr[i])) {\n      return arr[i];\n    }\n  }\n\n  return null;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar _I18N_ATTR = 'i18n';\nvar _I18N_ATTR_PREFIX = 'i18n-';\nvar _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\nvar MEANING_SEPARATOR = '|';\nvar ID_SEPARATOR = '@@';\nvar i18nCommentsWarned = false;\n/**\r\n * Extract translatable messages from an html AST\r\n */\n\nfunction extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {\n  var visitor = new _Visitor$2(implicitTags, implicitAttrs);\n  return visitor.extract(nodes, interpolationConfig);\n}\n\nfunction mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {\n  var visitor = new _Visitor$2(implicitTags, implicitAttrs);\n  return visitor.merge(nodes, translations, interpolationConfig);\n}\n\nvar ExtractionResult = function ExtractionResult(messages, errors) {\n  _classCallCheck(this, ExtractionResult);\n\n  this.messages = messages;\n  this.errors = errors;\n};\n\nvar _VisitorMode;\n\n(function (_VisitorMode) {\n  _VisitorMode[_VisitorMode[\"Extract\"] = 0] = \"Extract\";\n  _VisitorMode[_VisitorMode[\"Merge\"] = 1] = \"Merge\";\n})(_VisitorMode || (_VisitorMode = {}));\n/**\r\n * This Visitor is used:\r\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\r\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\r\n *\r\n * @internal\r\n */\n\n\nvar _Visitor$2 = /*#__PURE__*/function () {\n  function _Visitor$2(_implicitTags, _implicitAttrs) {\n    _classCallCheck(this, _Visitor$2);\n\n    this._implicitTags = _implicitTags;\n    this._implicitAttrs = _implicitAttrs;\n  }\n  /**\r\n   * Extracts the messages from the tree\r\n   */\n\n\n  _createClass(_Visitor$2, [{\n    key: \"extract\",\n    value: function extract(nodes, interpolationConfig) {\n      var _this206 = this;\n\n      this._init(_VisitorMode.Extract, interpolationConfig);\n\n      nodes.forEach(function (node) {\n        return node.visit(_this206, null);\n      });\n\n      if (this._inI18nBlock) {\n        this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n      }\n\n      return new ExtractionResult(this._messages, this._errors);\n    }\n    /**\r\n     * Returns a tree where all translatable nodes are translated\r\n     */\n\n  }, {\n    key: \"merge\",\n    value: function merge(nodes, translations, interpolationConfig) {\n      this._init(_VisitorMode.Merge, interpolationConfig);\n\n      this._translations = translations; // Construct a single fake root element\n\n      var wrapper = new Element$1('wrapper', [], nodes, undefined, undefined, undefined);\n      var translatedNode = wrapper.visit(this, null);\n\n      if (this._inI18nBlock) {\n        this._reportError(nodes[nodes.length - 1], 'Unclosed block');\n      }\n\n      return new ParseTreeResult(translatedNode.children, this._errors);\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(icuCase, context) {\n      // Parse cases for translatable html attributes\n      var expression = visitAll$1(this, icuCase.expression, context);\n\n      if (this._mode === _VisitorMode.Merge) {\n        return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);\n      }\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(icu, context) {\n      this._mayBeAddBlockChildren(icu);\n\n      var wasInIcu = this._inIcu;\n\n      if (!this._inIcu) {\n        // nested ICU messages should not be extracted but top-level translated as a whole\n        if (this._isInTranslatableSection) {\n          this._addMessage([icu]);\n        }\n\n        this._inIcu = true;\n      }\n\n      var cases = visitAll$1(this, icu.cases, context);\n\n      if (this._mode === _VisitorMode.Merge) {\n        icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\n      }\n\n      this._inIcu = wasInIcu;\n      return icu;\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment, context) {\n      var isOpening = _isOpeningComment(comment);\n\n      if (isOpening && this._isInTranslatableSection) {\n        this._reportError(comment, 'Could not start a block inside a translatable section');\n\n        return;\n      }\n\n      var isClosing = _isClosingComment(comment);\n\n      if (isClosing && !this._inI18nBlock) {\n        this._reportError(comment, 'Trying to close an unopened block');\n\n        return;\n      }\n\n      if (!this._inI18nNode && !this._inIcu) {\n        if (!this._inI18nBlock) {\n          if (isOpening) {\n            // deprecated from v5 you should use <ng-container i18n> instead of i18n comments\n            if (!i18nCommentsWarned && console && console.warn) {\n              i18nCommentsWarned = true;\n              var details = comment.sourceSpan.details ? \", \".concat(comment.sourceSpan.details) : ''; // TODO(ocombe): use a log service once there is a public one available\n\n              console.warn(\"I18n comments are deprecated, use an <ng-container> element instead (\".concat(comment.sourceSpan.start).concat(details, \")\"));\n            }\n\n            this._inI18nBlock = true;\n            this._blockStartDepth = this._depth;\n            this._blockChildren = [];\n            this._blockMeaningAndDesc = comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\n\n            this._openTranslatableSection(comment);\n          }\n        } else {\n          if (isClosing) {\n            if (this._depth == this._blockStartDepth) {\n              this._closeTranslatableSection(comment, this._blockChildren);\n\n              this._inI18nBlock = false;\n\n              var message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc); // merge attributes in sections\n\n\n              var nodes = this._translateMessage(comment, message);\n\n              return visitAll$1(this, nodes);\n            } else {\n              this._reportError(comment, 'I18N blocks should not cross element boundaries');\n\n              return;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      if (this._isInTranslatableSection) {\n        this._mayBeAddBlockChildren(text);\n      }\n\n      return text;\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(el, context) {\n      var _this207 = this;\n\n      this._mayBeAddBlockChildren(el);\n\n      this._depth++;\n      var wasInI18nNode = this._inI18nNode;\n      var wasInImplicitNode = this._inImplicitNode;\n      var childNodes = [];\n      var translatedChildNodes = undefined; // Extract:\n      // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\n      // - ICU messages\n\n      var i18nAttr = _getI18nAttr(el);\n\n      var i18nMeta = i18nAttr ? i18nAttr.value : '';\n      var isImplicit = this._implicitTags.some(function (tag) {\n        return el.name === tag;\n      }) && !this._inIcu && !this._isInTranslatableSection;\n      var isTopLevelImplicit = !wasInImplicitNode && isImplicit;\n      this._inImplicitNode = wasInImplicitNode || isImplicit;\n\n      if (!this._isInTranslatableSection && !this._inIcu) {\n        if (i18nAttr || isTopLevelImplicit) {\n          this._inI18nNode = true;\n\n          var message = this._addMessage(el.children, i18nMeta);\n\n          translatedChildNodes = this._translateMessage(el, message);\n        }\n\n        if (this._mode == _VisitorMode.Extract) {\n          var isTranslatable = i18nAttr || isTopLevelImplicit;\n          if (isTranslatable) this._openTranslatableSection(el);\n          visitAll$1(this, el.children);\n          if (isTranslatable) this._closeTranslatableSection(el, el.children);\n        }\n      } else {\n        if (i18nAttr || isTopLevelImplicit) {\n          this._reportError(el, 'Could not mark an element as translatable inside a translatable section');\n        }\n\n        if (this._mode == _VisitorMode.Extract) {\n          // Descend into child nodes for extraction\n          visitAll$1(this, el.children);\n        }\n      }\n\n      if (this._mode === _VisitorMode.Merge) {\n        var visitNodes = translatedChildNodes || el.children;\n        visitNodes.forEach(function (child) {\n          var visited = child.visit(_this207, context);\n\n          if (visited && !_this207._isInTranslatableSection) {\n            // Do not add the children from translatable sections (= i18n blocks here)\n            // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\n            childNodes = childNodes.concat(visited);\n          }\n        });\n      }\n\n      this._visitAttributesOf(el);\n\n      this._depth--;\n      this._inI18nNode = wasInI18nNode;\n      this._inImplicitNode = wasInImplicitNode;\n\n      if (this._mode === _VisitorMode.Merge) {\n        var translatedAttrs = this._translateAttributes(el);\n\n        return new Element$1(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute, context) {\n      throw new Error('unreachable code');\n    }\n  }, {\n    key: \"_init\",\n    value: function _init(mode, interpolationConfig) {\n      this._mode = mode;\n      this._inI18nBlock = false;\n      this._inI18nNode = false;\n      this._depth = 0;\n      this._inIcu = false;\n      this._msgCountAtSectionStart = undefined;\n      this._errors = [];\n      this._messages = [];\n      this._inImplicitNode = false;\n      this._createI18nMessage = createI18nMessageFactory(interpolationConfig);\n    } // looks for translatable attributes\n\n  }, {\n    key: \"_visitAttributesOf\",\n    value: function _visitAttributesOf(el) {\n      var _this208 = this;\n\n      var explicitAttrNameToValue = {};\n      var implicitAttrNames = this._implicitAttrs[el.name] || [];\n      el.attrs.filter(function (attr) {\n        return attr.name.startsWith(_I18N_ATTR_PREFIX);\n      }).forEach(function (attr) {\n        return explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] = attr.value;\n      });\n      el.attrs.forEach(function (attr) {\n        if (attr.name in explicitAttrNameToValue) {\n          _this208._addMessage([attr], explicitAttrNameToValue[attr.name]);\n        } else if (implicitAttrNames.some(function (name) {\n          return attr.name === name;\n        })) {\n          _this208._addMessage([attr]);\n        }\n      });\n    } // add a translatable message\n\n  }, {\n    key: \"_addMessage\",\n    value: function _addMessage(ast, msgMeta) {\n      if (ast.length == 0 || ast.length == 1 && ast[0] instanceof Attribute && !ast[0].value) {\n        // Do not create empty messages\n        return null;\n      }\n\n      var _parseMessageMeta2 = _parseMessageMeta(msgMeta),\n          meaning = _parseMessageMeta2.meaning,\n          description = _parseMessageMeta2.description,\n          id = _parseMessageMeta2.id;\n\n      var message = this._createI18nMessage(ast, meaning, description, id);\n\n      this._messages.push(message);\n\n      return message;\n    } // Translates the given message given the `TranslationBundle`\n    // This is used for translating elements / blocks - see `_translateAttributes` for attributes\n    // no-op when called in extraction mode (returns [])\n\n  }, {\n    key: \"_translateMessage\",\n    value: function _translateMessage(el, message) {\n      if (message && this._mode === _VisitorMode.Merge) {\n        var nodes = this._translations.get(message);\n\n        if (nodes) {\n          return nodes;\n        }\n\n        this._reportError(el, \"Translation unavailable for message id=\\\"\".concat(this._translations.digest(message), \"\\\"\"));\n      }\n\n      return [];\n    } // translate the attributes of an element and remove i18n specific attributes\n\n  }, {\n    key: \"_translateAttributes\",\n    value: function _translateAttributes(el) {\n      var _this209 = this;\n\n      var attributes = el.attrs;\n      var i18nParsedMessageMeta = {};\n      attributes.forEach(function (attr) {\n        if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n          i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] = _parseMessageMeta(attr.value);\n        }\n      });\n      var translatedAttributes = [];\n      attributes.forEach(function (attr) {\n        if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\n          // strip i18n specific attributes\n          return;\n        }\n\n        if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\n          var _i18nParsedMessageMet = i18nParsedMessageMeta[attr.name],\n              meaning = _i18nParsedMessageMet.meaning,\n              description = _i18nParsedMessageMet.description,\n              id = _i18nParsedMessageMet.id;\n\n          var message = _this209._createI18nMessage([attr], meaning, description, id);\n\n          var nodes = _this209._translations.get(message);\n\n          if (nodes) {\n            if (nodes.length == 0) {\n              translatedAttributes.push(new Attribute(attr.name, '', attr.sourceSpan, undefined\n              /* keySpan */\n              , undefined\n              /* valueSpan */\n              , undefined\n              /* i18n */\n              ));\n            } else if (nodes[0] instanceof Text$3) {\n              var value = nodes[0].value;\n              translatedAttributes.push(new Attribute(attr.name, value, attr.sourceSpan, undefined\n              /* keySpan */\n              , undefined\n              /* valueSpan */\n              , undefined\n              /* i18n */\n              ));\n            } else {\n              _this209._reportError(el, \"Unexpected translation for attribute \\\"\".concat(attr.name, \"\\\" (id=\\\"\").concat(id || _this209._translations.digest(message), \"\\\")\"));\n            }\n          } else {\n            _this209._reportError(el, \"Translation unavailable for attribute \\\"\".concat(attr.name, \"\\\" (id=\\\"\").concat(id || _this209._translations.digest(message), \"\\\")\"));\n          }\n        } else {\n          translatedAttributes.push(attr);\n        }\n      });\n      return translatedAttributes;\n    }\n    /**\r\n     * Add the node as a child of the block when:\r\n     * - we are in a block,\r\n     * - we are not inside a ICU message (those are handled separately),\r\n     * - the node is a \"direct child\" of the block\r\n     */\n\n  }, {\n    key: \"_mayBeAddBlockChildren\",\n    value: function _mayBeAddBlockChildren(node) {\n      if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\n        this._blockChildren.push(node);\n      }\n    }\n    /**\r\n     * Marks the start of a section, see `_closeTranslatableSection`\r\n     */\n\n  }, {\n    key: \"_openTranslatableSection\",\n    value: function _openTranslatableSection(node) {\n      if (this._isInTranslatableSection) {\n        this._reportError(node, 'Unexpected section start');\n      } else {\n        this._msgCountAtSectionStart = this._messages.length;\n      }\n    }\n    /**\r\n     * A translatable section could be:\r\n     * - the content of translatable element,\r\n     * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\r\n     */\n\n  }, {\n    key: \"_isInTranslatableSection\",\n    get: function get() {\n      return this._msgCountAtSectionStart !== void 0;\n    }\n    /**\r\n     * Terminates a section.\r\n     *\r\n     * If a section has only one significant children (comments not significant) then we should not\r\n     * keep the message from this children:\r\n     *\r\n     * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\r\n     * - one for the <p> content with meaning and description,\r\n     * - another one for the ICU message.\r\n     *\r\n     * In this case the last message is discarded as it contains less information (the AST is\r\n     * otherwise identical).\r\n     *\r\n     * Note that we should still keep messages extracted from attributes inside the section (ie in the\r\n     * ICU message here)\r\n     */\n\n  }, {\n    key: \"_closeTranslatableSection\",\n    value: function _closeTranslatableSection(node, directChildren) {\n      if (!this._isInTranslatableSection) {\n        this._reportError(node, 'Unexpected section end');\n\n        return;\n      }\n\n      var startIndex = this._msgCountAtSectionStart;\n      var significantChildren = directChildren.reduce(function (count, node) {\n        return count + (node instanceof Comment$1 ? 0 : 1);\n      }, 0);\n\n      if (significantChildren == 1) {\n        for (var i = this._messages.length - 1; i >= startIndex; i--) {\n          var ast = this._messages[i].nodes;\n\n          if (!(ast.length == 1 && ast[0] instanceof Text$1)) {\n            this._messages.splice(i, 1);\n\n            break;\n          }\n        }\n      }\n\n      this._msgCountAtSectionStart = undefined;\n    }\n  }, {\n    key: \"_reportError\",\n    value: function _reportError(node, msg) {\n      this._errors.push(new I18nError(node.sourceSpan, msg));\n    }\n  }]);\n\n  return _Visitor$2;\n}();\n\nfunction _isOpeningComment(n) {\n  return !!(n instanceof Comment$1 && n.value && n.value.startsWith('i18n'));\n}\n\nfunction _isClosingComment(n) {\n  return !!(n instanceof Comment$1 && n.value && n.value === '/i18n');\n}\n\nfunction _getI18nAttr(p) {\n  return p.attrs.find(function (attr) {\n    return attr.name === _I18N_ATTR;\n  }) || null;\n}\n\nfunction _parseMessageMeta(i18n) {\n  if (!i18n) return {\n    meaning: '',\n    description: '',\n    id: ''\n  };\n  var idIndex = i18n.indexOf(ID_SEPARATOR);\n  var descIndex = i18n.indexOf(MEANING_SEPARATOR);\n\n  var _ref22 = idIndex > -1 ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''],\n      _ref23 = _slicedToArray(_ref22, 2),\n      meaningAndDesc = _ref23[0],\n      id = _ref23[1];\n\n  var _ref24 = descIndex > -1 ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ['', meaningAndDesc],\n      _ref25 = _slicedToArray(_ref24, 2),\n      meaning = _ref25[0],\n      description = _ref25[1];\n\n  return {\n    meaning: meaning,\n    description: description,\n    id: id.trim()\n  };\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar XmlTagDefinition = /*#__PURE__*/function () {\n  function XmlTagDefinition() {\n    _classCallCheck(this, XmlTagDefinition);\n\n    this.closedByParent = false;\n    this.isVoid = false;\n    this.ignoreFirstLf = false;\n    this.canSelfClose = true;\n    this.preventNamespaceInheritance = false;\n  }\n\n  _createClass(XmlTagDefinition, [{\n    key: \"requireExtraParent\",\n    value: function requireExtraParent(currentParent) {\n      return false;\n    }\n  }, {\n    key: \"isClosedByChild\",\n    value: function isClosedByChild(name) {\n      return false;\n    }\n  }, {\n    key: \"getContentType\",\n    value: function getContentType() {\n      return TagContentType.PARSABLE_DATA;\n    }\n  }]);\n\n  return XmlTagDefinition;\n}();\n\nvar _TAG_DEFINITION = new XmlTagDefinition();\n\nfunction getXmlTagDefinition(tagName) {\n  return _TAG_DEFINITION;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar XmlParser = /*#__PURE__*/function (_Parser2) {\n  _inherits(XmlParser, _Parser2);\n\n  var _super101 = _createSuper(XmlParser);\n\n  function XmlParser() {\n    _classCallCheck(this, XmlParser);\n\n    return _super101.call(this, getXmlTagDefinition);\n  }\n\n  _createClass(XmlParser, [{\n    key: \"parse\",\n    value: function parse(source, url, options) {\n      return _get(_getPrototypeOf(XmlParser.prototype), \"parse\", this).call(this, source, url, options);\n    }\n  }]);\n\n  return XmlParser;\n}(Parser);\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar _VERSION = '1.2';\nvar _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2'; // TODO(vicb): make this a param (s/_/-/)\n\nvar _DEFAULT_SOURCE_LANG = 'en';\nvar _PLACEHOLDER_TAG$1 = 'x';\nvar _MARKER_TAG = 'mrk';\nvar _FILE_TAG = 'file';\nvar _SOURCE_TAG$1 = 'source';\nvar _SEGMENT_SOURCE_TAG = 'seg-source';\nvar _ALT_TRANS_TAG = 'alt-trans';\nvar _TARGET_TAG = 'target';\nvar _UNIT_TAG = 'trans-unit';\nvar _CONTEXT_GROUP_TAG = 'context-group';\nvar _CONTEXT_TAG = 'context'; // https://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html\n// https://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html\n\nvar Xliff = /*#__PURE__*/function (_Serializer2) {\n  _inherits(Xliff, _Serializer2);\n\n  var _super102 = _createSuper(Xliff);\n\n  function Xliff() {\n    _classCallCheck(this, Xliff);\n\n    return _super102.apply(this, arguments);\n  }\n\n  _createClass(Xliff, [{\n    key: \"write\",\n    value: function write(messages, locale) {\n      var visitor = new _WriteVisitor();\n      var transUnits = [];\n      messages.forEach(function (message) {\n        var _transUnit$children;\n\n        var contextTags = [];\n        message.sources.forEach(function (source) {\n          var contextGroupTag = new Tag(_CONTEXT_GROUP_TAG, {\n            purpose: 'location'\n          });\n          contextGroupTag.children.push(new CR(10), new Tag(_CONTEXT_TAG, {\n            'context-type': 'sourcefile'\n          }, [new Text$2(source.filePath)]), new CR(10), new Tag(_CONTEXT_TAG, {\n            'context-type': 'linenumber'\n          }, [new Text$2(\"\".concat(source.startLine))]), new CR(8));\n          contextTags.push(new CR(8), contextGroupTag);\n        });\n        var transUnit = new Tag(_UNIT_TAG, {\n          id: message.id,\n          datatype: 'html'\n        });\n\n        (_transUnit$children = transUnit.children).push.apply(_transUnit$children, [new CR(8), new Tag(_SOURCE_TAG$1, {}, visitor.serialize(message.nodes))].concat(contextTags));\n\n        if (message.description) {\n          transUnit.children.push(new CR(8), new Tag('note', {\n            priority: '1',\n            from: 'description'\n          }, [new Text$2(message.description)]));\n        }\n\n        if (message.meaning) {\n          transUnit.children.push(new CR(8), new Tag('note', {\n            priority: '1',\n            from: 'meaning'\n          }, [new Text$2(message.meaning)]));\n        }\n\n        transUnit.children.push(new CR(6));\n        transUnits.push(new CR(6), transUnit);\n      });\n      var body = new Tag('body', {}, [].concat(transUnits, [new CR(4)]));\n      var file = new Tag('file', {\n        'source-language': locale || _DEFAULT_SOURCE_LANG,\n        datatype: 'plaintext',\n        original: 'ng2.template'\n      }, [new CR(4), body, new CR(2)]);\n      var xliff = new Tag('xliff', {\n        version: _VERSION,\n        xmlns: _XMLNS\n      }, [new CR(2), file, new CR()]);\n      return serialize([new Declaration({\n        version: '1.0',\n        encoding: 'UTF-8'\n      }), new CR(), xliff, new CR()]);\n    }\n  }, {\n    key: \"load\",\n    value: function load(content, url) {\n      // xliff to xml nodes\n      var xliffParser = new XliffParser();\n\n      var _xliffParser$parse = xliffParser.parse(content, url),\n          locale = _xliffParser$parse.locale,\n          msgIdToHtml = _xliffParser$parse.msgIdToHtml,\n          errors = _xliffParser$parse.errors; // xml nodes to i18n nodes\n\n\n      var i18nNodesByMsgId = {};\n      var converter = new XmlToI18n();\n      Object.keys(msgIdToHtml).forEach(function (msgId) {\n        var _converter$convert = converter.convert(msgIdToHtml[msgId], url),\n            i18nNodes = _converter$convert.i18nNodes,\n            e = _converter$convert.errors;\n\n        errors.push.apply(errors, _toConsumableArray(e));\n        i18nNodesByMsgId[msgId] = i18nNodes;\n      });\n\n      if (errors.length) {\n        throw new Error(\"xliff parse errors:\\n\".concat(errors.join('\\n')));\n      }\n\n      return {\n        locale: locale,\n        i18nNodesByMsgId: i18nNodesByMsgId\n      };\n    }\n  }, {\n    key: \"digest\",\n    value: function digest(message) {\n      return _digest2(message);\n    }\n  }]);\n\n  return Xliff;\n}(Serializer);\n\nvar _WriteVisitor = /*#__PURE__*/function () {\n  function _WriteVisitor() {\n    _classCallCheck(this, _WriteVisitor);\n  }\n\n  _createClass(_WriteVisitor, [{\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      return [new Text$2(text.value)];\n    }\n  }, {\n    key: \"visitContainer\",\n    value: function visitContainer(container, context) {\n      var _this210 = this;\n\n      var nodes = [];\n      container.children.forEach(function (node) {\n        return nodes.push.apply(nodes, _toConsumableArray(node.visit(_this210)));\n      });\n      return nodes;\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu, context) {\n      var _this211 = this;\n\n      var nodes = [new Text$2(\"{\".concat(icu.expressionPlaceholder, \", \").concat(icu.type, \", \"))];\n      Object.keys(icu.cases).forEach(function (c) {\n        nodes.push.apply(nodes, [new Text$2(\"\".concat(c, \" {\"))].concat(_toConsumableArray(icu.cases[c].visit(_this211)), [new Text$2(\"} \")]));\n      });\n      nodes.push(new Text$2(\"}\"));\n      return nodes;\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph, context) {\n      var ctype = getCtypeForTag(ph.tag);\n\n      if (ph.isVoid) {\n        // void tags have no children nor closing tags\n        return [new Tag(_PLACEHOLDER_TAG$1, {\n          id: ph.startName,\n          ctype: ctype,\n          'equiv-text': \"<\".concat(ph.tag, \"/>\")\n        })];\n      }\n\n      var startTagPh = new Tag(_PLACEHOLDER_TAG$1, {\n        id: ph.startName,\n        ctype: ctype,\n        'equiv-text': \"<\".concat(ph.tag, \">\")\n      });\n      var closeTagPh = new Tag(_PLACEHOLDER_TAG$1, {\n        id: ph.closeName,\n        ctype: ctype,\n        'equiv-text': \"</\".concat(ph.tag, \">\")\n      });\n      return [startTagPh].concat(_toConsumableArray(this.serialize(ph.children)), [closeTagPh]);\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph, context) {\n      return [new Tag(_PLACEHOLDER_TAG$1, {\n        id: ph.name,\n        'equiv-text': \"{{\".concat(ph.value, \"}}\")\n      })];\n    }\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {\n      var equivText = \"{\".concat(ph.value.expression, \", \").concat(ph.value.type, \", \").concat(Object.keys(ph.value.cases).map(function (value) {\n        return value + ' {...}';\n      }).join(' '), \"}\");\n      return [new Tag(_PLACEHOLDER_TAG$1, {\n        id: ph.name,\n        'equiv-text': equivText\n      })];\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(nodes) {\n      var _ref26,\n          _this212 = this;\n\n      return (_ref26 = []).concat.apply(_ref26, _toConsumableArray(nodes.map(function (node) {\n        return node.visit(_this212);\n      })));\n    }\n  }]);\n\n  return _WriteVisitor;\n}(); // TODO(vicb): add error management (structure)\n// Extract messages as xml nodes from the xliff file\n\n\nvar XliffParser = /*#__PURE__*/function () {\n  function XliffParser() {\n    _classCallCheck(this, XliffParser);\n\n    this._locale = null;\n  }\n\n  _createClass(XliffParser, [{\n    key: \"parse\",\n    value: function parse(xliff, url) {\n      this._unitMlString = null;\n      this._msgIdToHtml = {};\n      var xml = new XmlParser().parse(xliff, url);\n      this._errors = xml.errors;\n      visitAll$1(this, xml.rootNodes, null);\n      return {\n        msgIdToHtml: this._msgIdToHtml,\n        errors: this._errors,\n        locale: this._locale\n      };\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(element, context) {\n      switch (element.name) {\n        case _UNIT_TAG:\n          this._unitMlString = null;\n          var idAttr = element.attrs.find(function (attr) {\n            return attr.name === 'id';\n          });\n\n          if (!idAttr) {\n            this._addError(element, \"<\".concat(_UNIT_TAG, \"> misses the \\\"id\\\" attribute\"));\n          } else {\n            var id = idAttr.value;\n\n            if (this._msgIdToHtml.hasOwnProperty(id)) {\n              this._addError(element, \"Duplicated translations for msg \".concat(id));\n            } else {\n              visitAll$1(this, element.children, null);\n\n              if (typeof this._unitMlString === 'string') {\n                this._msgIdToHtml[id] = this._unitMlString;\n              } else {\n                this._addError(element, \"Message \".concat(id, \" misses a translation\"));\n              }\n            }\n          }\n\n          break;\n        // ignore those tags\n\n        case _SOURCE_TAG$1:\n        case _SEGMENT_SOURCE_TAG:\n        case _ALT_TRANS_TAG:\n          break;\n\n        case _TARGET_TAG:\n          var innerTextStart = element.startSourceSpan.end.offset;\n          var innerTextEnd = element.endSourceSpan.start.offset;\n          var content = element.startSourceSpan.start.file.content;\n          var innerText = content.slice(innerTextStart, innerTextEnd);\n          this._unitMlString = innerText;\n          break;\n\n        case _FILE_TAG:\n          var localeAttr = element.attrs.find(function (attr) {\n            return attr.name === 'target-language';\n          });\n\n          if (localeAttr) {\n            this._locale = localeAttr.value;\n          }\n\n          visitAll$1(this, element.children, null);\n          break;\n\n        default:\n          // TODO(vicb): assert file structure, xliff version\n          // For now only recurse on unhandled nodes\n          visitAll$1(this, element.children, null);\n      }\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute, context) {}\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, context) {}\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment, context) {}\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(expansion, context) {}\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(expansionCase, context) {}\n  }, {\n    key: \"_addError\",\n    value: function _addError(node, message) {\n      this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n  }]);\n\n  return XliffParser;\n}(); // Convert ml nodes (xliff syntax) to i18n nodes\n\n\nvar XmlToI18n = /*#__PURE__*/function () {\n  function XmlToI18n() {\n    _classCallCheck(this, XmlToI18n);\n  }\n\n  _createClass(XmlToI18n, [{\n    key: \"convert\",\n    value: function convert(message, url) {\n      var _ref27;\n\n      var xmlIcu = new XmlParser().parse(message, url, {\n        tokenizeExpansionForms: true\n      });\n      this._errors = xmlIcu.errors;\n      var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : (_ref27 = []).concat.apply(_ref27, _toConsumableArray(visitAll$1(this, xmlIcu.rootNodes)));\n      return {\n        i18nNodes: i18nNodes,\n        errors: this._errors\n      };\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      return new Text$1(text.value, text.sourceSpan);\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(el, context) {\n      if (el.name === _PLACEHOLDER_TAG$1) {\n        var nameAttr = el.attrs.find(function (attr) {\n          return attr.name === 'id';\n        });\n\n        if (nameAttr) {\n          return new Placeholder('', nameAttr.value, el.sourceSpan);\n        }\n\n        this._addError(el, \"<\".concat(_PLACEHOLDER_TAG$1, \"> misses the \\\"id\\\" attribute\"));\n\n        return null;\n      }\n\n      if (el.name === _MARKER_TAG) {\n        var _ref28;\n\n        return (_ref28 = []).concat.apply(_ref28, _toConsumableArray(visitAll$1(this, el.children)));\n      }\n\n      this._addError(el, \"Unexpected tag\");\n\n      return null;\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(icu, context) {\n      var caseMap = {};\n      visitAll$1(this, icu.cases).forEach(function (c) {\n        caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n      });\n      return new Icu$1(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(icuCase, context) {\n      return {\n        value: icuCase.value,\n        nodes: visitAll$1(this, icuCase.expression)\n      };\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment, context) {}\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute, context) {}\n  }, {\n    key: \"_addError\",\n    value: function _addError(node, message) {\n      this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n  }]);\n\n  return XmlToI18n;\n}();\n\nfunction getCtypeForTag(tag) {\n  switch (tag.toLowerCase()) {\n    case 'br':\n      return 'lb';\n\n    case 'img':\n      return 'image';\n\n    default:\n      return \"x-\".concat(tag);\n  }\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar _VERSION$1 = '2.0';\nvar _XMLNS$1 = 'urn:oasis:names:tc:xliff:document:2.0'; // TODO(vicb): make this a param (s/_/-/)\n\nvar _DEFAULT_SOURCE_LANG$1 = 'en';\nvar _PLACEHOLDER_TAG$2 = 'ph';\nvar _PLACEHOLDER_SPANNING_TAG = 'pc';\nvar _MARKER_TAG$1 = 'mrk';\nvar _XLIFF_TAG = 'xliff';\nvar _SOURCE_TAG$2 = 'source';\nvar _TARGET_TAG$1 = 'target';\nvar _UNIT_TAG$1 = 'unit'; // https://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\n\nvar Xliff2 = /*#__PURE__*/function (_Serializer3) {\n  _inherits(Xliff2, _Serializer3);\n\n  var _super103 = _createSuper(Xliff2);\n\n  function Xliff2() {\n    _classCallCheck(this, Xliff2);\n\n    return _super103.apply(this, arguments);\n  }\n\n  _createClass(Xliff2, [{\n    key: \"write\",\n    value: function write(messages, locale) {\n      var visitor = new _WriteVisitor$1();\n      var units = [];\n      messages.forEach(function (message) {\n        var unit = new Tag(_UNIT_TAG$1, {\n          id: message.id\n        });\n        var notes = new Tag('notes');\n\n        if (message.description || message.meaning) {\n          if (message.description) {\n            notes.children.push(new CR(8), new Tag('note', {\n              category: 'description'\n            }, [new Text$2(message.description)]));\n          }\n\n          if (message.meaning) {\n            notes.children.push(new CR(8), new Tag('note', {\n              category: 'meaning'\n            }, [new Text$2(message.meaning)]));\n          }\n        }\n\n        message.sources.forEach(function (source) {\n          notes.children.push(new CR(8), new Tag('note', {\n            category: 'location'\n          }, [new Text$2(\"\".concat(source.filePath, \":\").concat(source.startLine).concat(source.endLine !== source.startLine ? ',' + source.endLine : ''))]));\n        });\n        notes.children.push(new CR(6));\n        unit.children.push(new CR(6), notes);\n        var segment = new Tag('segment');\n        segment.children.push(new CR(8), new Tag(_SOURCE_TAG$2, {}, visitor.serialize(message.nodes)), new CR(6));\n        unit.children.push(new CR(6), segment, new CR(4));\n        units.push(new CR(4), unit);\n      });\n      var file = new Tag('file', {\n        'original': 'ng.template',\n        id: 'ngi18n'\n      }, [].concat(units, [new CR(2)]));\n      var xliff = new Tag(_XLIFF_TAG, {\n        version: _VERSION$1,\n        xmlns: _XMLNS$1,\n        srcLang: locale || _DEFAULT_SOURCE_LANG$1\n      }, [new CR(2), file, new CR()]);\n      return serialize([new Declaration({\n        version: '1.0',\n        encoding: 'UTF-8'\n      }), new CR(), xliff, new CR()]);\n    }\n  }, {\n    key: \"load\",\n    value: function load(content, url) {\n      // xliff to xml nodes\n      var xliff2Parser = new Xliff2Parser();\n\n      var _xliff2Parser$parse = xliff2Parser.parse(content, url),\n          locale = _xliff2Parser$parse.locale,\n          msgIdToHtml = _xliff2Parser$parse.msgIdToHtml,\n          errors = _xliff2Parser$parse.errors; // xml nodes to i18n nodes\n\n\n      var i18nNodesByMsgId = {};\n      var converter = new XmlToI18n$1();\n      Object.keys(msgIdToHtml).forEach(function (msgId) {\n        var _converter$convert2 = converter.convert(msgIdToHtml[msgId], url),\n            i18nNodes = _converter$convert2.i18nNodes,\n            e = _converter$convert2.errors;\n\n        errors.push.apply(errors, _toConsumableArray(e));\n        i18nNodesByMsgId[msgId] = i18nNodes;\n      });\n\n      if (errors.length) {\n        throw new Error(\"xliff2 parse errors:\\n\".concat(errors.join('\\n')));\n      }\n\n      return {\n        locale: locale,\n        i18nNodesByMsgId: i18nNodesByMsgId\n      };\n    }\n  }, {\n    key: \"digest\",\n    value: function digest(message) {\n      return decimalDigest(message);\n    }\n  }]);\n\n  return Xliff2;\n}(Serializer);\n\nvar _WriteVisitor$1 = /*#__PURE__*/function () {\n  function _WriteVisitor$1() {\n    _classCallCheck(this, _WriteVisitor$1);\n  }\n\n  _createClass(_WriteVisitor$1, [{\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      return [new Text$2(text.value)];\n    }\n  }, {\n    key: \"visitContainer\",\n    value: function visitContainer(container, context) {\n      var _this213 = this;\n\n      var nodes = [];\n      container.children.forEach(function (node) {\n        return nodes.push.apply(nodes, _toConsumableArray(node.visit(_this213)));\n      });\n      return nodes;\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu, context) {\n      var _this214 = this;\n\n      var nodes = [new Text$2(\"{\".concat(icu.expressionPlaceholder, \", \").concat(icu.type, \", \"))];\n      Object.keys(icu.cases).forEach(function (c) {\n        nodes.push.apply(nodes, [new Text$2(\"\".concat(c, \" {\"))].concat(_toConsumableArray(icu.cases[c].visit(_this214)), [new Text$2(\"} \")]));\n      });\n      nodes.push(new Text$2(\"}\"));\n      return nodes;\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph, context) {\n      var _ref29,\n          _this215 = this;\n\n      var type = getTypeForTag(ph.tag);\n\n      if (ph.isVoid) {\n        var tagPh = new Tag(_PLACEHOLDER_TAG$2, {\n          id: (this._nextPlaceholderId++).toString(),\n          equiv: ph.startName,\n          type: type,\n          disp: \"<\".concat(ph.tag, \"/>\")\n        });\n        return [tagPh];\n      }\n\n      var tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {\n        id: (this._nextPlaceholderId++).toString(),\n        equivStart: ph.startName,\n        equivEnd: ph.closeName,\n        type: type,\n        dispStart: \"<\".concat(ph.tag, \">\"),\n        dispEnd: \"</\".concat(ph.tag, \">\")\n      });\n\n      var nodes = (_ref29 = []).concat.apply(_ref29, _toConsumableArray(ph.children.map(function (node) {\n        return node.visit(_this215);\n      })));\n\n      if (nodes.length) {\n        nodes.forEach(function (node) {\n          return tagPc.children.push(node);\n        });\n      } else {\n        tagPc.children.push(new Text$2(''));\n      }\n\n      return [tagPc];\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph, context) {\n      var idStr = (this._nextPlaceholderId++).toString();\n      return [new Tag(_PLACEHOLDER_TAG$2, {\n        id: idStr,\n        equiv: ph.name,\n        disp: \"{{\".concat(ph.value, \"}}\")\n      })];\n    }\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {\n      var cases = Object.keys(ph.value.cases).map(function (value) {\n        return value + ' {...}';\n      }).join(' ');\n      var idStr = (this._nextPlaceholderId++).toString();\n      return [new Tag(_PLACEHOLDER_TAG$2, {\n        id: idStr,\n        equiv: ph.name,\n        disp: \"{\".concat(ph.value.expression, \", \").concat(ph.value.type, \", \").concat(cases, \"}\")\n      })];\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(nodes) {\n      var _ref30,\n          _this216 = this;\n\n      this._nextPlaceholderId = 0;\n      return (_ref30 = []).concat.apply(_ref30, _toConsumableArray(nodes.map(function (node) {\n        return node.visit(_this216);\n      })));\n    }\n  }]);\n\n  return _WriteVisitor$1;\n}(); // Extract messages as xml nodes from the xliff file\n\n\nvar Xliff2Parser = /*#__PURE__*/function () {\n  function Xliff2Parser() {\n    _classCallCheck(this, Xliff2Parser);\n\n    this._locale = null;\n  }\n\n  _createClass(Xliff2Parser, [{\n    key: \"parse\",\n    value: function parse(xliff, url) {\n      this._unitMlString = null;\n      this._msgIdToHtml = {};\n      var xml = new XmlParser().parse(xliff, url);\n      this._errors = xml.errors;\n      visitAll$1(this, xml.rootNodes, null);\n      return {\n        msgIdToHtml: this._msgIdToHtml,\n        errors: this._errors,\n        locale: this._locale\n      };\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(element, context) {\n      switch (element.name) {\n        case _UNIT_TAG$1:\n          this._unitMlString = null;\n          var idAttr = element.attrs.find(function (attr) {\n            return attr.name === 'id';\n          });\n\n          if (!idAttr) {\n            this._addError(element, \"<\".concat(_UNIT_TAG$1, \"> misses the \\\"id\\\" attribute\"));\n          } else {\n            var id = idAttr.value;\n\n            if (this._msgIdToHtml.hasOwnProperty(id)) {\n              this._addError(element, \"Duplicated translations for msg \".concat(id));\n            } else {\n              visitAll$1(this, element.children, null);\n\n              if (typeof this._unitMlString === 'string') {\n                this._msgIdToHtml[id] = this._unitMlString;\n              } else {\n                this._addError(element, \"Message \".concat(id, \" misses a translation\"));\n              }\n            }\n          }\n\n          break;\n\n        case _SOURCE_TAG$2:\n          // ignore source message\n          break;\n\n        case _TARGET_TAG$1:\n          var innerTextStart = element.startSourceSpan.end.offset;\n          var innerTextEnd = element.endSourceSpan.start.offset;\n          var content = element.startSourceSpan.start.file.content;\n          var innerText = content.slice(innerTextStart, innerTextEnd);\n          this._unitMlString = innerText;\n          break;\n\n        case _XLIFF_TAG:\n          var localeAttr = element.attrs.find(function (attr) {\n            return attr.name === 'trgLang';\n          });\n\n          if (localeAttr) {\n            this._locale = localeAttr.value;\n          }\n\n          var versionAttr = element.attrs.find(function (attr) {\n            return attr.name === 'version';\n          });\n\n          if (versionAttr) {\n            var version = versionAttr.value;\n\n            if (version !== '2.0') {\n              this._addError(element, \"The XLIFF file version \".concat(version, \" is not compatible with XLIFF 2.0 serializer\"));\n            } else {\n              visitAll$1(this, element.children, null);\n            }\n          }\n\n          break;\n\n        default:\n          visitAll$1(this, element.children, null);\n      }\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute, context) {}\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, context) {}\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment, context) {}\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(expansion, context) {}\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(expansionCase, context) {}\n  }, {\n    key: \"_addError\",\n    value: function _addError(node, message) {\n      this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n  }]);\n\n  return Xliff2Parser;\n}(); // Convert ml nodes (xliff syntax) to i18n nodes\n\n\nvar XmlToI18n$1 = /*#__PURE__*/function () {\n  function XmlToI18n$1() {\n    _classCallCheck(this, XmlToI18n$1);\n  }\n\n  _createClass(XmlToI18n$1, [{\n    key: \"convert\",\n    value: function convert(message, url) {\n      var _ref31;\n\n      var xmlIcu = new XmlParser().parse(message, url, {\n        tokenizeExpansionForms: true\n      });\n      this._errors = xmlIcu.errors;\n      var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : (_ref31 = []).concat.apply(_ref31, _toConsumableArray(visitAll$1(this, xmlIcu.rootNodes)));\n      return {\n        i18nNodes: i18nNodes,\n        errors: this._errors\n      };\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      return new Text$1(text.value, text.sourceSpan);\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(el, context) {\n      var _this217 = this,\n          _ref32;\n\n      switch (el.name) {\n        case _PLACEHOLDER_TAG$2:\n          var nameAttr = el.attrs.find(function (attr) {\n            return attr.name === 'equiv';\n          });\n\n          if (nameAttr) {\n            return [new Placeholder('', nameAttr.value, el.sourceSpan)];\n          }\n\n          this._addError(el, \"<\".concat(_PLACEHOLDER_TAG$2, \"> misses the \\\"equiv\\\" attribute\"));\n\n          break;\n\n        case _PLACEHOLDER_SPANNING_TAG:\n          var startAttr = el.attrs.find(function (attr) {\n            return attr.name === 'equivStart';\n          });\n          var endAttr = el.attrs.find(function (attr) {\n            return attr.name === 'equivEnd';\n          });\n\n          if (!startAttr) {\n            this._addError(el, \"<\".concat(_PLACEHOLDER_TAG$2, \"> misses the \\\"equivStart\\\" attribute\"));\n          } else if (!endAttr) {\n            this._addError(el, \"<\".concat(_PLACEHOLDER_TAG$2, \"> misses the \\\"equivEnd\\\" attribute\"));\n          } else {\n            var startId = startAttr.value;\n            var endId = endAttr.value;\n            var nodes = [];\n            return nodes.concat.apply(nodes, [new Placeholder('', startId, el.sourceSpan)].concat(_toConsumableArray(el.children.map(function (node) {\n              return node.visit(_this217, null);\n            })), [new Placeholder('', endId, el.sourceSpan)]));\n          }\n\n          break;\n\n        case _MARKER_TAG$1:\n          return (_ref32 = []).concat.apply(_ref32, _toConsumableArray(visitAll$1(this, el.children)));\n\n        default:\n          this._addError(el, \"Unexpected tag\");\n\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(icu, context) {\n      var caseMap = {};\n      visitAll$1(this, icu.cases).forEach(function (c) {\n        caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n      });\n      return new Icu$1(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(icuCase, context) {\n      var _ref33;\n\n      return {\n        value: icuCase.value,\n        nodes: (_ref33 = []).concat.apply(_ref33, _toConsumableArray(visitAll$1(this, icuCase.expression)))\n      };\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment, context) {}\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute, context) {}\n  }, {\n    key: \"_addError\",\n    value: function _addError(node, message) {\n      this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n  }]);\n\n  return XmlToI18n$1;\n}();\n\nfunction getTypeForTag(tag) {\n  switch (tag.toLowerCase()) {\n    case 'br':\n    case 'b':\n    case 'i':\n    case 'u':\n      return 'fmt';\n\n    case 'img':\n      return 'image';\n\n    case 'a':\n      return 'link';\n\n    default:\n      return 'other';\n  }\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar _TRANSLATIONS_TAG = 'translationbundle';\nvar _TRANSLATION_TAG = 'translation';\nvar _PLACEHOLDER_TAG$3 = 'ph';\n\nvar Xtb = /*#__PURE__*/function (_Serializer4) {\n  _inherits(Xtb, _Serializer4);\n\n  var _super104 = _createSuper(Xtb);\n\n  function Xtb() {\n    _classCallCheck(this, Xtb);\n\n    return _super104.apply(this, arguments);\n  }\n\n  _createClass(Xtb, [{\n    key: \"write\",\n    value: function write(messages, locale) {\n      throw new Error('Unsupported');\n    }\n  }, {\n    key: \"load\",\n    value: function load(content, url) {\n      // xtb to xml nodes\n      var xtbParser = new XtbParser();\n\n      var _xtbParser$parse = xtbParser.parse(content, url),\n          locale = _xtbParser$parse.locale,\n          msgIdToHtml = _xtbParser$parse.msgIdToHtml,\n          errors = _xtbParser$parse.errors; // xml nodes to i18n nodes\n\n\n      var i18nNodesByMsgId = {};\n      var converter = new XmlToI18n$2(); // Because we should be able to load xtb files that rely on features not supported by angular,\n      // we need to delay the conversion of html to i18n nodes so that non angular messages are not\n      // converted\n\n      Object.keys(msgIdToHtml).forEach(function (msgId) {\n        var valueFn = function valueFn() {\n          var _converter$convert3 = converter.convert(msgIdToHtml[msgId], url),\n              i18nNodes = _converter$convert3.i18nNodes,\n              errors = _converter$convert3.errors;\n\n          if (errors.length) {\n            throw new Error(\"xtb parse errors:\\n\".concat(errors.join('\\n')));\n          }\n\n          return i18nNodes;\n        };\n\n        createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\n      });\n\n      if (errors.length) {\n        throw new Error(\"xtb parse errors:\\n\".concat(errors.join('\\n')));\n      }\n\n      return {\n        locale: locale,\n        i18nNodesByMsgId: i18nNodesByMsgId\n      };\n    }\n  }, {\n    key: \"digest\",\n    value: function digest(message) {\n      return digest$1(message);\n    }\n  }, {\n    key: \"createNameMapper\",\n    value: function createNameMapper(message) {\n      return new SimplePlaceholderMapper(message, toPublicName);\n    }\n  }]);\n\n  return Xtb;\n}(Serializer);\n\nfunction createLazyProperty(messages, id, valueFn) {\n  Object.defineProperty(messages, id, {\n    configurable: true,\n    enumerable: true,\n    get: function get() {\n      var value = valueFn();\n      Object.defineProperty(messages, id, {\n        enumerable: true,\n        value: value\n      });\n      return value;\n    },\n    set: function set(_) {\n      throw new Error('Could not overwrite an XTB translation');\n    }\n  });\n} // Extract messages as xml nodes from the xtb file\n\n\nvar XtbParser = /*#__PURE__*/function () {\n  function XtbParser() {\n    _classCallCheck(this, XtbParser);\n\n    this._locale = null;\n  }\n\n  _createClass(XtbParser, [{\n    key: \"parse\",\n    value: function parse(xtb, url) {\n      this._bundleDepth = 0;\n      this._msgIdToHtml = {}; // We can not parse the ICU messages at this point as some messages might not originate\n      // from Angular that could not be lex'd.\n\n      var xml = new XmlParser().parse(xtb, url);\n      this._errors = xml.errors;\n      visitAll$1(this, xml.rootNodes);\n      return {\n        msgIdToHtml: this._msgIdToHtml,\n        errors: this._errors,\n        locale: this._locale\n      };\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(element, context) {\n      switch (element.name) {\n        case _TRANSLATIONS_TAG:\n          this._bundleDepth++;\n\n          if (this._bundleDepth > 1) {\n            this._addError(element, \"<\".concat(_TRANSLATIONS_TAG, \"> elements can not be nested\"));\n          }\n\n          var langAttr = element.attrs.find(function (attr) {\n            return attr.name === 'lang';\n          });\n\n          if (langAttr) {\n            this._locale = langAttr.value;\n          }\n\n          visitAll$1(this, element.children, null);\n          this._bundleDepth--;\n          break;\n\n        case _TRANSLATION_TAG:\n          var idAttr = element.attrs.find(function (attr) {\n            return attr.name === 'id';\n          });\n\n          if (!idAttr) {\n            this._addError(element, \"<\".concat(_TRANSLATION_TAG, \"> misses the \\\"id\\\" attribute\"));\n          } else {\n            var id = idAttr.value;\n\n            if (this._msgIdToHtml.hasOwnProperty(id)) {\n              this._addError(element, \"Duplicated translations for msg \".concat(id));\n            } else {\n              var innerTextStart = element.startSourceSpan.end.offset;\n              var innerTextEnd = element.endSourceSpan.start.offset;\n              var content = element.startSourceSpan.start.file.content;\n              var innerText = content.slice(innerTextStart, innerTextEnd);\n              this._msgIdToHtml[id] = innerText;\n            }\n          }\n\n          break;\n\n        default:\n          this._addError(element, 'Unexpected tag');\n\n      }\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute, context) {}\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, context) {}\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment, context) {}\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(expansion, context) {}\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(expansionCase, context) {}\n  }, {\n    key: \"_addError\",\n    value: function _addError(node, message) {\n      this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n  }]);\n\n  return XtbParser;\n}(); // Convert ml nodes (xtb syntax) to i18n nodes\n\n\nvar XmlToI18n$2 = /*#__PURE__*/function () {\n  function XmlToI18n$2() {\n    _classCallCheck(this, XmlToI18n$2);\n  }\n\n  _createClass(XmlToI18n$2, [{\n    key: \"convert\",\n    value: function convert(message, url) {\n      var xmlIcu = new XmlParser().parse(message, url, {\n        tokenizeExpansionForms: true\n      });\n      this._errors = xmlIcu.errors;\n      var i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ? [] : visitAll$1(this, xmlIcu.rootNodes);\n      return {\n        i18nNodes: i18nNodes,\n        errors: this._errors\n      };\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      return new Text$1(text.value, text.sourceSpan);\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(icu, context) {\n      var caseMap = {};\n      visitAll$1(this, icu.cases).forEach(function (c) {\n        caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\n      });\n      return new Icu$1(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(icuCase, context) {\n      return {\n        value: icuCase.value,\n        nodes: visitAll$1(this, icuCase.expression)\n      };\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(el, context) {\n      if (el.name === _PLACEHOLDER_TAG$3) {\n        var nameAttr = el.attrs.find(function (attr) {\n          return attr.name === 'name';\n        });\n\n        if (nameAttr) {\n          return new Placeholder('', nameAttr.value, el.sourceSpan);\n        }\n\n        this._addError(el, \"<\".concat(_PLACEHOLDER_TAG$3, \"> misses the \\\"name\\\" attribute\"));\n      } else {\n        this._addError(el, \"Unexpected tag\");\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment, context) {}\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute, context) {}\n  }, {\n    key: \"_addError\",\n    value: function _addError(node, message) {\n      this._errors.push(new I18nError(node.sourceSpan, message));\n    }\n  }]);\n\n  return XmlToI18n$2;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * A container for translated messages\r\n */\n\n\nvar TranslationBundle = /*#__PURE__*/function () {\n  function TranslationBundle() {\n    var _i18nNodesByMsgId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var locale = arguments.length > 1 ? arguments[1] : undefined;\n    var digest = arguments.length > 2 ? arguments[2] : undefined;\n    var mapperFactory = arguments.length > 3 ? arguments[3] : undefined;\n    var missingTranslationStrategy = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : MissingTranslationStrategy.Warning;\n    var console = arguments.length > 5 ? arguments[5] : undefined;\n\n    _classCallCheck(this, TranslationBundle);\n\n    this._i18nNodesByMsgId = _i18nNodesByMsgId;\n    this.digest = digest;\n    this.mapperFactory = mapperFactory;\n    this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);\n  } // Creates a `TranslationBundle` by parsing the given `content` with the `serializer`.\n\n\n  _createClass(TranslationBundle, [{\n    key: \"get\",\n    value: // Returns the translation as HTML nodes from the given source message.\n    function get(srcMsg) {\n      var html = this._i18nToHtml.convert(srcMsg);\n\n      if (html.errors.length) {\n        throw new Error(html.errors.join('\\n'));\n      }\n\n      return html.nodes;\n    }\n  }, {\n    key: \"has\",\n    value: function has(srcMsg) {\n      return this.digest(srcMsg) in this._i18nNodesByMsgId;\n    }\n  }], [{\n    key: \"load\",\n    value: function load(content, url, serializer, missingTranslationStrategy, console) {\n      var _serializer$load = serializer.load(content, url),\n          locale = _serializer$load.locale,\n          i18nNodesByMsgId = _serializer$load.i18nNodesByMsgId;\n\n      var digestFn = function digestFn(m) {\n        return serializer.digest(m);\n      };\n\n      var mapperFactory = function mapperFactory(m) {\n        return serializer.createNameMapper(m);\n      };\n\n      return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);\n    }\n  }]);\n\n  return TranslationBundle;\n}();\n\nvar I18nToHtmlVisitor = /*#__PURE__*/function () {\n  function I18nToHtmlVisitor() {\n    var _i18nNodesByMsgId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _locale = arguments.length > 1 ? arguments[1] : undefined;\n\n    var _digest = arguments.length > 2 ? arguments[2] : undefined;\n\n    var _mapperFactory = arguments.length > 3 ? arguments[3] : undefined;\n\n    var _missingTranslationStrategy = arguments.length > 4 ? arguments[4] : undefined;\n\n    var _console = arguments.length > 5 ? arguments[5] : undefined;\n\n    _classCallCheck(this, I18nToHtmlVisitor);\n\n    this._i18nNodesByMsgId = _i18nNodesByMsgId;\n    this._locale = _locale;\n    this._digest = _digest;\n    this._mapperFactory = _mapperFactory;\n    this._missingTranslationStrategy = _missingTranslationStrategy;\n    this._console = _console;\n    this._contextStack = [];\n    this._errors = [];\n  }\n\n  _createClass(I18nToHtmlVisitor, [{\n    key: \"convert\",\n    value: function convert(srcMsg) {\n      this._contextStack.length = 0;\n      this._errors.length = 0; // i18n to text\n\n      var text = this._convertToText(srcMsg); // text to html\n\n\n      var url = srcMsg.nodes[0].sourceSpan.start.file.url;\n      var html = new HtmlParser().parse(text, url, {\n        tokenizeExpansionForms: true\n      });\n      return {\n        nodes: html.rootNodes,\n        errors: [].concat(_toConsumableArray(this._errors), _toConsumableArray(html.errors))\n      };\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      // `convert()` uses an `HtmlParser` to return `html.Node`s\n      // we should then make sure that any special characters are escaped\n      return escapeXml(text.value);\n    }\n  }, {\n    key: \"visitContainer\",\n    value: function visitContainer(container, context) {\n      var _this218 = this;\n\n      return container.children.map(function (n) {\n        return n.visit(_this218);\n      }).join('');\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu, context) {\n      var _this219 = this;\n\n      var cases = Object.keys(icu.cases).map(function (k) {\n        return \"\".concat(k, \" {\").concat(icu.cases[k].visit(_this219), \"}\");\n      }); // TODO(vicb): Once all format switch to using expression placeholders\n      // we should throw when the placeholder is not in the source message\n\n      var exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ? this._srcMsg.placeholders[icu.expression].text : icu.expression;\n      return \"{\".concat(exp, \", \").concat(icu.type, \", \").concat(cases.join(' '), \"}\");\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph, context) {\n      var phName = this._mapper(ph.name);\n\n      if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\n        return this._srcMsg.placeholders[phName].text;\n      }\n\n      if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\n        return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\n      }\n\n      this._addError(ph, \"Unknown placeholder \\\"\".concat(ph.name, \"\\\"\"));\n\n      return '';\n    } // Loaded message contains only placeholders (vs tag and icu placeholders).\n    // However when a translation can not be found, we need to serialize the source message\n    // which can contain tag placeholders\n\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph, context) {\n      var _this220 = this;\n\n      var tag = \"\".concat(ph.tag);\n      var attrs = Object.keys(ph.attrs).map(function (name) {\n        return \"\".concat(name, \"=\\\"\").concat(ph.attrs[name], \"\\\"\");\n      }).join(' ');\n\n      if (ph.isVoid) {\n        return \"<\".concat(tag, \" \").concat(attrs, \"/>\");\n      }\n\n      var children = ph.children.map(function (c) {\n        return c.visit(_this220);\n      }).join('');\n      return \"<\".concat(tag, \" \").concat(attrs, \">\").concat(children, \"</\").concat(tag, \">\");\n    } // Loaded message contains only placeholders (vs tag and icu placeholders).\n    // However when a translation can not be found, we need to serialize the source message\n    // which can contain tag placeholders\n\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {\n      // An ICU placeholder references the source message to be serialized\n      return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\n    }\n    /**\r\n     * Convert a source message to a translated text string:\r\n     * - text nodes are replaced with their translation,\r\n     * - placeholders are replaced with their content,\r\n     * - ICU nodes are converted to ICU expressions.\r\n     */\n\n  }, {\n    key: \"_convertToText\",\n    value: function _convertToText(srcMsg) {\n      var _this221 = this;\n\n      var id = this._digest(srcMsg);\n\n      var mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\n      var nodes;\n\n      this._contextStack.push({\n        msg: this._srcMsg,\n        mapper: this._mapper\n      });\n\n      this._srcMsg = srcMsg;\n\n      if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\n        // When there is a translation use its nodes as the source\n        // And create a mapper to convert serialized placeholder names to internal names\n        nodes = this._i18nNodesByMsgId[id];\n\n        this._mapper = function (name) {\n          return mapper ? mapper.toInternalName(name) : name;\n        };\n      } else {\n        // When no translation has been found\n        // - report an error / a warning / nothing,\n        // - use the nodes from the original message\n        // - placeholders are already internal and need no mapper\n        if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {\n          var ctx = this._locale ? \" for locale \\\"\".concat(this._locale, \"\\\"\") : '';\n\n          this._addError(srcMsg.nodes[0], \"Missing translation for message \\\"\".concat(id, \"\\\"\").concat(ctx));\n        } else if (this._console && this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {\n          var _ctx2 = this._locale ? \" for locale \\\"\".concat(this._locale, \"\\\"\") : '';\n\n          this._console.warn(\"Missing translation for message \\\"\".concat(id, \"\\\"\").concat(_ctx2));\n        }\n\n        nodes = srcMsg.nodes;\n\n        this._mapper = function (name) {\n          return name;\n        };\n      }\n\n      var text = nodes.map(function (node) {\n        return node.visit(_this221);\n      }).join('');\n\n      var context = this._contextStack.pop();\n\n      this._srcMsg = context.msg;\n      this._mapper = context.mapper;\n      return text;\n    }\n  }, {\n    key: \"_addError\",\n    value: function _addError(el, msg) {\n      this._errors.push(new I18nError(el.sourceSpan, msg));\n    }\n  }]);\n\n  return I18nToHtmlVisitor;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar I18NHtmlParser = /*#__PURE__*/function () {\n  function I18NHtmlParser(_htmlParser, translations, translationsFormat) {\n    var missingTranslation = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : MissingTranslationStrategy.Warning;\n    var console = arguments.length > 4 ? arguments[4] : undefined;\n\n    _classCallCheck(this, I18NHtmlParser);\n\n    this._htmlParser = _htmlParser;\n\n    if (translations) {\n      var _serializer = createSerializer(translationsFormat);\n\n      this._translationBundle = TranslationBundle.load(translations, 'i18n', _serializer, missingTranslation, console);\n    } else {\n      this._translationBundle = new TranslationBundle({}, null, _digest2, undefined, missingTranslation, console);\n    }\n  }\n\n  _createClass(I18NHtmlParser, [{\n    key: \"parse\",\n    value: function parse(source, url) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n\n      var parseResult = this._htmlParser.parse(source, url, Object.assign({\n        interpolationConfig: interpolationConfig\n      }, options));\n\n      if (parseResult.errors.length) {\n        return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);\n      }\n\n      return mergeTranslations(parseResult.rootNodes, this._translationBundle, interpolationConfig, [], {});\n    }\n  }]);\n\n  return I18NHtmlParser;\n}();\n\nfunction createSerializer(format) {\n  format = (format || 'xlf').toLowerCase();\n\n  switch (format) {\n    case 'xmb':\n      return new Xmb();\n\n    case 'xtb':\n      return new Xtb();\n\n    case 'xliff2':\n    case 'xlf2':\n      return new Xliff2();\n\n    case 'xliff':\n    case 'xlf':\n    default:\n      return new Xliff();\n  }\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar QUOTED_KEYS = '$quoted$';\n\nfunction convertValueToOutputAst(ctx, value) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return visitValue(value, new _ValueOutputAstTransformer(ctx), type);\n}\n\nvar _ValueOutputAstTransformer = /*#__PURE__*/function () {\n  function _ValueOutputAstTransformer(ctx) {\n    _classCallCheck(this, _ValueOutputAstTransformer);\n\n    this.ctx = ctx;\n  }\n\n  _createClass(_ValueOutputAstTransformer, [{\n    key: \"visitArray\",\n    value: function visitArray(arr, type) {\n      var values = []; // Note Array.map() must not be used to convert the values because it will\n      // skip over empty elements in arrays constructed using `new Array(length)`,\n      // resulting in `undefined` elements. This breaks the type guarantee that\n      // all values in `o.LiteralArrayExpr` are of type `o.Expression`.\n      // See test case in `value_util_spec.ts`.\n\n      for (var i = 0; i < arr.length; ++i) {\n        values.push(visitValue(arr[i], this, null\n        /* context */\n        ));\n      }\n\n      return literalArr(values, type);\n    }\n  }, {\n    key: \"visitStringMap\",\n    value: function visitStringMap(map, type) {\n      var _this222 = this;\n\n      var entries = [];\n      var quotedSet = new Set(map && map[QUOTED_KEYS]);\n      Object.keys(map).forEach(function (key) {\n        entries.push(new LiteralMapEntry(key, visitValue(map[key], _this222, null), quotedSet.has(key)));\n      });\n      return new LiteralMapExpr(entries, type);\n    }\n  }, {\n    key: \"visitPrimitive\",\n    value: function visitPrimitive(value, type) {\n      return literal(value, type);\n    }\n  }, {\n    key: \"visitOther\",\n    value: function visitOther(value, type) {\n      if (value instanceof Expression) {\n        return value;\n      } else {\n        return this.ctx.importExpr(value);\n      }\n    }\n  }]);\n\n  return _ValueOutputAstTransformer;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nfunction mapEntry$1(key, value) {\n  return {\n    key: key,\n    value: value,\n    quoted: false\n  };\n}\n\nvar InjectableCompiler = /*#__PURE__*/function () {\n  function InjectableCompiler(reflector, alwaysGenerateDef) {\n    _classCallCheck(this, InjectableCompiler);\n\n    this.reflector = reflector;\n    this.alwaysGenerateDef = alwaysGenerateDef;\n    this.tokenInjector = reflector.resolveExternalReference(Identifiers$1.Injector);\n  }\n\n  _createClass(InjectableCompiler, [{\n    key: \"depsArray\",\n    value: function depsArray(deps, ctx) {\n      var _this223 = this;\n\n      return deps.map(function (dep) {\n        var token = dep;\n        var args = [token];\n        var flags = 0\n        /* Default */\n        ;\n\n        if (Array.isArray(dep)) {\n          for (var i = 0; i < dep.length; i++) {\n            var v = dep[i];\n\n            if (v) {\n              if (v.ngMetadataName === 'Optional') {\n                flags |= 8\n                /* Optional */\n                ;\n              } else if (v.ngMetadataName === 'SkipSelf') {\n                flags |= 4\n                /* SkipSelf */\n                ;\n              } else if (v.ngMetadataName === 'Self') {\n                flags |= 2\n                /* Self */\n                ;\n              } else if (v.ngMetadataName === 'Inject') {\n                token = v.token;\n              } else {\n                token = v;\n              }\n            }\n          }\n        }\n\n        var tokenExpr;\n\n        if (typeof token === 'string') {\n          tokenExpr = literal(token);\n        } else if (token === _this223.tokenInjector) {\n          tokenExpr = importExpr(Identifiers$1.INJECTOR);\n        } else {\n          tokenExpr = ctx.importExpr(token);\n        }\n\n        if (flags !== 0\n        /* Default */\n        ) {\n            args = [tokenExpr, literal(flags)];\n          } else {\n          args = [tokenExpr];\n        }\n\n        return importExpr(Identifiers$1.inject).callFn(args);\n      });\n    }\n  }, {\n    key: \"factoryFor\",\n    value: function factoryFor(injectable, ctx) {\n      var retValue;\n\n      if (injectable.useExisting) {\n        retValue = importExpr(Identifiers$1.inject).callFn([ctx.importExpr(injectable.useExisting)]);\n      } else if (injectable.useFactory) {\n        var deps = injectable.deps || [];\n\n        if (deps.length > 0) {\n          retValue = ctx.importExpr(injectable.useFactory).callFn(this.depsArray(deps, ctx));\n        } else {\n          return ctx.importExpr(injectable.useFactory);\n        }\n      } else if (injectable.useValue) {\n        retValue = convertValueToOutputAst(ctx, injectable.useValue);\n      } else {\n        var clazz = injectable.useClass || injectable.symbol;\n        var depArgs = this.depsArray(this.reflector.parameters(clazz), ctx);\n        retValue = new InstantiateExpr(ctx.importExpr(clazz), depArgs);\n      }\n\n      return fn([], [new ReturnStatement(retValue)], undefined, undefined, injectable.symbol.name + '_Factory');\n    }\n  }, {\n    key: \"injectableDef\",\n    value: function injectableDef(injectable, ctx) {\n      var providedIn = NULL_EXPR;\n\n      if (injectable.providedIn !== undefined) {\n        if (injectable.providedIn === null) {\n          providedIn = NULL_EXPR;\n        } else if (typeof injectable.providedIn === 'string') {\n          providedIn = literal(injectable.providedIn);\n        } else {\n          providedIn = ctx.importExpr(injectable.providedIn);\n        }\n      }\n\n      var def = [mapEntry$1('factory', this.factoryFor(injectable, ctx)), mapEntry$1('token', ctx.importExpr(injectable.type.reference)), mapEntry$1('providedIn', providedIn)];\n      return importExpr(Identifiers.ɵɵdefineInjectable).callFn([literalMap(def)], undefined, true);\n    }\n  }, {\n    key: \"compile\",\n    value: function compile(injectable, ctx) {\n      if (this.alwaysGenerateDef || injectable.providedIn !== undefined) {\n        var className = identifierName(injectable.type);\n        var clazz = new ClassStmt(className, null, [new ClassField('ɵprov', INFERRED_TYPE, [StmtModifier.Static], this.injectableDef(injectable, ctx))], [], new ClassMethod(null, [], []), []);\n        ctx.statements.push(clazz);\n      }\n    }\n  }]);\n\n  return InjectableCompiler;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar STRIP_SRC_FILE_SUFFIXES = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\nvar GENERATED_FILE = /\\.ngfactory\\.|\\.ngsummary\\./;\nvar JIT_SUMMARY_FILE = /\\.ngsummary\\./;\nvar JIT_SUMMARY_NAME = /NgSummary$/;\n\nfunction ngfactoryFilePath(filePath) {\n  var forceSourceFile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var urlWithSuffix = splitTypescriptSuffix(filePath, forceSourceFile);\n  return \"\".concat(urlWithSuffix[0], \".ngfactory\").concat(normalizeGenFileSuffix(urlWithSuffix[1]));\n}\n\nfunction stripGeneratedFileSuffix(filePath) {\n  return filePath.replace(GENERATED_FILE, '.');\n}\n\nfunction isGeneratedFile(filePath) {\n  return GENERATED_FILE.test(filePath);\n}\n\nfunction splitTypescriptSuffix(path) {\n  var forceSourceFile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (path.endsWith('.d.ts')) {\n    return [path.slice(0, -5), forceSourceFile ? '.ts' : '.d.ts'];\n  }\n\n  var lastDot = path.lastIndexOf('.');\n\n  if (lastDot !== -1) {\n    return [path.substring(0, lastDot), path.substring(lastDot)];\n  }\n\n  return [path, ''];\n}\n\nfunction normalizeGenFileSuffix(srcFileSuffix) {\n  return srcFileSuffix === '.tsx' ? '.ts' : srcFileSuffix;\n}\n\nfunction summaryFileName(fileName) {\n  var fileNameWithoutSuffix = fileName.replace(STRIP_SRC_FILE_SUFFIXES, '');\n  return \"\".concat(fileNameWithoutSuffix, \".ngsummary.json\");\n}\n\nfunction summaryForJitFileName(fileName) {\n  var forceSourceFile = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var urlWithSuffix = splitTypescriptSuffix(stripGeneratedFileSuffix(fileName), forceSourceFile);\n  return \"\".concat(urlWithSuffix[0], \".ngsummary\").concat(urlWithSuffix[1]);\n}\n\nfunction stripSummaryForJitFileSuffix(filePath) {\n  return filePath.replace(JIT_SUMMARY_FILE, '.');\n}\n\nfunction summaryForJitName(symbolName) {\n  return \"\".concat(symbolName, \"NgSummary\");\n}\n\nfunction stripSummaryForJitNameSuffix(symbolName) {\n  return symbolName.replace(JIT_SUMMARY_NAME, '');\n}\n\nvar LOWERED_SYMBOL = /\\u0275\\d+/;\n\nfunction isLoweredSymbol(name) {\n  return LOWERED_SYMBOL.test(name);\n}\n\nfunction createLoweredSymbol(id) {\n  return \"\\u0275\".concat(id);\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar LifecycleHooks;\n\n(function (LifecycleHooks) {\n  LifecycleHooks[LifecycleHooks[\"OnInit\"] = 0] = \"OnInit\";\n  LifecycleHooks[LifecycleHooks[\"OnDestroy\"] = 1] = \"OnDestroy\";\n  LifecycleHooks[LifecycleHooks[\"DoCheck\"] = 2] = \"DoCheck\";\n  LifecycleHooks[LifecycleHooks[\"OnChanges\"] = 3] = \"OnChanges\";\n  LifecycleHooks[LifecycleHooks[\"AfterContentInit\"] = 4] = \"AfterContentInit\";\n  LifecycleHooks[LifecycleHooks[\"AfterContentChecked\"] = 5] = \"AfterContentChecked\";\n  LifecycleHooks[LifecycleHooks[\"AfterViewInit\"] = 6] = \"AfterViewInit\";\n  LifecycleHooks[LifecycleHooks[\"AfterViewChecked\"] = 7] = \"AfterViewChecked\";\n})(LifecycleHooks || (LifecycleHooks = {}));\n\nvar LIFECYCLE_HOOKS_VALUES = [LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges, LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit, LifecycleHooks.AfterViewChecked];\n\nfunction hasLifecycleHook(reflector, hook, token) {\n  return reflector.hasLifecycleHook(token, getHookName(hook));\n}\n\nfunction getAllLifecycleHooks(reflector, token) {\n  return LIFECYCLE_HOOKS_VALUES.filter(function (hook) {\n    return hasLifecycleHook(reflector, hook, token);\n  });\n}\n\nfunction getHookName(hook) {\n  switch (hook) {\n    case LifecycleHooks.OnInit:\n      return 'ngOnInit';\n\n    case LifecycleHooks.OnDestroy:\n      return 'ngOnDestroy';\n\n    case LifecycleHooks.DoCheck:\n      return 'ngDoCheck';\n\n    case LifecycleHooks.OnChanges:\n      return 'ngOnChanges';\n\n    case LifecycleHooks.AfterContentInit:\n      return 'ngAfterContentInit';\n\n    case LifecycleHooks.AfterContentChecked:\n      return 'ngAfterContentChecked';\n\n    case LifecycleHooks.AfterViewInit:\n      return 'ngAfterViewInit';\n\n    case LifecycleHooks.AfterViewChecked:\n      return 'ngAfterViewChecked';\n\n    default:\n      // This default case is not needed by TypeScript compiler, as the switch is exhaustive.\n      // However Closure Compiler does not understand that and reports an error in typed mode.\n      // The `throw new Error` below works around the problem, and the unexpected: never variable\n      // makes sure tsc still checks this code is unreachable.\n      var unexpected = hook;\n      throw new Error(\"unexpected \".concat(unexpected));\n  }\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar ERROR_COMPONENT_TYPE = 'ngComponentType';\nvar MISSING_NG_MODULE_METADATA_ERROR_DATA = 'ngMissingNgModuleMetadataErrorData';\n\nfunction getMissingNgModuleMetadataErrorData(error) {\n  var _a;\n\n  return (_a = error[MISSING_NG_MODULE_METADATA_ERROR_DATA]) !== null && _a !== void 0 ? _a : null;\n} // Design notes:\n// - don't lazily create metadata:\n//   For some metadata, we need to do async work sometimes,\n//   so the user has to kick off this loading.\n//   But we want to report errors even when the async work is\n//   not required to check that the user would have been able\n//   to wait correctly.\n\n\nvar CompileMetadataResolver = /*#__PURE__*/function () {\n  function CompileMetadataResolver(_config, _htmlParser, _ngModuleResolver, _directiveResolver, _pipeResolver, _summaryResolver, _schemaRegistry, _directiveNormalizer, _console, _staticSymbolCache, _reflector, _errorCollector) {\n    _classCallCheck(this, CompileMetadataResolver);\n\n    this._config = _config;\n    this._htmlParser = _htmlParser;\n    this._ngModuleResolver = _ngModuleResolver;\n    this._directiveResolver = _directiveResolver;\n    this._pipeResolver = _pipeResolver;\n    this._summaryResolver = _summaryResolver;\n    this._schemaRegistry = _schemaRegistry;\n    this._directiveNormalizer = _directiveNormalizer;\n    this._console = _console;\n    this._staticSymbolCache = _staticSymbolCache;\n    this._reflector = _reflector;\n    this._errorCollector = _errorCollector;\n    this._nonNormalizedDirectiveCache = new Map();\n    this._directiveCache = new Map();\n    this._summaryCache = new Map();\n    this._pipeCache = new Map();\n    this._ngModuleCache = new Map();\n    this._ngModuleOfTypes = new Map();\n    this._shallowModuleCache = new Map();\n  }\n\n  _createClass(CompileMetadataResolver, [{\n    key: \"getReflector\",\n    value: function getReflector() {\n      return this._reflector;\n    }\n  }, {\n    key: \"clearCacheFor\",\n    value: function clearCacheFor(type) {\n      var dirMeta = this._directiveCache.get(type);\n\n      this._directiveCache.delete(type);\n\n      this._nonNormalizedDirectiveCache.delete(type);\n\n      this._summaryCache.delete(type);\n\n      this._pipeCache.delete(type);\n\n      this._ngModuleOfTypes.delete(type); // Clear all of the NgModule as they contain transitive information!\n\n\n      this._ngModuleCache.clear();\n\n      if (dirMeta) {\n        this._directiveNormalizer.clearCacheFor(dirMeta);\n      }\n    }\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {\n      this._directiveCache.clear();\n\n      this._nonNormalizedDirectiveCache.clear();\n\n      this._summaryCache.clear();\n\n      this._pipeCache.clear();\n\n      this._ngModuleCache.clear();\n\n      this._ngModuleOfTypes.clear();\n\n      this._directiveNormalizer.clearCache();\n    }\n  }, {\n    key: \"_createProxyClass\",\n    value: function _createProxyClass(baseType, name) {\n      var delegate = null;\n\n      var proxyClass = function proxyClass() {\n        if (!delegate) {\n          throw new Error(\"Illegal state: Class \".concat(name, \" for type \").concat(stringify(baseType), \" is not compiled yet!\"));\n        }\n\n        return delegate.apply(this, arguments);\n      };\n\n      proxyClass.setDelegate = function (d) {\n        delegate = d;\n        proxyClass.prototype = d.prototype;\n      }; // Make stringify work correctly\n\n\n      proxyClass.overriddenName = name;\n      return proxyClass;\n    }\n  }, {\n    key: \"getGeneratedClass\",\n    value: function getGeneratedClass(dirType, name) {\n      if (dirType instanceof StaticSymbol) {\n        return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), name);\n      } else {\n        return this._createProxyClass(dirType, name);\n      }\n    }\n  }, {\n    key: \"getComponentViewClass\",\n    value: function getComponentViewClass(dirType) {\n      return this.getGeneratedClass(dirType, viewClassName(dirType, 0));\n    }\n  }, {\n    key: \"getHostComponentViewClass\",\n    value: function getHostComponentViewClass(dirType) {\n      return this.getGeneratedClass(dirType, hostViewClassName(dirType));\n    }\n  }, {\n    key: \"getHostComponentType\",\n    value: function getHostComponentType(dirType) {\n      var name = \"\".concat(identifierName({\n        reference: dirType\n      }), \"_Host\");\n\n      if (dirType instanceof StaticSymbol) {\n        return this._staticSymbolCache.get(dirType.filePath, name);\n      }\n\n      return this._createProxyClass(dirType, name);\n    }\n  }, {\n    key: \"getRendererType\",\n    value: function getRendererType(dirType) {\n      if (dirType instanceof StaticSymbol) {\n        return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), rendererTypeName(dirType));\n      } else {\n        // returning an object as proxy,\n        // that we fill later during runtime compilation.\n        return {};\n      }\n    }\n  }, {\n    key: \"getComponentFactory\",\n    value: function getComponentFactory(selector, dirType, inputs, outputs) {\n      if (dirType instanceof StaticSymbol) {\n        return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), componentFactoryName(dirType));\n      } else {\n        var hostView = this.getHostComponentViewClass(dirType); // Note: ngContentSelectors will be filled later once the template is\n        // loaded.\n\n        var createComponentFactory = this._reflector.resolveExternalReference(Identifiers$1.createComponentFactory);\n\n        return createComponentFactory(selector, dirType, hostView, inputs, outputs, []);\n      }\n    }\n  }, {\n    key: \"initComponentFactory\",\n    value: function initComponentFactory(factory, ngContentSelectors) {\n      if (!(factory instanceof StaticSymbol)) {\n        var _factory$ngContentSel;\n\n        (_factory$ngContentSel = factory.ngContentSelectors).push.apply(_factory$ngContentSel, _toConsumableArray(ngContentSelectors));\n      }\n    }\n  }, {\n    key: \"_loadSummary\",\n    value: function _loadSummary(type, kind) {\n      var typeSummary = this._summaryCache.get(type);\n\n      if (!typeSummary) {\n        var summary = this._summaryResolver.resolveSummary(type);\n\n        typeSummary = summary ? summary.type : null;\n\n        this._summaryCache.set(type, typeSummary || null);\n      }\n\n      return typeSummary && typeSummary.summaryKind === kind ? typeSummary : null;\n    }\n  }, {\n    key: \"getHostComponentMetadata\",\n    value: function getHostComponentMetadata(compMeta, hostViewType) {\n      var hostType = this.getHostComponentType(compMeta.type.reference);\n\n      if (!hostViewType) {\n        hostViewType = this.getHostComponentViewClass(hostType);\n      } // Note: ! is ok here as this method should only be called with normalized directive\n      // metadata, which always fills in the selector.\n\n\n      var template = CssSelector.parse(compMeta.selector)[0].getMatchingElementTemplate();\n      var templateUrl = '';\n\n      var htmlAst = this._htmlParser.parse(template, templateUrl);\n\n      return CompileDirectiveMetadata.create({\n        isHost: true,\n        type: {\n          reference: hostType,\n          diDeps: [],\n          lifecycleHooks: []\n        },\n        template: new CompileTemplateMetadata({\n          encapsulation: ViewEncapsulation.None,\n          template: template,\n          templateUrl: templateUrl,\n          htmlAst: htmlAst,\n          styles: [],\n          styleUrls: [],\n          ngContentSelectors: [],\n          animations: [],\n          isInline: true,\n          externalStylesheets: [],\n          interpolation: null,\n          preserveWhitespaces: false\n        }),\n        exportAs: null,\n        changeDetection: ChangeDetectionStrategy.Default,\n        inputs: [],\n        outputs: [],\n        host: {},\n        isComponent: true,\n        selector: '*',\n        providers: [],\n        viewProviders: [],\n        queries: [],\n        guards: {},\n        viewQueries: [],\n        componentViewType: hostViewType,\n        rendererType: {\n          id: '__Host__',\n          encapsulation: ViewEncapsulation.None,\n          styles: [],\n          data: {}\n        },\n        entryComponents: [],\n        componentFactory: null\n      });\n    }\n  }, {\n    key: \"loadDirectiveMetadata\",\n    value: function loadDirectiveMetadata(ngModuleType, directiveType, isSync) {\n      var _this224 = this;\n\n      if (this._directiveCache.has(directiveType)) {\n        return null;\n      }\n\n      directiveType = resolveForwardRef(directiveType);\n\n      var _this$getNonNormalize = this.getNonNormalizedDirectiveMetadata(directiveType),\n          annotation = _this$getNonNormalize.annotation,\n          metadata = _this$getNonNormalize.metadata;\n\n      var createDirectiveMetadata = function createDirectiveMetadata(templateMetadata) {\n        var normalizedDirMeta = new CompileDirectiveMetadata({\n          isHost: false,\n          type: metadata.type,\n          isComponent: metadata.isComponent,\n          selector: metadata.selector,\n          exportAs: metadata.exportAs,\n          changeDetection: metadata.changeDetection,\n          inputs: metadata.inputs,\n          outputs: metadata.outputs,\n          hostListeners: metadata.hostListeners,\n          hostProperties: metadata.hostProperties,\n          hostAttributes: metadata.hostAttributes,\n          providers: metadata.providers,\n          viewProviders: metadata.viewProviders,\n          queries: metadata.queries,\n          guards: metadata.guards,\n          viewQueries: metadata.viewQueries,\n          entryComponents: metadata.entryComponents,\n          componentViewType: metadata.componentViewType,\n          rendererType: metadata.rendererType,\n          componentFactory: metadata.componentFactory,\n          template: templateMetadata\n        });\n\n        if (templateMetadata) {\n          _this224.initComponentFactory(metadata.componentFactory, templateMetadata.ngContentSelectors);\n        }\n\n        _this224._directiveCache.set(directiveType, normalizedDirMeta);\n\n        _this224._summaryCache.set(directiveType, normalizedDirMeta.toSummary());\n\n        return null;\n      };\n\n      if (metadata.isComponent) {\n        var template = metadata.template;\n\n        var templateMeta = this._directiveNormalizer.normalizeTemplate({\n          ngModuleType: ngModuleType,\n          componentType: directiveType,\n          moduleUrl: this._reflector.componentModuleUrl(directiveType, annotation),\n          encapsulation: template.encapsulation,\n          template: template.template,\n          templateUrl: template.templateUrl,\n          styles: template.styles,\n          styleUrls: template.styleUrls,\n          animations: template.animations,\n          interpolation: template.interpolation,\n          preserveWhitespaces: template.preserveWhitespaces\n        });\n\n        if (isPromise(templateMeta) && isSync) {\n          this._reportError(componentStillLoadingError(directiveType), directiveType);\n\n          return null;\n        }\n\n        return SyncAsync.then(templateMeta, createDirectiveMetadata);\n      } else {\n        // directive\n        createDirectiveMetadata(null);\n        return null;\n      }\n    }\n  }, {\n    key: \"getNonNormalizedDirectiveMetadata\",\n    value: function getNonNormalizedDirectiveMetadata(directiveType) {\n      var _this225 = this;\n\n      directiveType = resolveForwardRef(directiveType);\n\n      if (!directiveType) {\n        return null;\n      }\n\n      var cacheEntry = this._nonNormalizedDirectiveCache.get(directiveType);\n\n      if (cacheEntry) {\n        return cacheEntry;\n      }\n\n      var dirMeta = this._directiveResolver.resolve(directiveType, false);\n\n      if (!dirMeta) {\n        return null;\n      }\n\n      var nonNormalizedTemplateMetadata = undefined;\n\n      if (createComponent.isTypeOf(dirMeta)) {\n        // component\n        var compMeta = dirMeta;\n        assertArrayOfStrings('styles', compMeta.styles);\n        assertArrayOfStrings('styleUrls', compMeta.styleUrls);\n        assertInterpolationSymbols('interpolation', compMeta.interpolation);\n        var animations = compMeta.animations;\n        nonNormalizedTemplateMetadata = new CompileTemplateMetadata({\n          encapsulation: noUndefined(compMeta.encapsulation),\n          template: noUndefined(compMeta.template),\n          templateUrl: noUndefined(compMeta.templateUrl),\n          htmlAst: null,\n          styles: compMeta.styles || [],\n          styleUrls: compMeta.styleUrls || [],\n          animations: animations || [],\n          interpolation: noUndefined(compMeta.interpolation),\n          isInline: !!compMeta.template,\n          externalStylesheets: [],\n          ngContentSelectors: [],\n          preserveWhitespaces: noUndefined(dirMeta.preserveWhitespaces)\n        });\n      }\n\n      var changeDetectionStrategy = null;\n      var viewProviders = [];\n      var entryComponentMetadata = [];\n      var selector = dirMeta.selector;\n\n      if (createComponent.isTypeOf(dirMeta)) {\n        // Component\n        var _compMeta = dirMeta;\n        changeDetectionStrategy = _compMeta.changeDetection;\n\n        if (_compMeta.viewProviders) {\n          viewProviders = this._getProvidersMetadata(_compMeta.viewProviders, entryComponentMetadata, \"viewProviders for \\\"\".concat(stringifyType(directiveType), \"\\\"\"), [], directiveType);\n        }\n\n        if (_compMeta.entryComponents) {\n          entryComponentMetadata = flattenAndDedupeArray(_compMeta.entryComponents).map(function (type) {\n            return _this225._getEntryComponentMetadata(type);\n          }).concat(entryComponentMetadata);\n        }\n\n        if (!selector) {\n          selector = this._schemaRegistry.getDefaultComponentElementName();\n        }\n      } else {\n        // Directive\n        if (!selector) {\n          selector = null;\n        }\n      }\n\n      var providers = [];\n\n      if (dirMeta.providers != null) {\n        providers = this._getProvidersMetadata(dirMeta.providers, entryComponentMetadata, \"providers for \\\"\".concat(stringifyType(directiveType), \"\\\"\"), [], directiveType);\n      }\n\n      var queries = [];\n      var viewQueries = [];\n\n      if (dirMeta.queries != null) {\n        queries = this._getQueriesMetadata(dirMeta.queries, false, directiveType);\n        viewQueries = this._getQueriesMetadata(dirMeta.queries, true, directiveType);\n      }\n\n      var metadata = CompileDirectiveMetadata.create({\n        isHost: false,\n        selector: selector,\n        exportAs: noUndefined(dirMeta.exportAs),\n        isComponent: !!nonNormalizedTemplateMetadata,\n        type: this._getTypeMetadata(directiveType),\n        template: nonNormalizedTemplateMetadata,\n        changeDetection: changeDetectionStrategy,\n        inputs: dirMeta.inputs || [],\n        outputs: dirMeta.outputs || [],\n        host: dirMeta.host || {},\n        providers: providers || [],\n        viewProviders: viewProviders || [],\n        queries: queries || [],\n        guards: dirMeta.guards || {},\n        viewQueries: viewQueries || [],\n        entryComponents: entryComponentMetadata,\n        componentViewType: nonNormalizedTemplateMetadata ? this.getComponentViewClass(directiveType) : null,\n        rendererType: nonNormalizedTemplateMetadata ? this.getRendererType(directiveType) : null,\n        componentFactory: null\n      });\n\n      if (nonNormalizedTemplateMetadata) {\n        metadata.componentFactory = this.getComponentFactory(selector, directiveType, metadata.inputs, metadata.outputs);\n      }\n\n      cacheEntry = {\n        metadata: metadata,\n        annotation: dirMeta\n      };\n\n      this._nonNormalizedDirectiveCache.set(directiveType, cacheEntry);\n\n      return cacheEntry;\n    }\n    /**\r\n     * Gets the metadata for the given directive.\r\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\r\n     */\n\n  }, {\n    key: \"getDirectiveMetadata\",\n    value: function getDirectiveMetadata(directiveType) {\n      var dirMeta = this._directiveCache.get(directiveType);\n\n      if (!dirMeta) {\n        this._reportError(syntaxError(\"Illegal state: getDirectiveMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Directive \".concat(stringifyType(directiveType), \".\")), directiveType);\n      }\n\n      return dirMeta;\n    }\n  }, {\n    key: \"getDirectiveSummary\",\n    value: function getDirectiveSummary(dirType) {\n      var dirSummary = this._loadSummary(dirType, CompileSummaryKind.Directive);\n\n      if (!dirSummary) {\n        this._reportError(syntaxError(\"Illegal state: Could not load the summary for directive \".concat(stringifyType(dirType), \".\")), dirType);\n      }\n\n      return dirSummary;\n    }\n  }, {\n    key: \"isDirective\",\n    value: function isDirective(type) {\n      return !!this._loadSummary(type, CompileSummaryKind.Directive) || this._directiveResolver.isDirective(type);\n    }\n  }, {\n    key: \"isAbstractDirective\",\n    value: function isAbstractDirective(type) {\n      var summary = this._loadSummary(type, CompileSummaryKind.Directive);\n\n      if (summary && !summary.isComponent) {\n        return !summary.selector;\n      }\n\n      var meta = this._directiveResolver.resolve(type, false);\n\n      if (meta && !createComponent.isTypeOf(meta)) {\n        return !meta.selector;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isPipe\",\n    value: function isPipe(type) {\n      return !!this._loadSummary(type, CompileSummaryKind.Pipe) || this._pipeResolver.isPipe(type);\n    }\n  }, {\n    key: \"isNgModule\",\n    value: function isNgModule(type) {\n      return !!this._loadSummary(type, CompileSummaryKind.NgModule) || this._ngModuleResolver.isNgModule(type);\n    }\n  }, {\n    key: \"getNgModuleSummary\",\n    value: function getNgModuleSummary(moduleType) {\n      var alreadyCollecting = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      var moduleSummary = this._loadSummary(moduleType, CompileSummaryKind.NgModule);\n\n      if (!moduleSummary) {\n        var moduleMeta = this.getNgModuleMetadata(moduleType, false, alreadyCollecting);\n        moduleSummary = moduleMeta ? moduleMeta.toSummary() : null;\n\n        if (moduleSummary) {\n          this._summaryCache.set(moduleType, moduleSummary);\n        }\n      }\n\n      return moduleSummary;\n    }\n    /**\r\n     * Loads the declared directives and pipes of an NgModule.\r\n     */\n\n  }, {\n    key: \"loadNgModuleDirectiveAndPipeMetadata\",\n    value: function loadNgModuleDirectiveAndPipeMetadata(moduleType, isSync) {\n      var _this226 = this;\n\n      var throwIfNotFound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var ngModule = this.getNgModuleMetadata(moduleType, throwIfNotFound);\n      var loading = [];\n\n      if (ngModule) {\n        ngModule.declaredDirectives.forEach(function (id) {\n          var promise = _this226.loadDirectiveMetadata(moduleType, id.reference, isSync);\n\n          if (promise) {\n            loading.push(promise);\n          }\n        });\n        ngModule.declaredPipes.forEach(function (id) {\n          return _this226._loadPipeMetadata(id.reference);\n        });\n      }\n\n      return Promise.all(loading);\n    }\n  }, {\n    key: \"getShallowModuleMetadata\",\n    value: function getShallowModuleMetadata(moduleType) {\n      var compileMeta = this._shallowModuleCache.get(moduleType);\n\n      if (compileMeta) {\n        return compileMeta;\n      }\n\n      var ngModuleMeta = findLast(this._reflector.shallowAnnotations(moduleType), createNgModule.isTypeOf);\n      compileMeta = {\n        type: this._getTypeMetadata(moduleType),\n        rawExports: ngModuleMeta.exports,\n        rawImports: ngModuleMeta.imports,\n        rawProviders: ngModuleMeta.providers\n      };\n\n      this._shallowModuleCache.set(moduleType, compileMeta);\n\n      return compileMeta;\n    }\n  }, {\n    key: \"getNgModuleMetadata\",\n    value: function getNgModuleMetadata(moduleType) {\n      var _this227 = this;\n\n      var throwIfNotFound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var alreadyCollecting = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      moduleType = resolveForwardRef(moduleType);\n\n      var compileMeta = this._ngModuleCache.get(moduleType);\n\n      if (compileMeta) {\n        return compileMeta;\n      }\n\n      var meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);\n\n      if (!meta) {\n        return null;\n      }\n\n      var declaredDirectives = [];\n      var exportedNonModuleIdentifiers = [];\n      var declaredPipes = [];\n      var importedModules = [];\n      var exportedModules = [];\n      var providers = [];\n      var entryComponents = [];\n      var bootstrapComponents = [];\n      var schemas = [];\n\n      if (meta.imports) {\n        flattenAndDedupeArray(meta.imports).forEach(function (importedType) {\n          var importedModuleType = undefined;\n\n          if (isValidType(importedType)) {\n            importedModuleType = importedType;\n          } else if (importedType && importedType.ngModule) {\n            var moduleWithProviders = importedType;\n            importedModuleType = moduleWithProviders.ngModule;\n\n            if (moduleWithProviders.providers) {\n              providers.push.apply(providers, _toConsumableArray(_this227._getProvidersMetadata(moduleWithProviders.providers, entryComponents, \"provider for the NgModule '\".concat(stringifyType(importedModuleType), \"'\"), [], importedType)));\n            }\n          }\n\n          if (importedModuleType) {\n            if (_this227._checkSelfImport(moduleType, importedModuleType)) return;\n            if (!alreadyCollecting) alreadyCollecting = new Set();\n\n            if (alreadyCollecting.has(importedModuleType)) {\n              _this227._reportError(syntaxError(\"\".concat(_this227._getTypeDescriptor(importedModuleType), \" '\").concat(stringifyType(importedType), \"' is imported recursively by the module '\").concat(stringifyType(moduleType), \"'.\")), moduleType);\n\n              return;\n            }\n\n            alreadyCollecting.add(importedModuleType);\n\n            var importedModuleSummary = _this227.getNgModuleSummary(importedModuleType, alreadyCollecting);\n\n            alreadyCollecting.delete(importedModuleType);\n\n            if (!importedModuleSummary) {\n              var err = syntaxError(\"Unexpected \".concat(_this227._getTypeDescriptor(importedType), \" '\").concat(stringifyType(importedType), \"' imported by the module '\").concat(stringifyType(moduleType), \"'. Please add a @NgModule annotation.\")); // If possible, record additional context for this error to enable more useful\n              // diagnostics on the compiler side.\n\n              if (importedType instanceof StaticSymbol) {\n                err[MISSING_NG_MODULE_METADATA_ERROR_DATA] = {\n                  fileName: importedType.filePath,\n                  className: importedType.name\n                };\n              }\n\n              _this227._reportError(err, moduleType);\n\n              return;\n            }\n\n            importedModules.push(importedModuleSummary);\n          } else {\n            _this227._reportError(syntaxError(\"Unexpected value '\".concat(stringifyType(importedType), \"' imported by the module '\").concat(stringifyType(moduleType), \"'\")), moduleType);\n\n            return;\n          }\n        });\n      }\n\n      if (meta.exports) {\n        flattenAndDedupeArray(meta.exports).forEach(function (exportedType) {\n          if (!isValidType(exportedType)) {\n            _this227._reportError(syntaxError(\"Unexpected value '\".concat(stringifyType(exportedType), \"' exported by the module '\").concat(stringifyType(moduleType), \"'\")), moduleType);\n\n            return;\n          }\n\n          if (!alreadyCollecting) alreadyCollecting = new Set();\n\n          if (alreadyCollecting.has(exportedType)) {\n            _this227._reportError(syntaxError(\"\".concat(_this227._getTypeDescriptor(exportedType), \" '\").concat(stringify(exportedType), \"' is exported recursively by the module '\").concat(stringifyType(moduleType), \"'\")), moduleType);\n\n            return;\n          }\n\n          alreadyCollecting.add(exportedType);\n\n          var exportedModuleSummary = _this227.getNgModuleSummary(exportedType, alreadyCollecting);\n\n          alreadyCollecting.delete(exportedType);\n\n          if (exportedModuleSummary) {\n            exportedModules.push(exportedModuleSummary);\n          } else {\n            exportedNonModuleIdentifiers.push(_this227._getIdentifierMetadata(exportedType));\n          }\n        });\n      } // Note: This will be modified later, so we rely on\n      // getting a new instance every time!\n\n\n      var transitiveModule = this._getTransitiveNgModuleMetadata(importedModules, exportedModules);\n\n      if (meta.declarations) {\n        flattenAndDedupeArray(meta.declarations).forEach(function (declaredType) {\n          if (!isValidType(declaredType)) {\n            _this227._reportError(syntaxError(\"Unexpected value '\".concat(stringifyType(declaredType), \"' declared by the module '\").concat(stringifyType(moduleType), \"'\")), moduleType);\n\n            return;\n          }\n\n          var declaredIdentifier = _this227._getIdentifierMetadata(declaredType);\n\n          if (_this227.isDirective(declaredType)) {\n            if (_this227.isAbstractDirective(declaredType)) {\n              _this227._reportError(syntaxError(\"Directive \".concat(stringifyType(declaredType), \" has no selector, please add it!\")), declaredType);\n            }\n\n            transitiveModule.addDirective(declaredIdentifier);\n            declaredDirectives.push(declaredIdentifier);\n\n            _this227._addTypeToModule(declaredType, moduleType);\n          } else if (_this227.isPipe(declaredType)) {\n            transitiveModule.addPipe(declaredIdentifier);\n            transitiveModule.pipes.push(declaredIdentifier);\n            declaredPipes.push(declaredIdentifier);\n\n            _this227._addTypeToModule(declaredType, moduleType);\n          } else {\n            _this227._reportError(syntaxError(\"Unexpected \".concat(_this227._getTypeDescriptor(declaredType), \" '\").concat(stringifyType(declaredType), \"' declared by the module '\").concat(stringifyType(moduleType), \"'. Please add a @Pipe/@Directive/@Component annotation.\")), moduleType);\n\n            return;\n          }\n        });\n      }\n\n      var exportedDirectives = [];\n      var exportedPipes = [];\n      exportedNonModuleIdentifiers.forEach(function (exportedId) {\n        if (transitiveModule.directivesSet.has(exportedId.reference)) {\n          exportedDirectives.push(exportedId);\n          transitiveModule.addExportedDirective(exportedId);\n        } else if (transitiveModule.pipesSet.has(exportedId.reference)) {\n          exportedPipes.push(exportedId);\n          transitiveModule.addExportedPipe(exportedId);\n        } else {\n          _this227._reportError(syntaxError(\"Can't export \".concat(_this227._getTypeDescriptor(exportedId.reference), \" \").concat(stringifyType(exportedId.reference), \" from \").concat(stringifyType(moduleType), \" as it was neither declared nor imported!\")), moduleType);\n\n          return;\n        }\n      }); // The providers of the module have to go last\n      // so that they overwrite any other provider we already added.\n\n      if (meta.providers) {\n        providers.push.apply(providers, _toConsumableArray(this._getProvidersMetadata(meta.providers, entryComponents, \"provider for the NgModule '\".concat(stringifyType(moduleType), \"'\"), [], moduleType)));\n      }\n\n      if (meta.entryComponents) {\n        entryComponents.push.apply(entryComponents, _toConsumableArray(flattenAndDedupeArray(meta.entryComponents).map(function (type) {\n          return _this227._getEntryComponentMetadata(type);\n        })));\n      }\n\n      if (meta.bootstrap) {\n        flattenAndDedupeArray(meta.bootstrap).forEach(function (type) {\n          if (!isValidType(type)) {\n            _this227._reportError(syntaxError(\"Unexpected value '\".concat(stringifyType(type), \"' used in the bootstrap property of module '\").concat(stringifyType(moduleType), \"'\")), moduleType);\n\n            return;\n          }\n\n          bootstrapComponents.push(_this227._getIdentifierMetadata(type));\n        });\n      }\n\n      entryComponents.push.apply(entryComponents, _toConsumableArray(bootstrapComponents.map(function (type) {\n        return _this227._getEntryComponentMetadata(type.reference);\n      })));\n\n      if (meta.schemas) {\n        schemas.push.apply(schemas, _toConsumableArray(flattenAndDedupeArray(meta.schemas)));\n      }\n\n      compileMeta = new CompileNgModuleMetadata({\n        type: this._getTypeMetadata(moduleType),\n        providers: providers,\n        entryComponents: entryComponents,\n        bootstrapComponents: bootstrapComponents,\n        schemas: schemas,\n        declaredDirectives: declaredDirectives,\n        exportedDirectives: exportedDirectives,\n        declaredPipes: declaredPipes,\n        exportedPipes: exportedPipes,\n        importedModules: importedModules,\n        exportedModules: exportedModules,\n        transitiveModule: transitiveModule,\n        id: meta.id || null\n      });\n      entryComponents.forEach(function (id) {\n        return transitiveModule.addEntryComponent(id);\n      });\n      providers.forEach(function (provider) {\n        return transitiveModule.addProvider(provider, compileMeta.type);\n      });\n      transitiveModule.addModule(compileMeta.type);\n\n      this._ngModuleCache.set(moduleType, compileMeta);\n\n      return compileMeta;\n    }\n  }, {\n    key: \"_checkSelfImport\",\n    value: function _checkSelfImport(moduleType, importedModuleType) {\n      if (moduleType === importedModuleType) {\n        this._reportError(syntaxError(\"'\".concat(stringifyType(moduleType), \"' module can't import itself\")), moduleType);\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_getTypeDescriptor\",\n    value: function _getTypeDescriptor(type) {\n      if (isValidType(type)) {\n        if (this.isDirective(type)) {\n          return 'directive';\n        }\n\n        if (this.isPipe(type)) {\n          return 'pipe';\n        }\n\n        if (this.isNgModule(type)) {\n          return 'module';\n        }\n      }\n\n      if (type.provide) {\n        return 'provider';\n      }\n\n      return 'value';\n    }\n  }, {\n    key: \"_addTypeToModule\",\n    value: function _addTypeToModule(type, moduleType) {\n      var oldModule = this._ngModuleOfTypes.get(type);\n\n      if (oldModule && oldModule !== moduleType) {\n        this._reportError(syntaxError(\"Type \".concat(stringifyType(type), \" is part of the declarations of 2 modules: \").concat(stringifyType(oldModule), \" and \").concat(stringifyType(moduleType), \"! \") + \"Please consider moving \".concat(stringifyType(type), \" to a higher module that imports \").concat(stringifyType(oldModule), \" and \").concat(stringifyType(moduleType), \". \") + \"You can also create a new NgModule that exports and includes \".concat(stringifyType(type), \" then import that NgModule in \").concat(stringifyType(oldModule), \" and \").concat(stringifyType(moduleType), \".\")), moduleType);\n\n        return;\n      }\n\n      this._ngModuleOfTypes.set(type, moduleType);\n    }\n  }, {\n    key: \"_getTransitiveNgModuleMetadata\",\n    value: function _getTransitiveNgModuleMetadata(importedModules, exportedModules) {\n      // collect `providers` / `entryComponents` from all imported and all exported modules\n      var result = new TransitiveCompileNgModuleMetadata();\n      var modulesByToken = new Map();\n      importedModules.concat(exportedModules).forEach(function (modSummary) {\n        modSummary.modules.forEach(function (mod) {\n          return result.addModule(mod);\n        });\n        modSummary.entryComponents.forEach(function (comp) {\n          return result.addEntryComponent(comp);\n        });\n        var addedTokens = new Set();\n        modSummary.providers.forEach(function (entry) {\n          var tokenRef = tokenReference(entry.provider.token);\n          var prevModules = modulesByToken.get(tokenRef);\n\n          if (!prevModules) {\n            prevModules = new Set();\n            modulesByToken.set(tokenRef, prevModules);\n          }\n\n          var moduleRef = entry.module.reference; // Note: the providers of one module may still contain multiple providers\n          // per token (e.g. for multi providers), and we need to preserve these.\n\n          if (addedTokens.has(tokenRef) || !prevModules.has(moduleRef)) {\n            prevModules.add(moduleRef);\n            addedTokens.add(tokenRef);\n            result.addProvider(entry.provider, entry.module);\n          }\n        });\n      });\n      exportedModules.forEach(function (modSummary) {\n        modSummary.exportedDirectives.forEach(function (id) {\n          return result.addExportedDirective(id);\n        });\n        modSummary.exportedPipes.forEach(function (id) {\n          return result.addExportedPipe(id);\n        });\n      });\n      importedModules.forEach(function (modSummary) {\n        modSummary.exportedDirectives.forEach(function (id) {\n          return result.addDirective(id);\n        });\n        modSummary.exportedPipes.forEach(function (id) {\n          return result.addPipe(id);\n        });\n      });\n      return result;\n    }\n  }, {\n    key: \"_getIdentifierMetadata\",\n    value: function _getIdentifierMetadata(type) {\n      type = resolveForwardRef(type);\n      return {\n        reference: type\n      };\n    }\n  }, {\n    key: \"isInjectable\",\n    value: function isInjectable(type) {\n      var annotations = this._reflector.tryAnnotations(type);\n\n      return annotations.some(function (ann) {\n        return createInjectable.isTypeOf(ann);\n      });\n    }\n  }, {\n    key: \"getInjectableSummary\",\n    value: function getInjectableSummary(type) {\n      return {\n        summaryKind: CompileSummaryKind.Injectable,\n        type: this._getTypeMetadata(type, null, false)\n      };\n    }\n  }, {\n    key: \"getInjectableMetadata\",\n    value: function getInjectableMetadata(type) {\n      var dependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var throwOnUnknownDeps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      var typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);\n\n      var typeMetadata = typeSummary ? typeSummary.type : this._getTypeMetadata(type, dependencies, throwOnUnknownDeps);\n\n      var annotations = this._reflector.annotations(type).filter(function (ann) {\n        return createInjectable.isTypeOf(ann);\n      });\n\n      if (annotations.length === 0) {\n        return null;\n      }\n\n      var meta = annotations[annotations.length - 1];\n      return {\n        symbol: type,\n        type: typeMetadata,\n        providedIn: meta.providedIn,\n        useValue: meta.useValue,\n        useClass: meta.useClass,\n        useExisting: meta.useExisting,\n        useFactory: meta.useFactory,\n        deps: meta.deps\n      };\n    }\n  }, {\n    key: \"_getTypeMetadata\",\n    value: function _getTypeMetadata(type) {\n      var dependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var throwOnUnknownDeps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n      var identifier = this._getIdentifierMetadata(type);\n\n      return {\n        reference: identifier.reference,\n        diDeps: this._getDependenciesMetadata(identifier.reference, dependencies, throwOnUnknownDeps),\n        lifecycleHooks: getAllLifecycleHooks(this._reflector, identifier.reference)\n      };\n    }\n  }, {\n    key: \"_getFactoryMetadata\",\n    value: function _getFactoryMetadata(factory) {\n      var dependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      factory = resolveForwardRef(factory);\n      return {\n        reference: factory,\n        diDeps: this._getDependenciesMetadata(factory, dependencies)\n      };\n    }\n    /**\r\n     * Gets the metadata for the given pipe.\r\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\r\n     */\n\n  }, {\n    key: \"getPipeMetadata\",\n    value: function getPipeMetadata(pipeType) {\n      var pipeMeta = this._pipeCache.get(pipeType);\n\n      if (!pipeMeta) {\n        this._reportError(syntaxError(\"Illegal state: getPipeMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Pipe \".concat(stringifyType(pipeType), \".\")), pipeType);\n      }\n\n      return pipeMeta || null;\n    }\n  }, {\n    key: \"getPipeSummary\",\n    value: function getPipeSummary(pipeType) {\n      var pipeSummary = this._loadSummary(pipeType, CompileSummaryKind.Pipe);\n\n      if (!pipeSummary) {\n        this._reportError(syntaxError(\"Illegal state: Could not load the summary for pipe \".concat(stringifyType(pipeType), \".\")), pipeType);\n      }\n\n      return pipeSummary;\n    }\n  }, {\n    key: \"getOrLoadPipeMetadata\",\n    value: function getOrLoadPipeMetadata(pipeType) {\n      var pipeMeta = this._pipeCache.get(pipeType);\n\n      if (!pipeMeta) {\n        pipeMeta = this._loadPipeMetadata(pipeType);\n      }\n\n      return pipeMeta;\n    }\n  }, {\n    key: \"_loadPipeMetadata\",\n    value: function _loadPipeMetadata(pipeType) {\n      pipeType = resolveForwardRef(pipeType);\n\n      var pipeAnnotation = this._pipeResolver.resolve(pipeType);\n\n      var pipeMeta = new CompilePipeMetadata({\n        type: this._getTypeMetadata(pipeType),\n        name: pipeAnnotation.name,\n        pure: !!pipeAnnotation.pure\n      });\n\n      this._pipeCache.set(pipeType, pipeMeta);\n\n      this._summaryCache.set(pipeType, pipeMeta.toSummary());\n\n      return pipeMeta;\n    }\n  }, {\n    key: \"_getDependenciesMetadata\",\n    value: function _getDependenciesMetadata(typeOrFunc, dependencies) {\n      var _this228 = this;\n\n      var throwOnUnknownDeps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var hasUnknownDeps = false;\n      var params = dependencies || this._reflector.parameters(typeOrFunc) || [];\n      var dependenciesMetadata = params.map(function (param) {\n        var isAttribute = false;\n        var isHost = false;\n        var isSelf = false;\n        var isSkipSelf = false;\n        var isOptional = false;\n        var token = null;\n\n        if (Array.isArray(param)) {\n          param.forEach(function (paramEntry) {\n            if (createHost.isTypeOf(paramEntry)) {\n              isHost = true;\n            } else if (createSelf.isTypeOf(paramEntry)) {\n              isSelf = true;\n            } else if (createSkipSelf.isTypeOf(paramEntry)) {\n              isSkipSelf = true;\n            } else if (createOptional.isTypeOf(paramEntry)) {\n              isOptional = true;\n            } else if (createAttribute.isTypeOf(paramEntry)) {\n              isAttribute = true;\n              token = paramEntry.attributeName;\n            } else if (createInject.isTypeOf(paramEntry)) {\n              token = paramEntry.token;\n            } else if (createInjectionToken.isTypeOf(paramEntry) || paramEntry instanceof StaticSymbol) {\n              token = paramEntry;\n            } else if (isValidType(paramEntry) && token == null) {\n              token = paramEntry;\n            }\n          });\n        } else {\n          token = param;\n        }\n\n        if (token == null) {\n          hasUnknownDeps = true;\n          return {};\n        }\n\n        return {\n          isAttribute: isAttribute,\n          isHost: isHost,\n          isSelf: isSelf,\n          isSkipSelf: isSkipSelf,\n          isOptional: isOptional,\n          token: _this228._getTokenMetadata(token)\n        };\n      });\n\n      if (hasUnknownDeps) {\n        var depsTokens = dependenciesMetadata.map(function (dep) {\n          return dep.token ? stringifyType(dep.token) : '?';\n        }).join(', ');\n        var message = \"Can't resolve all parameters for \".concat(stringifyType(typeOrFunc), \": (\").concat(depsTokens, \").\");\n\n        if (throwOnUnknownDeps || this._config.strictInjectionParameters) {\n          this._reportError(syntaxError(message), typeOrFunc);\n        }\n      }\n\n      return dependenciesMetadata;\n    }\n  }, {\n    key: \"_getTokenMetadata\",\n    value: function _getTokenMetadata(token) {\n      token = resolveForwardRef(token);\n      var compileToken;\n\n      if (typeof token === 'string') {\n        compileToken = {\n          value: token\n        };\n      } else {\n        compileToken = {\n          identifier: {\n            reference: token\n          }\n        };\n      }\n\n      return compileToken;\n    }\n  }, {\n    key: \"_getProvidersMetadata\",\n    value: function _getProvidersMetadata(providers, targetEntryComponents, debugInfo) {\n      var _this229 = this;\n\n      var compileProviders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n      var type = arguments.length > 4 ? arguments[4] : undefined;\n      providers.forEach(function (provider, providerIdx) {\n        if (Array.isArray(provider)) {\n          _this229._getProvidersMetadata(provider, targetEntryComponents, debugInfo, compileProviders);\n        } else {\n          provider = resolveForwardRef(provider);\n          var providerMeta = undefined;\n\n          if (provider && typeof provider === 'object' && provider.hasOwnProperty('provide')) {\n            _this229._validateProvider(provider);\n\n            providerMeta = new ProviderMeta(provider.provide, provider);\n          } else if (isValidType(provider)) {\n            providerMeta = new ProviderMeta(provider, {\n              useClass: provider\n            });\n          } else if (provider === void 0) {\n            _this229._reportError(syntaxError(\"Encountered undefined provider! Usually this means you have a circular dependencies. This might be caused by using 'barrel' index.ts files.\"));\n\n            return;\n          } else {\n            var providersInfo = providers.reduce(function (soFar, seenProvider, seenProviderIdx) {\n              if (seenProviderIdx < providerIdx) {\n                soFar.push(\"\".concat(stringifyType(seenProvider)));\n              } else if (seenProviderIdx == providerIdx) {\n                soFar.push(\"?\".concat(stringifyType(seenProvider), \"?\"));\n              } else if (seenProviderIdx == providerIdx + 1) {\n                soFar.push('...');\n              }\n\n              return soFar;\n            }, []).join(', ');\n\n            _this229._reportError(syntaxError(\"Invalid \".concat(debugInfo ? debugInfo : 'provider', \" - only instances of Provider and Type are allowed, got: [\").concat(providersInfo, \"]\")), type);\n\n            return;\n          }\n\n          if (providerMeta.token === _this229._reflector.resolveExternalReference(Identifiers$1.ANALYZE_FOR_ENTRY_COMPONENTS)) {\n            targetEntryComponents.push.apply(targetEntryComponents, _toConsumableArray(_this229._getEntryComponentsFromProvider(providerMeta, type)));\n          } else {\n            compileProviders.push(_this229.getProviderMetadata(providerMeta));\n          }\n        }\n      });\n      return compileProviders;\n    }\n  }, {\n    key: \"_validateProvider\",\n    value: function _validateProvider(provider) {\n      if (provider.hasOwnProperty('useClass') && provider.useClass == null) {\n        this._reportError(syntaxError(\"Invalid provider for \".concat(stringifyType(provider.provide), \". useClass cannot be \").concat(provider.useClass, \".\\n           Usually it happens when:\\n           1. There's a circular dependency (might be caused by using index.ts (barrel) files).\\n           2. Class was used before it was declared. Use forwardRef in this case.\")));\n      }\n    }\n  }, {\n    key: \"_getEntryComponentsFromProvider\",\n    value: function _getEntryComponentsFromProvider(provider, type) {\n      var _this230 = this;\n\n      var components = [];\n      var collectedIdentifiers = [];\n\n      if (provider.useFactory || provider.useExisting || provider.useClass) {\n        this._reportError(syntaxError(\"The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!\"), type);\n\n        return [];\n      }\n\n      if (!provider.multi) {\n        this._reportError(syntaxError(\"The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!\"), type);\n\n        return [];\n      }\n\n      extractIdentifiers(provider.useValue, collectedIdentifiers);\n      collectedIdentifiers.forEach(function (identifier) {\n        var entry = _this230._getEntryComponentMetadata(identifier.reference, false);\n\n        if (entry) {\n          components.push(entry);\n        }\n      });\n      return components;\n    }\n  }, {\n    key: \"_getEntryComponentMetadata\",\n    value: function _getEntryComponentMetadata(dirType) {\n      var throwIfNotFound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var dirMeta = this.getNonNormalizedDirectiveMetadata(dirType);\n\n      if (dirMeta && dirMeta.metadata.isComponent) {\n        return {\n          componentType: dirType,\n          componentFactory: dirMeta.metadata.componentFactory\n        };\n      }\n\n      var dirSummary = this._loadSummary(dirType, CompileSummaryKind.Directive);\n\n      if (dirSummary && dirSummary.isComponent) {\n        return {\n          componentType: dirType,\n          componentFactory: dirSummary.componentFactory\n        };\n      }\n\n      if (throwIfNotFound) {\n        throw syntaxError(\"\".concat(dirType.name, \" cannot be used as an entry component.\"));\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_getInjectableTypeMetadata\",\n    value: function _getInjectableTypeMetadata(type) {\n      var dependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      var typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);\n\n      if (typeSummary) {\n        return typeSummary.type;\n      }\n\n      return this._getTypeMetadata(type, dependencies);\n    }\n  }, {\n    key: \"getProviderMetadata\",\n    value: function getProviderMetadata(provider) {\n      var compileDeps = undefined;\n      var compileTypeMetadata = null;\n      var compileFactoryMetadata = null;\n\n      var token = this._getTokenMetadata(provider.token);\n\n      if (provider.useClass) {\n        compileTypeMetadata = this._getInjectableTypeMetadata(provider.useClass, provider.dependencies);\n        compileDeps = compileTypeMetadata.diDeps;\n\n        if (provider.token === provider.useClass) {\n          // use the compileTypeMetadata as it contains information about lifecycleHooks...\n          token = {\n            identifier: compileTypeMetadata\n          };\n        }\n      } else if (provider.useFactory) {\n        compileFactoryMetadata = this._getFactoryMetadata(provider.useFactory, provider.dependencies);\n        compileDeps = compileFactoryMetadata.diDeps;\n      }\n\n      return {\n        token: token,\n        useClass: compileTypeMetadata,\n        useValue: provider.useValue,\n        useFactory: compileFactoryMetadata,\n        useExisting: provider.useExisting ? this._getTokenMetadata(provider.useExisting) : undefined,\n        deps: compileDeps,\n        multi: provider.multi\n      };\n    }\n  }, {\n    key: \"_getQueriesMetadata\",\n    value: function _getQueriesMetadata(queries, isViewQuery, directiveType) {\n      var _this231 = this;\n\n      var res = [];\n      Object.keys(queries).forEach(function (propertyName) {\n        var query = queries[propertyName];\n\n        if (query.isViewQuery === isViewQuery) {\n          res.push(_this231._getQueryMetadata(query, propertyName, directiveType));\n        }\n      });\n      return res;\n    }\n  }, {\n    key: \"_queryVarBindings\",\n    value: function _queryVarBindings(selector) {\n      return selector.split(/\\s*,\\s*/);\n    }\n  }, {\n    key: \"_getQueryMetadata\",\n    value: function _getQueryMetadata(q, propertyName, typeOrFunc) {\n      var _this232 = this;\n\n      var selectors;\n\n      if (typeof q.selector === 'string') {\n        selectors = this._queryVarBindings(q.selector).map(function (varName) {\n          return _this232._getTokenMetadata(varName);\n        });\n      } else {\n        if (!q.selector) {\n          this._reportError(syntaxError(\"Can't construct a query for the property \\\"\".concat(propertyName, \"\\\" of \\\"\").concat(stringifyType(typeOrFunc), \"\\\" since the query selector wasn't defined.\")), typeOrFunc);\n\n          selectors = [];\n        } else {\n          selectors = [this._getTokenMetadata(q.selector)];\n        }\n      }\n\n      return {\n        selectors: selectors,\n        first: q.first,\n        descendants: q.descendants,\n        emitDistinctChangesOnly: q.emitDistinctChangesOnly,\n        propertyName: propertyName,\n        read: q.read ? this._getTokenMetadata(q.read) : null,\n        static: q.static\n      };\n    }\n  }, {\n    key: \"_reportError\",\n    value: function _reportError(error, type, otherType) {\n      if (this._errorCollector) {\n        this._errorCollector(error, type);\n\n        if (otherType) {\n          this._errorCollector(error, otherType);\n        }\n      } else {\n        throw error;\n      }\n    }\n  }]);\n\n  return CompileMetadataResolver;\n}();\n\nfunction flattenArray(tree) {\n  var out = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  if (tree) {\n    for (var i = 0; i < tree.length; i++) {\n      var item = resolveForwardRef(tree[i]);\n\n      if (Array.isArray(item)) {\n        flattenArray(item, out);\n      } else {\n        out.push(item);\n      }\n    }\n  }\n\n  return out;\n}\n\nfunction dedupeArray(array) {\n  if (array) {\n    return Array.from(new Set(array));\n  }\n\n  return [];\n}\n\nfunction flattenAndDedupeArray(tree) {\n  return dedupeArray(flattenArray(tree));\n}\n\nfunction isValidType(value) {\n  return value instanceof StaticSymbol || value instanceof Type;\n}\n\nfunction extractIdentifiers(value, targetIdentifiers) {\n  visitValue(value, new _CompileValueConverter(), targetIdentifiers);\n}\n\nvar _CompileValueConverter = /*#__PURE__*/function (_ValueTransformer) {\n  _inherits(_CompileValueConverter, _ValueTransformer);\n\n  var _super105 = _createSuper(_CompileValueConverter);\n\n  function _CompileValueConverter() {\n    _classCallCheck(this, _CompileValueConverter);\n\n    return _super105.apply(this, arguments);\n  }\n\n  _createClass(_CompileValueConverter, [{\n    key: \"visitOther\",\n    value: function visitOther(value, targetIdentifiers) {\n      targetIdentifiers.push({\n        reference: value\n      });\n    }\n  }]);\n\n  return _CompileValueConverter;\n}(ValueTransformer);\n\nfunction stringifyType(type) {\n  if (type instanceof StaticSymbol) {\n    return \"\".concat(type.name, \" in \").concat(type.filePath);\n  } else {\n    return stringify(type);\n  }\n}\n/**\r\n * Indicates that a component is still being loaded in a synchronous compile.\r\n */\n\n\nfunction componentStillLoadingError(compType) {\n  var error = Error(\"Can't compile synchronously as \".concat(stringify(compType), \" is still being loaded!\"));\n  error[ERROR_COMPONENT_TYPE] = compType;\n  return error;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nfunction providerDef(ctx, providerAst) {\n  var flags = 0\n  /* None */\n  ;\n\n  if (!providerAst.eager) {\n    flags |= 4096\n    /* LazyProvider */\n    ;\n  }\n\n  if (providerAst.providerType === ProviderAstType.PrivateService) {\n    flags |= 8192\n    /* PrivateProvider */\n    ;\n  }\n\n  if (providerAst.isModule) {\n    flags |= 1073741824\n    /* TypeModuleProvider */\n    ;\n  }\n\n  providerAst.lifecycleHooks.forEach(function (lifecycleHook) {\n    // for regular providers, we only support ngOnDestroy\n    if (lifecycleHook === LifecycleHooks.OnDestroy || providerAst.providerType === ProviderAstType.Directive || providerAst.providerType === ProviderAstType.Component) {\n      flags |= lifecycleHookToNodeFlag(lifecycleHook);\n    }\n  });\n\n  var _ref34 = providerAst.multiProvider ? multiProviderDef(ctx, flags, providerAst.providers) : singleProviderDef(ctx, flags, providerAst.providerType, providerAst.providers[0]),\n      providerExpr = _ref34.providerExpr,\n      providerFlags = _ref34.flags,\n      depsExpr = _ref34.depsExpr;\n\n  return {\n    providerExpr: providerExpr,\n    flags: providerFlags,\n    depsExpr: depsExpr,\n    tokenExpr: tokenExpr(ctx, providerAst.token)\n  };\n}\n\nfunction multiProviderDef(ctx, flags, providers) {\n  var allDepDefs = [];\n  var allParams = [];\n  var exprs = providers.map(function (provider, providerIndex) {\n    var expr;\n\n    if (provider.useClass) {\n      var depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);\n      expr = ctx.importExpr(provider.useClass.reference).instantiate(depExprs);\n    } else if (provider.useFactory) {\n      var _depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);\n\n      expr = ctx.importExpr(provider.useFactory.reference).callFn(_depExprs);\n    } else if (provider.useExisting) {\n      var _depExprs2 = convertDeps(providerIndex, [{\n        token: provider.useExisting\n      }]);\n\n      expr = _depExprs2[0];\n    } else {\n      expr = convertValueToOutputAst(ctx, provider.useValue);\n    }\n\n    return expr;\n  });\n  var providerExpr = fn(allParams, [new ReturnStatement(literalArr(exprs))], INFERRED_TYPE);\n  return {\n    providerExpr: providerExpr,\n    flags: flags | 1024\n    /* TypeFactoryProvider */\n    ,\n    depsExpr: literalArr(allDepDefs)\n  };\n\n  function convertDeps(providerIndex, deps) {\n    return deps.map(function (dep, depIndex) {\n      var paramName = \"p\".concat(providerIndex, \"_\").concat(depIndex);\n      allParams.push(new FnParam(paramName, DYNAMIC_TYPE));\n      allDepDefs.push(depDef(ctx, dep));\n      return variable(paramName);\n    });\n  }\n}\n\nfunction singleProviderDef(ctx, flags, providerType, providerMeta) {\n  var providerExpr;\n  var deps;\n\n  if (providerType === ProviderAstType.Directive || providerType === ProviderAstType.Component) {\n    providerExpr = ctx.importExpr(providerMeta.useClass.reference);\n    flags |= 16384\n    /* TypeDirective */\n    ;\n    deps = providerMeta.deps || providerMeta.useClass.diDeps;\n  } else {\n    if (providerMeta.useClass) {\n      providerExpr = ctx.importExpr(providerMeta.useClass.reference);\n      flags |= 512\n      /* TypeClassProvider */\n      ;\n      deps = providerMeta.deps || providerMeta.useClass.diDeps;\n    } else if (providerMeta.useFactory) {\n      providerExpr = ctx.importExpr(providerMeta.useFactory.reference);\n      flags |= 1024\n      /* TypeFactoryProvider */\n      ;\n      deps = providerMeta.deps || providerMeta.useFactory.diDeps;\n    } else if (providerMeta.useExisting) {\n      providerExpr = NULL_EXPR;\n      flags |= 2048\n      /* TypeUseExistingProvider */\n      ;\n      deps = [{\n        token: providerMeta.useExisting\n      }];\n    } else {\n      providerExpr = convertValueToOutputAst(ctx, providerMeta.useValue);\n      flags |= 256\n      /* TypeValueProvider */\n      ;\n      deps = [];\n    }\n  }\n\n  var depsExpr = literalArr(deps.map(function (dep) {\n    return depDef(ctx, dep);\n  }));\n  return {\n    providerExpr: providerExpr,\n    flags: flags,\n    depsExpr: depsExpr\n  };\n}\n\nfunction tokenExpr(ctx, tokenMeta) {\n  return tokenMeta.identifier ? ctx.importExpr(tokenMeta.identifier.reference) : literal(tokenMeta.value);\n}\n\nfunction depDef(ctx, dep) {\n  // Note: the following fields have already been normalized out by provider_analyzer:\n  // - isAttribute, isHost\n  var expr = dep.isValue ? convertValueToOutputAst(ctx, dep.value) : tokenExpr(ctx, dep.token);\n  var flags = 0\n  /* None */\n  ;\n\n  if (dep.isSkipSelf) {\n    flags |= 1\n    /* SkipSelf */\n    ;\n  }\n\n  if (dep.isOptional) {\n    flags |= 2\n    /* Optional */\n    ;\n  }\n\n  if (dep.isSelf) {\n    flags |= 4\n    /* Self */\n    ;\n  }\n\n  if (dep.isValue) {\n    flags |= 8\n    /* Value */\n    ;\n  }\n\n  return flags === 0\n  /* None */\n  ? expr : literalArr([literal(flags), expr]);\n}\n\nfunction lifecycleHookToNodeFlag(lifecycleHook) {\n  var nodeFlag = 0\n  /* None */\n  ;\n\n  switch (lifecycleHook) {\n    case LifecycleHooks.AfterContentChecked:\n      nodeFlag = 2097152\n      /* AfterContentChecked */\n      ;\n      break;\n\n    case LifecycleHooks.AfterContentInit:\n      nodeFlag = 1048576\n      /* AfterContentInit */\n      ;\n      break;\n\n    case LifecycleHooks.AfterViewChecked:\n      nodeFlag = 8388608\n      /* AfterViewChecked */\n      ;\n      break;\n\n    case LifecycleHooks.AfterViewInit:\n      nodeFlag = 4194304\n      /* AfterViewInit */\n      ;\n      break;\n\n    case LifecycleHooks.DoCheck:\n      nodeFlag = 262144\n      /* DoCheck */\n      ;\n      break;\n\n    case LifecycleHooks.OnChanges:\n      nodeFlag = 524288\n      /* OnChanges */\n      ;\n      break;\n\n    case LifecycleHooks.OnDestroy:\n      nodeFlag = 131072\n      /* OnDestroy */\n      ;\n      break;\n\n    case LifecycleHooks.OnInit:\n      nodeFlag = 65536\n      /* OnInit */\n      ;\n      break;\n  }\n\n  return nodeFlag;\n}\n\nfunction componentFactoryResolverProviderDef(reflector, ctx, flags, entryComponents) {\n  var entryComponentFactories = entryComponents.map(function (entryComponent) {\n    return ctx.importExpr(entryComponent.componentFactory);\n  });\n  var token = createTokenForExternalReference(reflector, Identifiers$1.ComponentFactoryResolver);\n  var classMeta = {\n    diDeps: [{\n      isValue: true,\n      value: literalArr(entryComponentFactories)\n    }, {\n      token: token,\n      isSkipSelf: true,\n      isOptional: true\n    }, {\n      token: createTokenForExternalReference(reflector, Identifiers$1.NgModuleRef)\n    }],\n    lifecycleHooks: [],\n    reference: reflector.resolveExternalReference(Identifiers$1.CodegenComponentFactoryResolver)\n  };\n\n  var _singleProviderDef = singleProviderDef(ctx, flags, ProviderAstType.PrivateService, {\n    token: token,\n    multi: false,\n    useClass: classMeta\n  }),\n      providerExpr = _singleProviderDef.providerExpr,\n      providerFlags = _singleProviderDef.flags,\n      depsExpr = _singleProviderDef.depsExpr;\n\n  return {\n    providerExpr: providerExpr,\n    flags: providerFlags,\n    depsExpr: depsExpr,\n    tokenExpr: tokenExpr(ctx, token)\n  };\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar NgModuleCompileResult = function NgModuleCompileResult(ngModuleFactoryVar) {\n  _classCallCheck(this, NgModuleCompileResult);\n\n  this.ngModuleFactoryVar = ngModuleFactoryVar;\n};\n\nvar LOG_VAR = variable('_l');\n\nvar NgModuleCompiler = /*#__PURE__*/function () {\n  function NgModuleCompiler(reflector) {\n    _classCallCheck(this, NgModuleCompiler);\n\n    this.reflector = reflector;\n  }\n\n  _createClass(NgModuleCompiler, [{\n    key: \"compile\",\n    value: function compile(ctx, ngModuleMeta, extraProviders) {\n      var sourceSpan = typeSourceSpan('NgModule', ngModuleMeta.type);\n      var entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents;\n      var bootstrapComponents = ngModuleMeta.bootstrapComponents;\n      var providerParser = new NgModuleProviderAnalyzer(this.reflector, ngModuleMeta, extraProviders, sourceSpan);\n      var providerDefs = [componentFactoryResolverProviderDef(this.reflector, ctx, 0\n      /* None */\n      , entryComponentFactories)].concat(providerParser.parse().map(function (provider) {\n        return providerDef(ctx, provider);\n      })).map(function (_ref35) {\n        var providerExpr = _ref35.providerExpr,\n            depsExpr = _ref35.depsExpr,\n            flags = _ref35.flags,\n            tokenExpr = _ref35.tokenExpr;\n        return importExpr(Identifiers$1.moduleProviderDef).callFn([literal(flags), tokenExpr, providerExpr, depsExpr]);\n      });\n      var ngModuleDef = importExpr(Identifiers$1.moduleDef).callFn([literalArr(providerDefs)]);\n      var ngModuleDefFactory = fn([new FnParam(LOG_VAR.name)], [new ReturnStatement(ngModuleDef)], INFERRED_TYPE);\n      var ngModuleFactoryVar = \"\".concat(identifierName(ngModuleMeta.type), \"NgFactory\");\n\n      this._createNgModuleFactory(ctx, ngModuleMeta.type.reference, importExpr(Identifiers$1.createModuleFactory).callFn([ctx.importExpr(ngModuleMeta.type.reference), literalArr(bootstrapComponents.map(function (id) {\n        return ctx.importExpr(id.reference);\n      })), ngModuleDefFactory]));\n\n      if (ngModuleMeta.id) {\n        var id = typeof ngModuleMeta.id === 'string' ? literal(ngModuleMeta.id) : ctx.importExpr(ngModuleMeta.id);\n        var registerFactoryStmt = importExpr(Identifiers$1.RegisterModuleFactoryFn).callFn([id, variable(ngModuleFactoryVar)]).toStmt();\n        ctx.statements.push(registerFactoryStmt);\n      }\n\n      return new NgModuleCompileResult(ngModuleFactoryVar);\n    }\n  }, {\n    key: \"createStub\",\n    value: function createStub(ctx, ngModuleReference) {\n      this._createNgModuleFactory(ctx, ngModuleReference, NULL_EXPR);\n    }\n  }, {\n    key: \"_createNgModuleFactory\",\n    value: function _createNgModuleFactory(ctx, reference, value) {\n      var ngModuleFactoryVar = \"\".concat(identifierName({\n        reference: reference\n      }), \"NgFactory\");\n      var ngModuleFactoryStmt = variable(ngModuleFactoryVar).set(value).toDeclStmt(importType(Identifiers$1.NgModuleFactory, [expressionType(ctx.importExpr(reference))], [TypeModifier.Const]), [StmtModifier.Final, StmtModifier.Exported]);\n      ctx.statements.push(ngModuleFactoryStmt);\n    }\n  }]);\n\n  return NgModuleCompiler;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Resolves types to {@link NgModule}.\r\n */\n\n\nvar NgModuleResolver = /*#__PURE__*/function () {\n  function NgModuleResolver(_reflector) {\n    _classCallCheck(this, NgModuleResolver);\n\n    this._reflector = _reflector;\n  }\n\n  _createClass(NgModuleResolver, [{\n    key: \"isNgModule\",\n    value: function isNgModule(type) {\n      return this._reflector.annotations(type).some(createNgModule.isTypeOf);\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(type) {\n      var throwIfNotFound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var ngModuleMeta = findLast(this._reflector.annotations(type), createNgModule.isTypeOf);\n\n      if (ngModuleMeta) {\n        return ngModuleMeta;\n      } else {\n        if (throwIfNotFound) {\n          throw new Error(\"No NgModule metadata found for '\".concat(stringify(type), \"'.\"));\n        }\n\n        return null;\n      }\n    }\n  }]);\n\n  return NgModuleResolver;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nfunction debugOutputAstAsTypeScript(ast) {\n  var converter = new _TsEmitterVisitor();\n  var ctx = EmitterVisitorContext.createRoot();\n  var asts = Array.isArray(ast) ? ast : [ast];\n  asts.forEach(function (ast) {\n    if (ast instanceof Statement) {\n      ast.visitStatement(converter, ctx);\n    } else if (ast instanceof Expression) {\n      ast.visitExpression(converter, ctx);\n    } else if (ast instanceof Type$1) {\n      ast.visitType(converter, ctx);\n    } else {\n      throw new Error(\"Don't know how to print debug info for \".concat(ast));\n    }\n  });\n  return ctx.toSource();\n}\n\nvar TypeScriptEmitter = /*#__PURE__*/function () {\n  function TypeScriptEmitter() {\n    _classCallCheck(this, TypeScriptEmitter);\n  }\n\n  _createClass(TypeScriptEmitter, [{\n    key: \"emitStatementsAndContext\",\n    value: function emitStatementsAndContext(genFilePath, stmts) {\n      var preamble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var emitSourceMaps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n      var referenceFilter = arguments.length > 4 ? arguments[4] : undefined;\n      var importFilter = arguments.length > 5 ? arguments[5] : undefined;\n      var converter = new _TsEmitterVisitor(referenceFilter, importFilter);\n      var ctx = EmitterVisitorContext.createRoot();\n      converter.visitAllStatements(stmts, ctx);\n      var preambleLines = preamble ? preamble.split('\\n') : [];\n      converter.reexports.forEach(function (reexports, exportedModuleName) {\n        var reexportsCode = reexports.map(function (reexport) {\n          return \"\".concat(reexport.name, \" as \").concat(reexport.as);\n        }).join(',');\n        preambleLines.push(\"export {\".concat(reexportsCode, \"} from '\").concat(exportedModuleName, \"';\"));\n      });\n      converter.importsWithPrefixes.forEach(function (prefix, importedModuleName) {\n        // Note: can't write the real word for import as it screws up system.js auto detection...\n        preambleLines.push(\"imp\" + \"ort * as \".concat(prefix, \" from '\").concat(importedModuleName, \"';\"));\n      });\n      var sm = emitSourceMaps ? ctx.toSourceMapGenerator(genFilePath, preambleLines.length).toJsComment() : '';\n      var lines = [].concat(_toConsumableArray(preambleLines), [ctx.toSource(), sm]);\n\n      if (sm) {\n        // always add a newline at the end, as some tools have bugs without it.\n        lines.push('');\n      }\n\n      ctx.setPreambleLineCount(preambleLines.length);\n      return {\n        sourceText: lines.join('\\n'),\n        context: ctx\n      };\n    }\n  }, {\n    key: \"emitStatements\",\n    value: function emitStatements(genFilePath, stmts) {\n      var preamble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      return this.emitStatementsAndContext(genFilePath, stmts, preamble).sourceText;\n    }\n  }]);\n\n  return TypeScriptEmitter;\n}();\n\nvar _TsEmitterVisitor = /*#__PURE__*/function (_AbstractEmitterVisit2) {\n  _inherits(_TsEmitterVisitor, _AbstractEmitterVisit2);\n\n  var _super106 = _createSuper(_TsEmitterVisitor);\n\n  function _TsEmitterVisitor(referenceFilter, importFilter) {\n    var _this233;\n\n    _classCallCheck(this, _TsEmitterVisitor);\n\n    _this233 = _super106.call(this, false);\n    _this233.referenceFilter = referenceFilter;\n    _this233.importFilter = importFilter;\n    _this233.typeExpression = 0;\n    _this233.importsWithPrefixes = new Map();\n    _this233.reexports = new Map();\n    return _this233;\n  }\n\n  _createClass(_TsEmitterVisitor, [{\n    key: \"visitType\",\n    value: function visitType(t, ctx) {\n      var defaultType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'any';\n\n      if (t) {\n        this.typeExpression++;\n        t.visitType(this, ctx);\n        this.typeExpression--;\n      } else {\n        ctx.print(null, defaultType);\n      }\n    }\n  }, {\n    key: \"visitLiteralExpr\",\n    value: function visitLiteralExpr(ast, ctx) {\n      var value = ast.value;\n\n      if (value == null && ast.type != INFERRED_TYPE) {\n        ctx.print(ast, \"(\".concat(value, \" as any)\"));\n        return null;\n      }\n\n      return _get(_getPrototypeOf(_TsEmitterVisitor.prototype), \"visitLiteralExpr\", this).call(this, ast, ctx);\n    } // Temporary workaround to support strictNullCheck enabled consumers of ngc emit.\n    // In SNC mode, [] have the type never[], so we cast here to any[].\n    // TODO: narrow the cast to a more explicit type, or use a pattern that does not\n    // start with [].concat. see https://github.com/angular/angular/pull/11846\n\n  }, {\n    key: \"visitLiteralArrayExpr\",\n    value: function visitLiteralArrayExpr(ast, ctx) {\n      if (ast.entries.length === 0) {\n        ctx.print(ast, '(');\n      }\n\n      var result = _get(_getPrototypeOf(_TsEmitterVisitor.prototype), \"visitLiteralArrayExpr\", this).call(this, ast, ctx);\n\n      if (ast.entries.length === 0) {\n        ctx.print(ast, ' as any[])');\n      }\n\n      return result;\n    }\n  }, {\n    key: \"visitExternalExpr\",\n    value: function visitExternalExpr(ast, ctx) {\n      this._visitIdentifier(ast.value, ast.typeParams, ctx);\n\n      return null;\n    }\n  }, {\n    key: \"visitAssertNotNullExpr\",\n    value: function visitAssertNotNullExpr(ast, ctx) {\n      var result = _get(_getPrototypeOf(_TsEmitterVisitor.prototype), \"visitAssertNotNullExpr\", this).call(this, ast, ctx);\n\n      ctx.print(ast, '!');\n      return result;\n    }\n  }, {\n    key: \"visitDeclareVarStmt\",\n    value: function visitDeclareVarStmt(stmt, ctx) {\n      if (stmt.hasModifier(StmtModifier.Exported) && stmt.value instanceof ExternalExpr && !stmt.type) {\n        // check for a reexport\n        var _stmt$value$value = stmt.value.value,\n            name = _stmt$value$value.name,\n            moduleName = _stmt$value$value.moduleName;\n\n        if (moduleName) {\n          var reexports = this.reexports.get(moduleName);\n\n          if (!reexports) {\n            reexports = [];\n            this.reexports.set(moduleName, reexports);\n          }\n\n          reexports.push({\n            name: name,\n            as: stmt.name\n          });\n          return null;\n        }\n      }\n\n      if (stmt.hasModifier(StmtModifier.Exported)) {\n        ctx.print(stmt, \"export \");\n      }\n\n      if (stmt.hasModifier(StmtModifier.Final)) {\n        ctx.print(stmt, \"const\");\n      } else {\n        ctx.print(stmt, \"var\");\n      }\n\n      ctx.print(stmt, \" \".concat(stmt.name));\n\n      this._printColonType(stmt.type, ctx);\n\n      if (stmt.value) {\n        ctx.print(stmt, \" = \");\n        stmt.value.visitExpression(this, ctx);\n      }\n\n      ctx.println(stmt, \";\");\n      return null;\n    }\n  }, {\n    key: \"visitWrappedNodeExpr\",\n    value: function visitWrappedNodeExpr(ast, ctx) {\n      throw new Error('Cannot visit a WrappedNodeExpr when outputting Typescript.');\n    }\n  }, {\n    key: \"visitCastExpr\",\n    value: function visitCastExpr(ast, ctx) {\n      ctx.print(ast, \"(<\");\n      ast.type.visitType(this, ctx);\n      ctx.print(ast, \">\");\n      ast.value.visitExpression(this, ctx);\n      ctx.print(ast, \")\");\n      return null;\n    }\n  }, {\n    key: \"visitInstantiateExpr\",\n    value: function visitInstantiateExpr(ast, ctx) {\n      ctx.print(ast, \"new \");\n      this.typeExpression++;\n      ast.classExpr.visitExpression(this, ctx);\n      this.typeExpression--;\n      ctx.print(ast, \"(\");\n      this.visitAllExpressions(ast.args, ctx, ',');\n      ctx.print(ast, \")\");\n      return null;\n    }\n  }, {\n    key: \"visitDeclareClassStmt\",\n    value: function visitDeclareClassStmt(stmt, ctx) {\n      var _this234 = this;\n\n      ctx.pushClass(stmt);\n\n      if (stmt.hasModifier(StmtModifier.Exported)) {\n        ctx.print(stmt, \"export \");\n      }\n\n      ctx.print(stmt, \"class \".concat(stmt.name));\n\n      if (stmt.parent != null) {\n        ctx.print(stmt, \" extends \");\n        this.typeExpression++;\n        stmt.parent.visitExpression(this, ctx);\n        this.typeExpression--;\n      }\n\n      ctx.println(stmt, \" {\");\n      ctx.incIndent();\n      stmt.fields.forEach(function (field) {\n        return _this234._visitClassField(field, ctx);\n      });\n\n      if (stmt.constructorMethod != null) {\n        this._visitClassConstructor(stmt, ctx);\n      }\n\n      stmt.getters.forEach(function (getter) {\n        return _this234._visitClassGetter(getter, ctx);\n      });\n      stmt.methods.forEach(function (method) {\n        return _this234._visitClassMethod(method, ctx);\n      });\n      ctx.decIndent();\n      ctx.println(stmt, \"}\");\n      ctx.popClass();\n      return null;\n    }\n  }, {\n    key: \"_visitClassField\",\n    value: function _visitClassField(field, ctx) {\n      if (field.hasModifier(StmtModifier.Private)) {\n        // comment out as a workaround for #10967\n        ctx.print(null, \"/*private*/ \");\n      }\n\n      if (field.hasModifier(StmtModifier.Static)) {\n        ctx.print(null, 'static ');\n      }\n\n      ctx.print(null, field.name);\n\n      this._printColonType(field.type, ctx);\n\n      if (field.initializer) {\n        ctx.print(null, ' = ');\n        field.initializer.visitExpression(this, ctx);\n      }\n\n      ctx.println(null, \";\");\n    }\n  }, {\n    key: \"_visitClassGetter\",\n    value: function _visitClassGetter(getter, ctx) {\n      if (getter.hasModifier(StmtModifier.Private)) {\n        ctx.print(null, \"private \");\n      }\n\n      ctx.print(null, \"get \".concat(getter.name, \"()\"));\n\n      this._printColonType(getter.type, ctx);\n\n      ctx.println(null, \" {\");\n      ctx.incIndent();\n      this.visitAllStatements(getter.body, ctx);\n      ctx.decIndent();\n      ctx.println(null, \"}\");\n    }\n  }, {\n    key: \"_visitClassConstructor\",\n    value: function _visitClassConstructor(stmt, ctx) {\n      ctx.print(stmt, \"constructor(\");\n\n      this._visitParams(stmt.constructorMethod.params, ctx);\n\n      ctx.println(stmt, \") {\");\n      ctx.incIndent();\n      this.visitAllStatements(stmt.constructorMethod.body, ctx);\n      ctx.decIndent();\n      ctx.println(stmt, \"}\");\n    }\n  }, {\n    key: \"_visitClassMethod\",\n    value: function _visitClassMethod(method, ctx) {\n      if (method.hasModifier(StmtModifier.Private)) {\n        ctx.print(null, \"private \");\n      }\n\n      ctx.print(null, \"\".concat(method.name, \"(\"));\n\n      this._visitParams(method.params, ctx);\n\n      ctx.print(null, \")\");\n\n      this._printColonType(method.type, ctx, 'void');\n\n      ctx.println(null, \" {\");\n      ctx.incIndent();\n      this.visitAllStatements(method.body, ctx);\n      ctx.decIndent();\n      ctx.println(null, \"}\");\n    }\n  }, {\n    key: \"visitFunctionExpr\",\n    value: function visitFunctionExpr(ast, ctx) {\n      if (ast.name) {\n        ctx.print(ast, 'function ');\n        ctx.print(ast, ast.name);\n      }\n\n      ctx.print(ast, \"(\");\n\n      this._visitParams(ast.params, ctx);\n\n      ctx.print(ast, \")\");\n\n      this._printColonType(ast.type, ctx, 'void');\n\n      if (!ast.name) {\n        ctx.print(ast, \" => \");\n      }\n\n      ctx.println(ast, '{');\n      ctx.incIndent();\n      this.visitAllStatements(ast.statements, ctx);\n      ctx.decIndent();\n      ctx.print(ast, \"}\");\n      return null;\n    }\n  }, {\n    key: \"visitDeclareFunctionStmt\",\n    value: function visitDeclareFunctionStmt(stmt, ctx) {\n      if (stmt.hasModifier(StmtModifier.Exported)) {\n        ctx.print(stmt, \"export \");\n      }\n\n      ctx.print(stmt, \"function \".concat(stmt.name, \"(\"));\n\n      this._visitParams(stmt.params, ctx);\n\n      ctx.print(stmt, \")\");\n\n      this._printColonType(stmt.type, ctx, 'void');\n\n      ctx.println(stmt, \" {\");\n      ctx.incIndent();\n      this.visitAllStatements(stmt.statements, ctx);\n      ctx.decIndent();\n      ctx.println(stmt, \"}\");\n      return null;\n    }\n  }, {\n    key: \"visitTryCatchStmt\",\n    value: function visitTryCatchStmt(stmt, ctx) {\n      ctx.println(stmt, \"try {\");\n      ctx.incIndent();\n      this.visitAllStatements(stmt.bodyStmts, ctx);\n      ctx.decIndent();\n      ctx.println(stmt, \"} catch (\".concat(CATCH_ERROR_VAR$1.name, \") {\"));\n      ctx.incIndent();\n      var catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack', null)).toDeclStmt(null, [StmtModifier.Final])].concat(stmt.catchStmts);\n      this.visitAllStatements(catchStmts, ctx);\n      ctx.decIndent();\n      ctx.println(stmt, \"}\");\n      return null;\n    }\n  }, {\n    key: \"visitBuiltinType\",\n    value: function visitBuiltinType(type, ctx) {\n      var typeStr;\n\n      switch (type.name) {\n        case BuiltinTypeName.Bool:\n          typeStr = 'boolean';\n          break;\n\n        case BuiltinTypeName.Dynamic:\n          typeStr = 'any';\n          break;\n\n        case BuiltinTypeName.Function:\n          typeStr = 'Function';\n          break;\n\n        case BuiltinTypeName.Number:\n          typeStr = 'number';\n          break;\n\n        case BuiltinTypeName.Int:\n          typeStr = 'number';\n          break;\n\n        case BuiltinTypeName.String:\n          typeStr = 'string';\n          break;\n\n        case BuiltinTypeName.None:\n          typeStr = 'never';\n          break;\n\n        default:\n          throw new Error(\"Unsupported builtin type \".concat(type.name));\n      }\n\n      ctx.print(null, typeStr);\n      return null;\n    }\n  }, {\n    key: \"visitExpressionType\",\n    value: function visitExpressionType(ast, ctx) {\n      var _this235 = this;\n\n      ast.value.visitExpression(this, ctx);\n\n      if (ast.typeParams !== null) {\n        ctx.print(null, '<');\n        this.visitAllObjects(function (type) {\n          return _this235.visitType(type, ctx);\n        }, ast.typeParams, ctx, ',');\n        ctx.print(null, '>');\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitArrayType\",\n    value: function visitArrayType(type, ctx) {\n      this.visitType(type.of, ctx);\n      ctx.print(null, \"[]\");\n      return null;\n    }\n  }, {\n    key: \"visitMapType\",\n    value: function visitMapType(type, ctx) {\n      ctx.print(null, \"{[key: string]:\");\n      this.visitType(type.valueType, ctx);\n      ctx.print(null, \"}\");\n      return null;\n    }\n  }, {\n    key: \"getBuiltinMethodName\",\n    value: function getBuiltinMethodName(method) {\n      var name;\n\n      switch (method) {\n        case BuiltinMethod.ConcatArray:\n          name = 'concat';\n          break;\n\n        case BuiltinMethod.SubscribeObservable:\n          name = 'subscribe';\n          break;\n\n        case BuiltinMethod.Bind:\n          name = 'bind';\n          break;\n\n        default:\n          throw new Error(\"Unknown builtin method: \".concat(method));\n      }\n\n      return name;\n    }\n  }, {\n    key: \"_visitParams\",\n    value: function _visitParams(params, ctx) {\n      var _this236 = this;\n\n      this.visitAllObjects(function (param) {\n        ctx.print(null, param.name);\n\n        _this236._printColonType(param.type, ctx);\n      }, params, ctx, ',');\n    }\n  }, {\n    key: \"_visitIdentifier\",\n    value: function _visitIdentifier(value, typeParams, ctx) {\n      var _this237 = this;\n\n      var name = value.name,\n          moduleName = value.moduleName;\n\n      if (this.referenceFilter && this.referenceFilter(value)) {\n        ctx.print(null, '(null as any)');\n        return;\n      }\n\n      if (moduleName && (!this.importFilter || !this.importFilter(value))) {\n        var prefix = this.importsWithPrefixes.get(moduleName);\n\n        if (prefix == null) {\n          prefix = \"i\".concat(this.importsWithPrefixes.size);\n          this.importsWithPrefixes.set(moduleName, prefix);\n        }\n\n        ctx.print(null, \"\".concat(prefix, \".\"));\n      }\n\n      ctx.print(null, name);\n\n      if (this.typeExpression > 0) {\n        // If we are in a type expression that refers to a generic type then supply\n        // the required type parameters. If there were not enough type parameters\n        // supplied, supply any as the type. Outside a type expression the reference\n        // should not supply type parameters and be treated as a simple value reference\n        // to the constructor function itself.\n        var suppliedParameters = typeParams || [];\n\n        if (suppliedParameters.length > 0) {\n          ctx.print(null, \"<\");\n          this.visitAllObjects(function (type) {\n            return type.visitType(_this237, ctx);\n          }, typeParams, ctx, ',');\n          ctx.print(null, \">\");\n        }\n      }\n    }\n  }, {\n    key: \"_printColonType\",\n    value: function _printColonType(type, ctx, defaultType) {\n      if (type !== INFERRED_TYPE) {\n        ctx.print(null, ':');\n        this.visitType(type, ctx, defaultType);\n      }\n    }\n  }]);\n\n  return _TsEmitterVisitor;\n}(AbstractEmitterVisitor);\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Resolve a `Type` for {@link Pipe}.\r\n *\r\n * This interface can be overridden by the application developer to create custom behavior.\r\n *\r\n * See {@link Compiler}\r\n */\n\n\nvar PipeResolver = /*#__PURE__*/function () {\n  function PipeResolver(_reflector) {\n    _classCallCheck(this, PipeResolver);\n\n    this._reflector = _reflector;\n  }\n\n  _createClass(PipeResolver, [{\n    key: \"isPipe\",\n    value: function isPipe(type) {\n      var typeMetadata = this._reflector.annotations(resolveForwardRef(type));\n\n      return typeMetadata && typeMetadata.some(createPipe.isTypeOf);\n    }\n    /**\r\n     * Return {@link Pipe} for a given `Type`.\r\n     */\n\n  }, {\n    key: \"resolve\",\n    value: function resolve(type) {\n      var throwIfNotFound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      var metas = this._reflector.annotations(resolveForwardRef(type));\n\n      if (metas) {\n        var annotation = findLast(metas, createPipe.isTypeOf);\n\n        if (annotation) {\n          return annotation;\n        }\n      }\n\n      if (throwIfNotFound) {\n        throw new Error(\"No Pipe decorator found on \".concat(stringify(type)));\n      }\n\n      return null;\n    }\n  }]);\n\n  return PipeResolver;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Generates code that is used to type check templates.\r\n */\n\n\nvar TypeCheckCompiler = /*#__PURE__*/function () {\n  function TypeCheckCompiler(options, reflector) {\n    _classCallCheck(this, TypeCheckCompiler);\n\n    this.options = options;\n    this.reflector = reflector;\n  }\n  /**\r\n   * Important notes:\r\n   * - This must not produce new `import` statements, but only refer to types outside\r\n   *   of the file via the variables provided via externalReferenceVars.\r\n   *   This allows Typescript to reuse the old program's structure as no imports have changed.\r\n   * - This must not produce any exports, as this would pollute the .d.ts file\r\n   *   and also violate the point above.\r\n   */\n\n\n  _createClass(TypeCheckCompiler, [{\n    key: \"compileComponent\",\n    value: function compileComponent(componentId, component, template, usedPipes, externalReferenceVars, ctx) {\n      var _this238 = this;\n\n      var pipes = new Map();\n      usedPipes.forEach(function (p) {\n        return pipes.set(p.name, p.type.reference);\n      });\n      var embeddedViewCount = 0;\n\n      var viewBuilderFactory = function viewBuilderFactory(parent, guards) {\n        var embeddedViewIndex = embeddedViewCount++;\n        return new ViewBuilder(_this238.options, _this238.reflector, externalReferenceVars, parent, component.type.reference, component.isHost, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory);\n      };\n\n      var visitor = viewBuilderFactory(null, []);\n      visitor.visitAll([], template);\n      return visitor.build(componentId);\n    }\n  }]);\n\n  return TypeCheckCompiler;\n}();\n\nvar DYNAMIC_VAR_NAME = '_any';\n\nvar TypeCheckLocalResolver = /*#__PURE__*/function () {\n  function TypeCheckLocalResolver() {\n    _classCallCheck(this, TypeCheckLocalResolver);\n  }\n\n  _createClass(TypeCheckLocalResolver, [{\n    key: \"notifyImplicitReceiverUse\",\n    value: function notifyImplicitReceiverUse() {}\n  }, {\n    key: \"maybeRestoreView\",\n    value: function maybeRestoreView() {}\n  }, {\n    key: \"getLocal\",\n    value: function getLocal(name) {\n      if (name === EventHandlerVars.event.name) {\n        // References to the event should not be type-checked.\n        // TODO(chuckj): determine a better type for the event.\n        return variable(DYNAMIC_VAR_NAME);\n      }\n\n      return null;\n    }\n  }]);\n\n  return TypeCheckLocalResolver;\n}();\n\nvar defaultResolver = new TypeCheckLocalResolver();\n\nvar ViewBuilder = /*#__PURE__*/function () {\n  function ViewBuilder(options, reflector, externalReferenceVars, parent, component, isHostComponent, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory) {\n    _classCallCheck(this, ViewBuilder);\n\n    this.options = options;\n    this.reflector = reflector;\n    this.externalReferenceVars = externalReferenceVars;\n    this.parent = parent;\n    this.component = component;\n    this.isHostComponent = isHostComponent;\n    this.embeddedViewIndex = embeddedViewIndex;\n    this.pipes = pipes;\n    this.guards = guards;\n    this.ctx = ctx;\n    this.viewBuilderFactory = viewBuilderFactory;\n    this.refOutputVars = new Map();\n    this.variables = [];\n    this.children = [];\n    this.updates = [];\n    this.actions = [];\n  }\n\n  _createClass(ViewBuilder, [{\n    key: \"getOutputVar\",\n    value: function getOutputVar(type) {\n      var varName;\n\n      if (type === this.component && this.isHostComponent) {\n        varName = DYNAMIC_VAR_NAME;\n      } else if (type instanceof StaticSymbol) {\n        varName = this.externalReferenceVars.get(type);\n      } else {\n        varName = DYNAMIC_VAR_NAME;\n      }\n\n      if (!varName) {\n        throw new Error(\"Illegal State: referring to a type without a variable \".concat(JSON.stringify(type)));\n      }\n\n      return varName;\n    }\n  }, {\n    key: \"getTypeGuardExpressions\",\n    value: function getTypeGuardExpressions(ast) {\n      var result = _toConsumableArray(this.guards);\n\n      var _iterator23 = _createForOfIteratorHelper(ast.directives),\n          _step23;\n\n      try {\n        for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n          var directive = _step23.value;\n\n          var _iterator24 = _createForOfIteratorHelper(directive.inputs),\n              _step24;\n\n          try {\n            for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n              var input = _step24.value;\n              var guard = directive.directive.guards[input.directiveName];\n\n              if (guard) {\n                var useIf = guard === 'UseIf';\n                result.push({\n                  guard: guard,\n                  useIf: useIf,\n                  expression: {\n                    context: this.component,\n                    value: input.value,\n                    sourceSpan: input.sourceSpan\n                  }\n                });\n              }\n            }\n          } catch (err) {\n            _iterator24.e(err);\n          } finally {\n            _iterator24.f();\n          }\n        }\n      } catch (err) {\n        _iterator23.e(err);\n      } finally {\n        _iterator23.f();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"visitAll\",\n    value: function visitAll(variables, astNodes) {\n      this.variables = variables;\n      templateVisitAll(this, astNodes);\n    }\n  }, {\n    key: \"build\",\n    value: function build(componentId) {\n      var _this239 = this;\n\n      var targetStatements = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      this.children.forEach(function (child) {\n        return child.build(componentId, targetStatements);\n      });\n      var viewStmts = [variable(DYNAMIC_VAR_NAME).set(NULL_EXPR).toDeclStmt(DYNAMIC_TYPE)];\n      var bindingCount = 0;\n      this.updates.forEach(function (expression) {\n        var _viewStmts;\n\n        var _this239$preprocessUp = _this239.preprocessUpdateExpression(expression),\n            sourceSpan = _this239$preprocessUp.sourceSpan,\n            context = _this239$preprocessUp.context,\n            value = _this239$preprocessUp.value;\n\n        var bindingId = \"\".concat(bindingCount++);\n        var nameResolver = context === _this239.component ? _this239 : defaultResolver;\n\n        var _convertPropertyBindi = _convertPropertyBinding(nameResolver, variable(_this239.getOutputVar(context)), value, bindingId, BindingForm.General),\n            stmts = _convertPropertyBindi.stmts,\n            currValExpr = _convertPropertyBindi.currValExpr;\n\n        stmts.push(new ExpressionStatement(currValExpr));\n\n        (_viewStmts = viewStmts).push.apply(_viewStmts, _toConsumableArray(stmts.map(function (stmt) {\n          return applySourceSpanToStatementIfNeeded(stmt, sourceSpan);\n        })));\n      });\n      this.actions.forEach(function (_ref36) {\n        var _viewStmts2;\n\n        var sourceSpan = _ref36.sourceSpan,\n            context = _ref36.context,\n            value = _ref36.value;\n        var bindingId = \"\".concat(bindingCount++);\n        var nameResolver = context === _this239.component ? _this239 : defaultResolver;\n\n        var _convertActionBinding = convertActionBinding(nameResolver, variable(_this239.getOutputVar(context)), value, bindingId),\n            stmts = _convertActionBinding.stmts;\n\n        (_viewStmts2 = viewStmts).push.apply(_viewStmts2, _toConsumableArray(stmts.map(function (stmt) {\n          return applySourceSpanToStatementIfNeeded(stmt, sourceSpan);\n        })));\n      });\n\n      if (this.guards.length) {\n        var guardExpression = undefined;\n\n        var _iterator25 = _createForOfIteratorHelper(this.guards),\n            _step25;\n\n        try {\n          for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n            var guard = _step25.value;\n\n            var _this$preprocessUpdat = this.preprocessUpdateExpression(guard.expression),\n                context = _this$preprocessUpdat.context,\n                value = _this$preprocessUpdat.value;\n\n            var bindingId = \"\".concat(bindingCount++);\n            var nameResolver = context === this.component ? this : defaultResolver; // We only support support simple expressions and ignore others as they\n            // are unlikely to affect type narrowing.\n\n            var _convertPropertyBindi2 = _convertPropertyBinding(nameResolver, variable(this.getOutputVar(context)), value, bindingId, BindingForm.TrySimple),\n                stmts = _convertPropertyBindi2.stmts,\n                currValExpr = _convertPropertyBindi2.currValExpr;\n\n            if (stmts.length == 0) {\n              var guardClause = guard.useIf ? currValExpr : this.ctx.importExpr(guard.guard).callFn([currValExpr]);\n              guardExpression = guardExpression ? guardExpression.and(guardClause) : guardClause;\n            }\n          }\n        } catch (err) {\n          _iterator25.e(err);\n        } finally {\n          _iterator25.f();\n        }\n\n        if (guardExpression) {\n          viewStmts = [new IfStmt(guardExpression, viewStmts)];\n        }\n      }\n\n      var viewName = \"_View_\".concat(componentId, \"_\").concat(this.embeddedViewIndex);\n      var viewFactory = new DeclareFunctionStmt(viewName, [], viewStmts);\n      targetStatements.push(viewFactory);\n      return targetStatements;\n    }\n  }, {\n    key: \"visitBoundText\",\n    value: function visitBoundText(ast, context) {\n      var _this240 = this;\n\n      var astWithSource = ast.value;\n      var inter = astWithSource.ast;\n      inter.expressions.forEach(function (expr) {\n        return _this240.updates.push({\n          context: _this240.component,\n          value: expr,\n          sourceSpan: ast.sourceSpan\n        });\n      });\n    }\n  }, {\n    key: \"visitEmbeddedTemplate\",\n    value: function visitEmbeddedTemplate(ast, context) {\n      this.visitElementOrTemplate(ast); // Note: The old view compiler used to use an `any` type\n      // for the context in any embedded view.\n      // We keep this behaivor behind a flag for now.\n\n      if (this.options.fullTemplateTypeCheck) {\n        // Find any applicable type guards. For example, NgIf has a type guard on ngIf\n        // (see NgIf.ngIfTypeGuard) that can be used to indicate that a template is only\n        // stamped out if ngIf is truthy so any bindings in the template can assume that,\n        // if a nullable type is used for ngIf, that expression is not null or undefined.\n        var guards = this.getTypeGuardExpressions(ast);\n        var childVisitor = this.viewBuilderFactory(this, guards);\n        this.children.push(childVisitor);\n        childVisitor.visitAll(ast.variables, ast.children);\n      }\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(ast, context) {\n      var _this241 = this;\n\n      this.visitElementOrTemplate(ast);\n      var inputDefs = [];\n      var updateRendererExpressions = [];\n      var outputDefs = [];\n      ast.inputs.forEach(function (inputAst) {\n        _this241.updates.push({\n          context: _this241.component,\n          value: inputAst.value,\n          sourceSpan: inputAst.sourceSpan\n        });\n      });\n      templateVisitAll(this, ast.children);\n    }\n  }, {\n    key: \"visitElementOrTemplate\",\n    value: function visitElementOrTemplate(ast) {\n      var _this242 = this;\n\n      ast.directives.forEach(function (dirAst) {\n        _this242.visitDirective(dirAst);\n      });\n      ast.references.forEach(function (ref) {\n        var outputVarType = null; // Note: The old view compiler used to use an `any` type\n        // for directives exposed via `exportAs`.\n        // We keep this behaivor behind a flag for now.\n\n        if (ref.value && ref.value.identifier && _this242.options.fullTemplateTypeCheck) {\n          outputVarType = ref.value.identifier.reference;\n        } else {\n          outputVarType = BuiltinTypeName.Dynamic;\n        }\n\n        _this242.refOutputVars.set(ref.name, outputVarType);\n      });\n      ast.outputs.forEach(function (outputAst) {\n        _this242.actions.push({\n          context: _this242.component,\n          value: outputAst.handler,\n          sourceSpan: outputAst.sourceSpan\n        });\n      });\n    }\n  }, {\n    key: \"visitDirective\",\n    value: function visitDirective(dirAst) {\n      var _this243 = this;\n\n      var dirType = dirAst.directive.type.reference;\n      dirAst.inputs.forEach(function (input) {\n        return _this243.updates.push({\n          context: _this243.component,\n          value: input.value,\n          sourceSpan: input.sourceSpan\n        });\n      }); // Note: The old view compiler used to use an `any` type\n      // for expressions in host properties / events.\n      // We keep this behaivor behind a flag for now.\n\n      if (this.options.fullTemplateTypeCheck) {\n        dirAst.hostProperties.forEach(function (inputAst) {\n          return _this243.updates.push({\n            context: dirType,\n            value: inputAst.value,\n            sourceSpan: inputAst.sourceSpan\n          });\n        });\n        dirAst.hostEvents.forEach(function (hostEventAst) {\n          return _this243.actions.push({\n            context: dirType,\n            value: hostEventAst.handler,\n            sourceSpan: hostEventAst.sourceSpan\n          });\n        });\n      }\n    }\n  }, {\n    key: \"notifyImplicitReceiverUse\",\n    value: function notifyImplicitReceiverUse() {}\n  }, {\n    key: \"maybeRestoreView\",\n    value: function maybeRestoreView() {}\n  }, {\n    key: \"getLocal\",\n    value: function getLocal(name) {\n      if (name == EventHandlerVars.event.name) {\n        return variable(this.getOutputVar(BuiltinTypeName.Dynamic));\n      }\n\n      for (var currBuilder = this; currBuilder; currBuilder = currBuilder.parent) {\n        var outputVarType = void 0; // check references\n\n        outputVarType = currBuilder.refOutputVars.get(name);\n\n        if (outputVarType == null) {\n          // check variables\n          var varAst = currBuilder.variables.find(function (varAst) {\n            return varAst.name === name;\n          });\n\n          if (varAst) {\n            outputVarType = BuiltinTypeName.Dynamic;\n          }\n        }\n\n        if (outputVarType != null) {\n          return variable(this.getOutputVar(outputVarType));\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"pipeOutputVar\",\n    value: function pipeOutputVar(name) {\n      var pipe = this.pipes.get(name);\n\n      if (!pipe) {\n        throw new Error(\"Illegal State: Could not find pipe \".concat(name, \" in template of \").concat(this.component));\n      }\n\n      return this.getOutputVar(pipe);\n    }\n  }, {\n    key: \"preprocessUpdateExpression\",\n    value: function preprocessUpdateExpression(expression) {\n      var _this244 = this;\n\n      return {\n        sourceSpan: expression.sourceSpan,\n        context: expression.context,\n        value: convertPropertyBindingBuiltins({\n          createLiteralArrayConverter: function createLiteralArrayConverter(argCount) {\n            return function (args) {\n              var arr = literalArr(args); // Note: The old view compiler used to use an `any` type\n              // for arrays.\n\n              return _this244.options.fullTemplateTypeCheck ? arr : arr.cast(DYNAMIC_TYPE);\n            };\n          },\n          createLiteralMapConverter: function createLiteralMapConverter(keys) {\n            return function (values) {\n              var entries = keys.map(function (k, i) {\n                return {\n                  key: k.key,\n                  value: values[i],\n                  quoted: k.quoted\n                };\n              });\n              var map = literalMap(entries); // Note: The old view compiler used to use an `any` type\n              // for maps.\n\n              return _this244.options.fullTemplateTypeCheck ? map : map.cast(DYNAMIC_TYPE);\n            };\n          },\n          createPipeConverter: function createPipeConverter(name, argCount) {\n            return function (args) {\n              // Note: The old view compiler used to use an `any` type\n              // for pipes.\n              var pipeExpr = _this244.options.fullTemplateTypeCheck ? variable(_this244.pipeOutputVar(name)) : variable(_this244.getOutputVar(BuiltinTypeName.Dynamic));\n              return pipeExpr.callMethod('transform', args);\n            };\n          }\n        }, expression.value)\n      };\n    }\n  }, {\n    key: \"visitNgContent\",\n    value: function visitNgContent(ast, context) {}\n  }, {\n    key: \"visitText\",\n    value: function visitText(ast, context) {}\n  }, {\n    key: \"visitDirectiveProperty\",\n    value: function visitDirectiveProperty(ast, context) {}\n  }, {\n    key: \"visitReference\",\n    value: function visitReference(ast, context) {}\n  }, {\n    key: \"visitVariable\",\n    value: function visitVariable(ast, context) {}\n  }, {\n    key: \"visitEvent\",\n    value: function visitEvent(ast, context) {}\n  }, {\n    key: \"visitElementProperty\",\n    value: function visitElementProperty(ast, context) {}\n  }, {\n    key: \"visitAttr\",\n    value: function visitAttr(ast, context) {}\n  }]);\n\n  return ViewBuilder;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar CLASS_ATTR$1 = 'class';\nvar STYLE_ATTR = 'style';\nvar IMPLICIT_TEMPLATE_VAR = '\\$implicit';\n\nvar ViewCompileResult = function ViewCompileResult(viewClassVar, rendererTypeVar) {\n  _classCallCheck(this, ViewCompileResult);\n\n  this.viewClassVar = viewClassVar;\n  this.rendererTypeVar = rendererTypeVar;\n};\n\nvar ViewCompiler = /*#__PURE__*/function () {\n  function ViewCompiler(_reflector) {\n    _classCallCheck(this, ViewCompiler);\n\n    this._reflector = _reflector;\n  }\n\n  _createClass(ViewCompiler, [{\n    key: \"compileComponent\",\n    value: function compileComponent(outputCtx, component, template, styles, usedPipes) {\n      var _this245 = this,\n          _outputCtx$statements;\n\n      var embeddedViewCount = 0;\n      var renderComponentVarName = undefined;\n\n      if (!component.isHost) {\n        var _template = component.template;\n        var customRenderData = [];\n\n        if (_template.animations && _template.animations.length) {\n          customRenderData.push(new LiteralMapEntry('animation', convertValueToOutputAst(outputCtx, _template.animations), true));\n        }\n\n        var renderComponentVar = variable(rendererTypeName(component.type.reference));\n        renderComponentVarName = renderComponentVar.name;\n        outputCtx.statements.push(renderComponentVar.set(importExpr(Identifiers$1.createRendererType2).callFn([new LiteralMapExpr([new LiteralMapEntry('encapsulation', literal(_template.encapsulation), false), new LiteralMapEntry('styles', styles, false), new LiteralMapEntry('data', new LiteralMapExpr(customRenderData), false)])])).toDeclStmt(importType(Identifiers$1.RendererType2), [StmtModifier.Final, StmtModifier.Exported]));\n      }\n\n      var viewBuilderFactory = function viewBuilderFactory(parent) {\n        var embeddedViewIndex = embeddedViewCount++;\n        return new ViewBuilder$1(_this245._reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, viewBuilderFactory);\n      };\n\n      var visitor = viewBuilderFactory(null);\n      visitor.visitAll([], template);\n\n      (_outputCtx$statements = outputCtx.statements).push.apply(_outputCtx$statements, _toConsumableArray(visitor.build()));\n\n      return new ViewCompileResult(visitor.viewName, renderComponentVarName);\n    }\n  }]);\n\n  return ViewCompiler;\n}();\n\nvar LOG_VAR$1 = variable('_l');\nvar VIEW_VAR = variable('_v');\nvar CHECK_VAR = variable('_ck');\nvar COMP_VAR = variable('_co');\nvar EVENT_NAME_VAR = variable('en');\nvar ALLOW_DEFAULT_VAR = variable(\"ad\");\n\nvar ViewBuilder$1 = /*#__PURE__*/function () {\n  function ViewBuilder$1(reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, viewBuilderFactory) {\n    _classCallCheck(this, ViewBuilder$1);\n\n    this.reflector = reflector;\n    this.outputCtx = outputCtx;\n    this.parent = parent;\n    this.component = component;\n    this.embeddedViewIndex = embeddedViewIndex;\n    this.usedPipes = usedPipes;\n    this.viewBuilderFactory = viewBuilderFactory;\n    this.nodes = [];\n    this.purePipeNodeIndices = Object.create(null); // Need Object.create so that we don't have builtin values...\n\n    this.refNodeIndices = Object.create(null);\n    this.variables = [];\n    this.children = []; // TODO(tbosch): The old view compiler used to use an `any` type\n    // for the context in any embedded view. We keep this behaivor for now\n    // to be able to introduce the new view compiler without too many errors.\n\n    this.compType = this.embeddedViewIndex > 0 ? DYNAMIC_TYPE : expressionType(outputCtx.importExpr(this.component.type.reference));\n    this.viewName = viewClassName(this.component.type.reference, this.embeddedViewIndex);\n  }\n\n  _createClass(ViewBuilder$1, [{\n    key: \"visitAll\",\n    value: function visitAll(variables, astNodes) {\n      var _this246 = this;\n\n      this.variables = variables; // create the pipes for the pure pipes immediately, so that we know their indices.\n\n      if (!this.parent) {\n        this.usedPipes.forEach(function (pipe) {\n          if (pipe.pure) {\n            _this246.purePipeNodeIndices[pipe.name] = _this246._createPipe(null, pipe);\n          }\n        });\n      }\n\n      if (!this.parent) {\n        this.component.viewQueries.forEach(function (query, queryIndex) {\n          // Note: queries start with id 1 so we can use the number in a Bloom filter!\n          var queryId = queryIndex + 1;\n          var bindingType = query.first ? 0\n          /* First */\n          : 1\n          /* All */\n          ;\n          var flags = 134217728\n          /* TypeViewQuery */\n          | calcQueryFlags(query);\n\n          _this246.nodes.push(function () {\n            return {\n              sourceSpan: null,\n              nodeFlags: flags,\n              nodeDef: importExpr(Identifiers$1.queryDef).callFn([literal(flags), literal(queryId), new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType), false)])])\n            };\n          });\n        });\n      }\n\n      templateVisitAll(this, astNodes);\n\n      if (this.parent && (astNodes.length === 0 || needsAdditionalRootNode(astNodes))) {\n        // if the view is an embedded view, then we need to add an additional root node in some cases\n        this.nodes.push(function () {\n          return {\n            sourceSpan: null,\n            nodeFlags: 1\n            /* TypeElement */\n            ,\n            nodeDef: importExpr(Identifiers$1.anchorDef).callFn([literal(0\n            /* None */\n            ), NULL_EXPR, NULL_EXPR, literal(0)])\n          };\n        });\n      }\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      var targetStatements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      this.children.forEach(function (child) {\n        return child.build(targetStatements);\n      });\n\n      var _this$_createNodeExpr = this._createNodeExpressions(),\n          updateRendererStmts = _this$_createNodeExpr.updateRendererStmts,\n          updateDirectivesStmts = _this$_createNodeExpr.updateDirectivesStmts,\n          nodeDefExprs = _this$_createNodeExpr.nodeDefExprs;\n\n      var updateRendererFn = this._createUpdateFn(updateRendererStmts);\n\n      var updateDirectivesFn = this._createUpdateFn(updateDirectivesStmts);\n\n      var viewFlags = 0\n      /* None */\n      ;\n\n      if (!this.parent && this.component.changeDetection === ChangeDetectionStrategy.OnPush) {\n        viewFlags |= 2\n        /* OnPush */\n        ;\n      }\n\n      var viewFactory = new DeclareFunctionStmt(this.viewName, [new FnParam(LOG_VAR$1.name)], [new ReturnStatement(importExpr(Identifiers$1.viewDef).callFn([literal(viewFlags), literalArr(nodeDefExprs), updateDirectivesFn, updateRendererFn]))], importType(Identifiers$1.ViewDefinition), this.embeddedViewIndex === 0 ? [StmtModifier.Exported] : []);\n      targetStatements.push(viewFactory);\n      return targetStatements;\n    }\n  }, {\n    key: \"_createUpdateFn\",\n    value: function _createUpdateFn(updateStmts) {\n      var updateFn;\n\n      if (updateStmts.length > 0) {\n        var preStmts = [];\n\n        if (!this.component.isHost && findReadVarNames(updateStmts).has(COMP_VAR.name)) {\n          preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n        }\n\n        updateFn = fn([new FnParam(CHECK_VAR.name, INFERRED_TYPE), new FnParam(VIEW_VAR.name, INFERRED_TYPE)], [].concat(preStmts, _toConsumableArray(updateStmts)), INFERRED_TYPE);\n      } else {\n        updateFn = NULL_EXPR;\n      }\n\n      return updateFn;\n    }\n  }, {\n    key: \"visitNgContent\",\n    value: function visitNgContent(ast, context) {\n      // ngContentDef(ngContentIndex: number, index: number): NodeDef;\n      this.nodes.push(function () {\n        return {\n          sourceSpan: ast.sourceSpan,\n          nodeFlags: 8\n          /* TypeNgContent */\n          ,\n          nodeDef: importExpr(Identifiers$1.ngContentDef).callFn([literal(ast.ngContentIndex), literal(ast.index)])\n        };\n      });\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(ast, context) {\n      // Static text nodes have no check function\n      var checkIndex = -1;\n      this.nodes.push(function () {\n        return {\n          sourceSpan: ast.sourceSpan,\n          nodeFlags: 2\n          /* TypeText */\n          ,\n          nodeDef: importExpr(Identifiers$1.textDef).callFn([literal(checkIndex), literal(ast.ngContentIndex), literalArr([literal(ast.value)])])\n        };\n      });\n    }\n  }, {\n    key: \"visitBoundText\",\n    value: function visitBoundText(ast, context) {\n      var _this247 = this;\n\n      var nodeIndex = this.nodes.length; // reserve the space in the nodeDefs array\n\n      this.nodes.push(null);\n      var astWithSource = ast.value;\n      var inter = astWithSource.ast;\n      var updateRendererExpressions = inter.expressions.map(function (expr, bindingIndex) {\n        return _this247._preprocessUpdateExpression({\n          nodeIndex: nodeIndex,\n          bindingIndex: bindingIndex,\n          sourceSpan: ast.sourceSpan,\n          context: COMP_VAR,\n          value: expr\n        });\n      }); // Check index is the same as the node index during compilation\n      // They might only differ at runtime\n\n      var checkIndex = nodeIndex;\n\n      this.nodes[nodeIndex] = function () {\n        return {\n          sourceSpan: ast.sourceSpan,\n          nodeFlags: 2\n          /* TypeText */\n          ,\n          nodeDef: importExpr(Identifiers$1.textDef).callFn([literal(checkIndex), literal(ast.ngContentIndex), literalArr(inter.strings.map(function (s) {\n            return literal(s);\n          }))]),\n          updateRenderer: updateRendererExpressions\n        };\n      };\n    }\n  }, {\n    key: \"visitEmbeddedTemplate\",\n    value: function visitEmbeddedTemplate(ast, context) {\n      var _this248 = this;\n\n      var nodeIndex = this.nodes.length; // reserve the space in the nodeDefs array\n\n      this.nodes.push(null);\n\n      var _this$_visitElementOr = this._visitElementOrTemplate(nodeIndex, ast),\n          flags = _this$_visitElementOr.flags,\n          queryMatchesExpr = _this$_visitElementOr.queryMatchesExpr,\n          hostEvents = _this$_visitElementOr.hostEvents;\n\n      var childVisitor = this.viewBuilderFactory(this);\n      this.children.push(childVisitor);\n      childVisitor.visitAll(ast.variables, ast.children);\n      var childCount = this.nodes.length - nodeIndex - 1; // anchorDef(\n      //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], ngContentIndex: number,\n      //   childCount: number, handleEventFn?: ElementHandleEventFn, templateFactory?:\n      //   ViewDefinitionFactory): NodeDef;\n\n      this.nodes[nodeIndex] = function () {\n        return {\n          sourceSpan: ast.sourceSpan,\n          nodeFlags: 1\n          /* TypeElement */\n          | flags,\n          nodeDef: importExpr(Identifiers$1.anchorDef).callFn([literal(flags), queryMatchesExpr, literal(ast.ngContentIndex), literal(childCount), _this248._createElementHandleEventFn(nodeIndex, hostEvents), variable(childVisitor.viewName)])\n        };\n      };\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(ast, context) {\n      var _this249 = this;\n\n      var nodeIndex = this.nodes.length; // reserve the space in the nodeDefs array so we can add children\n\n      this.nodes.push(null); // Using a null element name creates an anchor.\n\n      var elName = isNgContainer(ast.name) ? null : ast.name;\n\n      var _this$_visitElementOr2 = this._visitElementOrTemplate(nodeIndex, ast),\n          flags = _this$_visitElementOr2.flags,\n          usedEvents = _this$_visitElementOr2.usedEvents,\n          queryMatchesExpr = _this$_visitElementOr2.queryMatchesExpr,\n          dirHostBindings = _this$_visitElementOr2.hostBindings,\n          hostEvents = _this$_visitElementOr2.hostEvents;\n\n      var inputDefs = [];\n      var updateRendererExpressions = [];\n      var outputDefs = [];\n\n      if (elName) {\n        var hostBindings = ast.inputs.map(function (inputAst) {\n          return {\n            context: COMP_VAR,\n            inputAst: inputAst,\n            dirAst: null\n          };\n        }).concat(dirHostBindings);\n\n        if (hostBindings.length) {\n          updateRendererExpressions = hostBindings.map(function (hostBinding, bindingIndex) {\n            return _this249._preprocessUpdateExpression({\n              context: hostBinding.context,\n              nodeIndex: nodeIndex,\n              bindingIndex: bindingIndex,\n              sourceSpan: hostBinding.inputAst.sourceSpan,\n              value: hostBinding.inputAst.value\n            });\n          });\n          inputDefs = hostBindings.map(function (hostBinding) {\n            return elementBindingDef(hostBinding.inputAst, hostBinding.dirAst);\n          });\n        }\n\n        outputDefs = usedEvents.map(function (_ref37) {\n          var _ref38 = _slicedToArray(_ref37, 2),\n              target = _ref38[0],\n              eventName = _ref38[1];\n\n          return literalArr([literal(target), literal(eventName)]);\n        });\n      }\n\n      templateVisitAll(this, ast.children);\n      var childCount = this.nodes.length - nodeIndex - 1;\n      var compAst = ast.directives.find(function (dirAst) {\n        return dirAst.directive.isComponent;\n      });\n      var compRendererType = NULL_EXPR;\n      var compView = NULL_EXPR;\n\n      if (compAst) {\n        compView = this.outputCtx.importExpr(compAst.directive.componentViewType);\n        compRendererType = this.outputCtx.importExpr(compAst.directive.rendererType);\n      } // Check index is the same as the node index during compilation\n      // They might only differ at runtime\n\n\n      var checkIndex = nodeIndex;\n\n      this.nodes[nodeIndex] = function () {\n        return {\n          sourceSpan: ast.sourceSpan,\n          nodeFlags: 1\n          /* TypeElement */\n          | flags,\n          nodeDef: importExpr(Identifiers$1.elementDef).callFn([literal(checkIndex), literal(flags), queryMatchesExpr, literal(ast.ngContentIndex), literal(childCount), literal(elName), elName ? fixedAttrsDef(ast) : NULL_EXPR, inputDefs.length ? literalArr(inputDefs) : NULL_EXPR, outputDefs.length ? literalArr(outputDefs) : NULL_EXPR, _this249._createElementHandleEventFn(nodeIndex, hostEvents), compView, compRendererType]),\n          updateRenderer: updateRendererExpressions\n        };\n      };\n    }\n  }, {\n    key: \"_visitElementOrTemplate\",\n    value: function _visitElementOrTemplate(nodeIndex, ast) {\n      var _this250 = this;\n\n      var flags = 0\n      /* None */\n      ;\n\n      if (ast.hasViewContainer) {\n        flags |= 16777216\n        /* EmbeddedViews */\n        ;\n      }\n\n      var usedEvents = new Map();\n      ast.outputs.forEach(function (event) {\n        var _elementEventNameAndT = elementEventNameAndTarget(event, null),\n            name = _elementEventNameAndT.name,\n            target = _elementEventNameAndT.target;\n\n        usedEvents.set(elementEventFullName(target, name), [target, name]);\n      });\n      ast.directives.forEach(function (dirAst) {\n        dirAst.hostEvents.forEach(function (event) {\n          var _elementEventNameAndT2 = elementEventNameAndTarget(event, dirAst),\n              name = _elementEventNameAndT2.name,\n              target = _elementEventNameAndT2.target;\n\n          usedEvents.set(elementEventFullName(target, name), [target, name]);\n        });\n      });\n      var hostBindings = [];\n      var hostEvents = [];\n\n      this._visitComponentFactoryResolverProvider(ast.directives);\n\n      ast.providers.forEach(function (providerAst) {\n        var dirAst = undefined;\n        ast.directives.forEach(function (localDirAst) {\n          if (localDirAst.directive.type.reference === tokenReference(providerAst.token)) {\n            dirAst = localDirAst;\n          }\n        });\n\n        if (dirAst) {\n          var _this250$_visitDirect = _this250._visitDirective(providerAst, dirAst, ast.references, ast.queryMatches, usedEvents),\n              dirHostBindings = _this250$_visitDirect.hostBindings,\n              dirHostEvents = _this250$_visitDirect.hostEvents;\n\n          hostBindings.push.apply(hostBindings, _toConsumableArray(dirHostBindings));\n          hostEvents.push.apply(hostEvents, _toConsumableArray(dirHostEvents));\n        } else {\n          _this250._visitProvider(providerAst, ast.queryMatches);\n        }\n      });\n      var queryMatchExprs = [];\n      ast.queryMatches.forEach(function (match) {\n        var valueType = undefined;\n\n        if (tokenReference(match.value) === _this250.reflector.resolveExternalReference(Identifiers$1.ElementRef)) {\n          valueType = 0\n          /* ElementRef */\n          ;\n        } else if (tokenReference(match.value) === _this250.reflector.resolveExternalReference(Identifiers$1.ViewContainerRef)) {\n          valueType = 3\n          /* ViewContainerRef */\n          ;\n        } else if (tokenReference(match.value) === _this250.reflector.resolveExternalReference(Identifiers$1.TemplateRef)) {\n          valueType = 2\n          /* TemplateRef */\n          ;\n        }\n\n        if (valueType != null) {\n          queryMatchExprs.push(literalArr([literal(match.queryId), literal(valueType)]));\n        }\n      });\n      ast.references.forEach(function (ref) {\n        var valueType = undefined;\n\n        if (!ref.value) {\n          valueType = 1\n          /* RenderElement */\n          ;\n        } else if (tokenReference(ref.value) === _this250.reflector.resolveExternalReference(Identifiers$1.TemplateRef)) {\n          valueType = 2\n          /* TemplateRef */\n          ;\n        }\n\n        if (valueType != null) {\n          _this250.refNodeIndices[ref.name] = nodeIndex;\n          queryMatchExprs.push(literalArr([literal(ref.name), literal(valueType)]));\n        }\n      });\n      ast.outputs.forEach(function (outputAst) {\n        hostEvents.push({\n          context: COMP_VAR,\n          eventAst: outputAst,\n          dirAst: null\n        });\n      });\n      return {\n        flags: flags,\n        usedEvents: Array.from(usedEvents.values()),\n        queryMatchesExpr: queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,\n        hostBindings: hostBindings,\n        hostEvents: hostEvents\n      };\n    }\n  }, {\n    key: \"_visitDirective\",\n    value: function _visitDirective(providerAst, dirAst, refs, queryMatches, usedEvents) {\n      var _this251 = this;\n\n      var nodeIndex = this.nodes.length; // reserve the space in the nodeDefs array so we can add children\n\n      this.nodes.push(null);\n      dirAst.directive.queries.forEach(function (query, queryIndex) {\n        var queryId = dirAst.contentQueryStartId + queryIndex;\n        var flags = 67108864\n        /* TypeContentQuery */\n        | calcQueryFlags(query);\n        var bindingType = query.first ? 0\n        /* First */\n        : 1\n        /* All */\n        ;\n\n        _this251.nodes.push(function () {\n          return {\n            sourceSpan: dirAst.sourceSpan,\n            nodeFlags: flags,\n            nodeDef: importExpr(Identifiers$1.queryDef).callFn([literal(flags), literal(queryId), new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType), false)])])\n          };\n        });\n      }); // Note: the operation below might also create new nodeDefs,\n      // but we don't want them to be a child of a directive,\n      // as they might be a provider/pipe on their own.\n      // I.e. we only allow queries as children of directives nodes.\n\n      var childCount = this.nodes.length - nodeIndex - 1;\n\n      var _this$_visitProviderO = this._visitProviderOrDirective(providerAst, queryMatches),\n          flags = _this$_visitProviderO.flags,\n          queryMatchExprs = _this$_visitProviderO.queryMatchExprs,\n          providerExpr = _this$_visitProviderO.providerExpr,\n          depsExpr = _this$_visitProviderO.depsExpr;\n\n      refs.forEach(function (ref) {\n        if (ref.value && tokenReference(ref.value) === tokenReference(providerAst.token)) {\n          _this251.refNodeIndices[ref.name] = nodeIndex;\n          queryMatchExprs.push(literalArr([literal(ref.name), literal(4\n          /* Provider */\n          )]));\n        }\n      });\n\n      if (dirAst.directive.isComponent) {\n        flags |= 32768\n        /* Component */\n        ;\n      }\n\n      var inputDefs = dirAst.inputs.map(function (inputAst, inputIndex) {\n        var mapValue = literalArr([literal(inputIndex), literal(inputAst.directiveName)]); // Note: it's important to not quote the key so that we can capture renames by minifiers!\n\n        return new LiteralMapEntry(inputAst.directiveName, mapValue, false);\n      });\n      var outputDefs = [];\n      var dirMeta = dirAst.directive;\n      Object.keys(dirMeta.outputs).forEach(function (propName) {\n        var eventName = dirMeta.outputs[propName];\n\n        if (usedEvents.has(eventName)) {\n          // Note: it's important to not quote the key so that we can capture renames by minifiers!\n          outputDefs.push(new LiteralMapEntry(propName, literal(eventName), false));\n        }\n      });\n      var updateDirectiveExpressions = [];\n\n      if (dirAst.inputs.length || (flags & (262144\n      /* DoCheck */\n      | 65536\n      /* OnInit */\n      )) > 0) {\n        updateDirectiveExpressions = dirAst.inputs.map(function (input, bindingIndex) {\n          return _this251._preprocessUpdateExpression({\n            nodeIndex: nodeIndex,\n            bindingIndex: bindingIndex,\n            sourceSpan: input.sourceSpan,\n            context: COMP_VAR,\n            value: input.value\n          });\n        });\n      }\n\n      var dirContextExpr = importExpr(Identifiers$1.nodeValue).callFn([VIEW_VAR, literal(nodeIndex)]);\n      var hostBindings = dirAst.hostProperties.map(function (inputAst) {\n        return {\n          context: dirContextExpr,\n          dirAst: dirAst,\n          inputAst: inputAst\n        };\n      });\n      var hostEvents = dirAst.hostEvents.map(function (hostEventAst) {\n        return {\n          context: dirContextExpr,\n          eventAst: hostEventAst,\n          dirAst: dirAst\n        };\n      }); // Check index is the same as the node index during compilation\n      // They might only differ at runtime\n\n      var checkIndex = nodeIndex;\n\n      this.nodes[nodeIndex] = function () {\n        return {\n          sourceSpan: dirAst.sourceSpan,\n          nodeFlags: 16384\n          /* TypeDirective */\n          | flags,\n          nodeDef: importExpr(Identifiers$1.directiveDef).callFn([literal(checkIndex), literal(flags), queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR, literal(childCount), providerExpr, depsExpr, inputDefs.length ? new LiteralMapExpr(inputDefs) : NULL_EXPR, outputDefs.length ? new LiteralMapExpr(outputDefs) : NULL_EXPR]),\n          updateDirectives: updateDirectiveExpressions,\n          directive: dirAst.directive.type\n        };\n      };\n\n      return {\n        hostBindings: hostBindings,\n        hostEvents: hostEvents\n      };\n    }\n  }, {\n    key: \"_visitProvider\",\n    value: function _visitProvider(providerAst, queryMatches) {\n      this._addProviderNode(this._visitProviderOrDirective(providerAst, queryMatches));\n    }\n  }, {\n    key: \"_visitComponentFactoryResolverProvider\",\n    value: function _visitComponentFactoryResolverProvider(directives) {\n      var componentDirMeta = directives.find(function (dirAst) {\n        return dirAst.directive.isComponent;\n      });\n\n      if (componentDirMeta && componentDirMeta.directive.entryComponents.length) {\n        var _componentFactoryReso = componentFactoryResolverProviderDef(this.reflector, this.outputCtx, 8192\n        /* PrivateProvider */\n        ,\n        /* PrivateProvider */\n        componentDirMeta.directive.entryComponents),\n            providerExpr = _componentFactoryReso.providerExpr,\n            depsExpr = _componentFactoryReso.depsExpr,\n            flags = _componentFactoryReso.flags,\n            _tokenExpr = _componentFactoryReso.tokenExpr;\n\n        this._addProviderNode({\n          providerExpr: providerExpr,\n          depsExpr: depsExpr,\n          flags: flags,\n          tokenExpr: _tokenExpr,\n          queryMatchExprs: [],\n          sourceSpan: componentDirMeta.sourceSpan\n        });\n      }\n    }\n  }, {\n    key: \"_addProviderNode\",\n    value: function _addProviderNode(data) {\n      // providerDef(\n      //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], token:any,\n      //   value: any, deps: ([DepFlags, any] | any)[]): NodeDef;\n      this.nodes.push(function () {\n        return {\n          sourceSpan: data.sourceSpan,\n          nodeFlags: data.flags,\n          nodeDef: importExpr(Identifiers$1.providerDef).callFn([literal(data.flags), data.queryMatchExprs.length ? literalArr(data.queryMatchExprs) : NULL_EXPR, data.tokenExpr, data.providerExpr, data.depsExpr])\n        };\n      });\n    }\n  }, {\n    key: \"_visitProviderOrDirective\",\n    value: function _visitProviderOrDirective(providerAst, queryMatches) {\n      var flags = 0\n      /* None */\n      ;\n      var queryMatchExprs = [];\n      queryMatches.forEach(function (match) {\n        if (tokenReference(match.value) === tokenReference(providerAst.token)) {\n          queryMatchExprs.push(literalArr([literal(match.queryId), literal(4\n          /* Provider */\n          )]));\n        }\n      });\n\n      var _providerDef = providerDef(this.outputCtx, providerAst),\n          providerExpr = _providerDef.providerExpr,\n          depsExpr = _providerDef.depsExpr,\n          providerFlags = _providerDef.flags,\n          tokenExpr = _providerDef.tokenExpr;\n\n      return {\n        flags: flags | providerFlags,\n        queryMatchExprs: queryMatchExprs,\n        providerExpr: providerExpr,\n        depsExpr: depsExpr,\n        tokenExpr: tokenExpr,\n        sourceSpan: providerAst.sourceSpan\n      };\n    }\n  }, {\n    key: \"getLocal\",\n    value: function getLocal(name) {\n      if (name == EventHandlerVars.event.name) {\n        return EventHandlerVars.event;\n      }\n\n      var currViewExpr = VIEW_VAR;\n\n      for (var currBuilder = this; currBuilder; currBuilder = currBuilder.parent, currViewExpr = currViewExpr.prop('parent').cast(DYNAMIC_TYPE)) {\n        // check references\n        var refNodeIndex = currBuilder.refNodeIndices[name];\n\n        if (refNodeIndex != null) {\n          return importExpr(Identifiers$1.nodeValue).callFn([currViewExpr, literal(refNodeIndex)]);\n        } // check variables\n\n\n        var varAst = currBuilder.variables.find(function (varAst) {\n          return varAst.name === name;\n        });\n\n        if (varAst) {\n          var varValue = varAst.value || IMPLICIT_TEMPLATE_VAR;\n          return currViewExpr.prop('context').prop(varValue);\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"notifyImplicitReceiverUse\",\n    value: function notifyImplicitReceiverUse() {// Not needed in ViewEngine as ViewEngine walks through the generated\n      // expressions to figure out if the implicit receiver is used and needs\n      // to be generated as part of the pre-update statements.\n    }\n  }, {\n    key: \"maybeRestoreView\",\n    value: function maybeRestoreView() {// Not necessary in ViewEngine, because view restoration is an Ivy concept.\n    }\n  }, {\n    key: \"_createLiteralArrayConverter\",\n    value: function _createLiteralArrayConverter(sourceSpan, argCount) {\n      if (argCount === 0) {\n        var valueExpr = importExpr(Identifiers$1.EMPTY_ARRAY);\n        return function () {\n          return valueExpr;\n        };\n      }\n\n      var checkIndex = this.nodes.length;\n      this.nodes.push(function () {\n        return {\n          sourceSpan: sourceSpan,\n          nodeFlags: 32\n          /* TypePureArray */\n          ,\n          nodeDef: importExpr(Identifiers$1.pureArrayDef).callFn([literal(checkIndex), literal(argCount)])\n        };\n      });\n      return function (args) {\n        return callCheckStmt(checkIndex, args);\n      };\n    }\n  }, {\n    key: \"_createLiteralMapConverter\",\n    value: function _createLiteralMapConverter(sourceSpan, keys) {\n      if (keys.length === 0) {\n        var valueExpr = importExpr(Identifiers$1.EMPTY_MAP);\n        return function () {\n          return valueExpr;\n        };\n      }\n\n      var map = literalMap(keys.map(function (e, i) {\n        return Object.assign(Object.assign({}, e), {\n          value: literal(i)\n        });\n      }));\n      var checkIndex = this.nodes.length;\n      this.nodes.push(function () {\n        return {\n          sourceSpan: sourceSpan,\n          nodeFlags: 64\n          /* TypePureObject */\n          ,\n          nodeDef: importExpr(Identifiers$1.pureObjectDef).callFn([literal(checkIndex), map])\n        };\n      });\n      return function (args) {\n        return callCheckStmt(checkIndex, args);\n      };\n    }\n  }, {\n    key: \"_createPipeConverter\",\n    value: function _createPipeConverter(expression, name, argCount) {\n      var pipe = this.usedPipes.find(function (pipeSummary) {\n        return pipeSummary.name === name;\n      });\n\n      if (pipe.pure) {\n        var checkIndex = this.nodes.length;\n        this.nodes.push(function () {\n          return {\n            sourceSpan: expression.sourceSpan,\n            nodeFlags: 128\n            /* TypePurePipe */\n            ,\n            nodeDef: importExpr(Identifiers$1.purePipeDef).callFn([literal(checkIndex), literal(argCount)])\n          };\n        }); // find underlying pipe in the component view\n\n        var compViewExpr = VIEW_VAR;\n        var compBuilder = this;\n\n        while (compBuilder.parent) {\n          compBuilder = compBuilder.parent;\n          compViewExpr = compViewExpr.prop('parent').cast(DYNAMIC_TYPE);\n        }\n\n        var pipeNodeIndex = compBuilder.purePipeNodeIndices[name];\n        var pipeValueExpr = importExpr(Identifiers$1.nodeValue).callFn([compViewExpr, literal(pipeNodeIndex)]);\n        return function (args) {\n          return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, callCheckStmt(checkIndex, [pipeValueExpr].concat(args)));\n        };\n      } else {\n        var nodeIndex = this._createPipe(expression.sourceSpan, pipe);\n\n        var nodeValueExpr = importExpr(Identifiers$1.nodeValue).callFn([VIEW_VAR, literal(nodeIndex)]);\n        return function (args) {\n          return callUnwrapValue(expression.nodeIndex, expression.bindingIndex, nodeValueExpr.callMethod('transform', args));\n        };\n      }\n    }\n  }, {\n    key: \"_createPipe\",\n    value: function _createPipe(sourceSpan, pipe) {\n      var _this252 = this;\n\n      var nodeIndex = this.nodes.length;\n      var flags = 0\n      /* None */\n      ;\n      pipe.type.lifecycleHooks.forEach(function (lifecycleHook) {\n        // for pipes, we only support ngOnDestroy\n        if (lifecycleHook === LifecycleHooks.OnDestroy) {\n          flags |= lifecycleHookToNodeFlag(lifecycleHook);\n        }\n      });\n      var depExprs = pipe.type.diDeps.map(function (diDep) {\n        return depDef(_this252.outputCtx, diDep);\n      }); // function pipeDef(\n      //   flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef\n\n      this.nodes.push(function () {\n        return {\n          sourceSpan: sourceSpan,\n          nodeFlags: 16\n          /* TypePipe */\n          ,\n          nodeDef: importExpr(Identifiers$1.pipeDef).callFn([literal(flags), _this252.outputCtx.importExpr(pipe.type.reference), literalArr(depExprs)])\n        };\n      });\n      return nodeIndex;\n    }\n    /**\r\n     * For the AST in `UpdateExpression.value`:\r\n     * - create nodes for pipes, literal arrays and, literal maps,\r\n     * - update the AST to replace pipes, literal arrays and, literal maps with calls to check fn.\r\n     *\r\n     * WARNING: This might create new nodeDefs (for pipes and literal arrays and literal maps)!\r\n     */\n\n  }, {\n    key: \"_preprocessUpdateExpression\",\n    value: function _preprocessUpdateExpression(expression) {\n      var _this253 = this;\n\n      return {\n        nodeIndex: expression.nodeIndex,\n        bindingIndex: expression.bindingIndex,\n        sourceSpan: expression.sourceSpan,\n        context: expression.context,\n        value: convertPropertyBindingBuiltins({\n          createLiteralArrayConverter: function createLiteralArrayConverter(argCount) {\n            return _this253._createLiteralArrayConverter(expression.sourceSpan, argCount);\n          },\n          createLiteralMapConverter: function createLiteralMapConverter(keys) {\n            return _this253._createLiteralMapConverter(expression.sourceSpan, keys);\n          },\n          createPipeConverter: function createPipeConverter(name, argCount) {\n            return _this253._createPipeConverter(expression, name, argCount);\n          }\n        }, expression.value)\n      };\n    }\n  }, {\n    key: \"_createNodeExpressions\",\n    value: function _createNodeExpressions() {\n      var self = this;\n      var updateBindingCount = 0;\n      var updateRendererStmts = [];\n      var updateDirectivesStmts = [];\n      var nodeDefExprs = this.nodes.map(function (factory, nodeIndex) {\n        var _factory = factory(),\n            nodeDef = _factory.nodeDef,\n            nodeFlags = _factory.nodeFlags,\n            updateDirectives = _factory.updateDirectives,\n            updateRenderer = _factory.updateRenderer,\n            sourceSpan = _factory.sourceSpan;\n\n        if (updateRenderer) {\n          updateRendererStmts.push.apply(updateRendererStmts, _toConsumableArray(createUpdateStatements(nodeIndex, sourceSpan, updateRenderer, false)));\n        }\n\n        if (updateDirectives) {\n          updateDirectivesStmts.push.apply(updateDirectivesStmts, _toConsumableArray(createUpdateStatements(nodeIndex, sourceSpan, updateDirectives, (nodeFlags & (262144\n          /* DoCheck */\n          | 65536\n          /* OnInit */\n          )) > 0)));\n        } // We use a comma expression to call the log function before\n        // the nodeDef function, but still use the result of the nodeDef function\n        // as the value.\n        // Note: We only add the logger to elements / text nodes,\n        // so we don't generate too much code.\n\n\n        var logWithNodeDef = nodeFlags & 3\n        /* CatRenderNode */\n        ? new CommaExpr([LOG_VAR$1.callFn([]).callFn([]), nodeDef]) : nodeDef;\n        return applySourceSpanToExpressionIfNeeded(logWithNodeDef, sourceSpan);\n      });\n      return {\n        updateRendererStmts: updateRendererStmts,\n        updateDirectivesStmts: updateDirectivesStmts,\n        nodeDefExprs: nodeDefExprs\n      };\n\n      function createUpdateStatements(nodeIndex, sourceSpan, expressions, allowEmptyExprs) {\n        var updateStmts = [];\n        var exprs = expressions.map(function (_ref39) {\n          var sourceSpan = _ref39.sourceSpan,\n              context = _ref39.context,\n              value = _ref39.value;\n          var bindingId = \"\".concat(updateBindingCount++);\n          var nameResolver = context === COMP_VAR ? self : null;\n\n          var _convertPropertyBindi3 = _convertPropertyBinding(nameResolver, context, value, bindingId, BindingForm.General),\n              stmts = _convertPropertyBindi3.stmts,\n              currValExpr = _convertPropertyBindi3.currValExpr;\n\n          updateStmts.push.apply(updateStmts, _toConsumableArray(stmts.map(function (stmt) {\n            return applySourceSpanToStatementIfNeeded(stmt, sourceSpan);\n          })));\n          return applySourceSpanToExpressionIfNeeded(currValExpr, sourceSpan);\n        });\n\n        if (expressions.length || allowEmptyExprs) {\n          updateStmts.push(applySourceSpanToStatementIfNeeded(callCheckStmt(nodeIndex, exprs).toStmt(), sourceSpan));\n        }\n\n        return updateStmts;\n      }\n    }\n  }, {\n    key: \"_createElementHandleEventFn\",\n    value: function _createElementHandleEventFn(nodeIndex, handlers) {\n      var _this254 = this;\n\n      var handleEventStmts = [];\n      var handleEventBindingCount = 0;\n      handlers.forEach(function (_ref40) {\n        var context = _ref40.context,\n            eventAst = _ref40.eventAst,\n            dirAst = _ref40.dirAst;\n        var bindingId = \"\".concat(handleEventBindingCount++);\n        var nameResolver = context === COMP_VAR ? _this254 : null;\n\n        var _convertActionBinding2 = convertActionBinding(nameResolver, context, eventAst.handler, bindingId),\n            stmts = _convertActionBinding2.stmts,\n            allowDefault = _convertActionBinding2.allowDefault;\n\n        var trueStmts = stmts;\n\n        if (allowDefault) {\n          trueStmts.push(ALLOW_DEFAULT_VAR.set(allowDefault.and(ALLOW_DEFAULT_VAR)).toStmt());\n        }\n\n        var _elementEventNameAndT3 = elementEventNameAndTarget(eventAst, dirAst),\n            eventTarget = _elementEventNameAndT3.target,\n            eventName = _elementEventNameAndT3.name;\n\n        var fullEventName = elementEventFullName(eventTarget, eventName);\n        handleEventStmts.push(applySourceSpanToStatementIfNeeded(new IfStmt(literal(fullEventName).identical(EVENT_NAME_VAR), trueStmts), eventAst.sourceSpan));\n      });\n      var handleEventFn;\n\n      if (handleEventStmts.length > 0) {\n        var preStmts = [ALLOW_DEFAULT_VAR.set(literal(true)).toDeclStmt(BOOL_TYPE)];\n\n        if (!this.component.isHost && findReadVarNames(handleEventStmts).has(COMP_VAR.name)) {\n          preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\n        }\n\n        handleEventFn = fn([new FnParam(VIEW_VAR.name, INFERRED_TYPE), new FnParam(EVENT_NAME_VAR.name, INFERRED_TYPE), new FnParam(EventHandlerVars.event.name, INFERRED_TYPE)], [].concat(preStmts, handleEventStmts, [new ReturnStatement(ALLOW_DEFAULT_VAR)]), INFERRED_TYPE);\n      } else {\n        handleEventFn = NULL_EXPR;\n      }\n\n      return handleEventFn;\n    }\n  }, {\n    key: \"visitDirective\",\n    value: function visitDirective(ast, context) {}\n  }, {\n    key: \"visitDirectiveProperty\",\n    value: function visitDirectiveProperty(ast, context) {}\n  }, {\n    key: \"visitReference\",\n    value: function visitReference(ast, context) {}\n  }, {\n    key: \"visitVariable\",\n    value: function visitVariable(ast, context) {}\n  }, {\n    key: \"visitEvent\",\n    value: function visitEvent(ast, context) {}\n  }, {\n    key: \"visitElementProperty\",\n    value: function visitElementProperty(ast, context) {}\n  }, {\n    key: \"visitAttr\",\n    value: function visitAttr(ast, context) {}\n  }]);\n\n  return ViewBuilder$1;\n}();\n\nfunction needsAdditionalRootNode(astNodes) {\n  var lastAstNode = astNodes[astNodes.length - 1];\n\n  if (lastAstNode instanceof EmbeddedTemplateAst) {\n    return lastAstNode.hasViewContainer;\n  }\n\n  if (lastAstNode instanceof ElementAst) {\n    if (isNgContainer(lastAstNode.name) && lastAstNode.children.length) {\n      return needsAdditionalRootNode(lastAstNode.children);\n    }\n\n    return lastAstNode.hasViewContainer;\n  }\n\n  return lastAstNode instanceof NgContentAst;\n}\n\nfunction elementBindingDef(inputAst, dirAst) {\n  var inputType = inputAst.type;\n\n  switch (inputType) {\n    case 1\n    /* Attribute */\n    :\n      return literalArr([literal(1\n      /* TypeElementAttribute */\n      ), literal(inputAst.name), literal(inputAst.securityContext)]);\n\n    case 0\n    /* Property */\n    :\n      return literalArr([literal(8\n      /* TypeProperty */\n      ), literal(inputAst.name), literal(inputAst.securityContext)]);\n\n    case 4\n    /* Animation */\n    :\n      var bindingType = 8\n      /* TypeProperty */\n      | (dirAst && dirAst.directive.isComponent ? 32\n      /* SyntheticHostProperty */\n      : 16\n      /* SyntheticProperty */\n      );\n      return literalArr([literal(bindingType), literal('@' + inputAst.name), literal(inputAst.securityContext)]);\n\n    case 2\n    /* Class */\n    :\n      return literalArr([literal(2\n      /* TypeElementClass */\n      ), literal(inputAst.name), NULL_EXPR]);\n\n    case 3\n    /* Style */\n    :\n      return literalArr([literal(4\n      /* TypeElementStyle */\n      ), literal(inputAst.name), literal(inputAst.unit)]);\n\n    default:\n      // This default case is not needed by TypeScript compiler, as the switch is exhaustive.\n      // However Closure Compiler does not understand that and reports an error in typed mode.\n      // The `throw new Error` below works around the problem, and the unexpected: never variable\n      // makes sure tsc still checks this code is unreachable.\n      var unexpected = inputType;\n      throw new Error(\"unexpected \".concat(unexpected));\n  }\n}\n\nfunction fixedAttrsDef(elementAst) {\n  var mapResult = Object.create(null);\n  elementAst.attrs.forEach(function (attrAst) {\n    mapResult[attrAst.name] = attrAst.value;\n  });\n  elementAst.directives.forEach(function (dirAst) {\n    Object.keys(dirAst.directive.hostAttributes).forEach(function (name) {\n      var value = dirAst.directive.hostAttributes[name];\n      var prevValue = mapResult[name];\n      mapResult[name] = prevValue != null ? mergeAttributeValue(name, prevValue, value) : value;\n    });\n  }); // Note: We need to sort to get a defined output order\n  // for tests and for caching generated artifacts...\n\n  return literalArr(Object.keys(mapResult).sort().map(function (attrName) {\n    return literalArr([literal(attrName), literal(mapResult[attrName])]);\n  }));\n}\n\nfunction mergeAttributeValue(attrName, attrValue1, attrValue2) {\n  if (attrName == CLASS_ATTR$1 || attrName == STYLE_ATTR) {\n    return \"\".concat(attrValue1, \" \").concat(attrValue2);\n  } else {\n    return attrValue2;\n  }\n}\n\nfunction callCheckStmt(nodeIndex, exprs) {\n  if (exprs.length > 10) {\n    return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(1\n    /* Dynamic */\n    ), literalArr(exprs)]);\n  } else {\n    return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(0\n    /* Inline */\n    )].concat(_toConsumableArray(exprs)));\n  }\n}\n\nfunction callUnwrapValue(nodeIndex, bindingIdx, expr) {\n  return importExpr(Identifiers$1.unwrapValue).callFn([VIEW_VAR, literal(nodeIndex), literal(bindingIdx), expr]);\n}\n\nfunction elementEventNameAndTarget(eventAst, dirAst) {\n  if (eventAst.isAnimation) {\n    return {\n      name: \"@\".concat(eventAst.name, \".\").concat(eventAst.phase),\n      target: dirAst && dirAst.directive.isComponent ? 'component' : null\n    };\n  } else {\n    return eventAst;\n  }\n}\n\nfunction calcQueryFlags(query) {\n  var flags = 0\n  /* None */\n  ; // Note: We only make queries static that query for a single item and the user specifically\n  // set the to be static. This is because of backwards compatibility with the old view compiler...\n\n  if (query.first && query.static) {\n    flags |= 268435456\n    /* StaticQuery */\n    ;\n  } else {\n    flags |= 536870912\n    /* DynamicQuery */\n    ;\n  }\n\n  if (query.emitDistinctChangesOnly) {\n    flags |= -2147483648\n    /* EmitDistinctChangesOnly */\n    ;\n  }\n\n  return flags;\n}\n\nfunction elementEventFullName(target, name) {\n  return target ? \"\".concat(target, \":\").concat(name) : name;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * A container for message extracted from the templates.\r\n */\n\n\nvar MessageBundle = /*#__PURE__*/function () {\n  function MessageBundle(_htmlParser, _implicitTags, _implicitAttrs) {\n    var _locale = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    _classCallCheck(this, MessageBundle);\n\n    this._htmlParser = _htmlParser;\n    this._implicitTags = _implicitTags;\n    this._implicitAttrs = _implicitAttrs;\n    this._locale = _locale;\n    this._messages = [];\n  }\n\n  _createClass(MessageBundle, [{\n    key: \"updateFromTemplate\",\n    value: function updateFromTemplate(html, url, interpolationConfig) {\n      var _this$_messages;\n\n      var htmlParserResult = this._htmlParser.parse(html, url, {\n        tokenizeExpansionForms: true,\n        interpolationConfig: interpolationConfig\n      });\n\n      if (htmlParserResult.errors.length) {\n        return htmlParserResult.errors;\n      }\n\n      var i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);\n\n      if (i18nParserResult.errors.length) {\n        return i18nParserResult.errors;\n      }\n\n      (_this$_messages = this._messages).push.apply(_this$_messages, _toConsumableArray(i18nParserResult.messages));\n\n      return [];\n    } // Return the message in the internal format\n    // The public (serialized) format might be different, see the `write` method.\n\n  }, {\n    key: \"getMessages\",\n    value: function getMessages() {\n      return this._messages;\n    }\n  }, {\n    key: \"write\",\n    value: function write(serializer, filterSources) {\n      var messages = {};\n      var mapperVisitor = new MapPlaceholderNames(); // Deduplicate messages based on their ID\n\n      this._messages.forEach(function (message) {\n        var id = serializer.digest(message);\n\n        if (!messages.hasOwnProperty(id)) {\n          messages[id] = message;\n        } else {\n          var _messages$id$sources;\n\n          (_messages$id$sources = messages[id].sources).push.apply(_messages$id$sources, _toConsumableArray(message.sources));\n        }\n      }); // Transform placeholder names using the serializer mapping\n\n\n      var msgList = Object.keys(messages).map(function (id) {\n        var mapper = serializer.createNameMapper(messages[id]);\n        var src = messages[id];\n        var nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;\n        var transformedMessage = new Message(nodes, {}, {}, src.meaning, src.description, id);\n        transformedMessage.sources = src.sources;\n\n        if (filterSources) {\n          transformedMessage.sources.forEach(function (source) {\n            return source.filePath = filterSources(source.filePath);\n          });\n        }\n\n        return transformedMessage;\n      });\n      return serializer.write(msgList, this._locale);\n    }\n  }]);\n\n  return MessageBundle;\n}(); // Transform an i18n AST by renaming the placeholder nodes with the given mapper\n\n\nvar MapPlaceholderNames = /*#__PURE__*/function (_CloneVisitor) {\n  _inherits(MapPlaceholderNames, _CloneVisitor);\n\n  var _super107 = _createSuper(MapPlaceholderNames);\n\n  function MapPlaceholderNames() {\n    _classCallCheck(this, MapPlaceholderNames);\n\n    return _super107.apply(this, arguments);\n  }\n\n  _createClass(MapPlaceholderNames, [{\n    key: \"convert\",\n    value: function convert(nodes, mapper) {\n      var _this255 = this;\n\n      return mapper ? nodes.map(function (n) {\n        return n.visit(_this255, mapper);\n      }) : nodes;\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph, mapper) {\n      var _this256 = this;\n\n      var startName = mapper.toPublicName(ph.startName);\n      var closeName = ph.closeName ? mapper.toPublicName(ph.closeName) : ph.closeName;\n      var children = ph.children.map(function (n) {\n        return n.visit(_this256, mapper);\n      });\n      return new TagPlaceholder(ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph, mapper) {\n      return new Placeholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n    }\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, mapper) {\n      return new IcuPlaceholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\n    }\n  }]);\n\n  return MapPlaceholderNames;\n}(CloneVisitor);\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar GeneratedFile = /*#__PURE__*/function () {\n  function GeneratedFile(srcFileUrl, genFileUrl, sourceOrStmts) {\n    _classCallCheck(this, GeneratedFile);\n\n    this.srcFileUrl = srcFileUrl;\n    this.genFileUrl = genFileUrl;\n\n    if (typeof sourceOrStmts === 'string') {\n      this.source = sourceOrStmts;\n      this.stmts = null;\n    } else {\n      this.source = null;\n      this.stmts = sourceOrStmts;\n    }\n  }\n\n  _createClass(GeneratedFile, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(other) {\n      if (this.genFileUrl !== other.genFileUrl) {\n        return false;\n      }\n\n      if (this.source) {\n        return this.source === other.source;\n      }\n\n      if (other.stmts == null) {\n        return false;\n      } // Note: the constructor guarantees that if this.source is not filled,\n      // then this.stmts is.\n\n\n      return areAllEquivalent(this.stmts, other.stmts);\n    }\n  }]);\n\n  return GeneratedFile;\n}();\n\nfunction toTypeScript(file) {\n  var preamble = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n\n  if (!file.stmts) {\n    throw new Error(\"Illegal state: No stmts present on GeneratedFile \".concat(file.genFileUrl));\n  }\n\n  return new TypeScriptEmitter().emitStatements(file.genFileUrl, file.stmts, preamble);\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nfunction _listLazyRoutes(moduleMeta, reflector) {\n  var allLazyRoutes = [];\n\n  var _iterator26 = _createForOfIteratorHelper(moduleMeta.transitiveModule.providers),\n      _step26;\n\n  try {\n    for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n      var _step26$value = _step26.value,\n          provider = _step26$value.provider,\n          module = _step26$value.module;\n\n      if (tokenReference(provider.token) === reflector.ROUTES) {\n        var loadChildren = _collectLoadChildren(provider.useValue);\n\n        var _iterator27 = _createForOfIteratorHelper(loadChildren),\n            _step27;\n\n        try {\n          for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n            var route = _step27.value;\n            allLazyRoutes.push(parseLazyRoute(route, reflector, module.reference));\n          }\n        } catch (err) {\n          _iterator27.e(err);\n        } finally {\n          _iterator27.f();\n        }\n      }\n    }\n  } catch (err) {\n    _iterator26.e(err);\n  } finally {\n    _iterator26.f();\n  }\n\n  return allLazyRoutes;\n}\n\nfunction _collectLoadChildren(routes) {\n  var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  if (typeof routes === 'string') {\n    target.push(routes);\n  } else if (Array.isArray(routes)) {\n    var _iterator28 = _createForOfIteratorHelper(routes),\n        _step28;\n\n    try {\n      for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n        var route = _step28.value;\n\n        _collectLoadChildren(route, target);\n      }\n    } catch (err) {\n      _iterator28.e(err);\n    } finally {\n      _iterator28.f();\n    }\n  } else if (routes.loadChildren) {\n    _collectLoadChildren(routes.loadChildren, target);\n  } else if (routes.children) {\n    _collectLoadChildren(routes.children, target);\n  }\n\n  return target;\n}\n\nfunction parseLazyRoute(route, reflector, module) {\n  var _route$split = route.split('#'),\n      _route$split2 = _slicedToArray(_route$split, 2),\n      routePath = _route$split2[0],\n      routeName = _route$split2[1];\n\n  var referencedModule = reflector.resolveExternalReference({\n    moduleName: routePath,\n    name: routeName\n  }, module ? module.filePath : undefined);\n  return {\n    route: route,\n    module: module || referencedModule,\n    referencedModule: referencedModule\n  };\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar TS = /^(?!.*\\.d\\.ts$).*\\.ts$/;\n\nvar ResolvedStaticSymbol = function ResolvedStaticSymbol(symbol, metadata) {\n  _classCallCheck(this, ResolvedStaticSymbol);\n\n  this.symbol = symbol;\n  this.metadata = metadata;\n};\n\nvar SUPPORTED_SCHEMA_VERSION = 4;\n/**\r\n * This class is responsible for loading metadata per symbol,\r\n * and normalizing references between symbols.\r\n *\r\n * Internally, it only uses symbols without members,\r\n * and deduces the values for symbols with members based\r\n * on these symbols.\r\n */\n\nvar StaticSymbolResolver = /*#__PURE__*/function () {\n  function StaticSymbolResolver(host, staticSymbolCache, summaryResolver, errorRecorder) {\n    _classCallCheck(this, StaticSymbolResolver);\n\n    this.host = host;\n    this.staticSymbolCache = staticSymbolCache;\n    this.summaryResolver = summaryResolver;\n    this.errorRecorder = errorRecorder;\n    this.metadataCache = new Map(); // Note: this will only contain StaticSymbols without members!\n\n    this.resolvedSymbols = new Map(); // Note: this will only contain StaticSymbols without members!\n\n    this.importAs = new Map();\n    this.symbolResourcePaths = new Map();\n    this.symbolFromFile = new Map();\n    this.knownFileNameToModuleNames = new Map();\n  }\n\n  _createClass(StaticSymbolResolver, [{\n    key: \"resolveSymbol\",\n    value: function resolveSymbol(staticSymbol) {\n      if (staticSymbol.members.length > 0) {\n        return this._resolveSymbolMembers(staticSymbol);\n      } // Note: always ask for a summary first,\n      // as we might have read shallow metadata via a .d.ts file\n      // for the symbol.\n\n\n      var resultFromSummary = this._resolveSymbolFromSummary(staticSymbol);\n\n      if (resultFromSummary) {\n        return resultFromSummary;\n      }\n\n      var resultFromCache = this.resolvedSymbols.get(staticSymbol);\n\n      if (resultFromCache) {\n        return resultFromCache;\n      } // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n      // have summaries, only .d.ts files. So we always need to check both, the summary\n      // and metadata.\n\n\n      this._createSymbolsOf(staticSymbol.filePath);\n\n      return this.resolvedSymbols.get(staticSymbol);\n    }\n    /**\r\n     * getImportAs produces a symbol that can be used to import the given symbol.\r\n     * The import might be different than the symbol if the symbol is exported from\r\n     * a library with a summary; in which case we want to import the symbol from the\r\n     * ngfactory re-export instead of directly to avoid introducing a direct dependency\r\n     * on an otherwise indirect dependency.\r\n     *\r\n     * @param staticSymbol the symbol for which to generate a import symbol\r\n     */\n\n  }, {\n    key: \"getImportAs\",\n    value: function getImportAs(staticSymbol) {\n      var useSummaries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (staticSymbol.members.length) {\n        var baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);\n        var baseImportAs = this.getImportAs(baseSymbol, useSummaries);\n        return baseImportAs ? this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) : null;\n      }\n\n      var summarizedFileName = stripSummaryForJitFileSuffix(staticSymbol.filePath);\n\n      if (summarizedFileName !== staticSymbol.filePath) {\n        var summarizedName = stripSummaryForJitNameSuffix(staticSymbol.name);\n\n        var _baseSymbol = this.getStaticSymbol(summarizedFileName, summarizedName, staticSymbol.members);\n\n        var _baseImportAs = this.getImportAs(_baseSymbol, useSummaries);\n\n        return _baseImportAs ? this.getStaticSymbol(summaryForJitFileName(_baseImportAs.filePath), summaryForJitName(_baseImportAs.name), _baseSymbol.members) : null;\n      }\n\n      var result = useSummaries && this.summaryResolver.getImportAs(staticSymbol) || null;\n\n      if (!result) {\n        result = this.importAs.get(staticSymbol);\n      }\n\n      return result;\n    }\n    /**\r\n     * getResourcePath produces the path to the original location of the symbol and should\r\n     * be used to determine the relative location of resource references recorded in\r\n     * symbol metadata.\r\n     */\n\n  }, {\n    key: \"getResourcePath\",\n    value: function getResourcePath(staticSymbol) {\n      return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;\n    }\n    /**\r\n     * getTypeArity returns the number of generic type parameters the given symbol\r\n     * has. If the symbol is not a type the result is null.\r\n     */\n\n  }, {\n    key: \"getTypeArity\",\n    value: function getTypeArity(staticSymbol) {\n      // If the file is a factory/ngsummary file, don't resolve the symbol as doing so would\n      // cause the metadata for an factory/ngsummary file to be loaded which doesn't exist.\n      // All references to generated classes must include the correct arity whenever\n      // generating code.\n      if (isGeneratedFile(staticSymbol.filePath)) {\n        return null;\n      }\n\n      var resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(staticSymbol));\n\n      while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n        resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(resolvedSymbol.metadata));\n      }\n\n      return resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity || null;\n    }\n  }, {\n    key: \"getKnownModuleName\",\n    value: function getKnownModuleName(filePath) {\n      return this.knownFileNameToModuleNames.get(filePath) || null;\n    }\n  }, {\n    key: \"recordImportAs\",\n    value: function recordImportAs(sourceSymbol, targetSymbol) {\n      sourceSymbol.assertNoMembers();\n      targetSymbol.assertNoMembers();\n      this.importAs.set(sourceSymbol, targetSymbol);\n    }\n  }, {\n    key: \"recordModuleNameForFileName\",\n    value: function recordModuleNameForFileName(fileName, moduleName) {\n      this.knownFileNameToModuleNames.set(fileName, moduleName);\n    }\n    /**\r\n     * Invalidate all information derived from the given file and return the\r\n     * static symbols contained in the file.\r\n     *\r\n     * @param fileName the file to invalidate\r\n     */\n\n  }, {\n    key: \"invalidateFile\",\n    value: function invalidateFile(fileName) {\n      this.metadataCache.delete(fileName);\n      var symbols = this.symbolFromFile.get(fileName);\n\n      if (!symbols) {\n        return [];\n      }\n\n      this.symbolFromFile.delete(fileName);\n\n      var _iterator29 = _createForOfIteratorHelper(symbols),\n          _step29;\n\n      try {\n        for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n          var symbol = _step29.value;\n          this.resolvedSymbols.delete(symbol);\n          this.importAs.delete(symbol);\n          this.symbolResourcePaths.delete(symbol);\n        }\n      } catch (err) {\n        _iterator29.e(err);\n      } finally {\n        _iterator29.f();\n      }\n\n      return symbols;\n    }\n    /** @internal */\n\n  }, {\n    key: \"ignoreErrorsFor\",\n    value: function ignoreErrorsFor(cb) {\n      var recorder = this.errorRecorder;\n\n      this.errorRecorder = function () {};\n\n      try {\n        return cb();\n      } finally {\n        this.errorRecorder = recorder;\n      }\n    }\n  }, {\n    key: \"_resolveSymbolMembers\",\n    value: function _resolveSymbolMembers(staticSymbol) {\n      var members = staticSymbol.members;\n      var baseResolvedSymbol = this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\n\n      if (!baseResolvedSymbol) {\n        return null;\n      }\n\n      var baseMetadata = unwrapResolvedMetadata(baseResolvedSymbol.metadata);\n\n      if (baseMetadata instanceof StaticSymbol) {\n        return new ResolvedStaticSymbol(staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\n      } else if (baseMetadata && baseMetadata.__symbolic === 'class') {\n        if (baseMetadata.statics && members.length === 1) {\n          return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\n        }\n      } else {\n        var value = baseMetadata;\n\n        for (var i = 0; i < members.length && value; i++) {\n          value = value[members[i]];\n        }\n\n        return new ResolvedStaticSymbol(staticSymbol, value);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_resolveSymbolFromSummary\",\n    value: function _resolveSymbolFromSummary(staticSymbol) {\n      var summary = this.summaryResolver.resolveSummary(staticSymbol);\n      return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\n    }\n    /**\r\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\r\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\r\n     *\r\n     * @param declarationFile the absolute path of the file where the symbol is declared\r\n     * @param name the name of the type.\r\n     * @param members a symbol for a static member of the named type\r\n     */\n\n  }, {\n    key: \"getStaticSymbol\",\n    value: function getStaticSymbol(declarationFile, name, members) {\n      return this.staticSymbolCache.get(declarationFile, name, members);\n    }\n    /**\r\n     * hasDecorators checks a file's metadata for the presence of decorators without evaluating the\r\n     * metadata.\r\n     *\r\n     * @param filePath the absolute path to examine for decorators.\r\n     * @returns true if any class in the file has a decorator.\r\n     */\n\n  }, {\n    key: \"hasDecorators\",\n    value: function hasDecorators(filePath) {\n      var metadata = this.getModuleMetadata(filePath);\n\n      if (metadata['metadata']) {\n        return Object.keys(metadata['metadata']).some(function (metadataKey) {\n          var entry = metadata['metadata'][metadataKey];\n          return entry && entry.__symbolic === 'class' && entry.decorators;\n        });\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getSymbolsOf\",\n    value: function getSymbolsOf(filePath) {\n      var summarySymbols = this.summaryResolver.getSymbolsOf(filePath);\n\n      if (summarySymbols) {\n        return summarySymbols;\n      } // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n      // have summaries, only .d.ts files, but `summaryResolver.isLibraryFile` returns true.\n\n\n      this._createSymbolsOf(filePath);\n\n      return this.symbolFromFile.get(filePath) || [];\n    }\n  }, {\n    key: \"_createSymbolsOf\",\n    value: function _createSymbolsOf(filePath) {\n      var _this257 = this;\n\n      if (this.symbolFromFile.has(filePath)) {\n        return;\n      }\n\n      var resolvedSymbols = [];\n      var metadata = this.getModuleMetadata(filePath);\n\n      if (metadata['importAs']) {\n        // Index bundle indices should use the importAs module name defined\n        // in the bundle.\n        this.knownFileNameToModuleNames.set(filePath, metadata['importAs']);\n      } // handle the symbols in one of the re-export location\n\n\n      if (metadata['exports']) {\n        var _iterator30 = _createForOfIteratorHelper(metadata['exports']),\n            _step30;\n\n        try {\n          var _loop3 = function _loop3() {\n            var moduleExport = _step30.value;\n\n            // handle the symbols in the list of explicitly re-exported symbols.\n            if (moduleExport.export) {\n              moduleExport.export.forEach(function (exportSymbol) {\n                var symbolName;\n\n                if (typeof exportSymbol === 'string') {\n                  symbolName = exportSymbol;\n                } else {\n                  symbolName = exportSymbol.as;\n                }\n\n                symbolName = unescapeIdentifier(symbolName);\n                var symName = symbolName;\n\n                if (typeof exportSymbol !== 'string') {\n                  symName = unescapeIdentifier(exportSymbol.name);\n                }\n\n                var resolvedModule = _this257.resolveModule(moduleExport.from, filePath);\n\n                if (resolvedModule) {\n                  var targetSymbol = _this257.getStaticSymbol(resolvedModule, symName);\n\n                  var sourceSymbol = _this257.getStaticSymbol(filePath, symbolName);\n\n                  resolvedSymbols.push(_this257.createExport(sourceSymbol, targetSymbol));\n                }\n              });\n            } else {\n              // Handle the symbols loaded by 'export *' directives.\n              var resolvedModule = _this257.resolveModule(moduleExport.from, filePath);\n\n              if (resolvedModule && resolvedModule !== filePath) {\n                var nestedExports = _this257.getSymbolsOf(resolvedModule);\n\n                nestedExports.forEach(function (targetSymbol) {\n                  var sourceSymbol = _this257.getStaticSymbol(filePath, targetSymbol.name);\n\n                  resolvedSymbols.push(_this257.createExport(sourceSymbol, targetSymbol));\n                });\n              }\n            }\n          };\n\n          for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n            _loop3();\n          }\n        } catch (err) {\n          _iterator30.e(err);\n        } finally {\n          _iterator30.f();\n        }\n      } // handle the actual metadata. Has to be after the exports\n      // as there might be collisions in the names, and we want the symbols\n      // of the current module to win ofter reexports.\n\n\n      if (metadata['metadata']) {\n        // handle direct declarations of the symbol\n        var topLevelSymbolNames = new Set(Object.keys(metadata['metadata']).map(unescapeIdentifier));\n        var origins = metadata['origins'] || {};\n        Object.keys(metadata['metadata']).forEach(function (metadataKey) {\n          var symbolMeta = metadata['metadata'][metadataKey];\n          var name = unescapeIdentifier(metadataKey);\n\n          var symbol = _this257.getStaticSymbol(filePath, name);\n\n          var origin = origins.hasOwnProperty(metadataKey) && origins[metadataKey];\n\n          if (origin) {\n            // If the symbol is from a bundled index, use the declaration location of the\n            // symbol so relative references (such as './my.html') will be calculated\n            // correctly.\n            var originFilePath = _this257.resolveModule(origin, filePath);\n\n            if (!originFilePath) {\n              _this257.reportError(new Error(\"Couldn't resolve original symbol for \".concat(origin, \" from \").concat(_this257.host.getOutputName(filePath))));\n            } else {\n              _this257.symbolResourcePaths.set(symbol, originFilePath);\n            }\n          }\n\n          resolvedSymbols.push(_this257.createResolvedSymbol(symbol, filePath, topLevelSymbolNames, symbolMeta));\n        });\n      }\n\n      var uniqueSymbols = new Set();\n\n      for (var _i11 = 0, _resolvedSymbols = resolvedSymbols; _i11 < _resolvedSymbols.length; _i11++) {\n        var resolvedSymbol = _resolvedSymbols[_i11];\n        this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol);\n        uniqueSymbols.add(resolvedSymbol.symbol);\n      }\n\n      this.symbolFromFile.set(filePath, Array.from(uniqueSymbols));\n    }\n  }, {\n    key: \"createResolvedSymbol\",\n    value: function createResolvedSymbol(sourceSymbol, topLevelPath, topLevelSymbolNames, metadata) {\n      var _this258 = this;\n\n      // For classes that don't have Angular summaries / metadata,\n      // we only keep their arity, but nothing else\n      // (e.g. their constructor parameters).\n      // We do this to prevent introducing deep imports\n      // as we didn't generate .ngfactory.ts files with proper reexports.\n      var isTsFile = TS.test(sourceSymbol.filePath);\n\n      if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && !isTsFile && metadata && metadata['__symbolic'] === 'class') {\n        var _transformedMeta = {\n          __symbolic: 'class',\n          arity: metadata.arity\n        };\n        return new ResolvedStaticSymbol(sourceSymbol, _transformedMeta);\n      }\n\n      var _originalFileMemo;\n\n      var getOriginalName = function getOriginalName() {\n        if (!_originalFileMemo) {\n          // Guess what the original file name is from the reference. If it has a `.d.ts` extension\n          // replace it with `.ts`. If it already has `.ts` just leave it in place. If it doesn't have\n          // .ts or .d.ts, append `.ts'. Also, if it is in `node_modules`, trim the `node_module`\n          // location as it is not important to finding the file.\n          _originalFileMemo = _this258.host.getOutputName(topLevelPath.replace(/((\\.ts)|(\\.d\\.ts)|)$/, '.ts').replace(/^.*node_modules[/\\\\]/, ''));\n        }\n\n        return _originalFileMemo;\n      };\n\n      var self = this;\n\n      var ReferenceTransformer = /*#__PURE__*/function (_ValueTransformer2) {\n        _inherits(ReferenceTransformer, _ValueTransformer2);\n\n        var _super108 = _createSuper(ReferenceTransformer);\n\n        function ReferenceTransformer() {\n          _classCallCheck(this, ReferenceTransformer);\n\n          return _super108.apply(this, arguments);\n        }\n\n        _createClass(ReferenceTransformer, [{\n          key: \"visitStringMap\",\n          value: function visitStringMap(map, functionParams) {\n            var symbolic = map['__symbolic'];\n\n            if (symbolic === 'function') {\n              var oldLen = functionParams.length;\n              functionParams.push.apply(functionParams, _toConsumableArray(map['parameters'] || []));\n\n              var result = _get(_getPrototypeOf(ReferenceTransformer.prototype), \"visitStringMap\", this).call(this, map, functionParams);\n\n              functionParams.length = oldLen;\n              return result;\n            } else if (symbolic === 'reference') {\n              var module = map['module'];\n              var name = map['name'] ? unescapeIdentifier(map['name']) : map['name'];\n\n              if (!name) {\n                return null;\n              }\n\n              var filePath;\n\n              if (module) {\n                filePath = self.resolveModule(module, sourceSymbol.filePath);\n\n                if (!filePath) {\n                  return {\n                    __symbolic: 'error',\n                    message: \"Could not resolve \".concat(module, \" relative to \").concat(self.host.getMetadataFor(sourceSymbol.filePath), \".\"),\n                    line: map['line'],\n                    character: map['character'],\n                    fileName: getOriginalName()\n                  };\n                }\n\n                return {\n                  __symbolic: 'resolved',\n                  symbol: self.getStaticSymbol(filePath, name),\n                  line: map['line'],\n                  character: map['character'],\n                  fileName: getOriginalName()\n                };\n              } else if (functionParams.indexOf(name) >= 0) {\n                // reference to a function parameter\n                return {\n                  __symbolic: 'reference',\n                  name: name\n                };\n              } else {\n                if (topLevelSymbolNames.has(name)) {\n                  return self.getStaticSymbol(topLevelPath, name);\n                } // ambient value\n\n\n                null;\n              }\n            } else if (symbolic === 'error') {\n              return Object.assign(Object.assign({}, map), {\n                fileName: getOriginalName()\n              });\n            } else {\n              return _get(_getPrototypeOf(ReferenceTransformer.prototype), \"visitStringMap\", this).call(this, map, functionParams);\n            }\n          }\n        }]);\n\n        return ReferenceTransformer;\n      }(ValueTransformer);\n\n      var transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);\n      var unwrappedTransformedMeta = unwrapResolvedMetadata(transformedMeta);\n\n      if (unwrappedTransformedMeta instanceof StaticSymbol) {\n        return this.createExport(sourceSymbol, unwrappedTransformedMeta);\n      }\n\n      return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n    }\n  }, {\n    key: \"createExport\",\n    value: function createExport(sourceSymbol, targetSymbol) {\n      sourceSymbol.assertNoMembers();\n      targetSymbol.assertNoMembers();\n\n      if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && this.summaryResolver.isLibraryFile(targetSymbol.filePath)) {\n        // This case is for an ng library importing symbols from a plain ts library\n        // transitively.\n        // Note: We rely on the fact that we discover symbols in the direction\n        // from source files to library files\n        this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);\n      }\n\n      return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);\n    }\n  }, {\n    key: \"reportError\",\n    value: function reportError(error, context, path) {\n      if (this.errorRecorder) {\n        this.errorRecorder(error, context && context.filePath || path);\n      } else {\n        throw error;\n      }\n    }\n    /**\r\n     * @param module an absolute path to a module file.\r\n     */\n\n  }, {\n    key: \"getModuleMetadata\",\n    value: function getModuleMetadata(module) {\n      var moduleMetadata = this.metadataCache.get(module);\n\n      if (!moduleMetadata) {\n        var moduleMetadatas = this.host.getMetadataFor(module);\n\n        if (moduleMetadatas) {\n          var maxVersion = -1;\n          moduleMetadatas.forEach(function (md) {\n            if (md && md['version'] > maxVersion) {\n              maxVersion = md['version'];\n              moduleMetadata = md;\n            }\n          });\n        }\n\n        if (!moduleMetadata) {\n          moduleMetadata = {\n            __symbolic: 'module',\n            version: SUPPORTED_SCHEMA_VERSION,\n            module: module,\n            metadata: {}\n          };\n        }\n\n        if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\n          var errorMessage = moduleMetadata['version'] == 2 ? \"Unsupported metadata version \".concat(moduleMetadata['version'], \" for module \").concat(module, \". This module should be compiled with a newer version of ngc\") : \"Metadata version mismatch for module \".concat(this.host.getOutputName(module), \", found version \").concat(moduleMetadata['version'], \", expected \").concat(SUPPORTED_SCHEMA_VERSION);\n          this.reportError(new Error(errorMessage));\n        }\n\n        this.metadataCache.set(module, moduleMetadata);\n      }\n\n      return moduleMetadata;\n    }\n  }, {\n    key: \"getSymbolByModule\",\n    value: function getSymbolByModule(module, symbolName, containingFile) {\n      var filePath = this.resolveModule(module, containingFile);\n\n      if (!filePath) {\n        this.reportError(new Error(\"Could not resolve module \".concat(module).concat(containingFile ? ' relative to ' + this.host.getOutputName(containingFile) : '')));\n        return this.getStaticSymbol(\"ERROR:\".concat(module), symbolName);\n      }\n\n      return this.getStaticSymbol(filePath, symbolName);\n    }\n  }, {\n    key: \"resolveModule\",\n    value: function resolveModule(module, containingFile) {\n      try {\n        return this.host.moduleNameToFileName(module, containingFile);\n      } catch (e) {\n        console.error(\"Could not resolve module '\".concat(module, \"' relative to file \").concat(containingFile));\n        this.reportError(e, undefined, containingFile);\n      }\n\n      return null;\n    }\n  }]);\n\n  return StaticSymbolResolver;\n}(); // Remove extra underscore from escaped identifier.\n// See https://github.com/Microsoft/TypeScript/blob/master/src/compiler/utilities.ts\n\n\nfunction unescapeIdentifier(identifier) {\n  return identifier.startsWith('___') ? identifier.substr(1) : identifier;\n}\n\nfunction unwrapResolvedMetadata(metadata) {\n  if (metadata && metadata.__symbolic === 'resolved') {\n    return metadata.symbol;\n  }\n\n  return metadata;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nfunction serializeSummaries(srcFileName, forJitCtx, summaryResolver, symbolResolver, symbols, types) {\n  var createExternalSymbolReexports = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  var toJsonSerializer = new ToJsonSerializer(symbolResolver, summaryResolver, srcFileName); // for symbols, we use everything except for the class metadata itself\n  // (we keep the statics though), as the class metadata is contained in the\n  // CompileTypeSummary.\n\n  symbols.forEach(function (resolvedSymbol) {\n    return toJsonSerializer.addSummary({\n      symbol: resolvedSymbol.symbol,\n      metadata: resolvedSymbol.metadata\n    });\n  }); // Add type summaries.\n\n  types.forEach(function (_ref41) {\n    var summary = _ref41.summary,\n        metadata = _ref41.metadata;\n    toJsonSerializer.addSummary({\n      symbol: summary.type.reference,\n      metadata: undefined,\n      type: summary\n    });\n  });\n\n  var _toJsonSerializer$ser = toJsonSerializer.serialize(createExternalSymbolReexports),\n      json = _toJsonSerializer$ser.json,\n      exportAs = _toJsonSerializer$ser.exportAs;\n\n  if (forJitCtx) {\n    var forJitSerializer = new ForJitSerializer(forJitCtx, symbolResolver, summaryResolver);\n    types.forEach(function (_ref42) {\n      var summary = _ref42.summary,\n          metadata = _ref42.metadata;\n      forJitSerializer.addSourceType(summary, metadata);\n    });\n    toJsonSerializer.unprocessedSymbolSummariesBySymbol.forEach(function (summary) {\n      if (summaryResolver.isLibraryFile(summary.symbol.filePath) && summary.type) {\n        forJitSerializer.addLibType(summary.type);\n      }\n    });\n    forJitSerializer.serialize(exportAs);\n  }\n\n  return {\n    json: json,\n    exportAs: exportAs\n  };\n}\n\nfunction deserializeSummaries(symbolCache, summaryResolver, libraryFileName, json) {\n  var deserializer = new FromJsonDeserializer(symbolCache, summaryResolver);\n  return deserializer.deserialize(libraryFileName, json);\n}\n\nfunction createForJitStub(outputCtx, reference) {\n  return createSummaryForJitFunction(outputCtx, reference, NULL_EXPR);\n}\n\nfunction createSummaryForJitFunction(outputCtx, reference, value) {\n  var fnName = summaryForJitName(reference.name);\n  outputCtx.statements.push(fn([], [new ReturnStatement(value)], new ArrayType(DYNAMIC_TYPE)).toDeclStmt(fnName, [StmtModifier.Final, StmtModifier.Exported]));\n}\n\nvar ToJsonSerializer = /*#__PURE__*/function (_ValueTransformer3) {\n  _inherits(ToJsonSerializer, _ValueTransformer3);\n\n  var _super109 = _createSuper(ToJsonSerializer);\n\n  function ToJsonSerializer(symbolResolver, summaryResolver, srcFileName) {\n    var _this259;\n\n    _classCallCheck(this, ToJsonSerializer);\n\n    _this259 = _super109.call(this);\n    _this259.symbolResolver = symbolResolver;\n    _this259.summaryResolver = summaryResolver;\n    _this259.srcFileName = srcFileName; // Note: This only contains symbols without members.\n\n    _this259.symbols = [];\n    _this259.indexBySymbol = new Map();\n    _this259.reexportedBy = new Map(); // This now contains a `__symbol: number` in the place of\n    // StaticSymbols, but otherwise has the same shape as the original objects.\n\n    _this259.processedSummaryBySymbol = new Map();\n    _this259.processedSummaries = [];\n    _this259.unprocessedSymbolSummariesBySymbol = new Map();\n    _this259.moduleName = symbolResolver.getKnownModuleName(srcFileName);\n    return _this259;\n  }\n\n  _createClass(ToJsonSerializer, [{\n    key: \"addSummary\",\n    value: function addSummary(summary) {\n      var _this260 = this;\n\n      var unprocessedSummary = this.unprocessedSymbolSummariesBySymbol.get(summary.symbol);\n      var processedSummary = this.processedSummaryBySymbol.get(summary.symbol);\n\n      if (!unprocessedSummary) {\n        unprocessedSummary = {\n          symbol: summary.symbol,\n          metadata: undefined\n        };\n        this.unprocessedSymbolSummariesBySymbol.set(summary.symbol, unprocessedSummary);\n        processedSummary = {\n          symbol: this.processValue(summary.symbol, 0\n          /* None */\n          )\n        };\n        this.processedSummaries.push(processedSummary);\n        this.processedSummaryBySymbol.set(summary.symbol, processedSummary);\n      }\n\n      if (!unprocessedSummary.metadata && summary.metadata) {\n        var metadata = summary.metadata || {};\n\n        if (metadata.__symbolic === 'class') {\n          // For classes, we keep everything except their class decorators.\n          // We need to keep e.g. the ctor args, method names, method decorators\n          // so that the class can be extended in another compilation unit.\n          // We don't keep the class decorators as\n          // 1) they refer to data\n          //   that should not cause a rebuild of downstream compilation units\n          //   (e.g. inline templates of @Component, or @NgModule.declarations)\n          // 2) their data is already captured in TypeSummaries, e.g. DirectiveSummary.\n          var clone = {};\n          Object.keys(metadata).forEach(function (propName) {\n            if (propName !== 'decorators') {\n              clone[propName] = metadata[propName];\n            }\n          });\n          metadata = clone;\n        } else if (isCall(metadata)) {\n          if (!isFunctionCall(metadata) && !isMethodCallOnVariable(metadata)) {\n            // Don't store complex calls as we won't be able to simplify them anyways later on.\n            metadata = {\n              __symbolic: 'error',\n              message: 'Complex function calls are not supported.'\n            };\n          }\n        } // Note: We need to keep storing ctor calls for e.g.\n        // `export const x = new InjectionToken(...)`\n\n\n        unprocessedSummary.metadata = metadata;\n        processedSummary.metadata = this.processValue(metadata, 1\n        /* ResolveValue */\n        );\n\n        if (metadata instanceof StaticSymbol && this.summaryResolver.isLibraryFile(metadata.filePath)) {\n          var declarationSymbol = this.symbols[this.indexBySymbol.get(metadata)];\n\n          if (!isLoweredSymbol(declarationSymbol.name)) {\n            // Note: symbols that were introduced during codegen in the user file can have a reexport\n            // if a user used `export *`. However, we can't rely on this as tsickle will change\n            // `export *` into named exports, using only the information from the typechecker.\n            // As we introduce the new symbols after typecheck, Tsickle does not know about them,\n            // and omits them when expanding `export *`.\n            // So we have to keep reexporting these symbols manually via .ngfactory files.\n            this.reexportedBy.set(declarationSymbol, summary.symbol);\n          }\n        }\n      }\n\n      if (!unprocessedSummary.type && summary.type) {\n        unprocessedSummary.type = summary.type; // Note: We don't add the summaries of all referenced symbols as for the ResolvedSymbols,\n        // as the type summaries already contain the transitive data that they require\n        // (in a minimal way).\n\n        processedSummary.type = this.processValue(summary.type, 0\n        /* None */\n        ); // except for reexported directives / pipes, so we need to store\n        // their summaries explicitly.\n\n        if (summary.type.summaryKind === CompileSummaryKind.NgModule) {\n          var ngModuleSummary = summary.type;\n          ngModuleSummary.exportedDirectives.concat(ngModuleSummary.exportedPipes).forEach(function (id) {\n            var symbol = id.reference;\n\n            if (_this260.summaryResolver.isLibraryFile(symbol.filePath) && !_this260.unprocessedSymbolSummariesBySymbol.has(symbol)) {\n              var _summary = _this260.summaryResolver.resolveSummary(symbol);\n\n              if (_summary) {\n                _this260.addSummary(_summary);\n              }\n            }\n          });\n        }\n      }\n    }\n    /**\r\n     * @param createExternalSymbolReexports Whether external static symbols should be re-exported.\r\n     * This can be enabled if external symbols should be re-exported by the current module in\r\n     * order to avoid dynamically generated module dependencies which can break strict dependency\r\n     * enforcements (as in Google3). Read more here: https://github.com/angular/angular/issues/25644\r\n     */\n\n  }, {\n    key: \"serialize\",\n    value: function serialize(createExternalSymbolReexports) {\n      var _this261 = this;\n\n      var exportAs = [];\n      var json = JSON.stringify({\n        moduleName: this.moduleName,\n        summaries: this.processedSummaries,\n        symbols: this.symbols.map(function (symbol, index) {\n          symbol.assertNoMembers();\n          var importAs = undefined;\n\n          if (_this261.summaryResolver.isLibraryFile(symbol.filePath)) {\n            var reexportSymbol = _this261.reexportedBy.get(symbol);\n\n            if (reexportSymbol) {\n              // In case the given external static symbol is already manually exported by the\n              // user, we just proxy the external static symbol reference to the manual export.\n              // This ensures that the AOT compiler imports the external symbol through the\n              // user export and does not introduce another dependency which is not needed.\n              importAs = _this261.indexBySymbol.get(reexportSymbol);\n            } else if (createExternalSymbolReexports) {\n              // In this case, the given external static symbol is *not* manually exported by\n              // the user, and we manually create a re-export in the factory file so that we\n              // don't introduce another module dependency. This is useful when running within\n              // Bazel so that the AOT compiler does not introduce any module dependencies\n              // which can break the strict dependency enforcement. (e.g. as in Google3)\n              // Read more about this here: https://github.com/angular/angular/issues/25644\n              var summary = _this261.unprocessedSymbolSummariesBySymbol.get(symbol);\n\n              if (!summary || !summary.metadata || summary.metadata.__symbolic !== 'interface') {\n                importAs = \"\".concat(symbol.name, \"_\").concat(index);\n                exportAs.push({\n                  symbol: symbol,\n                  exportAs: importAs\n                });\n              }\n            }\n          }\n\n          return {\n            __symbol: index,\n            name: symbol.name,\n            filePath: _this261.summaryResolver.toSummaryFileName(symbol.filePath, _this261.srcFileName),\n            importAs: importAs\n          };\n        })\n      });\n      return {\n        json: json,\n        exportAs: exportAs\n      };\n    }\n  }, {\n    key: \"processValue\",\n    value: function processValue(value, flags) {\n      return visitValue(value, this, flags);\n    }\n  }, {\n    key: \"visitOther\",\n    value: function visitOther(value, context) {\n      if (value instanceof StaticSymbol) {\n        var baseSymbol = this.symbolResolver.getStaticSymbol(value.filePath, value.name);\n        var index = this.visitStaticSymbol(baseSymbol, context);\n        return {\n          __symbol: index,\n          members: value.members\n        };\n      }\n    }\n    /**\r\n     * Strip line and character numbers from ngsummaries.\r\n     * Emitting them causes white spaces changes to retrigger upstream\r\n     * recompilations in bazel.\r\n     * TODO: find out a way to have line and character numbers in errors without\r\n     * excessive recompilation in bazel.\r\n     */\n\n  }, {\n    key: \"visitStringMap\",\n    value: function visitStringMap(map, context) {\n      if (map['__symbolic'] === 'resolved') {\n        return visitValue(map['symbol'], this, context);\n      }\n\n      if (map['__symbolic'] === 'error') {\n        delete map['line'];\n        delete map['character'];\n      }\n\n      return _get(_getPrototypeOf(ToJsonSerializer.prototype), \"visitStringMap\", this).call(this, map, context);\n    }\n    /**\r\n     * Returns null if the options.resolveValue is true, and the summary for the symbol\r\n     * resolved to a type or could not be resolved.\r\n     */\n\n  }, {\n    key: \"visitStaticSymbol\",\n    value: function visitStaticSymbol(baseSymbol, flags) {\n      var index = this.indexBySymbol.get(baseSymbol);\n      var summary = null;\n\n      if (flags & 1\n      /* ResolveValue */\n      && this.summaryResolver.isLibraryFile(baseSymbol.filePath)) {\n        if (this.unprocessedSymbolSummariesBySymbol.has(baseSymbol)) {\n          // the summary for this symbol was already added\n          // -> nothing to do.\n          return index;\n        }\n\n        summary = this.loadSummary(baseSymbol);\n\n        if (summary && summary.metadata instanceof StaticSymbol) {\n          // The summary is a reexport\n          index = this.visitStaticSymbol(summary.metadata, flags); // reset the summary as it is just a reexport, so we don't want to store it.\n\n          summary = null;\n        }\n      } else if (index != null) {\n        // Note: == on purpose to compare with undefined!\n        // No summary and the symbol is already added -> nothing to do.\n        return index;\n      } // Note: == on purpose to compare with undefined!\n\n\n      if (index == null) {\n        index = this.symbols.length;\n        this.symbols.push(baseSymbol);\n      }\n\n      this.indexBySymbol.set(baseSymbol, index);\n\n      if (summary) {\n        this.addSummary(summary);\n      }\n\n      return index;\n    }\n  }, {\n    key: \"loadSummary\",\n    value: function loadSummary(symbol) {\n      var summary = this.summaryResolver.resolveSummary(symbol);\n\n      if (!summary) {\n        // some symbols might originate from a plain typescript library\n        // that just exported .d.ts and .metadata.json files, i.e. where no summary\n        // files were created.\n        var resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\n\n        if (resolvedSymbol) {\n          summary = {\n            symbol: resolvedSymbol.symbol,\n            metadata: resolvedSymbol.metadata\n          };\n        }\n      }\n\n      return summary;\n    }\n  }]);\n\n  return ToJsonSerializer;\n}(ValueTransformer);\n\nvar ForJitSerializer = /*#__PURE__*/function () {\n  function ForJitSerializer(outputCtx, symbolResolver, summaryResolver) {\n    _classCallCheck(this, ForJitSerializer);\n\n    this.outputCtx = outputCtx;\n    this.symbolResolver = symbolResolver;\n    this.summaryResolver = summaryResolver;\n    this.data = [];\n  }\n\n  _createClass(ForJitSerializer, [{\n    key: \"addSourceType\",\n    value: function addSourceType(summary, metadata) {\n      this.data.push({\n        summary: summary,\n        metadata: metadata,\n        isLibrary: false\n      });\n    }\n  }, {\n    key: \"addLibType\",\n    value: function addLibType(summary) {\n      this.data.push({\n        summary: summary,\n        metadata: null,\n        isLibrary: true\n      });\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(exportAsArr) {\n      var _this262 = this;\n\n      var exportAsBySymbol = new Map();\n\n      var _iterator31 = _createForOfIteratorHelper(exportAsArr),\n          _step31;\n\n      try {\n        for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n          var _step31$value = _step31.value,\n              symbol = _step31$value.symbol,\n              exportAs = _step31$value.exportAs;\n          exportAsBySymbol.set(symbol, exportAs);\n        }\n      } catch (err) {\n        _iterator31.e(err);\n      } finally {\n        _iterator31.f();\n      }\n\n      var ngModuleSymbols = new Set();\n\n      var _iterator32 = _createForOfIteratorHelper(this.data),\n          _step32;\n\n      try {\n        for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n          var _step32$value = _step32.value,\n              summary = _step32$value.summary,\n              metadata = _step32$value.metadata,\n              isLibrary = _step32$value.isLibrary;\n\n          if (summary.summaryKind === CompileSummaryKind.NgModule) {\n            // collect the symbols that refer to NgModule classes.\n            // Note: we can't just rely on `summary.type.summaryKind` to determine this as\n            // we don't add the summaries of all referenced symbols when we serialize type summaries.\n            // See serializeSummaries for details.\n            ngModuleSymbols.add(summary.type.reference);\n            var modSummary = summary;\n\n            var _iterator33 = _createForOfIteratorHelper(modSummary.modules),\n                _step33;\n\n            try {\n              for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n                var mod = _step33.value;\n                ngModuleSymbols.add(mod.reference);\n              }\n            } catch (err) {\n              _iterator33.e(err);\n            } finally {\n              _iterator33.f();\n            }\n          }\n\n          if (!isLibrary) {\n            var fnName = summaryForJitName(summary.type.reference.name);\n            createSummaryForJitFunction(this.outputCtx, summary.type.reference, this.serializeSummaryWithDeps(summary, metadata));\n          }\n        }\n      } catch (err) {\n        _iterator32.e(err);\n      } finally {\n        _iterator32.f();\n      }\n\n      ngModuleSymbols.forEach(function (ngModuleSymbol) {\n        if (_this262.summaryResolver.isLibraryFile(ngModuleSymbol.filePath)) {\n          var exportAs = exportAsBySymbol.get(ngModuleSymbol) || ngModuleSymbol.name;\n          var jitExportAsName = summaryForJitName(exportAs);\n\n          _this262.outputCtx.statements.push(variable(jitExportAsName).set(_this262.serializeSummaryRef(ngModuleSymbol)).toDeclStmt(null, [StmtModifier.Exported]));\n        }\n      });\n    }\n  }, {\n    key: \"serializeSummaryWithDeps\",\n    value: function serializeSummaryWithDeps(summary, metadata) {\n      var _this263 = this;\n\n      var expressions = [this.serializeSummary(summary)];\n      var providers = [];\n\n      if (metadata instanceof CompileNgModuleMetadata) {\n        expressions.push.apply(expressions, _toConsumableArray( // For directives / pipes, we only add the declared ones,\n        // and rely on transitively importing NgModules to get the transitive\n        // summaries.\n        metadata.declaredDirectives.concat(metadata.declaredPipes).map(function (type) {\n          return type.reference;\n        }) // For modules,\n        // we also add the summaries for modules\n        // from libraries.\n        // This is ok as we produce reexports for all transitive modules.\n        .concat(metadata.transitiveModule.modules.map(function (type) {\n          return type.reference;\n        }).filter(function (ref) {\n          return ref !== metadata.type.reference;\n        })).map(function (ref) {\n          return _this263.serializeSummaryRef(ref);\n        }))); // Note: We don't use `NgModuleSummary.providers`, as that one is transitive,\n        // and we already have transitive modules.\n\n        providers = metadata.providers;\n      } else if (summary.summaryKind === CompileSummaryKind.Directive) {\n        var dirSummary = summary;\n        providers = dirSummary.providers.concat(dirSummary.viewProviders);\n      } // Note: We can't just refer to the `ngsummary.ts` files for `useClass` providers (as we do for\n      // declaredDirectives / declaredPipes), as we allow\n      // providers without ctor arguments to skip the `@Injectable` decorator,\n      // i.e. we didn't generate .ngsummary.ts files for these.\n\n\n      expressions.push.apply(expressions, _toConsumableArray(providers.filter(function (provider) {\n        return !!provider.useClass;\n      }).map(function (provider) {\n        return _this263.serializeSummary({\n          summaryKind: CompileSummaryKind.Injectable,\n          type: provider.useClass\n        });\n      })));\n      return literalArr(expressions);\n    }\n  }, {\n    key: \"serializeSummaryRef\",\n    value: function serializeSummaryRef(typeSymbol) {\n      var jitImportedSymbol = this.symbolResolver.getStaticSymbol(summaryForJitFileName(typeSymbol.filePath), summaryForJitName(typeSymbol.name));\n      return this.outputCtx.importExpr(jitImportedSymbol);\n    }\n  }, {\n    key: \"serializeSummary\",\n    value: function serializeSummary(data) {\n      var outputCtx = this.outputCtx;\n\n      var Transformer = /*#__PURE__*/function () {\n        function Transformer() {\n          _classCallCheck(this, Transformer);\n        }\n\n        _createClass(Transformer, [{\n          key: \"visitArray\",\n          value: function visitArray(arr, context) {\n            var _this264 = this;\n\n            return literalArr(arr.map(function (entry) {\n              return visitValue(entry, _this264, context);\n            }));\n          }\n        }, {\n          key: \"visitStringMap\",\n          value: function visitStringMap(map, context) {\n            var _this265 = this;\n\n            return new LiteralMapExpr(Object.keys(map).map(function (key) {\n              return new LiteralMapEntry(key, visitValue(map[key], _this265, context), false);\n            }));\n          }\n        }, {\n          key: \"visitPrimitive\",\n          value: function visitPrimitive(value, context) {\n            return literal(value);\n          }\n        }, {\n          key: \"visitOther\",\n          value: function visitOther(value, context) {\n            if (value instanceof StaticSymbol) {\n              return outputCtx.importExpr(value);\n            } else {\n              throw new Error(\"Illegal State: Encountered value \".concat(value));\n            }\n          }\n        }]);\n\n        return Transformer;\n      }();\n\n      return visitValue(data, new Transformer(), null);\n    }\n  }]);\n\n  return ForJitSerializer;\n}();\n\nvar FromJsonDeserializer = /*#__PURE__*/function (_ValueTransformer4) {\n  _inherits(FromJsonDeserializer, _ValueTransformer4);\n\n  var _super110 = _createSuper(FromJsonDeserializer);\n\n  function FromJsonDeserializer(symbolCache, summaryResolver) {\n    var _this266;\n\n    _classCallCheck(this, FromJsonDeserializer);\n\n    _this266 = _super110.call(this);\n    _this266.symbolCache = symbolCache;\n    _this266.summaryResolver = summaryResolver;\n    return _this266;\n  }\n\n  _createClass(FromJsonDeserializer, [{\n    key: \"deserialize\",\n    value: function deserialize(libraryFileName, json) {\n      var _this267 = this;\n\n      var data = JSON.parse(json);\n      var allImportAs = [];\n      this.symbols = data.symbols.map(function (serializedSymbol) {\n        return _this267.symbolCache.get(_this267.summaryResolver.fromSummaryFileName(serializedSymbol.filePath, libraryFileName), serializedSymbol.name);\n      });\n      data.symbols.forEach(function (serializedSymbol, index) {\n        var symbol = _this267.symbols[index];\n        var importAs = serializedSymbol.importAs;\n\n        if (typeof importAs === 'number') {\n          allImportAs.push({\n            symbol: symbol,\n            importAs: _this267.symbols[importAs]\n          });\n        } else if (typeof importAs === 'string') {\n          allImportAs.push({\n            symbol: symbol,\n            importAs: _this267.symbolCache.get(ngfactoryFilePath(libraryFileName), importAs)\n          });\n        }\n      });\n      var summaries = visitValue(data.summaries, this, null);\n      return {\n        moduleName: data.moduleName,\n        summaries: summaries,\n        importAs: allImportAs\n      };\n    }\n  }, {\n    key: \"visitStringMap\",\n    value: function visitStringMap(map, context) {\n      if ('__symbol' in map) {\n        var baseSymbol = this.symbols[map['__symbol']];\n        var members = map['members'];\n        return members.length ? this.symbolCache.get(baseSymbol.filePath, baseSymbol.name, members) : baseSymbol;\n      } else {\n        return _get(_getPrototypeOf(FromJsonDeserializer.prototype), \"visitStringMap\", this).call(this, map, context);\n      }\n    }\n  }]);\n\n  return FromJsonDeserializer;\n}(ValueTransformer);\n\nfunction isCall(metadata) {\n  return metadata && metadata.__symbolic === 'call';\n}\n\nfunction isFunctionCall(metadata) {\n  return isCall(metadata) && unwrapResolvedMetadata(metadata.expression) instanceof StaticSymbol;\n}\n\nfunction isMethodCallOnVariable(metadata) {\n  return isCall(metadata) && metadata.expression && metadata.expression.__symbolic === 'select' && unwrapResolvedMetadata(metadata.expression.expression) instanceof StaticSymbol;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar AotCompiler = /*#__PURE__*/function () {\n  function AotCompiler(_config, _options, _host, reflector, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _typeCheckCompiler, _ngModuleCompiler, _injectableCompiler, _outputEmitter, _summaryResolver, _symbolResolver) {\n    _classCallCheck(this, AotCompiler);\n\n    this._config = _config;\n    this._options = _options;\n    this._host = _host;\n    this.reflector = reflector;\n    this._metadataResolver = _metadataResolver;\n    this._templateParser = _templateParser;\n    this._styleCompiler = _styleCompiler;\n    this._viewCompiler = _viewCompiler;\n    this._typeCheckCompiler = _typeCheckCompiler;\n    this._ngModuleCompiler = _ngModuleCompiler;\n    this._injectableCompiler = _injectableCompiler;\n    this._outputEmitter = _outputEmitter;\n    this._summaryResolver = _summaryResolver;\n    this._symbolResolver = _symbolResolver;\n    this._templateAstCache = new Map();\n    this._analyzedFiles = new Map();\n    this._analyzedFilesForInjectables = new Map();\n  }\n\n  _createClass(AotCompiler, [{\n    key: \"clearCache\",\n    value: function clearCache() {\n      this._metadataResolver.clearCache();\n    }\n  }, {\n    key: \"analyzeModulesSync\",\n    value: function analyzeModulesSync(rootFiles) {\n      var _this268 = this;\n\n      var analyzeResult = analyzeAndValidateNgModules(rootFiles, this._host, this._symbolResolver, this._metadataResolver);\n      analyzeResult.ngModules.forEach(function (ngModule) {\n        return _this268._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, true);\n      });\n      return analyzeResult;\n    }\n  }, {\n    key: \"analyzeModulesAsync\",\n    value: function analyzeModulesAsync(rootFiles) {\n      var _this269 = this;\n\n      var analyzeResult = analyzeAndValidateNgModules(rootFiles, this._host, this._symbolResolver, this._metadataResolver);\n      return Promise.all(analyzeResult.ngModules.map(function (ngModule) {\n        return _this269._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false);\n      })).then(function () {\n        return analyzeResult;\n      });\n    }\n  }, {\n    key: \"_analyzeFile\",\n    value: function _analyzeFile(fileName) {\n      var analyzedFile = this._analyzedFiles.get(fileName);\n\n      if (!analyzedFile) {\n        analyzedFile = analyzeFile(this._host, this._symbolResolver, this._metadataResolver, fileName);\n\n        this._analyzedFiles.set(fileName, analyzedFile);\n      }\n\n      return analyzedFile;\n    }\n  }, {\n    key: \"_analyzeFileForInjectables\",\n    value: function _analyzeFileForInjectables(fileName) {\n      var analyzedFile = this._analyzedFilesForInjectables.get(fileName);\n\n      if (!analyzedFile) {\n        analyzedFile = analyzeFileForInjectables(this._host, this._symbolResolver, this._metadataResolver, fileName);\n\n        this._analyzedFilesForInjectables.set(fileName, analyzedFile);\n      }\n\n      return analyzedFile;\n    }\n  }, {\n    key: \"findGeneratedFileNames\",\n    value: function findGeneratedFileNames(fileName) {\n      var _this270 = this;\n\n      var genFileNames = [];\n\n      var file = this._analyzeFile(fileName); // Make sure we create a .ngfactory if we have a injectable/directive/pipe/NgModule\n      // or a reference to a non source file.\n      // Note: This is overestimating the required .ngfactory files as the real calculation is harder.\n      // Only do this for StubEmitFlags.Basic, as adding a type check block\n      // does not change this file (as we generate type check blocks based on NgModules).\n\n\n      if (this._options.allowEmptyCodegenFiles || file.directives.length || file.pipes.length || file.injectables.length || file.ngModules.length || file.exportsNonSourceFiles) {\n        genFileNames.push(ngfactoryFilePath(file.fileName, true));\n\n        if (this._options.enableSummariesForJit) {\n          genFileNames.push(summaryForJitFileName(file.fileName, true));\n        }\n      }\n\n      var fileSuffix = normalizeGenFileSuffix(splitTypescriptSuffix(file.fileName, true)[1]);\n      file.directives.forEach(function (dirSymbol) {\n        var compMeta = _this270._metadataResolver.getNonNormalizedDirectiveMetadata(dirSymbol).metadata;\n\n        if (!compMeta.isComponent) {\n          return;\n        } // Note: compMeta is a component and therefore template is non null.\n\n\n        compMeta.template.styleUrls.forEach(function (styleUrl) {\n          var normalizedUrl = _this270._host.resourceNameToFileName(styleUrl, file.fileName);\n\n          if (!normalizedUrl) {\n            throw syntaxError(\"Couldn't resolve resource \".concat(styleUrl, \" relative to \").concat(file.fileName));\n          }\n\n          var needsShim = (compMeta.template.encapsulation || _this270._config.defaultEncapsulation) === ViewEncapsulation.Emulated;\n          genFileNames.push(_stylesModuleUrl(normalizedUrl, needsShim, fileSuffix));\n\n          if (_this270._options.allowEmptyCodegenFiles) {\n            genFileNames.push(_stylesModuleUrl(normalizedUrl, !needsShim, fileSuffix));\n          }\n        });\n      });\n      return genFileNames;\n    }\n  }, {\n    key: \"emitBasicStub\",\n    value: function emitBasicStub(genFileName, originalFileName) {\n      var outputCtx = this._createOutputContext(genFileName);\n\n      if (genFileName.endsWith('.ngfactory.ts')) {\n        if (!originalFileName) {\n          throw new Error(\"Assertion error: require the original file for .ngfactory.ts stubs. File: \".concat(genFileName));\n        }\n\n        var originalFile = this._analyzeFile(originalFileName);\n\n        this._createNgFactoryStub(outputCtx, originalFile, 1\n        /* Basic */\n        );\n      } else if (genFileName.endsWith('.ngsummary.ts')) {\n        if (this._options.enableSummariesForJit) {\n          if (!originalFileName) {\n            throw new Error(\"Assertion error: require the original file for .ngsummary.ts stubs. File: \".concat(genFileName));\n          }\n\n          var _originalFile = this._analyzeFile(originalFileName);\n\n          _createEmptyStub(outputCtx);\n\n          _originalFile.ngModules.forEach(function (ngModule) {\n            // create exports that user code can reference\n            createForJitStub(outputCtx, ngModule.type.reference);\n          });\n        }\n      } else if (genFileName.endsWith('.ngstyle.ts')) {\n        _createEmptyStub(outputCtx);\n      } // Note: for the stubs, we don't need a property srcFileUrl,\n      // as later on in emitAllImpls we will create the proper GeneratedFiles with the\n      // correct srcFileUrl.\n      // This is good as e.g. for .ngstyle.ts files we can't derive\n      // the url of components based on the genFileUrl.\n\n\n      return this._codegenSourceModule('unknown', outputCtx);\n    }\n  }, {\n    key: \"emitTypeCheckStub\",\n    value: function emitTypeCheckStub(genFileName, originalFileName) {\n      var originalFile = this._analyzeFile(originalFileName);\n\n      var outputCtx = this._createOutputContext(genFileName);\n\n      if (genFileName.endsWith('.ngfactory.ts')) {\n        this._createNgFactoryStub(outputCtx, originalFile, 2\n        /* TypeCheck */\n        );\n      }\n\n      return outputCtx.statements.length > 0 ? this._codegenSourceModule(originalFile.fileName, outputCtx) : null;\n    }\n  }, {\n    key: \"loadFilesAsync\",\n    value: function loadFilesAsync(fileNames, tsFiles) {\n      var _this271 = this;\n\n      var files = fileNames.map(function (fileName) {\n        return _this271._analyzeFile(fileName);\n      });\n      var loadingPromises = [];\n      files.forEach(function (file) {\n        return file.ngModules.forEach(function (ngModule) {\n          return loadingPromises.push(_this271._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false));\n        });\n      });\n      var analyzedInjectables = tsFiles.map(function (tsFile) {\n        return _this271._analyzeFileForInjectables(tsFile);\n      });\n      return Promise.all(loadingPromises).then(function (_) {\n        return {\n          analyzedModules: mergeAndValidateNgFiles(files),\n          analyzedInjectables: analyzedInjectables\n        };\n      });\n    }\n  }, {\n    key: \"loadFilesSync\",\n    value: function loadFilesSync(fileNames, tsFiles) {\n      var _this272 = this;\n\n      var files = fileNames.map(function (fileName) {\n        return _this272._analyzeFile(fileName);\n      });\n      files.forEach(function (file) {\n        return file.ngModules.forEach(function (ngModule) {\n          return _this272._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, true);\n        });\n      });\n      var analyzedInjectables = tsFiles.map(function (tsFile) {\n        return _this272._analyzeFileForInjectables(tsFile);\n      });\n      return {\n        analyzedModules: mergeAndValidateNgFiles(files),\n        analyzedInjectables: analyzedInjectables\n      };\n    }\n  }, {\n    key: \"_createNgFactoryStub\",\n    value: function _createNgFactoryStub(outputCtx, file, emitFlags) {\n      var _this273 = this;\n\n      var componentId = 0;\n      file.ngModules.forEach(function (ngModuleMeta, ngModuleIndex) {\n        // Note: the code below needs to executed for StubEmitFlags.Basic and StubEmitFlags.TypeCheck,\n        // so we don't change the .ngfactory file too much when adding the type-check block.\n        // create exports that user code can reference\n        _this273._ngModuleCompiler.createStub(outputCtx, ngModuleMeta.type.reference); // add references to the symbols from the metadata.\n        // These can be used by the type check block for components,\n        // and they also cause TypeScript to include these files into the program too,\n        // which will make them part of the analyzedFiles.\n\n\n        var externalReferences = [].concat(_toConsumableArray(ngModuleMeta.transitiveModule.directives.map(function (d) {\n          return d.reference;\n        })), _toConsumableArray(ngModuleMeta.transitiveModule.pipes.map(function (d) {\n          return d.reference;\n        })), _toConsumableArray(ngModuleMeta.importedModules.map(function (m) {\n          return m.type.reference;\n        })), _toConsumableArray(ngModuleMeta.exportedModules.map(function (m) {\n          return m.type.reference;\n        })), _toConsumableArray(_this273._externalIdentifierReferences([Identifiers$1.TemplateRef, Identifiers$1.ElementRef])));\n        var externalReferenceVars = new Map();\n        externalReferences.forEach(function (ref, typeIndex) {\n          externalReferenceVars.set(ref, \"_decl\".concat(ngModuleIndex, \"_\").concat(typeIndex));\n        });\n        externalReferenceVars.forEach(function (varName, reference) {\n          outputCtx.statements.push(variable(varName).set(NULL_EXPR.cast(DYNAMIC_TYPE)).toDeclStmt(expressionType(outputCtx.importExpr(reference,\n          /* typeParams */\n          null,\n          /* useSummaries */\n          false))));\n        });\n\n        if (emitFlags & 2\n        /* TypeCheck */\n        ) {\n            // add the type-check block for all components of the NgModule\n            ngModuleMeta.declaredDirectives.forEach(function (dirId) {\n              var compMeta = _this273._metadataResolver.getDirectiveMetadata(dirId.reference);\n\n              if (!compMeta.isComponent) {\n                return;\n              }\n\n              componentId++;\n\n              _this273._createTypeCheckBlock(outputCtx, \"\".concat(compMeta.type.reference.name, \"_Host_\").concat(componentId), ngModuleMeta, _this273._metadataResolver.getHostComponentMetadata(compMeta), [compMeta.type], externalReferenceVars);\n\n              _this273._createTypeCheckBlock(outputCtx, \"\".concat(compMeta.type.reference.name, \"_\").concat(componentId), ngModuleMeta, compMeta, ngModuleMeta.transitiveModule.directives, externalReferenceVars);\n            });\n          }\n      });\n\n      if (outputCtx.statements.length === 0) {\n        _createEmptyStub(outputCtx);\n      }\n    }\n  }, {\n    key: \"_externalIdentifierReferences\",\n    value: function _externalIdentifierReferences(references) {\n      var result = [];\n\n      var _iterator34 = _createForOfIteratorHelper(references),\n          _step34;\n\n      try {\n        for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n          var reference = _step34.value;\n          var token = createTokenForExternalReference(this.reflector, reference);\n\n          if (token.identifier) {\n            result.push(token.identifier.reference);\n          }\n        }\n      } catch (err) {\n        _iterator34.e(err);\n      } finally {\n        _iterator34.f();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_createTypeCheckBlock\",\n    value: function _createTypeCheckBlock(ctx, componentId, moduleMeta, compMeta, directives, externalReferenceVars) {\n      var _ctx$statements;\n\n      var _this$_parseTemplate = this._parseTemplate(compMeta, moduleMeta, directives),\n          parsedTemplate = _this$_parseTemplate.template,\n          usedPipes = _this$_parseTemplate.pipes;\n\n      (_ctx$statements = ctx.statements).push.apply(_ctx$statements, _toConsumableArray(this._typeCheckCompiler.compileComponent(componentId, compMeta, parsedTemplate, usedPipes, externalReferenceVars, ctx)));\n    }\n  }, {\n    key: \"emitMessageBundle\",\n    value: function emitMessageBundle(analyzeResult, locale) {\n      var _this274 = this;\n\n      var errors = [];\n      var htmlParser = new HtmlParser(); // TODO(vicb): implicit tags & attributes\n\n      var messageBundle = new MessageBundle(htmlParser, [], {}, locale);\n      analyzeResult.files.forEach(function (file) {\n        var compMetas = [];\n        file.directives.forEach(function (directiveType) {\n          var dirMeta = _this274._metadataResolver.getDirectiveMetadata(directiveType);\n\n          if (dirMeta && dirMeta.isComponent) {\n            compMetas.push(dirMeta);\n          }\n        });\n        compMetas.forEach(function (compMeta) {\n          var html = compMeta.template.template; // Template URL points to either an HTML or TS file depending on whether\n          // the file is used with `templateUrl:` or `template:`, respectively.\n\n          var templateUrl = compMeta.template.templateUrl;\n          var interpolationConfig = InterpolationConfig.fromArray(compMeta.template.interpolation);\n          errors.push.apply(errors, _toConsumableArray(messageBundle.updateFromTemplate(html, templateUrl, interpolationConfig)));\n        });\n      });\n\n      if (errors.length) {\n        throw new Error(errors.map(function (e) {\n          return e.toString();\n        }).join('\\n'));\n      }\n\n      return messageBundle;\n    }\n  }, {\n    key: \"emitAllPartialModules2\",\n    value: function emitAllPartialModules2(files) {\n      var _this275 = this;\n\n      // Using reduce like this is a select many pattern (where map is a select pattern)\n      return files.reduce(function (r, file) {\n        r.push.apply(r, _toConsumableArray(_this275._emitPartialModule2(file.fileName, file.injectables)));\n        return r;\n      }, []);\n    }\n  }, {\n    key: \"_emitPartialModule2\",\n    value: function _emitPartialModule2(fileName, injectables) {\n      var _this276 = this;\n\n      var context = this._createOutputContext(fileName);\n\n      injectables.forEach(function (injectable) {\n        return _this276._injectableCompiler.compile(injectable, context);\n      });\n\n      if (context.statements && context.statements.length > 0) {\n        return [{\n          fileName: fileName,\n          statements: [].concat(_toConsumableArray(context.constantPool.statements), _toConsumableArray(context.statements))\n        }];\n      }\n\n      return [];\n    }\n  }, {\n    key: \"emitAllImpls\",\n    value: function emitAllImpls(analyzeResult) {\n      var _this277 = this;\n\n      var ngModuleByPipeOrDirective = analyzeResult.ngModuleByPipeOrDirective,\n          files = analyzeResult.files;\n      var sourceModules = files.map(function (file) {\n        return _this277._compileImplFile(file.fileName, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules, file.injectables);\n      });\n      return flatten(sourceModules);\n    }\n  }, {\n    key: \"_compileImplFile\",\n    value: function _compileImplFile(srcFileUrl, ngModuleByPipeOrDirective, directives, pipes, ngModules, injectables) {\n      var _this278 = this;\n\n      var fileSuffix = normalizeGenFileSuffix(splitTypescriptSuffix(srcFileUrl, true)[1]);\n      var generatedFiles = [];\n\n      var outputCtx = this._createOutputContext(ngfactoryFilePath(srcFileUrl, true));\n\n      generatedFiles.push.apply(generatedFiles, _toConsumableArray(this._createSummary(srcFileUrl, directives, pipes, ngModules, injectables, outputCtx))); // compile all ng modules\n\n      ngModules.forEach(function (ngModuleMeta) {\n        return _this278._compileModule(outputCtx, ngModuleMeta);\n      }); // compile components\n\n      directives.forEach(function (dirType) {\n        var compMeta = _this278._metadataResolver.getDirectiveMetadata(dirType);\n\n        if (!compMeta.isComponent) {\n          return;\n        }\n\n        var ngModule = ngModuleByPipeOrDirective.get(dirType);\n\n        if (!ngModule) {\n          throw new Error(\"Internal Error: cannot determine the module for component \".concat(identifierName(compMeta.type), \"!\"));\n        } // compile styles\n\n\n        var componentStylesheet = _this278._styleCompiler.compileComponent(outputCtx, compMeta); // Note: compMeta is a component and therefore template is non null.\n\n\n        compMeta.template.externalStylesheets.forEach(function (stylesheetMeta) {\n          // Note: fill non shim and shim style files as they might\n          // be shared by component with and without ViewEncapsulation.\n          var shim = _this278._styleCompiler.needsStyleShim(compMeta);\n\n          generatedFiles.push(_this278._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, shim, fileSuffix));\n\n          if (_this278._options.allowEmptyCodegenFiles) {\n            generatedFiles.push(_this278._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, !shim, fileSuffix));\n          }\n        }); // compile components\n\n        var compViewVars = _this278._compileComponent(outputCtx, compMeta, ngModule, ngModule.transitiveModule.directives, componentStylesheet, fileSuffix);\n\n        _this278._compileComponentFactory(outputCtx, compMeta, ngModule, fileSuffix);\n      });\n\n      if (outputCtx.statements.length > 0 || this._options.allowEmptyCodegenFiles) {\n        var srcModule = this._codegenSourceModule(srcFileUrl, outputCtx);\n\n        generatedFiles.unshift(srcModule);\n      }\n\n      return generatedFiles;\n    }\n  }, {\n    key: \"_createSummary\",\n    value: function _createSummary(srcFileName, directives, pipes, ngModules, injectables, ngFactoryCtx) {\n      var _this279 = this;\n\n      var symbolSummaries = this._symbolResolver.getSymbolsOf(srcFileName).map(function (symbol) {\n        return _this279._symbolResolver.resolveSymbol(symbol);\n      });\n\n      var typeData = [].concat(_toConsumableArray(ngModules.map(function (meta) {\n        return {\n          summary: _this279._metadataResolver.getNgModuleSummary(meta.type.reference),\n          metadata: _this279._metadataResolver.getNgModuleMetadata(meta.type.reference)\n        };\n      })), _toConsumableArray(directives.map(function (ref) {\n        return {\n          summary: _this279._metadataResolver.getDirectiveSummary(ref),\n          metadata: _this279._metadataResolver.getDirectiveMetadata(ref)\n        };\n      })), _toConsumableArray(pipes.map(function (ref) {\n        return {\n          summary: _this279._metadataResolver.getPipeSummary(ref),\n          metadata: _this279._metadataResolver.getPipeMetadata(ref)\n        };\n      })), _toConsumableArray(injectables.map(function (ref) {\n        return {\n          summary: _this279._metadataResolver.getInjectableSummary(ref.symbol),\n          metadata: _this279._metadataResolver.getInjectableSummary(ref.symbol).type\n        };\n      })));\n      var forJitOutputCtx = this._options.enableSummariesForJit ? this._createOutputContext(summaryForJitFileName(srcFileName, true)) : null;\n\n      var _serializeSummaries = serializeSummaries(srcFileName, forJitOutputCtx, this._summaryResolver, this._symbolResolver, symbolSummaries, typeData, this._options.createExternalSymbolFactoryReexports),\n          json = _serializeSummaries.json,\n          exportAs = _serializeSummaries.exportAs;\n\n      exportAs.forEach(function (entry) {\n        ngFactoryCtx.statements.push(variable(entry.exportAs).set(ngFactoryCtx.importExpr(entry.symbol)).toDeclStmt(null, [StmtModifier.Exported]));\n      });\n      var summaryJson = new GeneratedFile(srcFileName, summaryFileName(srcFileName), json);\n      var result = [summaryJson];\n\n      if (forJitOutputCtx) {\n        result.push(this._codegenSourceModule(srcFileName, forJitOutputCtx));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_compileModule\",\n    value: function _compileModule(outputCtx, ngModule) {\n      var providers = [];\n\n      if (this._options.locale) {\n        var normalizedLocale = this._options.locale.replace(/_/g, '-');\n\n        providers.push({\n          token: createTokenForExternalReference(this.reflector, Identifiers$1.LOCALE_ID),\n          useValue: normalizedLocale\n        });\n      }\n\n      if (this._options.i18nFormat) {\n        providers.push({\n          token: createTokenForExternalReference(this.reflector, Identifiers$1.TRANSLATIONS_FORMAT),\n          useValue: this._options.i18nFormat\n        });\n      }\n\n      this._ngModuleCompiler.compile(outputCtx, ngModule, providers);\n    }\n  }, {\n    key: \"_compileComponentFactory\",\n    value: function _compileComponentFactory(outputCtx, compMeta, ngModule, fileSuffix) {\n      var hostMeta = this._metadataResolver.getHostComponentMetadata(compMeta);\n\n      var hostViewFactoryVar = this._compileComponent(outputCtx, hostMeta, ngModule, [compMeta.type], null, fileSuffix).viewClassVar;\n\n      var compFactoryVar = componentFactoryName(compMeta.type.reference);\n      var inputsExprs = [];\n\n      for (var propName in compMeta.inputs) {\n        var templateName = compMeta.inputs[propName]; // Don't quote so that the key gets minified...\n\n        inputsExprs.push(new LiteralMapEntry(propName, literal(templateName), false));\n      }\n\n      var outputsExprs = [];\n\n      for (var _propName in compMeta.outputs) {\n        var _templateName = compMeta.outputs[_propName]; // Don't quote so that the key gets minified...\n\n        outputsExprs.push(new LiteralMapEntry(_propName, literal(_templateName), false));\n      }\n\n      outputCtx.statements.push(variable(compFactoryVar).set(importExpr(Identifiers$1.createComponentFactory).callFn([literal(compMeta.selector), outputCtx.importExpr(compMeta.type.reference), variable(hostViewFactoryVar), new LiteralMapExpr(inputsExprs), new LiteralMapExpr(outputsExprs), literalArr(compMeta.template.ngContentSelectors.map(function (selector) {\n        return literal(selector);\n      }))])).toDeclStmt(importType(Identifiers$1.ComponentFactory, [expressionType(outputCtx.importExpr(compMeta.type.reference))], [TypeModifier.Const]), [StmtModifier.Final, StmtModifier.Exported]));\n    }\n  }, {\n    key: \"_compileComponent\",\n    value: function _compileComponent(outputCtx, compMeta, ngModule, directiveIdentifiers, componentStyles, fileSuffix) {\n      var _this$_parseTemplate2 = this._parseTemplate(compMeta, ngModule, directiveIdentifiers),\n          parsedTemplate = _this$_parseTemplate2.template,\n          usedPipes = _this$_parseTemplate2.pipes;\n\n      var stylesExpr = componentStyles ? variable(componentStyles.stylesVar) : literalArr([]);\n\n      var viewResult = this._viewCompiler.compileComponent(outputCtx, compMeta, parsedTemplate, stylesExpr, usedPipes);\n\n      if (componentStyles) {\n        _resolveStyleStatements(this._symbolResolver, componentStyles, this._styleCompiler.needsStyleShim(compMeta), fileSuffix);\n      }\n\n      return viewResult;\n    }\n  }, {\n    key: \"_parseTemplate\",\n    value: function _parseTemplate(compMeta, ngModule, directiveIdentifiers) {\n      var _this280 = this;\n\n      if (this._templateAstCache.has(compMeta.type.reference)) {\n        return this._templateAstCache.get(compMeta.type.reference);\n      }\n\n      var preserveWhitespaces = compMeta.template.preserveWhitespaces;\n      var directives = directiveIdentifiers.map(function (dir) {\n        return _this280._metadataResolver.getDirectiveSummary(dir.reference);\n      });\n      var pipes = ngModule.transitiveModule.pipes.map(function (pipe) {\n        return _this280._metadataResolver.getPipeSummary(pipe.reference);\n      });\n\n      var result = this._templateParser.parse(compMeta, compMeta.template.htmlAst, directives, pipes, ngModule.schemas, templateSourceUrl(ngModule.type, compMeta, compMeta.template), preserveWhitespaces);\n\n      this._templateAstCache.set(compMeta.type.reference, result);\n\n      return result;\n    }\n  }, {\n    key: \"_createOutputContext\",\n    value: function _createOutputContext(genFilePath) {\n      var _this281 = this;\n\n      var importExpr$1 = function importExpr$1(symbol) {\n        var typeParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n        var useSummaries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n        if (!(symbol instanceof StaticSymbol)) {\n          throw new Error(\"Internal error: unknown identifier \".concat(JSON.stringify(symbol)));\n        }\n\n        var arity = _this281._symbolResolver.getTypeArity(symbol) || 0;\n\n        var _ref43 = _this281._symbolResolver.getImportAs(symbol, useSummaries) || symbol,\n            filePath = _ref43.filePath,\n            name = _ref43.name,\n            members = _ref43.members;\n\n        var importModule = _this281._fileNameToModuleName(filePath, genFilePath); // It should be good enough to compare filePath to genFilePath and if they are equal\n        // there is a self reference. However, ngfactory files generate to .ts but their\n        // symbols have .d.ts so a simple compare is insufficient. They should be canonical\n        // and is tracked by #17705.\n\n\n        var selfReference = _this281._fileNameToModuleName(genFilePath, genFilePath);\n\n        var moduleName = importModule === selfReference ? null : importModule; // If we are in a type expression that refers to a generic type then supply\n        // the required type parameters. If there were not enough type parameters\n        // supplied, supply any as the type. Outside a type expression the reference\n        // should not supply type parameters and be treated as a simple value reference\n        // to the constructor function itself.\n\n        var suppliedTypeParams = typeParams || [];\n        var missingTypeParamsCount = arity - suppliedTypeParams.length;\n        var allTypeParams = suppliedTypeParams.concat(newArray(missingTypeParamsCount, DYNAMIC_TYPE));\n        return members.reduce(function (expr, memberName) {\n          return expr.prop(memberName);\n        }, importExpr(new ExternalReference(moduleName, name, null), allTypeParams));\n      };\n\n      return {\n        statements: [],\n        genFilePath: genFilePath,\n        importExpr: importExpr$1,\n        constantPool: new ConstantPool()\n      };\n    }\n  }, {\n    key: \"_fileNameToModuleName\",\n    value: function _fileNameToModuleName(importedFilePath, containingFilePath) {\n      return this._summaryResolver.getKnownModuleName(importedFilePath) || this._symbolResolver.getKnownModuleName(importedFilePath) || this._host.fileNameToModuleName(importedFilePath, containingFilePath);\n    }\n  }, {\n    key: \"_codegenStyles\",\n    value: function _codegenStyles(srcFileUrl, compMeta, stylesheetMetadata, isShimmed, fileSuffix) {\n      var outputCtx = this._createOutputContext(_stylesModuleUrl(stylesheetMetadata.moduleUrl, isShimmed, fileSuffix));\n\n      var compiledStylesheet = this._styleCompiler.compileStyles(outputCtx, compMeta, stylesheetMetadata, isShimmed);\n\n      _resolveStyleStatements(this._symbolResolver, compiledStylesheet, isShimmed, fileSuffix);\n\n      return this._codegenSourceModule(srcFileUrl, outputCtx);\n    }\n  }, {\n    key: \"_codegenSourceModule\",\n    value: function _codegenSourceModule(srcFileUrl, ctx) {\n      return new GeneratedFile(srcFileUrl, ctx.genFilePath, ctx.statements);\n    }\n  }, {\n    key: \"listLazyRoutes\",\n    value: function listLazyRoutes(entryRoute, analyzedModules) {\n      var self = this;\n\n      if (entryRoute) {\n        var symbol = parseLazyRoute(entryRoute, this.reflector).referencedModule;\n        return visitLazyRoute(symbol);\n      } else if (analyzedModules) {\n        var allLazyRoutes = [];\n\n        var _iterator35 = _createForOfIteratorHelper(analyzedModules.ngModules),\n            _step35;\n\n        try {\n          for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n            var ngModule = _step35.value;\n\n            var lazyRoutes = _listLazyRoutes(ngModule, this.reflector);\n\n            var _iterator36 = _createForOfIteratorHelper(lazyRoutes),\n                _step36;\n\n            try {\n              for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n                var lazyRoute = _step36.value;\n                allLazyRoutes.push(lazyRoute);\n              }\n            } catch (err) {\n              _iterator36.e(err);\n            } finally {\n              _iterator36.f();\n            }\n          }\n        } catch (err) {\n          _iterator35.e(err);\n        } finally {\n          _iterator35.f();\n        }\n\n        return allLazyRoutes;\n      } else {\n        throw new Error(\"Either route or analyzedModules has to be specified!\");\n      }\n\n      function visitLazyRoute(symbol) {\n        var seenRoutes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();\n        var allLazyRoutes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n        // Support pointing to default exports, but stop recursing there,\n        // as the StaticReflector does not yet support default exports.\n        if (seenRoutes.has(symbol) || !symbol.name) {\n          return allLazyRoutes;\n        }\n\n        seenRoutes.add(symbol);\n\n        var lazyRoutes = _listLazyRoutes(self._metadataResolver.getNgModuleMetadata(symbol, true), self.reflector);\n\n        var _iterator37 = _createForOfIteratorHelper(lazyRoutes),\n            _step37;\n\n        try {\n          for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {\n            var _lazyRoute = _step37.value;\n            allLazyRoutes.push(_lazyRoute);\n            visitLazyRoute(_lazyRoute.referencedModule, seenRoutes, allLazyRoutes);\n          }\n        } catch (err) {\n          _iterator37.e(err);\n        } finally {\n          _iterator37.f();\n        }\n\n        return allLazyRoutes;\n      }\n    }\n  }]);\n\n  return AotCompiler;\n}();\n\nfunction _createEmptyStub(outputCtx) {\n  // Note: We need to produce at least one import statement so that\n  // TypeScript knows that the file is an es6 module. Otherwise our generated\n  // exports / imports won't be emitted properly by TypeScript.\n  outputCtx.statements.push(importExpr(Identifiers$1.ComponentFactory).toStmt());\n}\n\nfunction _resolveStyleStatements(symbolResolver, compileResult, needsShim, fileSuffix) {\n  compileResult.dependencies.forEach(function (dep) {\n    dep.setValue(symbolResolver.getStaticSymbol(_stylesModuleUrl(dep.moduleUrl, needsShim, fileSuffix), dep.name));\n  });\n}\n\nfunction _stylesModuleUrl(stylesheetUrl, shim, suffix) {\n  return \"\".concat(stylesheetUrl).concat(shim ? '.shim' : '', \".ngstyle\").concat(suffix);\n}\n\nfunction analyzeNgModules(fileNames, host, staticSymbolResolver, metadataResolver) {\n  var files = _analyzeFilesIncludingNonProgramFiles(fileNames, host, staticSymbolResolver, metadataResolver);\n\n  return mergeAnalyzedFiles(files);\n}\n\nfunction analyzeAndValidateNgModules(fileNames, host, staticSymbolResolver, metadataResolver) {\n  return validateAnalyzedModules(analyzeNgModules(fileNames, host, staticSymbolResolver, metadataResolver));\n}\n\nfunction validateAnalyzedModules(analyzedModules) {\n  if (analyzedModules.symbolsMissingModule && analyzedModules.symbolsMissingModule.length) {\n    var messages = analyzedModules.symbolsMissingModule.map(function (s) {\n      return \"Cannot determine the module for class \".concat(s.name, \" in \").concat(s.filePath, \"! Add \").concat(s.name, \" to the NgModule to fix it.\");\n    });\n    throw syntaxError(messages.join('\\n'));\n  }\n\n  return analyzedModules;\n} // Analyzes all of the program files,\n// including files that are not part of the program\n// but are referenced by an NgModule.\n\n\nfunction _analyzeFilesIncludingNonProgramFiles(fileNames, host, staticSymbolResolver, metadataResolver) {\n  var seenFiles = new Set();\n  var files = [];\n\n  var visitFile = function visitFile(fileName) {\n    if (seenFiles.has(fileName) || !host.isSourceFile(fileName)) {\n      return false;\n    }\n\n    seenFiles.add(fileName);\n    var analyzedFile = analyzeFile(host, staticSymbolResolver, metadataResolver, fileName);\n    files.push(analyzedFile);\n    analyzedFile.ngModules.forEach(function (ngModule) {\n      ngModule.transitiveModule.modules.forEach(function (modMeta) {\n        return visitFile(modMeta.reference.filePath);\n      });\n    });\n  };\n\n  fileNames.forEach(function (fileName) {\n    return visitFile(fileName);\n  });\n  return files;\n}\n\nfunction analyzeFile(host, staticSymbolResolver, metadataResolver, fileName) {\n  var abstractDirectives = [];\n  var directives = [];\n  var pipes = [];\n  var injectables = [];\n  var ngModules = [];\n  var hasDecorators = staticSymbolResolver.hasDecorators(fileName);\n  var exportsNonSourceFiles = false;\n  var isDeclarationFile = fileName.endsWith('.d.ts'); // Don't analyze .d.ts files that have no decorators as a shortcut\n  // to speed up the analysis. This prevents us from\n  // resolving the references in these files.\n  // Note: exportsNonSourceFiles is only needed when compiling with summaries,\n  // which is not the case when .d.ts files are treated as input files.\n\n  if (!isDeclarationFile || hasDecorators) {\n    staticSymbolResolver.getSymbolsOf(fileName).forEach(function (symbol) {\n      var resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n      var symbolMeta = resolvedSymbol.metadata;\n\n      if (!symbolMeta || symbolMeta.__symbolic === 'error') {\n        return;\n      }\n\n      var isNgSymbol = false;\n\n      if (symbolMeta.__symbolic === 'class') {\n        if (metadataResolver.isDirective(symbol)) {\n          isNgSymbol = true; // This directive either has a selector or doesn't. Selector-less directives get tracked\n          // in abstractDirectives, not directives. The compiler doesn't deal with selector-less\n          // directives at all, really, other than to persist their metadata. This is done so that\n          // apps will have an easier time migrating to Ivy, which requires the selector-less\n          // annotations to be applied.\n\n          if (!metadataResolver.isAbstractDirective(symbol)) {\n            // The directive is an ordinary directive.\n            directives.push(symbol);\n          } else {\n            // The directive has no selector and is an \"abstract\" directive, so track it\n            // accordingly.\n            abstractDirectives.push(symbol);\n          }\n        } else if (metadataResolver.isPipe(symbol)) {\n          isNgSymbol = true;\n          pipes.push(symbol);\n        } else if (metadataResolver.isNgModule(symbol)) {\n          var ngModule = metadataResolver.getNgModuleMetadata(symbol, false);\n\n          if (ngModule) {\n            isNgSymbol = true;\n            ngModules.push(ngModule);\n          }\n        } else if (metadataResolver.isInjectable(symbol)) {\n          isNgSymbol = true;\n          var injectable = metadataResolver.getInjectableMetadata(symbol, null, false);\n\n          if (injectable) {\n            injectables.push(injectable);\n          }\n        }\n      }\n\n      if (!isNgSymbol) {\n        exportsNonSourceFiles = exportsNonSourceFiles || isValueExportingNonSourceFile(host, symbolMeta);\n      }\n    });\n  }\n\n  return {\n    fileName: fileName,\n    directives: directives,\n    abstractDirectives: abstractDirectives,\n    pipes: pipes,\n    ngModules: ngModules,\n    injectables: injectables,\n    exportsNonSourceFiles: exportsNonSourceFiles\n  };\n}\n\nfunction analyzeFileForInjectables(host, staticSymbolResolver, metadataResolver, fileName) {\n  var injectables = [];\n  var shallowModules = [];\n\n  if (staticSymbolResolver.hasDecorators(fileName)) {\n    staticSymbolResolver.getSymbolsOf(fileName).forEach(function (symbol) {\n      var resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\n      var symbolMeta = resolvedSymbol.metadata;\n\n      if (!symbolMeta || symbolMeta.__symbolic === 'error') {\n        return;\n      }\n\n      if (symbolMeta.__symbolic === 'class') {\n        if (metadataResolver.isInjectable(symbol)) {\n          var injectable = metadataResolver.getInjectableMetadata(symbol, null, false);\n\n          if (injectable) {\n            injectables.push(injectable);\n          }\n        } else if (metadataResolver.isNgModule(symbol)) {\n          var module = metadataResolver.getShallowModuleMetadata(symbol);\n\n          if (module) {\n            shallowModules.push(module);\n          }\n        }\n      }\n    });\n  }\n\n  return {\n    fileName: fileName,\n    injectables: injectables,\n    shallowModules: shallowModules\n  };\n}\n\nfunction isValueExportingNonSourceFile(host, metadata) {\n  var exportsNonSourceFiles = false;\n\n  var Visitor = /*#__PURE__*/function () {\n    function Visitor() {\n      _classCallCheck(this, Visitor);\n    }\n\n    _createClass(Visitor, [{\n      key: \"visitArray\",\n      value: function visitArray(arr, context) {\n        var _this282 = this;\n\n        arr.forEach(function (v) {\n          return visitValue(v, _this282, context);\n        });\n      }\n    }, {\n      key: \"visitStringMap\",\n      value: function visitStringMap(map, context) {\n        var _this283 = this;\n\n        Object.keys(map).forEach(function (key) {\n          return visitValue(map[key], _this283, context);\n        });\n      }\n    }, {\n      key: \"visitPrimitive\",\n      value: function visitPrimitive(value, context) {}\n    }, {\n      key: \"visitOther\",\n      value: function visitOther(value, context) {\n        if (value instanceof StaticSymbol && !host.isSourceFile(value.filePath)) {\n          exportsNonSourceFiles = true;\n        }\n      }\n    }]);\n\n    return Visitor;\n  }();\n\n  visitValue(metadata, new Visitor(), null);\n  return exportsNonSourceFiles;\n}\n\nfunction mergeAnalyzedFiles(analyzedFiles) {\n  var allNgModules = [];\n  var ngModuleByPipeOrDirective = new Map();\n  var allPipesAndDirectives = new Set();\n  analyzedFiles.forEach(function (af) {\n    af.ngModules.forEach(function (ngModule) {\n      allNgModules.push(ngModule);\n      ngModule.declaredDirectives.forEach(function (d) {\n        return ngModuleByPipeOrDirective.set(d.reference, ngModule);\n      });\n      ngModule.declaredPipes.forEach(function (p) {\n        return ngModuleByPipeOrDirective.set(p.reference, ngModule);\n      });\n    });\n    af.directives.forEach(function (d) {\n      return allPipesAndDirectives.add(d);\n    });\n    af.pipes.forEach(function (p) {\n      return allPipesAndDirectives.add(p);\n    });\n  });\n  var symbolsMissingModule = [];\n  allPipesAndDirectives.forEach(function (ref) {\n    if (!ngModuleByPipeOrDirective.has(ref)) {\n      symbolsMissingModule.push(ref);\n    }\n  });\n  return {\n    ngModules: allNgModules,\n    ngModuleByPipeOrDirective: ngModuleByPipeOrDirective,\n    symbolsMissingModule: symbolsMissingModule,\n    files: analyzedFiles\n  };\n}\n\nfunction mergeAndValidateNgFiles(files) {\n  return validateAnalyzedModules(mergeAnalyzedFiles(files));\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar FORMATTED_MESSAGE = 'ngFormattedMessage';\n\nfunction indentStr(level) {\n  if (level <= 0) return '';\n  if (level < 6) return ['', ' ', '  ', '   ', '    ', '     '][level];\n  var half = indentStr(Math.floor(level / 2));\n  return half + half + (level % 2 === 1 ? ' ' : '');\n}\n\nfunction formatChain(chain) {\n  var indent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  if (!chain) return '';\n  var position = chain.position ? \"\".concat(chain.position.fileName, \"(\").concat(chain.position.line + 1, \",\").concat(chain.position.column + 1, \")\") : '';\n  var prefix = position && indent === 0 ? \"\".concat(position, \": \") : '';\n  var postfix = position && indent !== 0 ? \" at \".concat(position) : '';\n  var message = \"\".concat(prefix).concat(chain.message).concat(postfix);\n\n  if (chain.next) {\n    var _iterator38 = _createForOfIteratorHelper(chain.next),\n        _step38;\n\n    try {\n      for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {\n        var kid = _step38.value;\n        message += '\\n' + formatChain(kid, indent + 2);\n      }\n    } catch (err) {\n      _iterator38.e(err);\n    } finally {\n      _iterator38.f();\n    }\n  }\n\n  return \"\".concat(indentStr(indent)).concat(message);\n}\n\nfunction formattedError(chain) {\n  var message = formatChain(chain) + '.';\n  var error = syntaxError(message);\n  error[FORMATTED_MESSAGE] = true;\n  error.chain = chain;\n  error.position = chain.position;\n  return error;\n}\n\nfunction isFormattedError(error) {\n  return !!error[FORMATTED_MESSAGE];\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar ANGULAR_CORE = '@angular/core';\nvar ANGULAR_ROUTER = '@angular/router';\nvar HIDDEN_KEY = /^\\$.*\\$$/;\nvar IGNORE = {\n  __symbolic: 'ignore'\n};\nvar USE_VALUE$1 = 'useValue';\nvar PROVIDE = 'provide';\nvar REFERENCE_SET = new Set([USE_VALUE$1, 'useFactory', 'data', 'id', 'loadChildren']);\nvar TYPEGUARD_POSTFIX = 'TypeGuard';\nvar USE_IF = 'UseIf';\n\nfunction shouldIgnore(value) {\n  return value && value.__symbolic == 'ignore';\n}\n/**\r\n * A static reflector implements enough of the Reflector API that is necessary to compile\r\n * templates statically.\r\n */\n\n\nvar StaticReflector = /*#__PURE__*/function () {\n  function StaticReflector(summaryResolver, symbolResolver) {\n    var _this284 = this;\n\n    var knownMetadataClasses = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var knownMetadataFunctions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    var errorRecorder = arguments.length > 4 ? arguments[4] : undefined;\n\n    _classCallCheck(this, StaticReflector);\n\n    this.summaryResolver = summaryResolver;\n    this.symbolResolver = symbolResolver;\n    this.errorRecorder = errorRecorder;\n    this.annotationCache = new Map();\n    this.shallowAnnotationCache = new Map();\n    this.propertyCache = new Map();\n    this.parameterCache = new Map();\n    this.methodCache = new Map();\n    this.staticCache = new Map();\n    this.conversionMap = new Map();\n    this.resolvedExternalReferences = new Map();\n    this.annotationForParentClassWithSummaryKind = new Map();\n    this.initializeConversionMap();\n    knownMetadataClasses.forEach(function (kc) {\n      return _this284._registerDecoratorOrConstructor(_this284.getStaticSymbol(kc.filePath, kc.name), kc.ctor);\n    });\n    knownMetadataFunctions.forEach(function (kf) {\n      return _this284._registerFunction(_this284.getStaticSymbol(kf.filePath, kf.name), kf.fn);\n    });\n    this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Directive, [createDirective, createComponent]);\n    this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Pipe, [createPipe]);\n    this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.NgModule, [createNgModule]);\n    this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Injectable, [createInjectable, createPipe, createDirective, createComponent, createNgModule]);\n  }\n\n  _createClass(StaticReflector, [{\n    key: \"componentModuleUrl\",\n    value: function componentModuleUrl(typeOrFunc) {\n      var staticSymbol = this.findSymbolDeclaration(typeOrFunc);\n      return this.symbolResolver.getResourcePath(staticSymbol);\n    }\n    /**\r\n     * Invalidate the specified `symbols` on program change.\r\n     * @param symbols\r\n     */\n\n  }, {\n    key: \"invalidateSymbols\",\n    value: function invalidateSymbols(symbols) {\n      var _iterator39 = _createForOfIteratorHelper(symbols),\n          _step39;\n\n      try {\n        for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {\n          var symbol = _step39.value;\n          this.annotationCache.delete(symbol);\n          this.shallowAnnotationCache.delete(symbol);\n          this.propertyCache.delete(symbol);\n          this.parameterCache.delete(symbol);\n          this.methodCache.delete(symbol);\n          this.staticCache.delete(symbol);\n          this.conversionMap.delete(symbol);\n        }\n      } catch (err) {\n        _iterator39.e(err);\n      } finally {\n        _iterator39.f();\n      }\n    }\n  }, {\n    key: \"resolveExternalReference\",\n    value: function resolveExternalReference(ref, containingFile) {\n      var key = undefined;\n\n      if (!containingFile) {\n        key = \"\".concat(ref.moduleName, \":\").concat(ref.name);\n\n        var _declarationSymbol = this.resolvedExternalReferences.get(key);\n\n        if (_declarationSymbol) return _declarationSymbol;\n      }\n\n      var refSymbol = this.symbolResolver.getSymbolByModule(ref.moduleName, ref.name, containingFile);\n      var declarationSymbol = this.findSymbolDeclaration(refSymbol);\n\n      if (!containingFile) {\n        this.symbolResolver.recordModuleNameForFileName(refSymbol.filePath, ref.moduleName);\n        this.symbolResolver.recordImportAs(declarationSymbol, refSymbol);\n      }\n\n      if (key) {\n        this.resolvedExternalReferences.set(key, declarationSymbol);\n      }\n\n      return declarationSymbol;\n    }\n  }, {\n    key: \"findDeclaration\",\n    value: function findDeclaration(moduleUrl, name, containingFile) {\n      return this.findSymbolDeclaration(this.symbolResolver.getSymbolByModule(moduleUrl, name, containingFile));\n    }\n  }, {\n    key: \"tryFindDeclaration\",\n    value: function tryFindDeclaration(moduleUrl, name, containingFile) {\n      var _this285 = this;\n\n      return this.symbolResolver.ignoreErrorsFor(function () {\n        return _this285.findDeclaration(moduleUrl, name, containingFile);\n      });\n    }\n  }, {\n    key: \"findSymbolDeclaration\",\n    value: function findSymbolDeclaration(symbol) {\n      var resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\n\n      if (resolvedSymbol) {\n        var resolvedMetadata = resolvedSymbol.metadata;\n\n        if (resolvedMetadata && resolvedMetadata.__symbolic === 'resolved') {\n          resolvedMetadata = resolvedMetadata.symbol;\n        }\n\n        if (resolvedMetadata instanceof StaticSymbol) {\n          return this.findSymbolDeclaration(resolvedSymbol.metadata);\n        }\n      }\n\n      return symbol;\n    }\n  }, {\n    key: \"tryAnnotations\",\n    value: function tryAnnotations(type) {\n      var originalRecorder = this.errorRecorder;\n\n      this.errorRecorder = function (error, fileName) {};\n\n      try {\n        return this.annotations(type);\n      } finally {\n        this.errorRecorder = originalRecorder;\n      }\n    }\n  }, {\n    key: \"annotations\",\n    value: function annotations(type) {\n      var _this286 = this;\n\n      return this._annotations(type, function (type, decorators) {\n        return _this286.simplify(type, decorators);\n      }, this.annotationCache);\n    }\n  }, {\n    key: \"shallowAnnotations\",\n    value: function shallowAnnotations(type) {\n      var _this287 = this;\n\n      return this._annotations(type, function (type, decorators) {\n        return _this287.simplify(type, decorators, true);\n      }, this.shallowAnnotationCache);\n    }\n  }, {\n    key: \"_annotations\",\n    value: function _annotations(type, simplify, annotationCache) {\n      var annotations = annotationCache.get(type);\n\n      if (!annotations) {\n        annotations = [];\n        var classMetadata = this.getTypeMetadata(type);\n        var parentType = this.findParentType(type, classMetadata);\n\n        if (parentType) {\n          var _annotations2;\n\n          var parentAnnotations = this.annotations(parentType);\n\n          (_annotations2 = annotations).push.apply(_annotations2, _toConsumableArray(parentAnnotations));\n        }\n\n        var ownAnnotations = [];\n\n        if (classMetadata['decorators']) {\n          ownAnnotations = simplify(type, classMetadata['decorators']);\n\n          if (ownAnnotations) {\n            var _annotations3;\n\n            (_annotations3 = annotations).push.apply(_annotations3, _toConsumableArray(ownAnnotations));\n          }\n        }\n\n        if (parentType && !this.summaryResolver.isLibraryFile(type.filePath) && this.summaryResolver.isLibraryFile(parentType.filePath)) {\n          var summary = this.summaryResolver.resolveSummary(parentType);\n\n          if (summary && summary.type) {\n            var requiredAnnotationTypes = this.annotationForParentClassWithSummaryKind.get(summary.type.summaryKind);\n            var typeHasRequiredAnnotation = requiredAnnotationTypes.some(function (requiredType) {\n              return ownAnnotations.some(function (ann) {\n                return requiredType.isTypeOf(ann);\n              });\n            });\n\n            if (!typeHasRequiredAnnotation) {\n              this.reportError(formatMetadataError(metadataError(\"Class \".concat(type.name, \" in \").concat(type.filePath, \" extends from a \").concat(CompileSummaryKind[summary.type.summaryKind], \" in another compilation unit without duplicating the decorator\"),\n              /* summary */\n              undefined, \"Please add a \".concat(requiredAnnotationTypes.map(function (type) {\n                return type.ngMetadataName;\n              }).join(' or '), \" decorator to the class\")), type), type);\n            }\n          }\n        }\n\n        annotationCache.set(type, annotations.filter(function (ann) {\n          return !!ann;\n        }));\n      }\n\n      return annotations;\n    }\n  }, {\n    key: \"propMetadata\",\n    value: function propMetadata(type) {\n      var _this288 = this;\n\n      var propMetadata = this.propertyCache.get(type);\n\n      if (!propMetadata) {\n        var classMetadata = this.getTypeMetadata(type);\n        propMetadata = {};\n        var parentType = this.findParentType(type, classMetadata);\n\n        if (parentType) {\n          var parentPropMetadata = this.propMetadata(parentType);\n          Object.keys(parentPropMetadata).forEach(function (parentProp) {\n            propMetadata[parentProp] = parentPropMetadata[parentProp];\n          });\n        }\n\n        var members = classMetadata['members'] || {};\n        Object.keys(members).forEach(function (propName) {\n          var propData = members[propName];\n          var prop = propData.find(function (a) {\n            return a['__symbolic'] == 'property' || a['__symbolic'] == 'method';\n          });\n          var decorators = []; // hasOwnProperty() is used here to make sure we do not look up methods\n          // on `Object.prototype`.\n\n          if (propMetadata === null || propMetadata === void 0 ? void 0 : propMetadata.hasOwnProperty(propName)) {\n            decorators.push.apply(decorators, _toConsumableArray(propMetadata[propName]));\n          }\n\n          propMetadata[propName] = decorators;\n\n          if (prop && prop['decorators']) {\n            decorators.push.apply(decorators, _toConsumableArray(_this288.simplify(type, prop['decorators'])));\n          }\n        });\n        this.propertyCache.set(type, propMetadata);\n      }\n\n      return propMetadata;\n    }\n  }, {\n    key: \"parameters\",\n    value: function parameters(type) {\n      var _this289 = this;\n\n      if (!(type instanceof StaticSymbol)) {\n        this.reportError(new Error(\"parameters received \".concat(JSON.stringify(type), \" which is not a StaticSymbol\")), type);\n        return [];\n      }\n\n      try {\n        var parameters = this.parameterCache.get(type);\n\n        if (!parameters) {\n          var classMetadata = this.getTypeMetadata(type);\n          var parentType = this.findParentType(type, classMetadata);\n          var members = classMetadata ? classMetadata['members'] : null;\n          var ctorData = members ? members['__ctor__'] : null;\n\n          if (ctorData) {\n            var ctor = ctorData.find(function (a) {\n              return a['__symbolic'] == 'constructor';\n            });\n            var rawParameterTypes = ctor['parameters'] || [];\n            var parameterDecorators = this.simplify(type, ctor['parameterDecorators'] || []);\n            parameters = [];\n            rawParameterTypes.forEach(function (rawParamType, index) {\n              var nestedResult = [];\n\n              var paramType = _this289.trySimplify(type, rawParamType);\n\n              if (paramType) nestedResult.push(paramType);\n              var decorators = parameterDecorators ? parameterDecorators[index] : null;\n\n              if (decorators) {\n                nestedResult.push.apply(nestedResult, _toConsumableArray(decorators));\n              }\n\n              parameters.push(nestedResult);\n            });\n          } else if (parentType) {\n            parameters = this.parameters(parentType);\n          }\n\n          if (!parameters) {\n            parameters = [];\n          }\n\n          this.parameterCache.set(type, parameters);\n        }\n\n        return parameters;\n      } catch (e) {\n        console.error(\"Failed on type \".concat(JSON.stringify(type), \" with error \").concat(e));\n        throw e;\n      }\n    }\n  }, {\n    key: \"_methodNames\",\n    value: function _methodNames(type) {\n      var methodNames = this.methodCache.get(type);\n\n      if (!methodNames) {\n        var classMetadata = this.getTypeMetadata(type);\n        methodNames = {};\n        var parentType = this.findParentType(type, classMetadata);\n\n        if (parentType) {\n          var parentMethodNames = this._methodNames(parentType);\n\n          Object.keys(parentMethodNames).forEach(function (parentProp) {\n            methodNames[parentProp] = parentMethodNames[parentProp];\n          });\n        }\n\n        var members = classMetadata['members'] || {};\n        Object.keys(members).forEach(function (propName) {\n          var propData = members[propName];\n          var isMethod = propData.some(function (a) {\n            return a['__symbolic'] == 'method';\n          });\n          methodNames[propName] = methodNames[propName] || isMethod;\n        });\n        this.methodCache.set(type, methodNames);\n      }\n\n      return methodNames;\n    }\n  }, {\n    key: \"_staticMembers\",\n    value: function _staticMembers(type) {\n      var staticMembers = this.staticCache.get(type);\n\n      if (!staticMembers) {\n        var classMetadata = this.getTypeMetadata(type);\n        var staticMemberData = classMetadata['statics'] || {};\n        staticMembers = Object.keys(staticMemberData);\n        this.staticCache.set(type, staticMembers);\n      }\n\n      return staticMembers;\n    }\n  }, {\n    key: \"findParentType\",\n    value: function findParentType(type, classMetadata) {\n      var parentType = this.trySimplify(type, classMetadata['extends']);\n\n      if (parentType instanceof StaticSymbol) {\n        return parentType;\n      }\n    }\n  }, {\n    key: \"hasLifecycleHook\",\n    value: function hasLifecycleHook(type, lcProperty) {\n      if (!(type instanceof StaticSymbol)) {\n        this.reportError(new Error(\"hasLifecycleHook received \".concat(JSON.stringify(type), \" which is not a StaticSymbol\")), type);\n      }\n\n      try {\n        return !!this._methodNames(type)[lcProperty];\n      } catch (e) {\n        console.error(\"Failed on type \".concat(JSON.stringify(type), \" with error \").concat(e));\n        throw e;\n      }\n    }\n  }, {\n    key: \"guards\",\n    value: function guards(type) {\n      if (!(type instanceof StaticSymbol)) {\n        this.reportError(new Error(\"guards received \".concat(JSON.stringify(type), \" which is not a StaticSymbol\")), type);\n        return {};\n      }\n\n      var staticMembers = this._staticMembers(type);\n\n      var result = {};\n\n      var _iterator40 = _createForOfIteratorHelper(staticMembers),\n          _step40;\n\n      try {\n        for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {\n          var name = _step40.value;\n\n          if (name.endsWith(TYPEGUARD_POSTFIX)) {\n            var property = name.substr(0, name.length - TYPEGUARD_POSTFIX.length);\n            var value = void 0;\n\n            if (property.endsWith(USE_IF)) {\n              property = name.substr(0, property.length - USE_IF.length);\n              value = USE_IF;\n            } else {\n              value = this.getStaticSymbol(type.filePath, type.name, [name]);\n            }\n\n            result[property] = value;\n          }\n        }\n      } catch (err) {\n        _iterator40.e(err);\n      } finally {\n        _iterator40.f();\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_registerDecoratorOrConstructor\",\n    value: function _registerDecoratorOrConstructor(type, ctor) {\n      this.conversionMap.set(type, function (context, args) {\n        return _construct(ctor, _toConsumableArray(args));\n      });\n    }\n  }, {\n    key: \"_registerFunction\",\n    value: function _registerFunction(type, fn) {\n      this.conversionMap.set(type, function (context, args) {\n        return fn.apply(undefined, args);\n      });\n    }\n  }, {\n    key: \"initializeConversionMap\",\n    value: function initializeConversionMap() {\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Injectable'), createInjectable);\n\n      this.injectionToken = this.findDeclaration(ANGULAR_CORE, 'InjectionToken');\n      this.opaqueToken = this.findDeclaration(ANGULAR_CORE, 'OpaqueToken');\n      this.ROUTES = this.tryFindDeclaration(ANGULAR_ROUTER, 'ROUTES');\n      this.ANALYZE_FOR_ENTRY_COMPONENTS = this.findDeclaration(ANGULAR_CORE, 'ANALYZE_FOR_ENTRY_COMPONENTS');\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), createHost);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), createSelf);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), createSkipSelf);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Inject'), createInject);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), createOptional);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Attribute'), createAttribute);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChild'), createContentChild);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChildren'), createContentChildren);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChild'), createViewChild);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChildren'), createViewChildren);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Input'), createInput);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Output'), createOutput);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Pipe'), createPipe);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostBinding'), createHostBinding);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostListener'), createHostListener);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Directive'), createDirective);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Component'), createComponent);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'NgModule'), createNgModule); // Note: Some metadata classes can be used directly with Provider.deps.\n\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), createHost);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), createSelf);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), createSkipSelf);\n\n      this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), createOptional);\n    }\n    /**\r\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\r\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\r\n     *\r\n     * @param declarationFile the absolute path of the file where the symbol is declared\r\n     * @param name the name of the type.\r\n     */\n\n  }, {\n    key: \"getStaticSymbol\",\n    value: function getStaticSymbol(declarationFile, name, members) {\n      return this.symbolResolver.getStaticSymbol(declarationFile, name, members);\n    }\n    /**\r\n     * Simplify but discard any errors\r\n     */\n\n  }, {\n    key: \"trySimplify\",\n    value: function trySimplify(context, value) {\n      var originalRecorder = this.errorRecorder;\n\n      this.errorRecorder = function (error, fileName) {};\n\n      var result = this.simplify(context, value);\n      this.errorRecorder = originalRecorder;\n      return result;\n    }\n    /** @internal */\n\n  }, {\n    key: \"simplify\",\n    value: function simplify(context, value) {\n      var lazy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var self = this;\n      var scope = BindingScope$1.empty;\n      var calling = new Map();\n      var rootContext = context;\n\n      function simplifyInContext(context, value, depth, references) {\n        function resolveReferenceValue(staticSymbol) {\n          var resolvedSymbol = self.symbolResolver.resolveSymbol(staticSymbol);\n          return resolvedSymbol ? resolvedSymbol.metadata : null;\n        }\n\n        function simplifyEagerly(value) {\n          return simplifyInContext(context, value, depth, 0);\n        }\n\n        function simplifyLazily(value) {\n          return simplifyInContext(context, value, depth, references + 1);\n        }\n\n        function simplifyNested(nestedContext, value) {\n          if (nestedContext === context) {\n            // If the context hasn't changed let the exception propagate unmodified.\n            return simplifyInContext(nestedContext, value, depth + 1, references);\n          }\n\n          try {\n            return simplifyInContext(nestedContext, value, depth + 1, references);\n          } catch (e) {\n            if (isMetadataError(e)) {\n              // Propagate the message text up but add a message to the chain that explains how we got\n              // here.\n              // e.chain implies e.symbol\n              var summaryMsg = e.chain ? 'references \\'' + e.symbol.name + '\\'' : errorSummary(e);\n              var summary = \"'\".concat(nestedContext.name, \"' \").concat(summaryMsg);\n              var chain = {\n                message: summary,\n                position: e.position,\n                next: e.chain\n              }; // TODO(chuckj): retrieve the position information indirectly from the collectors node\n              // map if the metadata is from a .ts file.\n\n              self.error({\n                message: e.message,\n                advise: e.advise,\n                context: e.context,\n                chain: chain,\n                symbol: nestedContext\n              }, context);\n            } else {\n              // It is probably an internal error.\n              throw e;\n            }\n          }\n        }\n\n        function simplifyCall(functionSymbol, targetFunction, args, targetExpression) {\n          if (targetFunction && targetFunction['__symbolic'] == 'function') {\n            if (calling.get(functionSymbol)) {\n              self.error({\n                message: 'Recursion is not supported',\n                summary: \"called '\".concat(functionSymbol.name, \"' recursively\"),\n                value: targetFunction\n              }, functionSymbol);\n            }\n\n            try {\n              var _value6 = targetFunction['value'];\n\n              if (_value6 && (depth != 0 || _value6.__symbolic != 'error')) {\n                var parameters = targetFunction['parameters'];\n                var defaults = targetFunction.defaults;\n                args = args.map(function (arg) {\n                  return simplifyNested(context, arg);\n                }).map(function (arg) {\n                  return shouldIgnore(arg) ? undefined : arg;\n                });\n\n                if (defaults && defaults.length > args.length) {\n                  var _args3;\n\n                  (_args3 = args).push.apply(_args3, _toConsumableArray(defaults.slice(args.length).map(function (value) {\n                    return simplify(value);\n                  })));\n                }\n\n                calling.set(functionSymbol, true);\n                var functionScope = BindingScope$1.build();\n\n                for (var i = 0; i < parameters.length; i++) {\n                  functionScope.define(parameters[i], args[i]);\n                }\n\n                var oldScope = scope;\n\n                var _result;\n\n                try {\n                  scope = functionScope.done();\n                  _result = simplifyNested(functionSymbol, _value6);\n                } finally {\n                  scope = oldScope;\n                }\n\n                return _result;\n              }\n            } finally {\n              calling.delete(functionSymbol);\n            }\n          }\n\n          if (depth === 0) {\n            // If depth is 0 we are evaluating the top level expression that is describing element\n            // decorator. In this case, it is a decorator we don't understand, such as a custom\n            // non-angular decorator, and we should just ignore it.\n            return IGNORE;\n          }\n\n          var position = undefined;\n\n          if (targetExpression && targetExpression.__symbolic == 'resolved') {\n            var line = targetExpression.line;\n            var character = targetExpression.character;\n            var fileName = targetExpression.fileName;\n\n            if (fileName != null && line != null && character != null) {\n              position = {\n                fileName: fileName,\n                line: line,\n                column: character\n              };\n            }\n          }\n\n          self.error({\n            message: FUNCTION_CALL_NOT_SUPPORTED,\n            context: functionSymbol,\n            value: targetFunction,\n            position: position\n          }, context);\n        }\n\n        function simplify(expression) {\n          if (isPrimitive(expression)) {\n            return expression;\n          }\n\n          if (Array.isArray(expression)) {\n            var _result2 = [];\n\n            var _iterator41 = _createForOfIteratorHelper(expression),\n                _step41;\n\n            try {\n              for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {\n                var item = _step41.value;\n\n                // Check for a spread expression\n                if (item && item.__symbolic === 'spread') {\n                  // We call with references as 0 because we require the actual value and cannot\n                  // tolerate a reference here.\n                  var spreadArray = simplifyEagerly(item.expression);\n\n                  if (Array.isArray(spreadArray)) {\n                    var _iterator42 = _createForOfIteratorHelper(spreadArray),\n                        _step42;\n\n                    try {\n                      for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {\n                        var spreadItem = _step42.value;\n\n                        _result2.push(spreadItem);\n                      }\n                    } catch (err) {\n                      _iterator42.e(err);\n                    } finally {\n                      _iterator42.f();\n                    }\n\n                    continue;\n                  }\n                }\n\n                var _value7 = simplify(item);\n\n                if (shouldIgnore(_value7)) {\n                  continue;\n                }\n\n                _result2.push(_value7);\n              }\n            } catch (err) {\n              _iterator41.e(err);\n            } finally {\n              _iterator41.f();\n            }\n\n            return _result2;\n          }\n\n          if (expression instanceof StaticSymbol) {\n            // Stop simplification at builtin symbols or if we are in a reference context and\n            // the symbol doesn't have members.\n            if (expression === self.injectionToken || self.conversionMap.has(expression) || references > 0 && !expression.members.length) {\n              return expression;\n            } else {\n              var staticSymbol = expression;\n              var declarationValue = resolveReferenceValue(staticSymbol);\n\n              if (declarationValue != null) {\n                return simplifyNested(staticSymbol, declarationValue);\n              } else {\n                return staticSymbol;\n              }\n            }\n          }\n\n          if (expression) {\n            if (expression['__symbolic']) {\n              var _staticSymbol;\n\n              switch (expression['__symbolic']) {\n                case 'binop':\n                  var left = simplify(expression['left']);\n                  if (shouldIgnore(left)) return left;\n                  var right = simplify(expression['right']);\n                  if (shouldIgnore(right)) return right;\n\n                  switch (expression['operator']) {\n                    case '&&':\n                      return left && right;\n\n                    case '||':\n                      return left || right;\n\n                    case '|':\n                      return left | right;\n\n                    case '^':\n                      return left ^ right;\n\n                    case '&':\n                      return left & right;\n\n                    case '==':\n                      return left == right;\n\n                    case '!=':\n                      return left != right;\n\n                    case '===':\n                      return left === right;\n\n                    case '!==':\n                      return left !== right;\n\n                    case '<':\n                      return left < right;\n\n                    case '>':\n                      return left > right;\n\n                    case '<=':\n                      return left <= right;\n\n                    case '>=':\n                      return left >= right;\n\n                    case '<<':\n                      return left << right;\n\n                    case '>>':\n                      return left >> right;\n\n                    case '+':\n                      return left + right;\n\n                    case '-':\n                      return left - right;\n\n                    case '*':\n                      return left * right;\n\n                    case '/':\n                      return left / right;\n\n                    case '%':\n                      return left % right;\n\n                    case '??':\n                      return left !== null && left !== void 0 ? left : right;\n                  }\n\n                  return null;\n\n                case 'if':\n                  var condition = simplify(expression['condition']);\n                  return condition ? simplify(expression['thenExpression']) : simplify(expression['elseExpression']);\n\n                case 'pre':\n                  var operand = simplify(expression['operand']);\n                  if (shouldIgnore(operand)) return operand;\n\n                  switch (expression['operator']) {\n                    case '+':\n                      return operand;\n\n                    case '-':\n                      return -operand;\n\n                    case '!':\n                      return !operand;\n\n                    case '~':\n                      return ~operand;\n                  }\n\n                  return null;\n\n                case 'index':\n                  var indexTarget = simplifyEagerly(expression['expression']);\n                  var index = simplifyEagerly(expression['index']);\n                  if (indexTarget && isPrimitive(index)) return indexTarget[index];\n                  return null;\n\n                case 'select':\n                  var member = expression['member'];\n                  var selectContext = context;\n                  var selectTarget = simplify(expression['expression']);\n\n                  if (selectTarget instanceof StaticSymbol) {\n                    var members = selectTarget.members.concat(member);\n                    selectContext = self.getStaticSymbol(selectTarget.filePath, selectTarget.name, members);\n\n                    var _declarationValue = resolveReferenceValue(selectContext);\n\n                    if (_declarationValue != null) {\n                      return simplifyNested(selectContext, _declarationValue);\n                    } else {\n                      return selectContext;\n                    }\n                  }\n\n                  if (selectTarget && isPrimitive(member)) return simplifyNested(selectContext, selectTarget[member]);\n                  return null;\n\n                case 'reference':\n                  // Note: This only has to deal with variable references, as symbol references have\n                  // been converted into 'resolved'\n                  // in the StaticSymbolResolver.\n                  var name = expression['name'];\n                  var localValue = scope.resolve(name);\n\n                  if (localValue != BindingScope$1.missing) {\n                    return localValue;\n                  }\n\n                  break;\n\n                case 'resolved':\n                  try {\n                    return simplify(expression.symbol);\n                  } catch (e) {\n                    // If an error is reported evaluating the symbol record the position of the\n                    // reference in the error so it can\n                    // be reported in the error message generated from the exception.\n                    if (isMetadataError(e) && expression.fileName != null && expression.line != null && expression.character != null) {\n                      e.position = {\n                        fileName: expression.fileName,\n                        line: expression.line,\n                        column: expression.character\n                      };\n                    }\n\n                    throw e;\n                  }\n\n                case 'class':\n                  return context;\n\n                case 'function':\n                  return context;\n\n                case 'new':\n                case 'call':\n                  // Determine if the function is a built-in conversion\n                  _staticSymbol = simplifyInContext(context, expression['expression'], depth + 1,\n                  /* references */\n                  0);\n\n                  if (_staticSymbol instanceof StaticSymbol) {\n                    if (_staticSymbol === self.injectionToken || _staticSymbol === self.opaqueToken) {\n                      // if somebody calls new InjectionToken, don't create an InjectionToken,\n                      // but rather return the symbol to which the InjectionToken is assigned to.\n                      // OpaqueToken is supported too as it is required by the language service to\n                      // support v4 and prior versions of Angular.\n                      return context;\n                    }\n\n                    var argExpressions = expression['arguments'] || [];\n                    var converter = self.conversionMap.get(_staticSymbol);\n\n                    if (converter) {\n                      var args = argExpressions.map(function (arg) {\n                        return simplifyNested(context, arg);\n                      }).map(function (arg) {\n                        return shouldIgnore(arg) ? undefined : arg;\n                      });\n                      return converter(context, args);\n                    } else {\n                      // Determine if the function is one we can simplify.\n                      var targetFunction = resolveReferenceValue(_staticSymbol);\n                      return simplifyCall(_staticSymbol, targetFunction, argExpressions, expression['expression']);\n                    }\n                  }\n\n                  return IGNORE;\n\n                case 'error':\n                  var message = expression.message;\n\n                  if (expression['line'] != null) {\n                    self.error({\n                      message: message,\n                      context: expression.context,\n                      value: expression,\n                      position: {\n                        fileName: expression['fileName'],\n                        line: expression['line'],\n                        column: expression['character']\n                      }\n                    }, context);\n                  } else {\n                    self.error({\n                      message: message,\n                      context: expression.context\n                    }, context);\n                  }\n\n                  return IGNORE;\n\n                case 'ignore':\n                  return expression;\n              }\n\n              return null;\n            }\n\n            return mapStringMap(expression, function (value, name) {\n              if (REFERENCE_SET.has(name)) {\n                if (name === USE_VALUE$1 && PROVIDE in expression) {\n                  // If this is a provider expression, check for special tokens that need the value\n                  // during analysis.\n                  var provide = simplify(expression.provide);\n\n                  if (provide === self.ROUTES || provide == self.ANALYZE_FOR_ENTRY_COMPONENTS) {\n                    return simplify(value);\n                  }\n                }\n\n                return simplifyLazily(value);\n              }\n\n              return simplify(value);\n            });\n          }\n\n          return IGNORE;\n        }\n\n        return simplify(value);\n      }\n\n      var result;\n\n      try {\n        result = simplifyInContext(context, value, 0, lazy ? 1 : 0);\n      } catch (e) {\n        if (this.errorRecorder) {\n          this.reportError(e, context);\n        } else {\n          throw formatMetadataError(e, context);\n        }\n      }\n\n      if (shouldIgnore(result)) {\n        return undefined;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"getTypeMetadata\",\n    value: function getTypeMetadata(type) {\n      var resolvedSymbol = this.symbolResolver.resolveSymbol(type);\n      return resolvedSymbol && resolvedSymbol.metadata ? resolvedSymbol.metadata : {\n        __symbolic: 'class'\n      };\n    }\n  }, {\n    key: \"reportError\",\n    value: function reportError(error, context, path) {\n      if (this.errorRecorder) {\n        this.errorRecorder(formatMetadataError(error, context), context && context.filePath || path);\n      } else {\n        throw error;\n      }\n    }\n  }, {\n    key: \"error\",\n    value: function error(_ref44, reportingContext) {\n      var message = _ref44.message,\n          summary = _ref44.summary,\n          advise = _ref44.advise,\n          position = _ref44.position,\n          context = _ref44.context,\n          value = _ref44.value,\n          symbol = _ref44.symbol,\n          chain = _ref44.chain;\n      this.reportError(metadataError(message, summary, advise, position, symbol, context, chain), reportingContext);\n    }\n  }]);\n\n  return StaticReflector;\n}();\n\nvar METADATA_ERROR = 'ngMetadataError';\n\nfunction metadataError(message, summary, advise, position, symbol, context, chain) {\n  var error = syntaxError(message);\n  error[METADATA_ERROR] = true;\n  if (advise) error.advise = advise;\n  if (position) error.position = position;\n  if (summary) error.summary = summary;\n  if (context) error.context = context;\n  if (chain) error.chain = chain;\n  if (symbol) error.symbol = symbol;\n  return error;\n}\n\nfunction isMetadataError(error) {\n  return !!error[METADATA_ERROR];\n}\n\nvar REFERENCE_TO_NONEXPORTED_CLASS = 'Reference to non-exported class';\nvar VARIABLE_NOT_INITIALIZED = 'Variable not initialized';\nvar DESTRUCTURE_NOT_SUPPORTED = 'Destructuring not supported';\nvar COULD_NOT_RESOLVE_TYPE = 'Could not resolve type';\nvar FUNCTION_CALL_NOT_SUPPORTED = 'Function call not supported';\nvar REFERENCE_TO_LOCAL_SYMBOL = 'Reference to a local symbol';\nvar LAMBDA_NOT_SUPPORTED = 'Lambda not supported';\n\nfunction expandedMessage(message, context) {\n  switch (message) {\n    case REFERENCE_TO_NONEXPORTED_CLASS:\n      if (context && context.className) {\n        return \"References to a non-exported class are not supported in decorators but \".concat(context.className, \" was referenced.\");\n      }\n\n      break;\n\n    case VARIABLE_NOT_INITIALIZED:\n      return 'Only initialized variables and constants can be referenced in decorators because the value of this variable is needed by the template compiler';\n\n    case DESTRUCTURE_NOT_SUPPORTED:\n      return 'Referencing an exported destructured variable or constant is not supported in decorators and this value is needed by the template compiler';\n\n    case COULD_NOT_RESOLVE_TYPE:\n      if (context && context.typeName) {\n        return \"Could not resolve type \".concat(context.typeName);\n      }\n\n      break;\n\n    case FUNCTION_CALL_NOT_SUPPORTED:\n      if (context && context.name) {\n        return \"Function calls are not supported in decorators but '\".concat(context.name, \"' was called\");\n      }\n\n      return 'Function calls are not supported in decorators';\n\n    case REFERENCE_TO_LOCAL_SYMBOL:\n      if (context && context.name) {\n        return \"Reference to a local (non-exported) symbols are not supported in decorators but '\".concat(context.name, \"' was referenced\");\n      }\n\n      break;\n\n    case LAMBDA_NOT_SUPPORTED:\n      return \"Function expressions are not supported in decorators\";\n  }\n\n  return message;\n}\n\nfunction messageAdvise(message, context) {\n  switch (message) {\n    case REFERENCE_TO_NONEXPORTED_CLASS:\n      if (context && context.className) {\n        return \"Consider exporting '\".concat(context.className, \"'\");\n      }\n\n      break;\n\n    case DESTRUCTURE_NOT_SUPPORTED:\n      return 'Consider simplifying to avoid destructuring';\n\n    case REFERENCE_TO_LOCAL_SYMBOL:\n      if (context && context.name) {\n        return \"Consider exporting '\".concat(context.name, \"'\");\n      }\n\n      break;\n\n    case LAMBDA_NOT_SUPPORTED:\n      return \"Consider changing the function expression into an exported function\";\n  }\n\n  return undefined;\n}\n\nfunction errorSummary(error) {\n  if (error.summary) {\n    return error.summary;\n  }\n\n  switch (error.message) {\n    case REFERENCE_TO_NONEXPORTED_CLASS:\n      if (error.context && error.context.className) {\n        return \"references non-exported class \".concat(error.context.className);\n      }\n\n      break;\n\n    case VARIABLE_NOT_INITIALIZED:\n      return 'is not initialized';\n\n    case DESTRUCTURE_NOT_SUPPORTED:\n      return 'is a destructured variable';\n\n    case COULD_NOT_RESOLVE_TYPE:\n      return 'could not be resolved';\n\n    case FUNCTION_CALL_NOT_SUPPORTED:\n      if (error.context && error.context.name) {\n        return \"calls '\".concat(error.context.name, \"'\");\n      }\n\n      return \"calls a function\";\n\n    case REFERENCE_TO_LOCAL_SYMBOL:\n      if (error.context && error.context.name) {\n        return \"references local variable \".concat(error.context.name);\n      }\n\n      return \"references a local variable\";\n  }\n\n  return 'contains the error';\n}\n\nfunction mapStringMap(input, transform) {\n  if (!input) return {};\n  var result = {};\n  Object.keys(input).forEach(function (key) {\n    var value = transform(input[key], key);\n\n    if (!shouldIgnore(value)) {\n      if (HIDDEN_KEY.test(key)) {\n        Object.defineProperty(result, key, {\n          enumerable: false,\n          configurable: true,\n          value: value\n        });\n      } else {\n        result[key] = value;\n      }\n    }\n  });\n  return result;\n}\n\nfunction isPrimitive(o) {\n  return o === null || typeof o !== 'function' && typeof o !== 'object';\n}\n\nvar BindingScope$1 = /*#__PURE__*/function () {\n  function BindingScope$1() {\n    _classCallCheck(this, BindingScope$1);\n  }\n\n  _createClass(BindingScope$1, null, [{\n    key: \"build\",\n    value: function build() {\n      var current = new Map();\n      return {\n        define: function define(name, value) {\n          current.set(name, value);\n          return this;\n        },\n        done: function done() {\n          return current.size > 0 ? new PopulatedScope(current) : BindingScope$1.empty;\n        }\n      };\n    }\n  }]);\n\n  return BindingScope$1;\n}();\n\nBindingScope$1.missing = {};\nBindingScope$1.empty = {\n  resolve: function resolve(name) {\n    return BindingScope$1.missing;\n  }\n};\n\nvar PopulatedScope = /*#__PURE__*/function (_BindingScope$) {\n  _inherits(PopulatedScope, _BindingScope$);\n\n  var _super111 = _createSuper(PopulatedScope);\n\n  function PopulatedScope(bindings) {\n    var _this290;\n\n    _classCallCheck(this, PopulatedScope);\n\n    _this290 = _super111.call(this);\n    _this290.bindings = bindings;\n    return _this290;\n  }\n\n  _createClass(PopulatedScope, [{\n    key: \"resolve\",\n    value: function resolve(name) {\n      return this.bindings.has(name) ? this.bindings.get(name) : BindingScope$1.missing;\n    }\n  }]);\n\n  return PopulatedScope;\n}(BindingScope$1);\n\nfunction formatMetadataMessageChain(chain, advise) {\n  var expanded = expandedMessage(chain.message, chain.context);\n  var nesting = chain.symbol ? \" in '\".concat(chain.symbol.name, \"'\") : '';\n  var message = \"\".concat(expanded).concat(nesting);\n  var position = chain.position;\n  var next = chain.next ? formatMetadataMessageChain(chain.next, advise) : advise ? {\n    message: advise\n  } : undefined;\n  return {\n    message: message,\n    position: position,\n    next: next ? [next] : undefined\n  };\n}\n\nfunction formatMetadataError(e, context) {\n  if (isMetadataError(e)) {\n    // Produce a formatted version of the and leaving enough information in the original error\n    // to recover the formatting information to eventually produce a diagnostic error message.\n    var position = e.position;\n    var chain = {\n      message: \"Error during template compile of '\".concat(context.name, \"'\"),\n      position: position,\n      next: {\n        message: e.message,\n        next: e.chain,\n        context: e.context,\n        symbol: e.symbol\n      }\n    };\n    var advise = e.advise || messageAdvise(e.message, e.context);\n    return formattedError(formatMetadataMessageChain(chain, advise));\n  }\n\n  return e;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar AotSummaryResolver = /*#__PURE__*/function () {\n  function AotSummaryResolver(host, staticSymbolCache) {\n    _classCallCheck(this, AotSummaryResolver);\n\n    this.host = host;\n    this.staticSymbolCache = staticSymbolCache; // Note: this will only contain StaticSymbols without members!\n\n    this.summaryCache = new Map();\n    this.loadedFilePaths = new Map(); // Note: this will only contain StaticSymbols without members!\n\n    this.importAs = new Map();\n    this.knownFileNameToModuleNames = new Map();\n  }\n\n  _createClass(AotSummaryResolver, [{\n    key: \"isLibraryFile\",\n    value: function isLibraryFile(filePath) {\n      // Note: We need to strip the .ngfactory. file path,\n      // so this method also works for generated files\n      // (for which host.isSourceFile will always return false).\n      return !this.host.isSourceFile(stripGeneratedFileSuffix(filePath));\n    }\n  }, {\n    key: \"toSummaryFileName\",\n    value: function toSummaryFileName(filePath, referringSrcFileName) {\n      return this.host.toSummaryFileName(filePath, referringSrcFileName);\n    }\n  }, {\n    key: \"fromSummaryFileName\",\n    value: function fromSummaryFileName(fileName, referringLibFileName) {\n      return this.host.fromSummaryFileName(fileName, referringLibFileName);\n    }\n  }, {\n    key: \"resolveSummary\",\n    value: function resolveSummary(staticSymbol) {\n      var rootSymbol = staticSymbol.members.length ? this.staticSymbolCache.get(staticSymbol.filePath, staticSymbol.name) : staticSymbol;\n      var summary = this.summaryCache.get(rootSymbol);\n\n      if (!summary) {\n        this._loadSummaryFile(staticSymbol.filePath);\n\n        summary = this.summaryCache.get(staticSymbol);\n      }\n\n      return rootSymbol === staticSymbol && summary || null;\n    }\n  }, {\n    key: \"getSymbolsOf\",\n    value: function getSymbolsOf(filePath) {\n      if (this._loadSummaryFile(filePath)) {\n        return Array.from(this.summaryCache.keys()).filter(function (symbol) {\n          return symbol.filePath === filePath;\n        });\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getImportAs\",\n    value: function getImportAs(staticSymbol) {\n      staticSymbol.assertNoMembers();\n      return this.importAs.get(staticSymbol);\n    }\n    /**\r\n     * Converts a file path to a module name that can be used as an `import`.\r\n     */\n\n  }, {\n    key: \"getKnownModuleName\",\n    value: function getKnownModuleName(importedFilePath) {\n      return this.knownFileNameToModuleNames.get(importedFilePath) || null;\n    }\n  }, {\n    key: \"addSummary\",\n    value: function addSummary(summary) {\n      this.summaryCache.set(summary.symbol, summary);\n    }\n  }, {\n    key: \"_loadSummaryFile\",\n    value: function _loadSummaryFile(filePath) {\n      var _this291 = this;\n\n      var hasSummary = this.loadedFilePaths.get(filePath);\n\n      if (hasSummary != null) {\n        return hasSummary;\n      }\n\n      var json = null;\n\n      if (this.isLibraryFile(filePath)) {\n        var summaryFilePath = summaryFileName(filePath);\n\n        try {\n          json = this.host.loadSummary(summaryFilePath);\n        } catch (e) {\n          console.error(\"Error loading summary file \".concat(summaryFilePath));\n          throw e;\n        }\n      }\n\n      hasSummary = json != null;\n      this.loadedFilePaths.set(filePath, hasSummary);\n\n      if (json) {\n        var _deserializeSummaries = deserializeSummaries(this.staticSymbolCache, this, filePath, json),\n            moduleName = _deserializeSummaries.moduleName,\n            summaries = _deserializeSummaries.summaries,\n            importAs = _deserializeSummaries.importAs;\n\n        summaries.forEach(function (summary) {\n          return _this291.summaryCache.set(summary.symbol, summary);\n        });\n\n        if (moduleName) {\n          this.knownFileNameToModuleNames.set(filePath, moduleName);\n        }\n\n        importAs.forEach(function (importAs) {\n          _this291.importAs.set(importAs.symbol, importAs.importAs);\n        });\n      }\n\n      return hasSummary;\n    }\n  }]);\n\n  return AotSummaryResolver;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nfunction createAotUrlResolver(host) {\n  return {\n    resolve: function resolve(basePath, url) {\n      var filePath = host.resourceNameToFileName(url, basePath);\n\n      if (!filePath) {\n        throw syntaxError(\"Couldn't resolve resource \".concat(url, \" from \").concat(basePath));\n      }\n\n      return filePath;\n    }\n  };\n}\n/**\r\n * Creates a new AotCompiler based on options and a host.\r\n */\n\n\nfunction createAotCompiler(compilerHost, options, errorCollector) {\n  var translations = options.translations || '';\n  var urlResolver = createAotUrlResolver(compilerHost);\n  var symbolCache = new StaticSymbolCache();\n  var summaryResolver = new AotSummaryResolver(compilerHost, symbolCache);\n  var symbolResolver = new StaticSymbolResolver(compilerHost, symbolCache, summaryResolver);\n  var staticReflector = new StaticReflector(summaryResolver, symbolResolver, [], [], errorCollector);\n  var htmlParser;\n\n  if (!!options.enableIvy) {\n    // Ivy handles i18n at the compiler level so we must use a regular parser\n    htmlParser = new HtmlParser();\n  } else {\n    htmlParser = new I18NHtmlParser(new HtmlParser(), translations, options.i18nFormat, options.missingTranslation, console);\n  }\n\n  var config = new CompilerConfig({\n    defaultEncapsulation: ViewEncapsulation.Emulated,\n    useJit: false,\n    missingTranslation: options.missingTranslation,\n    preserveWhitespaces: options.preserveWhitespaces,\n    strictInjectionParameters: options.strictInjectionParameters\n  });\n  var normalizer = new DirectiveNormalizer({\n    get: function get(url) {\n      return compilerHost.loadResource(url);\n    }\n  }, urlResolver, htmlParser, config);\n  var expressionParser = new Parser$1(new Lexer());\n  var elementSchemaRegistry = new DomElementSchemaRegistry();\n  var tmplParser = new TemplateParser(config, staticReflector, expressionParser, elementSchemaRegistry, htmlParser, console, []);\n  var resolver = new CompileMetadataResolver(config, htmlParser, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, console, symbolCache, staticReflector, errorCollector); // TODO(vicb): do not pass options.i18nFormat here\n\n  var viewCompiler = new ViewCompiler(staticReflector);\n  var typeCheckCompiler = new TypeCheckCompiler(options, staticReflector);\n  var compiler = new AotCompiler(config, options, compilerHost, staticReflector, resolver, tmplParser, new StyleCompiler(urlResolver), viewCompiler, typeCheckCompiler, new NgModuleCompiler(staticReflector), new InjectableCompiler(staticReflector, !!options.enableIvy), new TypeScriptEmitter(), summaryResolver, symbolResolver);\n  return {\n    compiler: compiler,\n    reflector: staticReflector\n  };\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar SummaryResolver = function SummaryResolver() {\n  _classCallCheck(this, SummaryResolver);\n};\n\nvar JitSummaryResolver = /*#__PURE__*/function () {\n  function JitSummaryResolver() {\n    _classCallCheck(this, JitSummaryResolver);\n\n    this._summaries = new Map();\n  }\n\n  _createClass(JitSummaryResolver, [{\n    key: \"isLibraryFile\",\n    value: function isLibraryFile() {\n      return false;\n    }\n  }, {\n    key: \"toSummaryFileName\",\n    value: function toSummaryFileName(fileName) {\n      return fileName;\n    }\n  }, {\n    key: \"fromSummaryFileName\",\n    value: function fromSummaryFileName(fileName) {\n      return fileName;\n    }\n  }, {\n    key: \"resolveSummary\",\n    value: function resolveSummary(reference) {\n      return this._summaries.get(reference) || null;\n    }\n  }, {\n    key: \"getSymbolsOf\",\n    value: function getSymbolsOf() {\n      return [];\n    }\n  }, {\n    key: \"getImportAs\",\n    value: function getImportAs(reference) {\n      return reference;\n    }\n  }, {\n    key: \"getKnownModuleName\",\n    value: function getKnownModuleName(fileName) {\n      return null;\n    }\n  }, {\n    key: \"addSummary\",\n    value: function addSummary(summary) {\n      this._summaries.set(summary.symbol, summary);\n    }\n  }]);\n\n  return JitSummaryResolver;\n}();\n\nfunction interpretStatements(statements, reflector) {\n  var ctx = new _ExecutionContext(null, null, null, new Map());\n  var visitor = new StatementInterpreter(reflector);\n  visitor.visitAllStatements(statements, ctx);\n  var result = {};\n  ctx.exports.forEach(function (exportName) {\n    result[exportName] = ctx.vars.get(exportName);\n  });\n  return result;\n}\n\nfunction _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {\n  var childCtx = ctx.createChildWihtLocalVars();\n\n  for (var i = 0; i < varNames.length; i++) {\n    childCtx.vars.set(varNames[i], varValues[i]);\n  }\n\n  var result = visitor.visitAllStatements(statements, childCtx);\n  return result ? result.value : null;\n}\n\nvar _ExecutionContext = /*#__PURE__*/function () {\n  function _ExecutionContext(parent, instance, className, vars) {\n    _classCallCheck(this, _ExecutionContext);\n\n    this.parent = parent;\n    this.instance = instance;\n    this.className = className;\n    this.vars = vars;\n    this.exports = [];\n  }\n\n  _createClass(_ExecutionContext, [{\n    key: \"createChildWihtLocalVars\",\n    value: function createChildWihtLocalVars() {\n      return new _ExecutionContext(this, this.instance, this.className, new Map());\n    }\n  }]);\n\n  return _ExecutionContext;\n}();\n\nvar ReturnValue = function ReturnValue(value) {\n  _classCallCheck(this, ReturnValue);\n\n  this.value = value;\n};\n\nfunction createDynamicClass(_classStmt, _ctx, _visitor) {\n  var propertyDescriptors = {};\n\n  _classStmt.getters.forEach(function (getter) {\n    // Note: use `function` instead of arrow function to capture `this`\n    propertyDescriptors[getter.name] = {\n      configurable: false,\n      get: function get() {\n        var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n        return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);\n      }\n    };\n  });\n\n  _classStmt.methods.forEach(function (method) {\n    var paramNames = method.params.map(function (param) {\n      return param.name;\n    }); // Note: use `function` instead of arrow function to capture `this`\n\n    propertyDescriptors[method.name] = {\n      writable: false,\n      configurable: false,\n      value: function value() {\n        var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n\n        for (var _len5 = arguments.length, args = new Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {\n          args[_key6] = arguments[_key6];\n        }\n\n        return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);\n      }\n    };\n  });\n\n  var ctorParamNames = _classStmt.constructorMethod.params.map(function (param) {\n    return param.name;\n  }); // Note: use `function` instead of arrow function to capture `this`\n\n\n  var ctor = function ctor() {\n    var _this292 = this;\n\n    var instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\n\n    _classStmt.fields.forEach(function (field) {\n      _this292[field.name] = undefined;\n    });\n\n    for (var _len6 = arguments.length, args = new Array(_len6), _key7 = 0; _key7 < _len6; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n\n    _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);\n  };\n\n  var superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;\n  ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);\n  return ctor;\n}\n\nvar StatementInterpreter = /*#__PURE__*/function () {\n  function StatementInterpreter(reflector) {\n    _classCallCheck(this, StatementInterpreter);\n\n    this.reflector = reflector;\n  }\n\n  _createClass(StatementInterpreter, [{\n    key: \"debugAst\",\n    value: function debugAst(ast) {\n      return debugOutputAstAsTypeScript(ast);\n    }\n  }, {\n    key: \"visitDeclareVarStmt\",\n    value: function visitDeclareVarStmt(stmt, ctx) {\n      var initialValue = stmt.value ? stmt.value.visitExpression(this, ctx) : undefined;\n      ctx.vars.set(stmt.name, initialValue);\n\n      if (stmt.hasModifier(StmtModifier.Exported)) {\n        ctx.exports.push(stmt.name);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitWriteVarExpr\",\n    value: function visitWriteVarExpr(expr, ctx) {\n      var value = expr.value.visitExpression(this, ctx);\n      var currCtx = ctx;\n\n      while (currCtx != null) {\n        if (currCtx.vars.has(expr.name)) {\n          currCtx.vars.set(expr.name, value);\n          return value;\n        }\n\n        currCtx = currCtx.parent;\n      }\n\n      throw new Error(\"Not declared variable \".concat(expr.name));\n    }\n  }, {\n    key: \"visitWrappedNodeExpr\",\n    value: function visitWrappedNodeExpr(ast, ctx) {\n      throw new Error('Cannot interpret a WrappedNodeExpr.');\n    }\n  }, {\n    key: \"visitTypeofExpr\",\n    value: function visitTypeofExpr(ast, ctx) {\n      throw new Error('Cannot interpret a TypeofExpr');\n    }\n  }, {\n    key: \"visitReadVarExpr\",\n    value: function visitReadVarExpr(ast, ctx) {\n      var varName = ast.name;\n\n      if (ast.builtin != null) {\n        switch (ast.builtin) {\n          case BuiltinVar.Super:\n            return Object.getPrototypeOf(ctx.instance);\n\n          case BuiltinVar.This:\n            return ctx.instance;\n\n          case BuiltinVar.CatchError:\n            varName = CATCH_ERROR_VAR$2;\n            break;\n\n          case BuiltinVar.CatchStack:\n            varName = CATCH_STACK_VAR$2;\n            break;\n\n          default:\n            throw new Error(\"Unknown builtin variable \".concat(ast.builtin));\n        }\n      }\n\n      var currCtx = ctx;\n\n      while (currCtx != null) {\n        if (currCtx.vars.has(varName)) {\n          return currCtx.vars.get(varName);\n        }\n\n        currCtx = currCtx.parent;\n      }\n\n      throw new Error(\"Not declared variable \".concat(varName));\n    }\n  }, {\n    key: \"visitWriteKeyExpr\",\n    value: function visitWriteKeyExpr(expr, ctx) {\n      var receiver = expr.receiver.visitExpression(this, ctx);\n      var index = expr.index.visitExpression(this, ctx);\n      var value = expr.value.visitExpression(this, ctx);\n      receiver[index] = value;\n      return value;\n    }\n  }, {\n    key: \"visitWritePropExpr\",\n    value: function visitWritePropExpr(expr, ctx) {\n      var receiver = expr.receiver.visitExpression(this, ctx);\n      var value = expr.value.visitExpression(this, ctx);\n      receiver[expr.name] = value;\n      return value;\n    }\n  }, {\n    key: \"visitInvokeMethodExpr\",\n    value: function visitInvokeMethodExpr(expr, ctx) {\n      var receiver = expr.receiver.visitExpression(this, ctx);\n      var args = this.visitAllExpressions(expr.args, ctx);\n      var result;\n\n      if (expr.builtin != null) {\n        switch (expr.builtin) {\n          case BuiltinMethod.ConcatArray:\n            result = receiver.concat.apply(receiver, _toConsumableArray(args));\n            break;\n\n          case BuiltinMethod.SubscribeObservable:\n            result = receiver.subscribe({\n              next: args[0]\n            });\n            break;\n\n          case BuiltinMethod.Bind:\n            result = receiver.bind.apply(receiver, _toConsumableArray(args));\n            break;\n\n          default:\n            throw new Error(\"Unknown builtin method \".concat(expr.builtin));\n        }\n      } else {\n        result = receiver[expr.name].apply(receiver, args);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"visitInvokeFunctionExpr\",\n    value: function visitInvokeFunctionExpr(stmt, ctx) {\n      var args = this.visitAllExpressions(stmt.args, ctx);\n      var fnExpr = stmt.fn;\n\n      if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\n        ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);\n        return null;\n      } else {\n        var _fn = stmt.fn.visitExpression(this, ctx);\n\n        return _fn.apply(null, args);\n      }\n    }\n  }, {\n    key: \"visitTaggedTemplateExpr\",\n    value: function visitTaggedTemplateExpr(expr, ctx) {\n      var templateElements = expr.template.elements.map(function (e) {\n        return e.text;\n      });\n      Object.defineProperty(templateElements, 'raw', {\n        value: expr.template.elements.map(function (e) {\n          return e.rawText;\n        })\n      });\n      var args = this.visitAllExpressions(expr.template.expressions, ctx);\n      args.unshift(templateElements);\n      var tag = expr.tag.visitExpression(this, ctx);\n      return tag.apply(null, args);\n    }\n  }, {\n    key: \"visitReturnStmt\",\n    value: function visitReturnStmt(stmt, ctx) {\n      return new ReturnValue(stmt.value.visitExpression(this, ctx));\n    }\n  }, {\n    key: \"visitDeclareClassStmt\",\n    value: function visitDeclareClassStmt(stmt, ctx) {\n      var clazz = createDynamicClass(stmt, ctx, this);\n      ctx.vars.set(stmt.name, clazz);\n\n      if (stmt.hasModifier(StmtModifier.Exported)) {\n        ctx.exports.push(stmt.name);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitExpressionStmt\",\n    value: function visitExpressionStmt(stmt, ctx) {\n      return stmt.expr.visitExpression(this, ctx);\n    }\n  }, {\n    key: \"visitIfStmt\",\n    value: function visitIfStmt(stmt, ctx) {\n      var condition = stmt.condition.visitExpression(this, ctx);\n\n      if (condition) {\n        return this.visitAllStatements(stmt.trueCase, ctx);\n      } else if (stmt.falseCase != null) {\n        return this.visitAllStatements(stmt.falseCase, ctx);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitTryCatchStmt\",\n    value: function visitTryCatchStmt(stmt, ctx) {\n      try {\n        return this.visitAllStatements(stmt.bodyStmts, ctx);\n      } catch (e) {\n        var childCtx = ctx.createChildWihtLocalVars();\n        childCtx.vars.set(CATCH_ERROR_VAR$2, e);\n        childCtx.vars.set(CATCH_STACK_VAR$2, e.stack);\n        return this.visitAllStatements(stmt.catchStmts, childCtx);\n      }\n    }\n  }, {\n    key: \"visitThrowStmt\",\n    value: function visitThrowStmt(stmt, ctx) {\n      throw stmt.error.visitExpression(this, ctx);\n    }\n  }, {\n    key: \"visitInstantiateExpr\",\n    value: function visitInstantiateExpr(ast, ctx) {\n      var args = this.visitAllExpressions(ast.args, ctx);\n      var clazz = ast.classExpr.visitExpression(this, ctx);\n      return _construct(clazz, _toConsumableArray(args));\n    }\n  }, {\n    key: \"visitLiteralExpr\",\n    value: function visitLiteralExpr(ast, ctx) {\n      return ast.value;\n    }\n  }, {\n    key: \"visitLocalizedString\",\n    value: function visitLocalizedString(ast, context) {\n      return null;\n    }\n  }, {\n    key: \"visitExternalExpr\",\n    value: function visitExternalExpr(ast, ctx) {\n      return this.reflector.resolveExternalReference(ast.value);\n    }\n  }, {\n    key: \"visitConditionalExpr\",\n    value: function visitConditionalExpr(ast, ctx) {\n      if (ast.condition.visitExpression(this, ctx)) {\n        return ast.trueCase.visitExpression(this, ctx);\n      } else if (ast.falseCase != null) {\n        return ast.falseCase.visitExpression(this, ctx);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitNotExpr\",\n    value: function visitNotExpr(ast, ctx) {\n      return !ast.condition.visitExpression(this, ctx);\n    }\n  }, {\n    key: \"visitAssertNotNullExpr\",\n    value: function visitAssertNotNullExpr(ast, ctx) {\n      return ast.condition.visitExpression(this, ctx);\n    }\n  }, {\n    key: \"visitCastExpr\",\n    value: function visitCastExpr(ast, ctx) {\n      return ast.value.visitExpression(this, ctx);\n    }\n  }, {\n    key: \"visitFunctionExpr\",\n    value: function visitFunctionExpr(ast, ctx) {\n      var paramNames = ast.params.map(function (param) {\n        return param.name;\n      });\n      return _declareFn(paramNames, ast.statements, ctx, this);\n    }\n  }, {\n    key: \"visitDeclareFunctionStmt\",\n    value: function visitDeclareFunctionStmt(stmt, ctx) {\n      var paramNames = stmt.params.map(function (param) {\n        return param.name;\n      });\n      ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));\n\n      if (stmt.hasModifier(StmtModifier.Exported)) {\n        ctx.exports.push(stmt.name);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitUnaryOperatorExpr\",\n    value: function visitUnaryOperatorExpr(ast, ctx) {\n      var _this293 = this;\n\n      var rhs = function rhs() {\n        return ast.expr.visitExpression(_this293, ctx);\n      };\n\n      switch (ast.operator) {\n        case UnaryOperator.Plus:\n          return +rhs();\n\n        case UnaryOperator.Minus:\n          return -rhs();\n\n        default:\n          throw new Error(\"Unknown operator \".concat(ast.operator));\n      }\n    }\n  }, {\n    key: \"visitBinaryOperatorExpr\",\n    value: function visitBinaryOperatorExpr(ast, ctx) {\n      var _this294 = this;\n\n      var _a;\n\n      var lhs = function lhs() {\n        return ast.lhs.visitExpression(_this294, ctx);\n      };\n\n      var rhs = function rhs() {\n        return ast.rhs.visitExpression(_this294, ctx);\n      };\n\n      switch (ast.operator) {\n        case BinaryOperator.Equals:\n          return lhs() == rhs();\n\n        case BinaryOperator.Identical:\n          return lhs() === rhs();\n\n        case BinaryOperator.NotEquals:\n          return lhs() != rhs();\n\n        case BinaryOperator.NotIdentical:\n          return lhs() !== rhs();\n\n        case BinaryOperator.And:\n          return lhs() && rhs();\n\n        case BinaryOperator.Or:\n          return lhs() || rhs();\n\n        case BinaryOperator.Plus:\n          return lhs() + rhs();\n\n        case BinaryOperator.Minus:\n          return lhs() - rhs();\n\n        case BinaryOperator.Divide:\n          return lhs() / rhs();\n\n        case BinaryOperator.Multiply:\n          return lhs() * rhs();\n\n        case BinaryOperator.Modulo:\n          return lhs() % rhs();\n\n        case BinaryOperator.Lower:\n          return lhs() < rhs();\n\n        case BinaryOperator.LowerEquals:\n          return lhs() <= rhs();\n\n        case BinaryOperator.Bigger:\n          return lhs() > rhs();\n\n        case BinaryOperator.BiggerEquals:\n          return lhs() >= rhs();\n\n        case BinaryOperator.NullishCoalesce:\n          return (_a = lhs()) !== null && _a !== void 0 ? _a : rhs();\n\n        default:\n          throw new Error(\"Unknown operator \".concat(ast.operator));\n      }\n    }\n  }, {\n    key: \"visitReadPropExpr\",\n    value: function visitReadPropExpr(ast, ctx) {\n      var result;\n      var receiver = ast.receiver.visitExpression(this, ctx);\n      result = receiver[ast.name];\n      return result;\n    }\n  }, {\n    key: \"visitReadKeyExpr\",\n    value: function visitReadKeyExpr(ast, ctx) {\n      var receiver = ast.receiver.visitExpression(this, ctx);\n      var prop = ast.index.visitExpression(this, ctx);\n      return receiver[prop];\n    }\n  }, {\n    key: \"visitLiteralArrayExpr\",\n    value: function visitLiteralArrayExpr(ast, ctx) {\n      return this.visitAllExpressions(ast.entries, ctx);\n    }\n  }, {\n    key: \"visitLiteralMapExpr\",\n    value: function visitLiteralMapExpr(ast, ctx) {\n      var _this295 = this;\n\n      var result = {};\n      ast.entries.forEach(function (entry) {\n        return result[entry.key] = entry.value.visitExpression(_this295, ctx);\n      });\n      return result;\n    }\n  }, {\n    key: \"visitCommaExpr\",\n    value: function visitCommaExpr(ast, context) {\n      var values = this.visitAllExpressions(ast.parts, context);\n      return values[values.length - 1];\n    }\n  }, {\n    key: \"visitAllExpressions\",\n    value: function visitAllExpressions(expressions, ctx) {\n      var _this296 = this;\n\n      return expressions.map(function (expr) {\n        return expr.visitExpression(_this296, ctx);\n      });\n    }\n  }, {\n    key: \"visitAllStatements\",\n    value: function visitAllStatements(statements, ctx) {\n      for (var i = 0; i < statements.length; i++) {\n        var stmt = statements[i];\n        var val = stmt.visitStatement(this, ctx);\n\n        if (val instanceof ReturnValue) {\n          return val;\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return StatementInterpreter;\n}();\n\nfunction _declareFn(varNames, statements, ctx, visitor) {\n  return function () {\n    for (var _len7 = arguments.length, args = new Array(_len7), _key8 = 0; _key8 < _len7; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n\n    return _executeFunctionStatements(varNames, args, statements, ctx, visitor);\n  };\n}\n\nvar CATCH_ERROR_VAR$2 = 'error';\nvar CATCH_STACK_VAR$2 = 'stack';\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * An internal module of the Angular compiler that begins with component types,\r\n * extracts templates, and eventually produces a compiled version of the component\r\n * ready for linking into an application.\r\n *\r\n * @security  When compiling templates at runtime, you must ensure that the entire template comes\r\n * from a trusted source. Attacker-controlled data introduced by a template could expose your\r\n * application to XSS risks.  For more detail, see the [Security Guide](https://g.co/ng/security).\r\n */\n\nvar JitCompiler = /*#__PURE__*/function () {\n  function JitCompiler(_metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _summaryResolver, _reflector, _jitEvaluator, _compilerConfig, _console, getExtraNgModuleProviders) {\n    _classCallCheck(this, JitCompiler);\n\n    this._metadataResolver = _metadataResolver;\n    this._templateParser = _templateParser;\n    this._styleCompiler = _styleCompiler;\n    this._viewCompiler = _viewCompiler;\n    this._ngModuleCompiler = _ngModuleCompiler;\n    this._summaryResolver = _summaryResolver;\n    this._reflector = _reflector;\n    this._jitEvaluator = _jitEvaluator;\n    this._compilerConfig = _compilerConfig;\n    this._console = _console;\n    this.getExtraNgModuleProviders = getExtraNgModuleProviders;\n    this._compiledTemplateCache = new Map();\n    this._compiledHostTemplateCache = new Map();\n    this._compiledDirectiveWrapperCache = new Map();\n    this._compiledNgModuleCache = new Map();\n    this._sharedStylesheetCount = 0;\n    this._addedAotSummaries = new Set();\n  }\n\n  _createClass(JitCompiler, [{\n    key: \"compileModuleSync\",\n    value: function compileModuleSync(moduleType) {\n      return SyncAsync.assertSync(this._compileModuleAndComponents(moduleType, true));\n    }\n  }, {\n    key: \"compileModuleAsync\",\n    value: function compileModuleAsync(moduleType) {\n      return Promise.resolve(this._compileModuleAndComponents(moduleType, false));\n    }\n  }, {\n    key: \"compileModuleAndAllComponentsSync\",\n    value: function compileModuleAndAllComponentsSync(moduleType) {\n      return SyncAsync.assertSync(this._compileModuleAndAllComponents(moduleType, true));\n    }\n  }, {\n    key: \"compileModuleAndAllComponentsAsync\",\n    value: function compileModuleAndAllComponentsAsync(moduleType) {\n      return Promise.resolve(this._compileModuleAndAllComponents(moduleType, false));\n    }\n  }, {\n    key: \"getComponentFactory\",\n    value: function getComponentFactory(component) {\n      var summary = this._metadataResolver.getDirectiveSummary(component);\n\n      return summary.componentFactory;\n    }\n  }, {\n    key: \"loadAotSummaries\",\n    value: function loadAotSummaries(summaries) {\n      this.clearCache();\n\n      this._addAotSummaries(summaries);\n    }\n  }, {\n    key: \"_addAotSummaries\",\n    value: function _addAotSummaries(fn) {\n      if (this._addedAotSummaries.has(fn)) {\n        return;\n      }\n\n      this._addedAotSummaries.add(fn);\n\n      var summaries = fn();\n\n      for (var i = 0; i < summaries.length; i++) {\n        var entry = summaries[i];\n\n        if (typeof entry === 'function') {\n          this._addAotSummaries(entry);\n        } else {\n          var summary = entry;\n\n          this._summaryResolver.addSummary({\n            symbol: summary.type.reference,\n            metadata: null,\n            type: summary\n          });\n        }\n      }\n    }\n  }, {\n    key: \"hasAotSummary\",\n    value: function hasAotSummary(ref) {\n      return !!this._summaryResolver.resolveSummary(ref);\n    }\n  }, {\n    key: \"_filterJitIdentifiers\",\n    value: function _filterJitIdentifiers(ids) {\n      var _this297 = this;\n\n      return ids.map(function (mod) {\n        return mod.reference;\n      }).filter(function (ref) {\n        return !_this297.hasAotSummary(ref);\n      });\n    }\n  }, {\n    key: \"_compileModuleAndComponents\",\n    value: function _compileModuleAndComponents(moduleType, isSync) {\n      var _this298 = this;\n\n      return SyncAsync.then(this._loadModules(moduleType, isSync), function () {\n        _this298._compileComponents(moduleType, null);\n\n        return _this298._compileModule(moduleType);\n      });\n    }\n  }, {\n    key: \"_compileModuleAndAllComponents\",\n    value: function _compileModuleAndAllComponents(moduleType, isSync) {\n      var _this299 = this;\n\n      return SyncAsync.then(this._loadModules(moduleType, isSync), function () {\n        var componentFactories = [];\n\n        _this299._compileComponents(moduleType, componentFactories);\n\n        return {\n          ngModuleFactory: _this299._compileModule(moduleType),\n          componentFactories: componentFactories\n        };\n      });\n    }\n  }, {\n    key: \"_loadModules\",\n    value: function _loadModules(mainModule, isSync) {\n      var _this300 = this;\n\n      var loading = [];\n\n      var mainNgModule = this._metadataResolver.getNgModuleMetadata(mainModule); // Note: for runtime compilation, we want to transitively compile all modules,\n      // so we also need to load the declared directives / pipes for all nested modules.\n\n\n      this._filterJitIdentifiers(mainNgModule.transitiveModule.modules).forEach(function (nestedNgModule) {\n        // getNgModuleMetadata only returns null if the value passed in is not an NgModule\n        var moduleMeta = _this300._metadataResolver.getNgModuleMetadata(nestedNgModule);\n\n        _this300._filterJitIdentifiers(moduleMeta.declaredDirectives).forEach(function (ref) {\n          var promise = _this300._metadataResolver.loadDirectiveMetadata(moduleMeta.type.reference, ref, isSync);\n\n          if (promise) {\n            loading.push(promise);\n          }\n        });\n\n        _this300._filterJitIdentifiers(moduleMeta.declaredPipes).forEach(function (ref) {\n          return _this300._metadataResolver.getOrLoadPipeMetadata(ref);\n        });\n      });\n\n      return SyncAsync.all(loading);\n    }\n  }, {\n    key: \"_compileModule\",\n    value: function _compileModule(moduleType) {\n      var ngModuleFactory = this._compiledNgModuleCache.get(moduleType);\n\n      if (!ngModuleFactory) {\n        var moduleMeta = this._metadataResolver.getNgModuleMetadata(moduleType); // Always provide a bound Compiler\n\n\n        var extraProviders = this.getExtraNgModuleProviders(moduleMeta.type.reference);\n        var outputCtx = createOutputContext();\n\n        var compileResult = this._ngModuleCompiler.compile(outputCtx, moduleMeta, extraProviders);\n\n        ngModuleFactory = this._interpretOrJit(ngModuleJitUrl(moduleMeta), outputCtx.statements)[compileResult.ngModuleFactoryVar];\n\n        this._compiledNgModuleCache.set(moduleMeta.type.reference, ngModuleFactory);\n      }\n\n      return ngModuleFactory;\n    }\n    /**\r\n     * @internal\r\n     */\n\n  }, {\n    key: \"_compileComponents\",\n    value: function _compileComponents(mainModule, allComponentFactories) {\n      var _this301 = this;\n\n      var ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);\n\n      var moduleByJitDirective = new Map();\n      var templates = new Set();\n\n      var transJitModules = this._filterJitIdentifiers(ngModule.transitiveModule.modules);\n\n      transJitModules.forEach(function (localMod) {\n        var localModuleMeta = _this301._metadataResolver.getNgModuleMetadata(localMod);\n\n        _this301._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach(function (dirRef) {\n          moduleByJitDirective.set(dirRef, localModuleMeta);\n\n          var dirMeta = _this301._metadataResolver.getDirectiveMetadata(dirRef);\n\n          if (dirMeta.isComponent) {\n            templates.add(_this301._createCompiledTemplate(dirMeta, localModuleMeta));\n\n            if (allComponentFactories) {\n              var template = _this301._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);\n\n              templates.add(template);\n              allComponentFactories.push(dirMeta.componentFactory);\n            }\n          }\n        });\n      });\n      transJitModules.forEach(function (localMod) {\n        var localModuleMeta = _this301._metadataResolver.getNgModuleMetadata(localMod);\n\n        _this301._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach(function (dirRef) {\n          var dirMeta = _this301._metadataResolver.getDirectiveMetadata(dirRef);\n\n          if (dirMeta.isComponent) {\n            dirMeta.entryComponents.forEach(function (entryComponentType) {\n              var moduleMeta = moduleByJitDirective.get(entryComponentType.componentType);\n              templates.add(_this301._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n            });\n          }\n        });\n\n        localModuleMeta.entryComponents.forEach(function (entryComponentType) {\n          if (!_this301.hasAotSummary(entryComponentType.componentType)) {\n            var moduleMeta = moduleByJitDirective.get(entryComponentType.componentType);\n            templates.add(_this301._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\n          }\n        });\n      });\n      templates.forEach(function (template) {\n        return _this301._compileTemplate(template);\n      });\n    }\n  }, {\n    key: \"clearCacheFor\",\n    value: function clearCacheFor(type) {\n      this._compiledNgModuleCache.delete(type);\n\n      this._metadataResolver.clearCacheFor(type);\n\n      this._compiledHostTemplateCache.delete(type);\n\n      var compiledTemplate = this._compiledTemplateCache.get(type);\n\n      if (compiledTemplate) {\n        this._compiledTemplateCache.delete(type);\n      }\n    }\n  }, {\n    key: \"clearCache\",\n    value: function clearCache() {\n      // Note: don't clear the _addedAotSummaries, as they don't change!\n      this._metadataResolver.clearCache();\n\n      this._compiledTemplateCache.clear();\n\n      this._compiledHostTemplateCache.clear();\n\n      this._compiledNgModuleCache.clear();\n    }\n  }, {\n    key: \"_createCompiledHostTemplate\",\n    value: function _createCompiledHostTemplate(compType, ngModule) {\n      if (!ngModule) {\n        throw new Error(\"Component \".concat(stringify(compType), \" is not part of any NgModule or the module has not been imported into your module.\"));\n      }\n\n      var compiledTemplate = this._compiledHostTemplateCache.get(compType);\n\n      if (!compiledTemplate) {\n        var compMeta = this._metadataResolver.getDirectiveMetadata(compType);\n\n        assertComponent(compMeta);\n\n        var hostMeta = this._metadataResolver.getHostComponentMetadata(compMeta, compMeta.componentFactory.viewDefFactory);\n\n        compiledTemplate = new CompiledTemplate(true, compMeta.type, hostMeta, ngModule, [compMeta.type]);\n\n        this._compiledHostTemplateCache.set(compType, compiledTemplate);\n      }\n\n      return compiledTemplate;\n    }\n  }, {\n    key: \"_createCompiledTemplate\",\n    value: function _createCompiledTemplate(compMeta, ngModule) {\n      var compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);\n\n      if (!compiledTemplate) {\n        assertComponent(compMeta);\n        compiledTemplate = new CompiledTemplate(false, compMeta.type, compMeta, ngModule, ngModule.transitiveModule.directives);\n\n        this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);\n      }\n\n      return compiledTemplate;\n    }\n  }, {\n    key: \"_compileTemplate\",\n    value: function _compileTemplate(template) {\n      var _this302 = this;\n\n      if (template.isCompiled) {\n        return;\n      }\n\n      var compMeta = template.compMeta;\n      var externalStylesheetsByModuleUrl = new Map();\n      var outputContext = createOutputContext();\n\n      var componentStylesheet = this._styleCompiler.compileComponent(outputContext, compMeta);\n\n      compMeta.template.externalStylesheets.forEach(function (stylesheetMeta) {\n        var compiledStylesheet = _this302._styleCompiler.compileStyles(createOutputContext(), compMeta, stylesheetMeta);\n\n        externalStylesheetsByModuleUrl.set(stylesheetMeta.moduleUrl, compiledStylesheet);\n      });\n\n      this._resolveStylesCompileResult(componentStylesheet, externalStylesheetsByModuleUrl);\n\n      var pipes = template.ngModule.transitiveModule.pipes.map(function (pipe) {\n        return _this302._metadataResolver.getPipeSummary(pipe.reference);\n      });\n\n      var _this$_parseTemplate3 = this._parseTemplate(compMeta, template.ngModule, template.directives),\n          parsedTemplate = _this$_parseTemplate3.template,\n          usedPipes = _this$_parseTemplate3.pipes;\n\n      var compileResult = this._viewCompiler.compileComponent(outputContext, compMeta, parsedTemplate, variable(componentStylesheet.stylesVar), usedPipes);\n\n      var evalResult = this._interpretOrJit(templateJitUrl(template.ngModule.type, template.compMeta), outputContext.statements);\n\n      var viewClass = evalResult[compileResult.viewClassVar];\n      var rendererType = evalResult[compileResult.rendererTypeVar];\n      template.compiled(viewClass, rendererType);\n    }\n  }, {\n    key: \"_parseTemplate\",\n    value: function _parseTemplate(compMeta, ngModule, directiveIdentifiers) {\n      var _this303 = this;\n\n      // Note: ! is ok here as components always have a template.\n      var preserveWhitespaces = compMeta.template.preserveWhitespaces;\n      var directives = directiveIdentifiers.map(function (dir) {\n        return _this303._metadataResolver.getDirectiveSummary(dir.reference);\n      });\n      var pipes = ngModule.transitiveModule.pipes.map(function (pipe) {\n        return _this303._metadataResolver.getPipeSummary(pipe.reference);\n      });\n      return this._templateParser.parse(compMeta, compMeta.template.htmlAst, directives, pipes, ngModule.schemas, templateSourceUrl(ngModule.type, compMeta, compMeta.template), preserveWhitespaces);\n    }\n  }, {\n    key: \"_resolveStylesCompileResult\",\n    value: function _resolveStylesCompileResult(result, externalStylesheetsByModuleUrl) {\n      var _this304 = this;\n\n      result.dependencies.forEach(function (dep, i) {\n        var nestedCompileResult = externalStylesheetsByModuleUrl.get(dep.moduleUrl);\n\n        var nestedStylesArr = _this304._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);\n\n        dep.setValue(nestedStylesArr);\n      });\n    }\n  }, {\n    key: \"_resolveAndEvalStylesCompileResult\",\n    value: function _resolveAndEvalStylesCompileResult(result, externalStylesheetsByModuleUrl) {\n      this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);\n\n      return this._interpretOrJit(sharedStylesheetJitUrl(result.meta, this._sharedStylesheetCount++), result.outputCtx.statements)[result.stylesVar];\n    }\n  }, {\n    key: \"_interpretOrJit\",\n    value: function _interpretOrJit(sourceUrl, statements) {\n      if (!this._compilerConfig.useJit) {\n        return interpretStatements(statements, this._reflector);\n      } else {\n        return this._jitEvaluator.evaluateStatements(sourceUrl, statements, this._reflector, this._compilerConfig.jitDevMode);\n      }\n    }\n  }]);\n\n  return JitCompiler;\n}();\n\nvar CompiledTemplate = /*#__PURE__*/function () {\n  function CompiledTemplate(isHost, compType, compMeta, ngModule, directives) {\n    _classCallCheck(this, CompiledTemplate);\n\n    this.isHost = isHost;\n    this.compType = compType;\n    this.compMeta = compMeta;\n    this.ngModule = ngModule;\n    this.directives = directives;\n    this._viewClass = null;\n    this.isCompiled = false;\n  }\n\n  _createClass(CompiledTemplate, [{\n    key: \"compiled\",\n    value: function compiled(viewClass, rendererType) {\n      this._viewClass = viewClass;\n      this.compMeta.componentViewType.setDelegate(viewClass);\n\n      for (var prop in rendererType) {\n        this.compMeta.rendererType[prop] = rendererType[prop];\n      }\n\n      this.isCompiled = true;\n    }\n  }]);\n\n  return CompiledTemplate;\n}();\n\nfunction assertComponent(meta) {\n  if (!meta.isComponent) {\n    throw new Error(\"Could not compile '\".concat(identifierName(meta.type), \"' because it is not a component.\"));\n  }\n}\n\nfunction createOutputContext() {\n  var importExpr$1 = function importExpr$1(symbol) {\n    return importExpr({\n      name: identifierName(symbol),\n      moduleName: null,\n      runtime: symbol\n    });\n  };\n\n  return {\n    statements: [],\n    genFilePath: '',\n    importExpr: importExpr$1,\n    constantPool: new ConstantPool()\n  };\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Provides access to reflection data about symbols that the compiler needs.\r\n */\n\n\nvar CompileReflector = function CompileReflector() {\n  _classCallCheck(this, CompileReflector);\n};\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Create a {@link UrlResolver} with no package prefix.\r\n */\n\n\nfunction createUrlResolverWithoutPackagePrefix() {\n  return new UrlResolver();\n}\n\nfunction createOfflineCompileUrlResolver() {\n  return new UrlResolver('.');\n}\n\nvar UrlResolver = /*#__PURE__*/function () {\n  function UrlResolverImpl() {\n    var _packagePrefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, UrlResolverImpl);\n\n    this._packagePrefix = _packagePrefix;\n  }\n  /**\r\n   * Resolves the `url` given the `baseUrl`:\r\n   * - when the `url` is null, the `baseUrl` is returned,\r\n   * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of\r\n   * `baseUrl` and `url`,\r\n   * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is\r\n   * returned as is (ignoring the `baseUrl`)\r\n   */\n\n\n  _createClass(UrlResolverImpl, [{\n    key: \"resolve\",\n    value: function resolve(baseUrl, url) {\n      var resolvedUrl = url;\n\n      if (baseUrl != null && baseUrl.length > 0) {\n        resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);\n      }\n\n      var resolvedParts = _split(resolvedUrl);\n\n      var prefix = this._packagePrefix;\n\n      if (prefix != null && resolvedParts != null && resolvedParts[_ComponentIndex.Scheme] == 'package') {\n        var path = resolvedParts[_ComponentIndex.Path];\n        prefix = prefix.replace(/\\/+$/, '');\n        path = path.replace(/^\\/+/, '');\n        return \"\".concat(prefix, \"/\").concat(path);\n      }\n\n      return resolvedUrl;\n    }\n  }]);\n\n  return UrlResolverImpl;\n}();\n/**\r\n * Extract the scheme of a URL.\r\n */\n\n\nfunction getUrlScheme(url) {\n  var match = _split(url);\n\n  return match && match[_ComponentIndex.Scheme] || '';\n} // The code below is adapted from Traceur:\n// https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js\n\n/**\r\n * Builds a URI string from already-encoded parts.\r\n *\r\n * No encoding is performed.  Any component may be omitted as either null or\r\n * undefined.\r\n *\r\n * @param opt_scheme The scheme such as 'http'.\r\n * @param opt_userInfo The user name before the '@'.\r\n * @param opt_domain The domain such as 'www.google.com', already\r\n *     URI-encoded.\r\n * @param opt_port The port number.\r\n * @param opt_path The path, already URI-encoded.  If it is not\r\n *     empty, it must begin with a slash.\r\n * @param opt_queryData The URI-encoded query data.\r\n * @param opt_fragment The URI-encoded fragment identifier.\r\n * @return The fully combined URI.\r\n */\n\n\nfunction _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\n  var out = [];\n\n  if (opt_scheme != null) {\n    out.push(opt_scheme + ':');\n  }\n\n  if (opt_domain != null) {\n    out.push('//');\n\n    if (opt_userInfo != null) {\n      out.push(opt_userInfo + '@');\n    }\n\n    out.push(opt_domain);\n\n    if (opt_port != null) {\n      out.push(':' + opt_port);\n    }\n  }\n\n  if (opt_path != null) {\n    out.push(opt_path);\n  }\n\n  if (opt_queryData != null) {\n    out.push('?' + opt_queryData);\n  }\n\n  if (opt_fragment != null) {\n    out.push('#' + opt_fragment);\n  }\n\n  return out.join('');\n}\n/**\r\n * A regular expression for breaking a URI into its component parts.\r\n *\r\n * {@link https://tools.ietf.org/html/rfc3986#appendix-B} says\r\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\r\n * disambiguation method used by POSIX regular expressions, it is natural and\r\n * commonplace to use a regular expression for parsing the potential five\r\n * components of a URI reference.\r\n *\r\n * The following line is the regular expression for breaking-down a\r\n * well-formed URI reference into its components.\r\n *\r\n * <pre>\r\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\r\n *  12            3  4          5       6  7        8 9\r\n * </pre>\r\n *\r\n * The numbers in the second line above are only to assist readability; they\r\n * indicate the reference points for each subexpression (i.e., each paired\r\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\r\n * For example, matching the above expression to\r\n * <pre>\r\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\r\n * </pre>\r\n * results in the following subexpression matches:\r\n * <pre>\r\n *    $1 = http:\r\n *    $2 = http\r\n *    $3 = //www.ics.uci.edu\r\n *    $4 = www.ics.uci.edu\r\n *    $5 = /pub/ietf/uri/\r\n *    $6 = <undefined>\r\n *    $7 = <undefined>\r\n *    $8 = #Related\r\n *    $9 = Related\r\n * </pre>\r\n * where <undefined> indicates that the component is not present, as is the\r\n * case for the query component in the above example. Therefore, we can\r\n * determine the value of the five components as\r\n * <pre>\r\n *    scheme    = $2\r\n *    authority = $4\r\n *    path      = $5\r\n *    query     = $7\r\n *    fragment  = $9\r\n * </pre>\r\n *\r\n * The regular expression has been modified slightly to expose the\r\n * userInfo, domain, and port separately from the authority.\r\n * The modified version yields\r\n * <pre>\r\n *    $1 = http              scheme\r\n *    $2 = <undefined>       userInfo -\\\r\n *    $3 = www.ics.uci.edu   domain     | authority\r\n *    $4 = <undefined>       port     -/\r\n *    $5 = /pub/ietf/uri/    path\r\n *    $6 = <undefined>       query without ?\r\n *    $7 = Related           fragment without #\r\n * </pre>\r\n * @internal\r\n */\n\n\nvar _splitRe = new RegExp('^' + '(?:' + '([^:/?#.]+)' + // scheme - ignore special characters\n// used by other URL parts such as :,\n// ?, /, #, and .\n':)?' + '(?://' + '(?:([^/?#]*)@)?' + // userInfo\n\"([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)\" + // domain - restrict to letters,\n// digits, dashes, dots, percent\n// escapes, and unicode characters.\n'(?::([0-9]+))?' + // port\n')?' + '([^?#]+)?' + // path\n'(?:\\\\?([^#]*))?' + // query\n'(?:#(.*))?' + // fragment\n'$');\n/**\r\n * The index of each URI component in the return value of goog.uri.utils.split.\r\n * @enum {number}\r\n */\n\n\nvar _ComponentIndex;\n\n(function (_ComponentIndex) {\n  _ComponentIndex[_ComponentIndex[\"Scheme\"] = 1] = \"Scheme\";\n  _ComponentIndex[_ComponentIndex[\"UserInfo\"] = 2] = \"UserInfo\";\n  _ComponentIndex[_ComponentIndex[\"Domain\"] = 3] = \"Domain\";\n  _ComponentIndex[_ComponentIndex[\"Port\"] = 4] = \"Port\";\n  _ComponentIndex[_ComponentIndex[\"Path\"] = 5] = \"Path\";\n  _ComponentIndex[_ComponentIndex[\"QueryData\"] = 6] = \"QueryData\";\n  _ComponentIndex[_ComponentIndex[\"Fragment\"] = 7] = \"Fragment\";\n})(_ComponentIndex || (_ComponentIndex = {}));\n/**\r\n * Splits a URI into its component parts.\r\n *\r\n * Each component can be accessed via the component indices; for example:\r\n * <pre>\r\n * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];\r\n * </pre>\r\n *\r\n * @param uri The URI string to examine.\r\n * @return Each component still URI-encoded.\r\n *     Each component that is present will contain the encoded value, whereas\r\n *     components that are not present will be undefined or empty, depending\r\n *     on the browser's regular expression implementation.  Never null, since\r\n *     arbitrary strings may still look like path names.\r\n */\n\n\nfunction _split(uri) {\n  return uri.match(_splitRe);\n}\n/**\r\n * Removes dot segments in given path component, as described in\r\n * RFC 3986, section 5.2.4.\r\n *\r\n * @param path A non-empty path component.\r\n * @return Path component with removed dot segments.\r\n */\n\n\nfunction _removeDotSegments(path) {\n  if (path == '/') return '/';\n  var leadingSlash = path[0] == '/' ? '/' : '';\n  var trailingSlash = path[path.length - 1] === '/' ? '/' : '';\n  var segments = path.split('/');\n  var out = [];\n  var up = 0;\n\n  for (var pos = 0; pos < segments.length; pos++) {\n    var segment = segments[pos];\n\n    switch (segment) {\n      case '':\n      case '.':\n        break;\n\n      case '..':\n        if (out.length > 0) {\n          out.pop();\n        } else {\n          up++;\n        }\n\n        break;\n\n      default:\n        out.push(segment);\n    }\n  }\n\n  if (leadingSlash == '') {\n    while (up-- > 0) {\n      out.unshift('..');\n    }\n\n    if (out.length === 0) out.push('.');\n  }\n\n  return leadingSlash + out.join('/') + trailingSlash;\n}\n/**\r\n * Takes an array of the parts from split and canonicalizes the path part\r\n * and then joins all the parts.\r\n */\n\n\nfunction _joinAndCanonicalizePath(parts) {\n  var path = parts[_ComponentIndex.Path];\n  path = path == null ? '' : _removeDotSegments(path);\n  parts[_ComponentIndex.Path] = path;\n  return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);\n}\n/**\r\n * Resolves a URL.\r\n * @param base The URL acting as the base URL.\r\n * @param to The URL to resolve.\r\n */\n\n\nfunction _resolveUrl(base, url) {\n  var parts = _split(encodeURI(url));\n\n  var baseParts = _split(base);\n\n  if (parts[_ComponentIndex.Scheme] != null) {\n    return _joinAndCanonicalizePath(parts);\n  } else {\n    parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];\n  }\n\n  for (var i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {\n    if (parts[i] == null) {\n      parts[i] = baseParts[i];\n    }\n  }\n\n  if (parts[_ComponentIndex.Path][0] == '/') {\n    return _joinAndCanonicalizePath(parts);\n  }\n\n  var path = baseParts[_ComponentIndex.Path];\n  if (path == null) path = '/';\n  var index = path.lastIndexOf('/');\n  path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];\n  parts[_ComponentIndex.Path] = path;\n  return _joinAndCanonicalizePath(parts);\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar Extractor = /*#__PURE__*/function () {\n  function Extractor(host, staticSymbolResolver, messageBundle, metadataResolver) {\n    _classCallCheck(this, Extractor);\n\n    this.host = host;\n    this.staticSymbolResolver = staticSymbolResolver;\n    this.messageBundle = messageBundle;\n    this.metadataResolver = metadataResolver;\n  }\n\n  _createClass(Extractor, [{\n    key: \"extract\",\n    value: function extract(rootFiles) {\n      var _this305 = this;\n\n      var _analyzeAndValidateNg = analyzeAndValidateNgModules(rootFiles, this.host, this.staticSymbolResolver, this.metadataResolver),\n          files = _analyzeAndValidateNg.files,\n          ngModules = _analyzeAndValidateNg.ngModules;\n\n      return Promise.all(ngModules.map(function (ngModule) {\n        return _this305.metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false);\n      })).then(function () {\n        var errors = [];\n        files.forEach(function (file) {\n          var compMetas = [];\n          file.directives.forEach(function (directiveType) {\n            var dirMeta = _this305.metadataResolver.getDirectiveMetadata(directiveType);\n\n            if (dirMeta && dirMeta.isComponent) {\n              compMetas.push(dirMeta);\n            }\n          });\n          compMetas.forEach(function (compMeta) {\n            var html = compMeta.template.template; // Template URL points to either an HTML or TS file depending on\n            // whether the file is used with `templateUrl:` or `template:`,\n            // respectively.\n\n            var templateUrl = compMeta.template.templateUrl;\n            var interpolationConfig = InterpolationConfig.fromArray(compMeta.template.interpolation);\n            errors.push.apply(errors, _toConsumableArray(_this305.messageBundle.updateFromTemplate(html, templateUrl, interpolationConfig)));\n          });\n        });\n\n        if (errors.length) {\n          throw new Error(errors.map(function (e) {\n            return e.toString();\n          }).join('\\n'));\n        }\n\n        return _this305.messageBundle;\n      });\n    }\n  }], [{\n    key: \"create\",\n    value: function create(host, locale) {\n      var htmlParser = new HtmlParser();\n      var urlResolver = createAotUrlResolver(host);\n      var symbolCache = new StaticSymbolCache();\n      var summaryResolver = new AotSummaryResolver(host, symbolCache);\n      var staticSymbolResolver = new StaticSymbolResolver(host, symbolCache, summaryResolver);\n      var staticReflector = new StaticReflector(summaryResolver, staticSymbolResolver);\n      var config = new CompilerConfig({\n        defaultEncapsulation: ViewEncapsulation.Emulated,\n        useJit: false\n      });\n      var normalizer = new DirectiveNormalizer({\n        get: function get(url) {\n          return host.loadResource(url);\n        }\n      }, urlResolver, htmlParser, config);\n      var elementSchemaRegistry = new DomElementSchemaRegistry();\n      var resolver = new CompileMetadataResolver(config, htmlParser, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, console, symbolCache, staticReflector); // TODO(vicb): implicit tags & attributes\n\n      var messageBundle = new MessageBundle(htmlParser, [], {}, locale);\n      var extractor = new Extractor(host, staticSymbolResolver, messageBundle, resolver);\n      return {\n        extractor: extractor,\n        staticReflector: staticReflector\n      };\n    }\n  }]);\n\n  return Extractor;\n}();\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nvar FactoryTarget$1;\n\n(function (FactoryTarget) {\n  FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n  FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\n  FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n  FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n  FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(FactoryTarget$1 || (FactoryTarget$1 = {}));\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Processes `Target`s with a given set of directives and performs a binding operation, which\r\n * returns an object similar to TypeScript's `ts.TypeChecker` that contains knowledge about the\r\n * target.\r\n */\n\n\nvar R3TargetBinder = /*#__PURE__*/function () {\n  function R3TargetBinder(directiveMatcher) {\n    _classCallCheck(this, R3TargetBinder);\n\n    this.directiveMatcher = directiveMatcher;\n  }\n  /**\r\n   * Perform a binding operation on the given `Target` and return a `BoundTarget` which contains\r\n   * metadata about the types referenced in the template.\r\n   */\n\n\n  _createClass(R3TargetBinder, [{\n    key: \"bind\",\n    value: function bind(target) {\n      if (!target.template) {\n        // TODO(alxhub): handle targets which contain things like HostBindings, etc.\n        throw new Error('Binding without a template not yet supported');\n      } // First, parse the template into a `Scope` structure. This operation captures the syntactic\n      // scopes in the template and makes them available for later use.\n\n\n      var scope = Scope.apply(target.template); // Use the `Scope` to extract the entities present at every level of the template.\n\n      var templateEntities = extractTemplateEntities(scope); // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:\n      //   - directives: Map of nodes (elements & ng-templates) to the directives on them.\n      //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims\n      //     them. TODO(alxhub): handle multiple directives claiming an input/output/etc.\n      //   - references: Map of #references to their targets.\n\n      var _DirectiveBinder$appl = DirectiveBinder.apply(target.template, this.directiveMatcher),\n          directives = _DirectiveBinder$appl.directives,\n          bindings = _DirectiveBinder$appl.bindings,\n          references = _DirectiveBinder$appl.references; // Finally, run the TemplateBinder to bind references, variables, and other entities within the\n      // template. This extracts all the metadata that doesn't depend on directive matching.\n\n\n      var _TemplateBinder$apply = TemplateBinder.apply(target.template, scope),\n          expressions = _TemplateBinder$apply.expressions,\n          symbols = _TemplateBinder$apply.symbols,\n          nestingLevel = _TemplateBinder$apply.nestingLevel,\n          usedPipes = _TemplateBinder$apply.usedPipes;\n\n      return new R3BoundTarget(target, directives, bindings, references, expressions, symbols, nestingLevel, templateEntities, usedPipes);\n    }\n  }]);\n\n  return R3TargetBinder;\n}();\n/**\r\n * Represents a binding scope within a template.\r\n *\r\n * Any variables, references, or other named entities declared within the template will\r\n * be captured and available by name in `namedEntities`. Additionally, child templates will\r\n * be analyzed and have their child `Scope`s available in `childScopes`.\r\n */\n\n\nvar Scope = /*#__PURE__*/function () {\n  function Scope(parentScope, template) {\n    _classCallCheck(this, Scope);\n\n    this.parentScope = parentScope;\n    this.template = template;\n    /**\r\n     * Named members of the `Scope`, such as `Reference`s or `Variable`s.\r\n     */\n\n    this.namedEntities = new Map();\n    /**\r\n     * Child `Scope`s for immediately nested `Template`s.\r\n     */\n\n    this.childScopes = new Map();\n  }\n\n  _createClass(Scope, [{\n    key: \"ingest\",\n    value:\n    /**\r\n     * Internal method to process the template and populate the `Scope`.\r\n     */\n    function ingest(template) {\n      var _this306 = this;\n\n      if (template instanceof Template) {\n        // Variables on an <ng-template> are defined in the inner scope.\n        template.variables.forEach(function (node) {\n          return _this306.visitVariable(node);\n        }); // Process the nodes of the template.\n\n        template.children.forEach(function (node) {\n          return node.visit(_this306);\n        });\n      } else {\n        // No overarching `Template` instance, so process the nodes directly.\n        template.forEach(function (node) {\n          return node.visit(_this306);\n        });\n      }\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(element) {\n      var _this307 = this;\n\n      // `Element`s in the template may have `Reference`s which are captured in the scope.\n      element.references.forEach(function (node) {\n        return _this307.visitReference(node);\n      }); // Recurse into the `Element`'s children.\n\n      element.children.forEach(function (node) {\n        return node.visit(_this307);\n      });\n    }\n  }, {\n    key: \"visitTemplate\",\n    value: function visitTemplate(template) {\n      var _this308 = this;\n\n      // References on a <ng-template> are defined in the outer scope, so capture them before\n      // processing the template's child scope.\n      template.references.forEach(function (node) {\n        return _this308.visitReference(node);\n      }); // Next, create an inner scope and process the template within it.\n\n      var scope = new Scope(this, template);\n      scope.ingest(template);\n      this.childScopes.set(template, scope);\n    }\n  }, {\n    key: \"visitVariable\",\n    value: function visitVariable(variable) {\n      // Declare the variable if it's not already.\n      this.maybeDeclare(variable);\n    }\n  }, {\n    key: \"visitReference\",\n    value: function visitReference(reference) {\n      // Declare the variable if it's not already.\n      this.maybeDeclare(reference);\n    } // Unused visitors.\n\n  }, {\n    key: \"visitContent\",\n    value: function visitContent(content) {}\n  }, {\n    key: \"visitBoundAttribute\",\n    value: function visitBoundAttribute(attr) {}\n  }, {\n    key: \"visitBoundEvent\",\n    value: function visitBoundEvent(event) {}\n  }, {\n    key: \"visitBoundText\",\n    value: function visitBoundText(text) {}\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {}\n  }, {\n    key: \"visitTextAttribute\",\n    value: function visitTextAttribute(attr) {}\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu) {}\n  }, {\n    key: \"maybeDeclare\",\n    value: function maybeDeclare(thing) {\n      // Declare something with a name, as long as that name isn't taken.\n      if (!this.namedEntities.has(thing.name)) {\n        this.namedEntities.set(thing.name, thing);\n      }\n    }\n    /**\r\n     * Look up a variable within this `Scope`.\r\n     *\r\n     * This can recurse into a parent `Scope` if it's available.\r\n     */\n\n  }, {\n    key: \"lookup\",\n    value: function lookup(name) {\n      if (this.namedEntities.has(name)) {\n        // Found in the local scope.\n        return this.namedEntities.get(name);\n      } else if (this.parentScope !== null) {\n        // Not in the local scope, but there's a parent scope so check there.\n        return this.parentScope.lookup(name);\n      } else {\n        // At the top level and it wasn't found.\n        return null;\n      }\n    }\n    /**\r\n     * Get the child scope for a `Template`.\r\n     *\r\n     * This should always be defined.\r\n     */\n\n  }, {\n    key: \"getChildScope\",\n    value: function getChildScope(template) {\n      var res = this.childScopes.get(template);\n\n      if (res === undefined) {\n        throw new Error(\"Assertion error: child scope for \".concat(template, \" not found\"));\n      }\n\n      return res;\n    }\n  }], [{\n    key: \"newRootScope\",\n    value: function newRootScope() {\n      return new Scope(null, null);\n    }\n    /**\r\n     * Process a template (either as a `Template` sub-template with variables, or a plain array of\r\n     * template `Node`s) and construct its `Scope`.\r\n     */\n\n  }, {\n    key: \"apply\",\n    value: function apply(template) {\n      var scope = Scope.newRootScope();\n      scope.ingest(template);\n      return scope;\n    }\n  }]);\n\n  return Scope;\n}();\n/**\r\n * Processes a template and matches directives on nodes (elements and templates).\r\n *\r\n * Usually used via the static `apply()` method.\r\n */\n\n\nvar DirectiveBinder = /*#__PURE__*/function () {\n  function DirectiveBinder(matcher, directives, bindings, references) {\n    _classCallCheck(this, DirectiveBinder);\n\n    this.matcher = matcher;\n    this.directives = directives;\n    this.bindings = bindings;\n    this.references = references;\n  }\n  /**\r\n   * Process a template (list of `Node`s) and perform directive matching against each node.\r\n   *\r\n   * @param template the list of template `Node`s to match (recursively).\r\n   * @param selectorMatcher a `SelectorMatcher` containing the directives that are in scope for\r\n   * this template.\r\n   * @returns three maps which contain information about directives in the template: the\r\n   * `directives` map which lists directives matched on each node, the `bindings` map which\r\n   * indicates which directives claimed which bindings (inputs, outputs, etc), and the `references`\r\n   * map which resolves #references (`Reference`s) within the template to the named directive or\r\n   * template node.\r\n   */\n\n\n  _createClass(DirectiveBinder, [{\n    key: \"ingest\",\n    value: function ingest(template) {\n      var _this309 = this;\n\n      template.forEach(function (node) {\n        return node.visit(_this309);\n      });\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(element) {\n      this.visitElementOrTemplate(element.name, element);\n    }\n  }, {\n    key: \"visitTemplate\",\n    value: function visitTemplate(template) {\n      this.visitElementOrTemplate('ng-template', template);\n    }\n  }, {\n    key: \"visitElementOrTemplate\",\n    value: function visitElementOrTemplate(elementName, node) {\n      var _this310 = this;\n\n      // First, determine the HTML shape of the node for the purpose of directive matching.\n      // Do this by building up a `CssSelector` for the node.\n      var cssSelector = createCssSelector(elementName, getAttrsForDirectiveMatching(node)); // Next, use the `SelectorMatcher` to get the list of directives on the node.\n\n      var directives = [];\n      this.matcher.match(cssSelector, function (_, directive) {\n        return directives.push(directive);\n      });\n\n      if (directives.length > 0) {\n        this.directives.set(node, directives);\n      } // Resolve any references that are created on this node.\n\n\n      node.references.forEach(function (ref) {\n        var dirTarget = null; // If the reference expression is empty, then it matches the \"primary\" directive on the node\n        // (if there is one). Otherwise it matches the host node itself (either an element or\n        // <ng-template> node).\n\n        if (ref.value.trim() === '') {\n          // This could be a reference to a component if there is one.\n          dirTarget = directives.find(function (dir) {\n            return dir.isComponent;\n          }) || null;\n        } else {\n          // This should be a reference to a directive exported via exportAs.\n          dirTarget = directives.find(function (dir) {\n            return dir.exportAs !== null && dir.exportAs.some(function (value) {\n              return value === ref.value;\n            });\n          }) || null; // Check if a matching directive was found.\n\n          if (dirTarget === null) {\n            // No matching directive was found - this reference points to an unknown target. Leave it\n            // unmapped.\n            return;\n          }\n        }\n\n        if (dirTarget !== null) {\n          // This reference points to a directive.\n          _this310.references.set(ref, {\n            directive: dirTarget,\n            node: node\n          });\n        } else {\n          // This reference points to the node itself.\n          _this310.references.set(ref, node);\n        }\n      });\n\n      var setAttributeBinding = function setAttributeBinding(attribute, ioType) {\n        var dir = directives.find(function (dir) {\n          return dir[ioType].hasBindingPropertyName(attribute.name);\n        });\n        var binding = dir !== undefined ? dir : node;\n\n        _this310.bindings.set(attribute, binding);\n      }; // Node inputs (bound attributes) and text attributes can be bound to an\n      // input on a directive.\n\n\n      node.inputs.forEach(function (input) {\n        return setAttributeBinding(input, 'inputs');\n      });\n      node.attributes.forEach(function (attr) {\n        return setAttributeBinding(attr, 'inputs');\n      });\n\n      if (node instanceof Template) {\n        node.templateAttrs.forEach(function (attr) {\n          return setAttributeBinding(attr, 'inputs');\n        });\n      } // Node outputs (bound events) can be bound to an output on a directive.\n\n\n      node.outputs.forEach(function (output) {\n        return setAttributeBinding(output, 'outputs');\n      }); // Recurse into the node's children.\n\n      node.children.forEach(function (child) {\n        return child.visit(_this310);\n      });\n    } // Unused visitors.\n\n  }, {\n    key: \"visitContent\",\n    value: function visitContent(content) {}\n  }, {\n    key: \"visitVariable\",\n    value: function visitVariable(variable) {}\n  }, {\n    key: \"visitReference\",\n    value: function visitReference(reference) {}\n  }, {\n    key: \"visitTextAttribute\",\n    value: function visitTextAttribute(attribute) {}\n  }, {\n    key: \"visitBoundAttribute\",\n    value: function visitBoundAttribute(attribute) {}\n  }, {\n    key: \"visitBoundEvent\",\n    value: function visitBoundEvent(attribute) {}\n  }, {\n    key: \"visitBoundAttributeOrEvent\",\n    value: function visitBoundAttributeOrEvent(node) {}\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {}\n  }, {\n    key: \"visitBoundText\",\n    value: function visitBoundText(text) {}\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu) {}\n  }], [{\n    key: \"apply\",\n    value: function apply(template, selectorMatcher) {\n      var directives = new Map();\n      var bindings = new Map();\n      var references = new Map();\n      var matcher = new DirectiveBinder(selectorMatcher, directives, bindings, references);\n      matcher.ingest(template);\n      return {\n        directives: directives,\n        bindings: bindings,\n        references: references\n      };\n    }\n  }]);\n\n  return DirectiveBinder;\n}();\n/**\r\n * Processes a template and extract metadata about expressions and symbols within.\r\n *\r\n * This is a companion to the `DirectiveBinder` that doesn't require knowledge of directives matched\r\n * within the template in order to operate.\r\n *\r\n * Expressions are visited by the superclass `RecursiveAstVisitor`, with custom logic provided\r\n * by overridden methods from that visitor.\r\n */\n\n\nvar TemplateBinder = /*#__PURE__*/function (_RecursiveAstVisitor$3) {\n  _inherits(TemplateBinder, _RecursiveAstVisitor$3);\n\n  var _super112 = _createSuper(TemplateBinder);\n\n  function TemplateBinder(bindings, symbols, usedPipes, nestingLevel, scope, template, level) {\n    var _this311;\n\n    _classCallCheck(this, TemplateBinder);\n\n    _this311 = _super112.call(this);\n    _this311.bindings = bindings;\n    _this311.symbols = symbols;\n    _this311.usedPipes = usedPipes;\n    _this311.nestingLevel = nestingLevel;\n    _this311.scope = scope;\n    _this311.template = template;\n    _this311.level = level;\n    _this311.pipesUsed = []; // Save a bit of processing time by constructing this closure in advance.\n\n    _this311.visitNode = function (node) {\n      return node.visit(_assertThisInitialized(_this311));\n    };\n\n    return _this311;\n  } // This method is defined to reconcile the type of TemplateBinder since both\n  // RecursiveAstVisitor and Visitor define the visit() method in their\n  // interfaces.\n\n\n  _createClass(TemplateBinder, [{\n    key: \"visit\",\n    value: function visit(node, context) {\n      if (node instanceof AST) {\n        node.visit(this, context);\n      } else {\n        node.visit(this);\n      }\n    }\n    /**\r\n     * Process a template and extract metadata about expressions and symbols within.\r\n     *\r\n     * @param template the nodes of the template to process\r\n     * @param scope the `Scope` of the template being processed.\r\n     * @returns three maps which contain metadata about the template: `expressions` which interprets\r\n     * special `AST` nodes in expressions as pointing to references or variables declared within the\r\n     * template, `symbols` which maps those variables and references to the nested `Template` which\r\n     * declares them, if any, and `nestingLevel` which associates each `Template` with a integer\r\n     * nesting level (how many levels deep within the template structure the `Template` is), starting\r\n     * at 1.\r\n     */\n\n  }, {\n    key: \"ingest\",\n    value: function ingest(template) {\n      if (template instanceof Template) {\n        // For <ng-template>s, process only variables and child nodes. Inputs, outputs, templateAttrs,\n        // and references were all processed in the scope of the containing template.\n        template.variables.forEach(this.visitNode);\n        template.children.forEach(this.visitNode); // Set the nesting level.\n\n        this.nestingLevel.set(template, this.level);\n      } else {\n        // Visit each node from the top-level template.\n        template.forEach(this.visitNode);\n      }\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(element) {\n      // Visit the inputs, outputs, and children of the element.\n      element.inputs.forEach(this.visitNode);\n      element.outputs.forEach(this.visitNode);\n      element.children.forEach(this.visitNode);\n    }\n  }, {\n    key: \"visitTemplate\",\n    value: function visitTemplate(template) {\n      // First, visit inputs, outputs and template attributes of the template node.\n      template.inputs.forEach(this.visitNode);\n      template.outputs.forEach(this.visitNode);\n      template.templateAttrs.forEach(this.visitNode); // References are also evaluated in the outer context.\n\n      template.references.forEach(this.visitNode); // Next, recurse into the template using its scope, and bumping the nesting level up by one.\n\n      var childScope = this.scope.getChildScope(template);\n      var binder = new TemplateBinder(this.bindings, this.symbols, this.usedPipes, this.nestingLevel, childScope, template, this.level + 1);\n      binder.ingest(template);\n    }\n  }, {\n    key: \"visitVariable\",\n    value: function visitVariable(variable) {\n      // Register the `Variable` as a symbol in the current `Template`.\n      if (this.template !== null) {\n        this.symbols.set(variable, this.template);\n      }\n    }\n  }, {\n    key: \"visitReference\",\n    value: function visitReference(reference) {\n      // Register the `Reference` as a symbol in the current `Template`.\n      if (this.template !== null) {\n        this.symbols.set(reference, this.template);\n      }\n    } // Unused template visitors\n\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {}\n  }, {\n    key: \"visitContent\",\n    value: function visitContent(content) {}\n  }, {\n    key: \"visitTextAttribute\",\n    value: function visitTextAttribute(attribute) {}\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu) {\n      var _this312 = this;\n\n      Object.keys(icu.vars).forEach(function (key) {\n        return icu.vars[key].visit(_this312);\n      });\n      Object.keys(icu.placeholders).forEach(function (key) {\n        return icu.placeholders[key].visit(_this312);\n      });\n    } // The remaining visitors are concerned with processing AST expressions within template bindings\n\n  }, {\n    key: \"visitBoundAttribute\",\n    value: function visitBoundAttribute(attribute) {\n      attribute.value.visit(this);\n    }\n  }, {\n    key: \"visitBoundEvent\",\n    value: function visitBoundEvent(event) {\n      event.handler.visit(this);\n    }\n  }, {\n    key: \"visitBoundText\",\n    value: function visitBoundText(text) {\n      text.value.visit(this);\n    }\n  }, {\n    key: \"visitPipe\",\n    value: function visitPipe(ast, context) {\n      this.usedPipes.add(ast.name);\n      return _get(_getPrototypeOf(TemplateBinder.prototype), \"visitPipe\", this).call(this, ast, context);\n    } // These five types of AST expressions can refer to expression roots, which could be variables\n    // or references in the current scope.\n\n  }, {\n    key: \"visitPropertyRead\",\n    value: function visitPropertyRead(ast, context) {\n      this.maybeMap(context, ast, ast.name);\n      return _get(_getPrototypeOf(TemplateBinder.prototype), \"visitPropertyRead\", this).call(this, ast, context);\n    }\n  }, {\n    key: \"visitSafePropertyRead\",\n    value: function visitSafePropertyRead(ast, context) {\n      this.maybeMap(context, ast, ast.name);\n      return _get(_getPrototypeOf(TemplateBinder.prototype), \"visitSafePropertyRead\", this).call(this, ast, context);\n    }\n  }, {\n    key: \"visitPropertyWrite\",\n    value: function visitPropertyWrite(ast, context) {\n      this.maybeMap(context, ast, ast.name);\n      return _get(_getPrototypeOf(TemplateBinder.prototype), \"visitPropertyWrite\", this).call(this, ast, context);\n    }\n  }, {\n    key: \"visitMethodCall\",\n    value: function visitMethodCall(ast, context) {\n      this.maybeMap(context, ast, ast.name);\n      return _get(_getPrototypeOf(TemplateBinder.prototype), \"visitMethodCall\", this).call(this, ast, context);\n    }\n  }, {\n    key: \"visitSafeMethodCall\",\n    value: function visitSafeMethodCall(ast, context) {\n      this.maybeMap(context, ast, ast.name);\n      return _get(_getPrototypeOf(TemplateBinder.prototype), \"visitSafeMethodCall\", this).call(this, ast, context);\n    }\n  }, {\n    key: \"maybeMap\",\n    value: function maybeMap(scope, ast, name) {\n      // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an\n      // `AST` expression that maps to a `Variable` or `Reference`.\n      if (!(ast.receiver instanceof ImplicitReceiver)) {\n        return;\n      } // Check whether the name exists in the current scope. If so, map it. Otherwise, the name is\n      // probably a property on the top-level component context.\n\n\n      var target = this.scope.lookup(name);\n\n      if (target !== null) {\n        this.bindings.set(ast, target);\n      }\n    }\n  }], [{\n    key: \"apply\",\n    value: function apply(template, scope) {\n      var expressions = new Map();\n      var symbols = new Map();\n      var nestingLevel = new Map();\n      var usedPipes = new Set(); // The top-level template has nesting level 0.\n\n      var binder = new TemplateBinder(expressions, symbols, usedPipes, nestingLevel, scope, template instanceof Template ? template : null, 0);\n      binder.ingest(template);\n      return {\n        expressions: expressions,\n        symbols: symbols,\n        nestingLevel: nestingLevel,\n        usedPipes: usedPipes\n      };\n    }\n  }]);\n\n  return TemplateBinder;\n}(RecursiveAstVisitor$1);\n/**\r\n * Metadata container for a `Target` that allows queries for specific bits of metadata.\r\n *\r\n * See `BoundTarget` for documentation on the individual methods.\r\n */\n\n\nvar R3BoundTarget = /*#__PURE__*/function () {\n  function R3BoundTarget(target, directives, bindings, references, exprTargets, symbols, nestingLevel, templateEntities, usedPipes) {\n    _classCallCheck(this, R3BoundTarget);\n\n    this.target = target;\n    this.directives = directives;\n    this.bindings = bindings;\n    this.references = references;\n    this.exprTargets = exprTargets;\n    this.symbols = symbols;\n    this.nestingLevel = nestingLevel;\n    this.templateEntities = templateEntities;\n    this.usedPipes = usedPipes;\n  }\n\n  _createClass(R3BoundTarget, [{\n    key: \"getEntitiesInTemplateScope\",\n    value: function getEntitiesInTemplateScope(template) {\n      var _a;\n\n      return (_a = this.templateEntities.get(template)) !== null && _a !== void 0 ? _a : new Set();\n    }\n  }, {\n    key: \"getDirectivesOfNode\",\n    value: function getDirectivesOfNode(node) {\n      return this.directives.get(node) || null;\n    }\n  }, {\n    key: \"getReferenceTarget\",\n    value: function getReferenceTarget(ref) {\n      return this.references.get(ref) || null;\n    }\n  }, {\n    key: \"getConsumerOfBinding\",\n    value: function getConsumerOfBinding(binding) {\n      return this.bindings.get(binding) || null;\n    }\n  }, {\n    key: \"getExpressionTarget\",\n    value: function getExpressionTarget(expr) {\n      return this.exprTargets.get(expr) || null;\n    }\n  }, {\n    key: \"getTemplateOfSymbol\",\n    value: function getTemplateOfSymbol(symbol) {\n      return this.symbols.get(symbol) || null;\n    }\n  }, {\n    key: \"getNestingLevel\",\n    value: function getNestingLevel(template) {\n      return this.nestingLevel.get(template) || 0;\n    }\n  }, {\n    key: \"getUsedDirectives\",\n    value: function getUsedDirectives() {\n      var set = new Set();\n      this.directives.forEach(function (dirs) {\n        return dirs.forEach(function (dir) {\n          return set.add(dir);\n        });\n      });\n      return Array.from(set.values());\n    }\n  }, {\n    key: \"getUsedPipes\",\n    value: function getUsedPipes() {\n      return Array.from(this.usedPipes);\n    }\n  }]);\n\n  return R3BoundTarget;\n}();\n\nfunction extractTemplateEntities(rootScope) {\n  var entityMap = new Map();\n\n  function extractScopeEntities(scope) {\n    if (entityMap.has(scope.template)) {\n      return entityMap.get(scope.template);\n    }\n\n    var currentEntities = scope.namedEntities;\n    var templateEntities;\n\n    if (scope.parentScope !== null) {\n      templateEntities = new Map([].concat(_toConsumableArray(extractScopeEntities(scope.parentScope)), _toConsumableArray(currentEntities)));\n    } else {\n      templateEntities = new Map(currentEntities);\n    }\n\n    entityMap.set(scope.template, templateEntities);\n    return templateEntities;\n  }\n\n  var scopesToProcess = [rootScope];\n\n  while (scopesToProcess.length > 0) {\n    var scope = scopesToProcess.pop();\n\n    var _iterator43 = _createForOfIteratorHelper(scope.childScopes.values()),\n        _step43;\n\n    try {\n      for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {\n        var childScope = _step43.value;\n        scopesToProcess.push(childScope);\n      }\n    } catch (err) {\n      _iterator43.e(err);\n    } finally {\n      _iterator43.f();\n    }\n\n    extractScopeEntities(scope);\n  }\n\n  var templateEntities = new Map();\n\n  var _iterator44 = _createForOfIteratorHelper(entityMap),\n      _step44;\n\n  try {\n    for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {\n      var _step44$value = _slicedToArray(_step44.value, 2),\n          template = _step44$value[0],\n          entities = _step44$value[1];\n\n      templateEntities.set(template, new Set(entities.values()));\n    }\n  } catch (err) {\n    _iterator44.e(err);\n  } finally {\n    _iterator44.f();\n  }\n\n  return templateEntities;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n\nfunction compileClassMetadata(metadata) {\n  var _a, _b; // Generate an ngDevMode guarded call to setClassMetadata with the class identifier and its\n  // metadata.\n\n\n  var fnCall = importExpr(Identifiers.setClassMetadata).callFn([metadata.type, metadata.decorators, (_a = metadata.ctorParameters) !== null && _a !== void 0 ? _a : literal(null), (_b = metadata.propDecorators) !== null && _b !== void 0 ? _b : literal(null)]);\n  var iife = fn([], [devOnlyGuardedExpression(fnCall).toStmt()]);\n  return iife.callFn([]);\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\r\n * must update this constant to prevent old partial-linkers from incorrectly processing the\r\n * declaration.\r\n *\r\n * Do not include any prerelease in these versions as they are ignored.\r\n */\n\n\nvar MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\n\nfunction compileDeclareClassMetadata(metadata) {\n  var definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION));\n  definitionMap.set('version', literal('12.1.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', metadata.type);\n  definitionMap.set('decorators', metadata.decorators);\n  definitionMap.set('ctorParameters', metadata.ctorParameters);\n  definitionMap.set('propDecorators', metadata.propDecorators);\n  return importExpr(Identifiers.declareClassMetadata).callFn([definitionMap.toLiteralMap()]);\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\r\n * must update this constant to prevent old partial-linkers from incorrectly processing the\r\n * declaration.\r\n *\r\n * Do not include any prerelease in these versions as they are ignored.\r\n */\n\n\nvar MINIMUM_PARTIAL_LINKER_VERSION$1 = '12.0.0';\n/**\r\n * Compile a directive declaration defined by the `R3DirectiveMetadata`.\r\n */\n\nfunction compileDeclareDirectiveFromMetadata(meta) {\n  var definitionMap = createDirectiveDefinitionMap(meta);\n  var expression = importExpr(Identifiers.declareDirective).callFn([definitionMap.toLiteralMap()]);\n  var type = createDirectiveType(meta);\n  return {\n    expression: expression,\n    type: type,\n    statements: []\n  };\n}\n/**\r\n * Gathers the declaration fields for a directive into a `DefinitionMap`. This allows for reusing\r\n * this logic for components, as they extend the directive metadata.\r\n */\n\n\nfunction createDirectiveDefinitionMap(meta) {\n  var definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$1));\n  definitionMap.set('version', literal('12.1.0')); // e.g. `type: MyDirective`\n\n  definitionMap.set('type', meta.internalType); // e.g. `selector: 'some-dir'`\n\n  if (meta.selector !== null) {\n    definitionMap.set('selector', literal(meta.selector));\n  }\n\n  definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));\n  definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));\n  definitionMap.set('host', compileHostMetadata(meta.host));\n  definitionMap.set('providers', meta.providers);\n\n  if (meta.queries.length > 0) {\n    definitionMap.set('queries', literalArr(meta.queries.map(compileQuery)));\n  }\n\n  if (meta.viewQueries.length > 0) {\n    definitionMap.set('viewQueries', literalArr(meta.viewQueries.map(compileQuery)));\n  }\n\n  if (meta.exportAs !== null) {\n    definitionMap.set('exportAs', asLiteral(meta.exportAs));\n  }\n\n  if (meta.usesInheritance) {\n    definitionMap.set('usesInheritance', literal(true));\n  }\n\n  if (meta.lifecycle.usesOnChanges) {\n    definitionMap.set('usesOnChanges', literal(true));\n  }\n\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  return definitionMap;\n}\n/**\r\n * Compiles the metadata of a single query into its partial declaration form as declared\r\n * by `R3DeclareQueryMetadata`.\r\n */\n\n\nfunction compileQuery(query) {\n  var meta = new DefinitionMap();\n  meta.set('propertyName', literal(query.propertyName));\n\n  if (query.first) {\n    meta.set('first', literal(true));\n  }\n\n  meta.set('predicate', Array.isArray(query.predicate) ? asLiteral(query.predicate) : query.predicate);\n\n  if (!query.emitDistinctChangesOnly) {\n    // `emitDistinctChangesOnly` is special because we expect it to be `true`.\n    // Therefore we explicitly emit the field, and explicitly place it only when it's `false`.\n    meta.set('emitDistinctChangesOnly', literal(false));\n  } else {// The linker will assume that an absent `emitDistinctChangesOnly` flag is by default `true`.\n  }\n\n  if (query.descendants) {\n    meta.set('descendants', literal(true));\n  }\n\n  meta.set('read', query.read);\n\n  if (query.static) {\n    meta.set('static', literal(true));\n  }\n\n  return meta.toLiteralMap();\n}\n/**\r\n * Compiles the host metadata into its partial declaration form as declared\r\n * in `R3DeclareDirectiveMetadata['host']`\r\n */\n\n\nfunction compileHostMetadata(meta) {\n  var hostMetadata = new DefinitionMap();\n  hostMetadata.set('attributes', toOptionalLiteralMap(meta.attributes, function (expression) {\n    return expression;\n  }));\n  hostMetadata.set('listeners', toOptionalLiteralMap(meta.listeners, literal));\n  hostMetadata.set('properties', toOptionalLiteralMap(meta.properties, literal));\n\n  if (meta.specialAttributes.styleAttr) {\n    hostMetadata.set('styleAttribute', literal(meta.specialAttributes.styleAttr));\n  }\n\n  if (meta.specialAttributes.classAttr) {\n    hostMetadata.set('classAttribute', literal(meta.specialAttributes.classAttr));\n  }\n\n  if (hostMetadata.values.length > 0) {\n    return hostMetadata.toLiteralMap();\n  } else {\n    return null;\n  }\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Compile a component declaration defined by the `R3ComponentMetadata`.\r\n */\n\n\nfunction compileDeclareComponentFromMetadata(meta, template, additionalTemplateInfo) {\n  var definitionMap = createComponentDefinitionMap(meta, template, additionalTemplateInfo);\n  var expression = importExpr(Identifiers.declareComponent).callFn([definitionMap.toLiteralMap()]);\n  var type = createComponentType(meta);\n  return {\n    expression: expression,\n    type: type,\n    statements: []\n  };\n}\n/**\r\n * Gathers the declaration fields for a component into a `DefinitionMap`.\r\n */\n\n\nfunction createComponentDefinitionMap(meta, template, templateInfo) {\n  var definitionMap = createDirectiveDefinitionMap(meta);\n  definitionMap.set('template', getTemplateExpression(template, templateInfo));\n\n  if (templateInfo.isInline) {\n    definitionMap.set('isInline', literal(true));\n  }\n\n  definitionMap.set('styles', toOptionalLiteralArray(meta.styles, literal));\n  definitionMap.set('components', compileUsedDirectiveMetadata(meta, function (directive) {\n    return directive.isComponent === true;\n  }));\n  definitionMap.set('directives', compileUsedDirectiveMetadata(meta, function (directive) {\n    return directive.isComponent !== true;\n  }));\n  definitionMap.set('pipes', compileUsedPipeMetadata(meta));\n  definitionMap.set('viewProviders', meta.viewProviders);\n  definitionMap.set('animations', meta.animations);\n\n  if (meta.changeDetection !== undefined) {\n    definitionMap.set('changeDetection', importExpr(Identifiers.ChangeDetectionStrategy).prop(ChangeDetectionStrategy[meta.changeDetection]));\n  }\n\n  if (meta.encapsulation !== ViewEncapsulation.Emulated) {\n    definitionMap.set('encapsulation', importExpr(Identifiers.ViewEncapsulation).prop(ViewEncapsulation[meta.encapsulation]));\n  }\n\n  if (meta.interpolation !== DEFAULT_INTERPOLATION_CONFIG) {\n    definitionMap.set('interpolation', literalArr([literal(meta.interpolation.start), literal(meta.interpolation.end)]));\n  }\n\n  if (template.preserveWhitespaces === true) {\n    definitionMap.set('preserveWhitespaces', literal(true));\n  }\n\n  return definitionMap;\n}\n\nfunction getTemplateExpression(template, templateInfo) {\n  // If the template has been defined using a direct literal, we use that expression directly\n  // without any modifications. This is ensures proper source mapping from the partially\n  // compiled code to the source file declaring the template. Note that this does not capture\n  // template literals referenced indirectly through an identifier.\n  if (templateInfo.inlineTemplateLiteralExpression !== null) {\n    return templateInfo.inlineTemplateLiteralExpression;\n  } // If the template is defined inline but not through a literal, the template has been resolved\n  // through static interpretation. We create a literal but cannot provide any source span. Note\n  // that we cannot use the expression defining the template because the linker expects the template\n  // to be defined as a literal in the declaration.\n\n\n  if (templateInfo.isInline) {\n    return literal(templateInfo.content, null, null);\n  } // The template is external so we must synthesize an expression node with\n  // the appropriate source-span.\n\n\n  var contents = templateInfo.content;\n  var file = new ParseSourceFile(contents, templateInfo.sourceUrl);\n  var start = new ParseLocation(file, 0, 0, 0);\n  var end = computeEndLocation(file, contents);\n  var span = new ParseSourceSpan(start, end);\n  return literal(contents, null, span);\n}\n\nfunction computeEndLocation(file, contents) {\n  var length = contents.length;\n  var lineStart = 0;\n  var lastLineStart = 0;\n  var line = 0;\n\n  do {\n    lineStart = contents.indexOf('\\n', lastLineStart);\n\n    if (lineStart !== -1) {\n      lastLineStart = lineStart + 1;\n      line++;\n    }\n  } while (lineStart !== -1);\n\n  return new ParseLocation(file, length, line, length - lastLineStart);\n}\n/**\r\n * Compiles the directives as registered in the component metadata into an array literal of the\r\n * individual directives. If the component does not use any directives, then null is returned.\r\n */\n\n\nfunction compileUsedDirectiveMetadata(meta, predicate) {\n  var wrapType = meta.declarationListEmitMode !== 0\n  /* Direct */\n  ? generateForwardRef : function (expr) {\n    return expr;\n  };\n  var directives = meta.directives.filter(predicate);\n  return toOptionalLiteralArray(directives, function (directive) {\n    var dirMeta = new DefinitionMap();\n    dirMeta.set('type', wrapType(directive.type));\n    dirMeta.set('selector', literal(directive.selector));\n    dirMeta.set('inputs', toOptionalLiteralArray(directive.inputs, literal));\n    dirMeta.set('outputs', toOptionalLiteralArray(directive.outputs, literal));\n    dirMeta.set('exportAs', toOptionalLiteralArray(directive.exportAs, literal));\n    return dirMeta.toLiteralMap();\n  });\n}\n/**\r\n * Compiles the pipes as registered in the component metadata into an object literal, where the\r\n * pipe's name is used as key and a reference to its type as value. If the component does not use\r\n * any pipes, then null is returned.\r\n */\n\n\nfunction compileUsedPipeMetadata(meta) {\n  if (meta.pipes.size === 0) {\n    return null;\n  }\n\n  var wrapType = meta.declarationListEmitMode !== 0\n  /* Direct */\n  ? generateForwardRef : function (expr) {\n    return expr;\n  };\n  var entries = [];\n\n  var _iterator45 = _createForOfIteratorHelper(meta.pipes),\n      _step45;\n\n  try {\n    for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {\n      var _step45$value = _slicedToArray(_step45.value, 2),\n          name = _step45$value[0],\n          pipe = _step45$value[1];\n\n      entries.push({\n        key: name,\n        value: wrapType(pipe),\n        quoted: true\n      });\n    }\n  } catch (err) {\n    _iterator45.e(err);\n  } finally {\n    _iterator45.f();\n  }\n\n  return literalMap(entries);\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\r\n * must update this constant to prevent old partial-linkers from incorrectly processing the\r\n * declaration.\r\n *\r\n * Do not include any prerelease in these versions as they are ignored.\r\n */\n\n\nvar MINIMUM_PARTIAL_LINKER_VERSION$2 = '12.0.0';\n\nfunction compileDeclareFactoryFunction(meta) {\n  var definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$2));\n  definitionMap.set('version', literal('12.1.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.internalType);\n  definitionMap.set('deps', compileDependencies(meta.deps));\n  definitionMap.set('target', importExpr(Identifiers.FactoryTarget).prop(FactoryTarget[meta.target]));\n  return {\n    expression: importExpr(Identifiers.declareFactory).callFn([definitionMap.toLiteralMap()]),\n    statements: [],\n    type: createFactoryType(meta)\n  };\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\r\n * must update this constant to prevent old partial-linkers from incorrectly processing the\r\n * declaration.\r\n *\r\n * Do not include any prerelease in these versions as they are ignored.\r\n */\n\n\nvar MINIMUM_PARTIAL_LINKER_VERSION$3 = '12.0.0';\n/**\r\n * Compile a Injectable declaration defined by the `R3InjectableMetadata`.\r\n */\n\nfunction compileDeclareInjectableFromMetadata(meta) {\n  var definitionMap = createInjectableDefinitionMap(meta);\n  var expression = importExpr(Identifiers.declareInjectable).callFn([definitionMap.toLiteralMap()]);\n  var type = createInjectableType(meta);\n  return {\n    expression: expression,\n    type: type,\n    statements: []\n  };\n}\n/**\r\n * Gathers the declaration fields for a Injectable into a `DefinitionMap`.\r\n */\n\n\nfunction createInjectableDefinitionMap(meta) {\n  var definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$3));\n  definitionMap.set('version', literal('12.1.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.internalType); // Only generate providedIn property if it has a non-null value\n\n  if (meta.providedIn !== undefined) {\n    var providedIn = convertFromProviderExpression(meta.providedIn);\n\n    if (providedIn.value !== null) {\n      definitionMap.set('providedIn', providedIn);\n    }\n  }\n\n  if (meta.useClass !== undefined) {\n    definitionMap.set('useClass', convertFromProviderExpression(meta.useClass));\n  }\n\n  if (meta.useExisting !== undefined) {\n    definitionMap.set('useExisting', convertFromProviderExpression(meta.useExisting));\n  }\n\n  if (meta.useValue !== undefined) {\n    definitionMap.set('useValue', convertFromProviderExpression(meta.useValue));\n  } // Factories do not contain `ForwardRef`s since any types are already wrapped in a function call\n  // so the types will not be eagerly evaluated. Therefore we do not need to process this expression\n  // with `convertFromProviderExpression()`.\n\n\n  if (meta.useFactory !== undefined) {\n    definitionMap.set('useFactory', meta.useFactory);\n  }\n\n  if (meta.deps !== undefined) {\n    definitionMap.set('deps', literalArr(meta.deps.map(compileDependency)));\n  }\n\n  return definitionMap;\n}\n/**\r\n * Convert an `R3ProviderExpression` to an `Expression`, possibly wrapping its expression in a\r\n * `forwardRef()` call.\r\n *\r\n * If `R3ProviderExpression.isForwardRef` is true then the expression was originally wrapped in a\r\n * `forwardRef()` call to prevent the value from being eagerly evaluated in the code.\r\n *\r\n * Normally, the linker will statically process the code, putting the `expression` inside a factory\r\n * function so the `forwardRef()` wrapper is not evaluated before it has been defined. But if the\r\n * partial declaration is evaluated by the JIT compiler the `forwardRef()` call is still needed to\r\n * prevent eager evaluation of the `expression`.\r\n *\r\n * So in partial declarations, expressions that could be forward-refs are wrapped in `forwardRef()`\r\n * calls, and this is then unwrapped in the linker as necessary.\r\n *\r\n * See `packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts` and\r\n * `packages/compiler/src/jit_compiler_facade.ts` for more information.\r\n */\n\n\nfunction convertFromProviderExpression(_ref45) {\n  var expression = _ref45.expression,\n      isForwardRef = _ref45.isForwardRef;\n  return isForwardRef ? generateForwardRef(expression) : expression;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\r\n * must update this constant to prevent old partial-linkers from incorrectly processing the\r\n * declaration.\r\n *\r\n * Do not include any prerelease in these versions as they are ignored.\r\n */\n\n\nvar MINIMUM_PARTIAL_LINKER_VERSION$4 = '12.0.0';\n\nfunction compileDeclareInjectorFromMetadata(meta) {\n  var definitionMap = createInjectorDefinitionMap(meta);\n  var expression = importExpr(Identifiers.declareInjector).callFn([definitionMap.toLiteralMap()]);\n  var type = createInjectorType(meta);\n  return {\n    expression: expression,\n    type: type,\n    statements: []\n  };\n}\n/**\r\n * Gathers the declaration fields for an Injector into a `DefinitionMap`.\r\n */\n\n\nfunction createInjectorDefinitionMap(meta) {\n  var definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$4));\n  definitionMap.set('version', literal('12.1.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.internalType);\n  definitionMap.set('providers', meta.providers);\n\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', literalArr(meta.imports));\n  }\n\n  return definitionMap;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\r\n * must update this constant to prevent old partial-linkers from incorrectly processing the\r\n * declaration.\r\n *\r\n * Do not include any prerelease in these versions as they are ignored.\r\n */\n\n\nvar MINIMUM_PARTIAL_LINKER_VERSION$5 = '12.0.0';\n\nfunction compileDeclareNgModuleFromMetadata(meta) {\n  var definitionMap = createNgModuleDefinitionMap(meta);\n  var expression = importExpr(Identifiers.declareNgModule).callFn([definitionMap.toLiteralMap()]);\n  var type = createNgModuleType(meta);\n  return {\n    expression: expression,\n    type: type,\n    statements: []\n  };\n}\n/**\r\n * Gathers the declaration fields for an NgModule into a `DefinitionMap`.\r\n */\n\n\nfunction createNgModuleDefinitionMap(meta) {\n  var definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$5));\n  definitionMap.set('version', literal('12.1.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core));\n  definitionMap.set('type', meta.internalType); // We only generate the keys in the metadata if the arrays contain values.\n  // We must wrap the arrays inside a function if any of the values are a forward reference to a\n  // not-yet-declared class. This is to support JIT execution of the `ɵɵngDeclareNgModule()` call.\n  // In the linker these wrappers are stripped and then reapplied for the `ɵɵdefineNgModule()` call.\n\n  if (meta.bootstrap.length > 0) {\n    definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));\n  }\n\n  if (meta.declarations.length > 0) {\n    definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\n  }\n\n  if (meta.imports.length > 0) {\n    definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\n  }\n\n  if (meta.exports.length > 0) {\n    definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\n  }\n\n  if (meta.schemas !== null && meta.schemas.length > 0) {\n    definitionMap.set('schemas', literalArr(meta.schemas.map(function (ref) {\n      return ref.value;\n    })));\n  }\n\n  if (meta.id !== null) {\n    definitionMap.set('id', meta.id);\n  }\n\n  return definitionMap;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\r\n * must update this constant to prevent old partial-linkers from incorrectly processing the\r\n * declaration.\r\n *\r\n * Do not include any prerelease in these versions as they are ignored.\r\n */\n\n\nvar MINIMUM_PARTIAL_LINKER_VERSION$6 = '12.0.0';\n/**\r\n * Compile a Pipe declaration defined by the `R3PipeMetadata`.\r\n */\n\nfunction compileDeclarePipeFromMetadata(meta) {\n  var definitionMap = createPipeDefinitionMap(meta);\n  var expression = importExpr(Identifiers.declarePipe).callFn([definitionMap.toLiteralMap()]);\n  var type = createPipeType(meta);\n  return {\n    expression: expression,\n    type: type,\n    statements: []\n  };\n}\n/**\r\n * Gathers the declaration fields for a Pipe into a `DefinitionMap`.\r\n */\n\n\nfunction createPipeDefinitionMap(meta) {\n  var definitionMap = new DefinitionMap();\n  definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$6));\n  definitionMap.set('version', literal('12.1.0'));\n  definitionMap.set('ngImport', importExpr(Identifiers.core)); // e.g. `type: MyPipe`\n\n  definitionMap.set('type', meta.internalType); // e.g. `name: \"myPipe\"`\n\n  definitionMap.set('name', literal(meta.pipeName));\n\n  if (meta.pure === false) {\n    // e.g. `pure: false`\n    definitionMap.set('pure', literal(meta.pure));\n  }\n\n  return definitionMap;\n}\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n// This function call has a global side effects and publishes the compiler into global namespace for\n// the late binding of the Compiler to the @angular/core for jit compilation.\n\n\npublishFacade(_global);\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n// This file only reexports content of the `src` folder. Keep it that way.\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\n\nexport { AST, ASTWithName, ASTWithSource, AbsoluteSourceSpan, AotCompiler, AotSummaryResolver, ArrayType, AssertNotNull, AstMemoryEfficientTransformer, AstPath, AstTransformer$1 as AstTransformer, AttrAst, Attribute, Binary, BinaryOperator, BinaryOperatorExpr, BindingPipe, BoundDirectivePropertyAst, BoundElementProperty, BoundElementPropertyAst, BoundEventAst, BoundTextAst, BuiltinMethod, BuiltinType, BuiltinTypeName, BuiltinVar, CONTENT_ATTR, CUSTOM_ELEMENTS_SCHEMA, CastExpr, Chain, ClassField, ClassMethod, ClassStmt, CommaExpr, Comment$1 as Comment, CompileDirectiveMetadata, CompileMetadataResolver, CompileNgModuleMetadata, CompilePipeMetadata, CompileReflector, CompileShallowModuleMetadata, CompileStylesheetMetadata, CompileSummaryKind, CompileTemplateMetadata, CompiledStylesheet, CompilerConfig, Conditional, ConditionalExpr, ConstantPool, CssSelector, DEFAULT_INTERPOLATION_CONFIG, DYNAMIC_TYPE, DeclareFunctionStmt, DeclareVarStmt, DirectiveAst, DirectiveNormalizer, DirectiveResolver, DomElementSchemaRegistry, EOF, ERROR_COMPONENT_TYPE, Element$1 as Element, ElementAst, ElementSchemaRegistry, EmbeddedTemplateAst, EmitterVisitorContext, EmptyExpr, Expansion, ExpansionCase, Expression, ExpressionBinding, ExpressionStatement, ExpressionType, ExternalExpr, ExternalReference, Extractor, FactoryTarget, FunctionCall, FunctionExpr, GeneratedFile, HOST_ATTR, HtmlParser, HtmlTagDefinition, I18NHtmlParser, Identifiers$1 as Identifiers, IfStmt, ImplicitReceiver, InstantiateExpr, Interpolation, InterpolationConfig, InvokeFunctionExpr, InvokeMethodExpr, IvyParser, JSDocComment, JitCompiler, JitEvaluator, JitSummaryResolver, KeyedRead, KeyedWrite, LeadingComment, Lexer, LiteralArray, LiteralArrayExpr, LiteralExpr, LiteralMap, LiteralMapExpr, LiteralPrimitive, LocalizedString, MapType, MessageBundle, MethodCall, NAMED_ENTITIES, NGSP_UNICODE, NONE_TYPE, NO_ERRORS_SCHEMA, NgContentAst, NgModuleCompiler, NgModuleResolver, NodeWithI18n, NonNullAssert, NotExpr, NullTemplateVisitor, ParseError, ParseErrorLevel, ParseLocation, ParseSourceFile, ParseSourceSpan, ParseSpan, ParseTreeResult, ParsedEvent, ParsedProperty, ParsedPropertyType, ParsedVariable, Parser$1 as Parser, ParserError, PipeResolver, PrefixNot, PropertyRead, PropertyWrite, ProviderAst, ProviderAstType, ProviderMeta, Quote, R3BoundTarget, Identifiers as R3Identifiers, R3TargetBinder, ReadKeyExpr, ReadPropExpr, ReadVarExpr, RecursiveAstVisitor$1 as RecursiveAstVisitor, RecursiveTemplateAstVisitor, RecursiveVisitor$1 as RecursiveVisitor, ReferenceAst, ResolvedStaticSymbol, ResourceLoader, ReturnStatement, STRING_TYPE, SafeKeyedRead, SafeMethodCall, SafePropertyRead, SelectorContext, SelectorListContext, SelectorMatcher, Serializer, SplitInterpolation, Statement, StaticReflector, StaticSymbol, StaticSymbolCache, StaticSymbolResolver, StmtModifier, StyleCompiler, StylesCompileDependency, SummaryResolver, TagContentType, TaggedTemplateExpr, TemplateBindingParseResult, TemplateLiteral, TemplateLiteralElement, TemplateParseError, TemplateParseResult, TemplateParser, Text$3 as Text, TextAst, ThisReceiver, ThrowStmt, BoundAttribute as TmplAstBoundAttribute, BoundEvent as TmplAstBoundEvent, BoundText as TmplAstBoundText, Content as TmplAstContent, Element as TmplAstElement, Icu as TmplAstIcu, RecursiveVisitor as TmplAstRecursiveVisitor, Reference as TmplAstReference, Template as TmplAstTemplate, Text as TmplAstText, TextAttribute as TmplAstTextAttribute, Variable as TmplAstVariable, Token$1 as Token, TokenType$1 as TokenType, TransitiveCompileNgModuleMetadata, TreeError, TryCatchStmt, Type$1 as Type, TypeScriptEmitter, TypeofExpr, Unary, UnaryOperator, UnaryOperatorExpr, UrlResolver, VERSION$1 as VERSION, VariableAst, VariableBinding, Version, ViewCompiler, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr, Xliff, Xliff2, Xmb, XmlParser, Xtb, _ParseAST, analyzeAndValidateNgModules, analyzeFile, analyzeFileForInjectables, analyzeNgModules, collectExternalReferences, compileClassMetadata, compileComponentFromMetadata, compileDeclareClassMetadata, compileDeclareComponentFromMetadata, compileDeclareDirectiveFromMetadata, compileDeclareFactoryFunction, compileDeclareInjectableFromMetadata, compileDeclareInjectorFromMetadata, compileDeclareNgModuleFromMetadata, compileDeclarePipeFromMetadata, compileDirectiveFromMetadata, compileFactoryFunction, _compileInjectable as compileInjectable, _compileInjector as compileInjector, _compileNgModule as compileNgModule, compilePipeFromMetadata, componentFactoryName, computeMsgId, core, createAotCompiler, createAotUrlResolver, createElementCssSelector, createInjectableType, createLoweredSymbol, createOfflineCompileUrlResolver, createR3ProviderExpression, createUrlResolverWithoutPackagePrefix, debugOutputAstAsTypeScript, devOnlyGuardedExpression, findNode, flatten, formattedError, getHtmlTagDefinition, getMissingNgModuleMetadataErrorData, getNsPrefix, getParseErrors, getSafePropertyAccessString, getUrlScheme, hostViewClassName, identifierModuleUrl, identifierName, isEmptyExpression, isFormattedError, isIdentifier, isLoweredSymbol, isNgContainer, isNgContent, isNgTemplate, isQuote, isSyntaxError, jsDocComment, leadingComment, literalMap, makeBindingParser, mergeAnalyzedFiles, mergeNsAndName, ngModuleJitUrl, parseHostBindings, parseTemplate, preserveWhitespacesDefault, publishFacade, r3JitTypeSourceSpan, removeSummaryDuplicates, rendererTypeName, sanitizeIdentifier, sharedStylesheetJitUrl, splitClasses, splitNsName, syntaxError, templateJitUrl, templateSourceUrl, templateVisitAll, toTypeScript, tokenName, tokenReference, typeSourceSpan, unescapeIdentifier, unwrapResolvedMetadata, verifyHostBindings, viewClassName, visitAll$1 as visitAll }; //# sourceMappingURL=compiler.js.map","map":{"version":3,"sources":["C:/Users/matia/Desktop/Proyecto/proyecto-agricola/node_modules/@angular/compiler/fesm2015/compiler.js"],"names":["TagContentType","splitNsName","elementName","colonIndex","indexOf","Error","slice","isNgContainer","tagName","isNgContent","isNgTemplate","getNsPrefix","fullName","mergeNsAndName","prefix","localName","NAMED_ENTITIES","NGSP_UNICODE","HtmlTagDefinition","closedByChildren","implicitNamespacePrefix","contentType","PARSABLE_DATA","closedByParent","isVoid","ignoreFirstLf","preventNamespaceInheritance","canSelfClose","length","forEach","name","toLowerCase","overrideType","undefined","default","_DEFAULT_TAG_DEFINITION","TAG_DEFINITIONS","getHtmlTagDefinition","_a","_b","RAW_TEXT","ESCAPABLE_RAW_TEXT","svg","_SELECTOR_REGEXP","RegExp","CssSelector","element","classNames","attrs","notSelectors","attr","result","escaping","i","char","charAt","replace","hasElementSelector","classAttr","join","attrName","attrValue","push","concat","value","res","klass","escapeAttribute","notSelector","selector","results","_addResult","cssSel","cssSelector","match","current","inNot","lastIndex","exec","tag","addAttribute","substr","addClassName","setElement","attribute","unescapeAttribute","SelectorMatcher","_elementMap","Map","_elementPartialMap","_classMap","_classPartialMap","_attrValueMap","_attrValuePartialMap","_listContexts","cssSelectors","callbackCtxt","listContext","SelectorListContext","_addSelectable","matcher","selectable","SelectorContext","isTerminal","_addTerminal","_addPartial","className","terminalMap","terminalValuesMap","get","set","partialMap","partialValuesMap","map","terminalList","matchedCallback","alreadyMatched","_matchTerminal","_matchPartial","selectables","starSelectables","finalize","nestedSelector","notMatcher","addSelectables","selectors","cbContext","callback","createNotMatcher","createInject","makeMetadataFactory","token","createInjectionToken","desc","_desc","ɵprov","createAttribute","attributeName","emitDistinctChangesOnlyDefaultValue","createContentChildren","data","Object","assign","first","isViewQuery","descendants","emitDistinctChangesOnly","createContentChild","createViewChildren","createViewChild","createDirective","dir","ViewEncapsulation","ChangeDetectionStrategy","createComponent","c","changeDetection","Default","createPipe","p","pure","createInput","bindingPropertyName","createOutput","createHostBinding","hostPropertyName","createHostListener","eventName","args","createNgModule","ngModule","createInjectable","injectable","CUSTOM_ELEMENTS_SCHEMA","NO_ERRORS_SCHEMA","createOptional","createSelf","createSkipSelf","createHost","Type","Function","SecurityContext","MissingTranslationStrategy","props","factory","values","ngMetadataName","isTypeOf","obj","parserSelectorToSimpleSelector","classes","parserSelectorToNegativeSelector","parserSelectorToR3Selector","positive","negative","parseSelectorToR3Selector","parse","core","freeze","__proto__","TypeModifier","Type$1","modifiers","modifier","BuiltinTypeName","BuiltinType","visitor","context","visitBuiltinType","ExpressionType","typeParams","visitExpressionType","ArrayType","of","visitArrayType","MapType","valueType","visitMapType","DYNAMIC_TYPE","Dynamic","INFERRED_TYPE","Inferred","BOOL_TYPE","Bool","INT_TYPE","Int","NUMBER_TYPE","Number","STRING_TYPE","String","FUNCTION_TYPE","NONE_TYPE","None","UnaryOperator","BinaryOperator","nullSafeIsEquivalent","base","other","isEquivalent","areAllEquivalentPredicate","equivalentPredicate","len","areAllEquivalent","baseElement","otherElement","Expression","type","sourceSpan","ReadPropExpr","index","ReadKeyExpr","params","InvokeMethodExpr","InvokeFunctionExpr","InstantiateExpr","trueCase","falseCase","ConditionalExpr","rhs","BinaryOperatorExpr","Equals","NotEquals","Identical","NotIdentical","Minus","Plus","Divide","Multiply","Modulo","And","parens","BitwiseAnd","Or","Lower","LowerEquals","Bigger","BiggerEquals","equals","TYPED_NULL_EXPR","CastExpr","NullishCoalesce","ExpressionStatement","BuiltinVar","ReadVarExpr","builtin","e","visitReadVarExpr","WriteVarExpr","TypeofExpr","expr","visitTypeofExpr","isConstant","WrappedNodeExpr","node","visitWrappedNodeExpr","visitWriteVarExpr","DeclareVarStmt","toDeclStmt","StmtModifier","Final","WriteKeyExpr","receiver","visitWriteKeyExpr","WritePropExpr","visitWritePropExpr","BuiltinMethod","method","visitInvokeMethodExpr","fn","visitInvokeFunctionExpr","TaggedTemplateExpr","template","elements","a","b","text","expressions","visitTaggedTemplateExpr","classExpr","visitInstantiateExpr","LiteralExpr","visitLiteralExpr","TemplateLiteral","TemplateLiteralElement","rawText","toString","escapeForTemplateLiteral","escapeSlashes","MessagePiece","LiteralPiece","PlaceholderPiece","LocalizedString","metaBlock","messageParts","placeHolderNames","visitLocalizedString","MEANING_SEPARATOR","ID_SEPARATOR","LEGACY_ID_INDICATOR","description","meaning","customId","legacyIds","legacyId","createCookedRawString","getMessagePartSourceSpan","_c","_d","partIndex","placeholderName","messagePart","str","escapeStartingColon","escapeColons","range","cooked","raw","ExternalExpr","moduleName","runtime","visitExternalExpr","ExternalReference","condition","visitConditionalExpr","NotExpr","visitNotExpr","AssertNotNull","visitAssertNotNullExpr","visitCastExpr","FnParam","param","FunctionExpr","statements","visitFunctionExpr","DeclareFunctionStmt","UnaryOperatorExpr","operator","visitUnaryOperatorExpr","lhs","visitBinaryOperatorExpr","visitReadPropExpr","visitReadKeyExpr","LiteralArrayExpr","entries","every","visitLiteralArrayExpr","LiteralMapEntry","key","quoted","LiteralMapExpr","visitLiteralMapExpr","CommaExpr","parts","visitCommaExpr","THIS_EXPR","This","SUPER_EXPR","Super","CATCH_ERROR_VAR","CatchError","CATCH_STACK_VAR","CatchStack","NULL_EXPR","LeadingComment","multiline","trailingNewline","JSDocComment","tags","serializeTags","Statement","leadingComments","leadingComment","stmt","visitDeclareVarStmt","visitDeclareFunctionStmt","visitExpressionStmt","ReturnStatement","visitReturnStmt","AbstractClassPart","ClassField","initializer","f","ClassMethod","body","m","ClassGetter","ClassStmt","parent","fields","getters","constructorMethod","methods","visitDeclareClassStmt","IfStmt","visitIfStmt","TryCatchStmt","bodyStmts","catchStmts","visitTryCatchStmt","ThrowStmt","error","visitThrowStmt","AstTransformer","ast","transformExpr","visitExpression","visitAllExpressions","visitAllStatements","entry","mapType","exprs","transformStmt","getter","ctorMethod","stmts","visitStatement","RecursiveAstVisitor","visitType","findReadVarNames","_ReadVarVisitor","varNames","arguments","Set","add","collectExternalReferences","_FindExternalReferencesVisitor","externalReferences","applySourceSpanToStatementIfNeeded","transformer","_ApplySourceSpanTransformer","applySourceSpanToExpressionIfNeeded","clone","create","constructor","prototype","keys","prop","_clone","jsDocComment","variable","importExpr","id","importType","typeModifiers","expressionType","typeofExpr","literalArr","literalMap","unary","not","assertNotNull","ifStmt","thenClause","elseClause","taggedTemplate","literal","localizedString","placeholderNames","isNull","exp","tagToString","out","CONSTANT_PREFIX","UNKNOWN_VALUE_KEY","KEY_CONTEXT","POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS","FixupExpression","resolved","original","expression","shared","ConstantPool","isClosureCompilerEnabled","literals","literalFactories","injectorDefinitions","directiveDefinitions","componentDefinitions","pipeDefinitions","nextNameIndex","forceShared","isLongStringLiteral","keyOf","fixup","newValue","freshName","definition","usage","callFn","kind","ctx","definitions","definitionsOf","property","propertyNameOf","argumentsForKey","_getLiteralFactory","expressionForKey","resultMap","literalFactory","literalFactoryArguments","filter","resultExpressions","getConstLiteral","parameters","isVariable","pureFunctionDeclaration","uniqueName","KeyVisitor","invalid","mapKey","quote","mapEntry","arg","CORE","Identifiers","NEW_METHOD","TRANSFORM_METHOD","PATCH_DEPS","namespaceHTML","namespaceMathML","namespaceSVG","elementStart","elementEnd","advance","syntheticHostProperty","syntheticHostListener","attributeInterpolate1","attributeInterpolate2","attributeInterpolate3","attributeInterpolate4","attributeInterpolate5","attributeInterpolate6","attributeInterpolate7","attributeInterpolate8","attributeInterpolateV","classProp","elementContainerStart","elementContainerEnd","elementContainer","styleMap","styleMapInterpolate1","styleMapInterpolate2","styleMapInterpolate3","styleMapInterpolate4","styleMapInterpolate5","styleMapInterpolate6","styleMapInterpolate7","styleMapInterpolate8","styleMapInterpolateV","classMap","classMapInterpolate1","classMapInterpolate2","classMapInterpolate3","classMapInterpolate4","classMapInterpolate5","classMapInterpolate6","classMapInterpolate7","classMapInterpolate8","classMapInterpolateV","styleProp","stylePropInterpolate1","stylePropInterpolate2","stylePropInterpolate3","stylePropInterpolate4","stylePropInterpolate5","stylePropInterpolate6","stylePropInterpolate7","stylePropInterpolate8","stylePropInterpolateV","nextContext","templateCreate","enableBindings","disableBindings","getCurrentView","textInterpolate","textInterpolate1","textInterpolate2","textInterpolate3","textInterpolate4","textInterpolate5","textInterpolate6","textInterpolate7","textInterpolate8","textInterpolateV","restoreView","pureFunction0","pureFunction1","pureFunction2","pureFunction3","pureFunction4","pureFunction5","pureFunction6","pureFunction7","pureFunction8","pureFunctionV","pipeBind1","pipeBind2","pipeBind3","pipeBind4","pipeBindV","hostProperty","propertyInterpolate","propertyInterpolate1","propertyInterpolate2","propertyInterpolate3","propertyInterpolate4","propertyInterpolate5","propertyInterpolate6","propertyInterpolate7","propertyInterpolate8","propertyInterpolateV","i18n","i18nAttributes","i18nExp","i18nStart","i18nEnd","i18nApply","i18nPostprocess","pipe","projection","projectionDef","reference","inject","injectAttribute","directiveInject","invalidFactory","invalidFactoryDep","templateRefExtractor","forwardRef","resolveForwardRef","ɵɵdefineInjectable","declareInjectable","InjectableDeclaration","resolveWindow","resolveDocument","resolveBody","defineComponent","declareComponent","setComponentScope","ComponentDeclaration","FactoryDeclaration","declareFactory","FactoryTarget","defineDirective","declareDirective","DirectiveDeclaration","InjectorDef","InjectorDeclaration","defineInjector","declareInjector","NgModuleDeclaration","ModuleWithProviders","defineNgModule","declareNgModule","setNgModuleScope","PipeDeclaration","definePipe","declarePipe","declareClassMetadata","setClassMetadata","queryRefresh","viewQuery","loadQuery","contentQuery","NgOnChangesFeature","InheritDefinitionFeature","CopyDefinitionFeature","ProvidersFeature","listener","getInheritedFactory","sanitizeHtml","sanitizeStyle","sanitizeResourceUrl","sanitizeScript","sanitizeUrl","sanitizeUrlOrResourceUrl","trustConstantHtml","trustConstantResourceUrl","DASH_CASE_REGEXP","dashCaseToCamelCase","input","toUpperCase","splitAtColon","defaultValues","_splitAt","splitAtPeriod","character","characterIndex","trim","visitValue","Array","isArray","visitArray","isStrictStringMap","visitStringMap","visitPrimitive","visitOther","isDefined","val","noUndefined","ValueTransformer","arr","SyncAsync","assertSync","isPromise","then","cb","all","syncAsyncValues","some","Promise","msg","syntaxError","parseErrors","ERROR_SYNTAX_ERROR","ERROR_PARSE_ERRORS","isSyntaxError","getParseErrors","escapeRegExp","s","STRING_MAP_PROTO","getPrototypeOf","utf8Encode","encoded","codePoint","charCodeAt","low","stringify","overriddenName","newLineIndex","substring","hasOwnProperty","Version","full","splits","split","major","minor","patch","__window","window","__self","self","WorkerGlobalScope","__global","global","_global","newArray","size","list","partitionArray","conditionFn","truthy","falsy","item","Comment","_visitor","Text","visitText","BoundText","visitBoundText","TextAttribute","keySpan","valueSpan","visitTextAttribute","BoundAttribute","securityContext","unit","visitBoundAttribute","BoundEvent","handler","target","phase","handlerSpan","visitBoundEvent","event","targetOrPhase","Element","attributes","inputs","outputs","children","references","startSourceSpan","endSourceSpan","visitElement","Template","templateAttrs","variables","visitTemplate","Content","visitContent","Variable","visitVariable","Reference","visitReference","Icu","vars","placeholders","visitIcu","NullVisitor","content","icu","RecursiveVisitor","visitAll","TransformVisitor","newAttributes","transformAll","newInputs","newOutputs","newChildren","newReferences","newTemplateAttrs","newVariables","nodes","visit","newNode","changed","Message","placeholderToMessage","sources","filePath","start","file","url","startLine","line","startCol","col","endLine","end","endCol","Text$1","Container","visitContainer","Icu$1","cases","TagPlaceholder","startName","closeName","visitTagPlaceholder","Placeholder","visitPlaceholder","IcuPlaceholder","visitIcuPlaceholder","CloneVisitor","container","n","expressionPlaceholder","ph","RecurseVisitor","child","k","BigInteger","digits","addToSelf","maxNrOfDigits","Math","max","carry","digitSum","BigIntForMultiplication","powerOfTwos","num","product","zero","multiplyByAndAddTo","exponent","getMultipliedByPowerOfTwo","previousPower","BigIntExponentiation","exponents","one","multiplyBy","digest","message","computeDigest","sha1","serializeNodes","decimalDigest","computeDecimalDigest","_SerializerIgnoreIcuExpVisitor","computeMsgId","_SerializerVisitor","strCases","serializerVisitor","utf8","words32","bytesToWords32","Endian","Big","w","d","h0","h1","h2","h3","h4","j","rol32","fkVal","fk","temp","reduce","add32","bytesToHexString","words32ToByteString","fingerprint","hi","hash32","lo","msgFingerprint","meaningFingerprint","add64","rol64","wordsToDecimalString","bytes","wordAt","Little","mix","sub32","add32to64","high","ah","al","bh","bl","l","h","count","endian","byteAt","word","word32ToByteString","hex","base256","decimal","toThePowerOf","Serializer","SimplePlaceholderMapper","mapName","internalToPublic","publicToNextId","publicToInternal","internalName","publicName","visitPlaceholderName","nextId","_Visitor","strAttrs","_serializeAttributes","strChildren","decl","doctype","rootTag","dtd","serialize","Declaration","unescapedAttrs","escapeXml","visitDeclaration","Doctype","visitDoctype","Tag","visitTag","Text$2","unescapedValue","CR","ws","_ESCAPED_CHARS","_MESSAGES_TAG","_MESSAGE_TAG","_PLACEHOLDER_TAG","_EXAMPLE_TAG","_SOURCE_TAG","_DOCTYPE","Xmb","messages","locale","exampleVisitor","ExampleVisitor","_Visitor$1","rootNode","sourceTags","source","version","encoding","addDefaultExamples","digest$1","toPublicName","startTagAsText","startEx","startTagPh","closeTagAsText","closeEx","closeTagPh","interpolationAsText","exTag","icuExpression","icuType","icuCases","icuAsText","exText","CLOSURE_TRANSLATION_VAR_PREFIX","TRANSLATION_VAR_PREFIX","I18N_ATTR","I18N_ATTR_PREFIX","I18N_ICU_VAR_PREFIX","I18N_ICU_MAPPING_PREFIX","I18N_PLACEHOLDER_SYMBOL","isI18nAttribute","startsWith","isI18nRootNode","meta","isSingleI18nIcu","hasI18nMeta","hasI18nAttrs","icuFromI18nMessage","wrapI18nPlaceholder","contextId","blockId","assembleI18nBoundString","strings","bindingStartIndex","acc","lastIdx","getSeqNumberGenerator","startsAt","placeholdersToParams","updatePlaceholderMap","assembleBoundTextPlaceholders","startIdx","find","idx","i18nFormatPlaceholderNames","useCamelCase","_params","formatI18nPlaceholderName","chunks","postfix","test","pop","shift","getTranslationConstPrefix","extra","declareI18nVariable","UNSAFE_OBJECT_KEY_NAME_REGEXP","TEMPORARY_NAME","CONTEXT_NAME","RENDER_FLAGS","REFERENCE_PREFIX","IMPLICIT_REFERENCE","NON_BINDABLE_ATTR","RESTORED_VIEW_CONTEXT_NAME","temporaryAllocator","unsupported","feature","invalid$1","asLiteral","conditionallyCreateMapObjectLiteral","keepDeclared","getOwnPropertyNames","mapToExpression","declaredName","minifiedName","needsDeclaredName","includes","trimTrailingNulls","getQueryPredicate","query","constantPool","predicate","DefinitionMap","getAttrsForDirectiveMatching","elOrTpl","attributesMap","o","chainedInstruction","calls","span","getInterpolationArgsLength","interpolation","toOptionalLiteralArray","mapper","toOptionalLiteralMap","object","compileDependencies","deps","compileDependency","dep","depMeta","attributeNameType","host","optional","skipSelf","toLiteralMap","generateForwardRef","VERSION","JS_B64_PREFIX","SourceMapGenerator","sourcesContent","lines","lastCol0","hasMappings","has","col0","sourceUrl","sourceLine0","sourceCol0","currentLine","sourcesIndex","from","mappings","lastSourceIndex","lastSourceLine0","lastSourceCol0","segments","segment","segAsStr","toBase64VLQ","toBase64String","JSON","b64","i1","i2","i3","toBase64Digit","digit","B64_DIGITS","_SINGLE_QUOTE_ESCAPE_STRING_RE","_LEGAL_IDENTIFIER_RE","_INDENT_WITH","CATCH_ERROR_VAR$1","CATCH_STACK_VAR$1","_EmittedLine","indent","partsLength","srcSpans","EmitterVisitorContext","_indent","_classes","_preambleLineCount","_lines","lastPart","print","_currentLine","part","newLine","lineIsEmpty","clazz","sourceLines","_createIndent","genFilePath","startsAtLine","firstOffsetMapped","mapFirstOffsetIfNeeded","addSource","addMapping","addLine","lineIdx","spans","spanIdx","sourceLine","sourceCol","column","emittedLine","columnsLeft","AbstractEmitterVisitor","_escapeDollarInStrings","comment","println","printLeadingComments","hasElseCase","removeEmptyLastLine","incIndent","decIndent","lineWasEmpty","getBuiltinMethodName","varName","escapeIdentifier","head","serializeI18nHead","serializeI18nTemplatePart","opStr","visitAllObjects","separator","incrementedIndent","lineLength","escapeDollar","alwaysQuote","requiresQuotes","typeWithParameters","numParams","ANIMATE_SYMBOL_PREFIX","prepareSyntheticPropertyName","prepareSyntheticListenerName","getSafePropertyAccessString","accessor","escapedName","prepareSyntheticListenerFunctionName","jitOnlyGuardedExpression","guardedExpression","devOnlyGuardedExpression","guard","guardExpr","guardNotDefined","guardUndefinedOrTrue","wrapReference","wrapped","refsToArray","refs","shouldForwardDeclare","ref","R3FactoryDelegateType","compileFactoryFunction","t","baseFactoryVar","typeForCtor","isDelegatedFactoryMetadata","internalType","ctorExpr","injectDependencies","retExpr","makeConditionalFactory","nonCtorExpr","r","ctorStmt","toStmt","delegateArgs","delegateDeps","factoryExpr","delegateType","Class","delegate","isExpressionFactoryMetadata","getInheritedFactoryCall","baseFactory","factoryFn","createFactoryType","ctorDepsType","createCtorDepsType","typeArgumentCount","compileInjectDependency","flags","Pipe","flagsParam","injectArgs","injectFn","getInjectFn","hasTypes","attributeTypes","createCtorDepType","Component","Directive","NgModule","Injectable","createR3ProviderExpression","isForwardRef","compileInjectable","resolveForwardRefs","factoryMeta","useClass","useClassOnSelf","delegateToFactory","useFactory","useValue","useExisting","injectableProps","providedIn","createInjectableType","unwrapForwardRefs","createFactoryFunction","unwrappedType","callMethod","assertArrayOfStrings","identifier","UNUSABLE_INTERPOLATION_REGEXPS","assertInterpolationSymbols","regexp","InterpolationConfig","markers","DEFAULT_INTERPOLATION_CONFIG","StaticSymbol","members","StaticSymbolCache","cache","declarationFile","memberSuffix","HOST_REG_EXP","sanitizeIdentifier","_anonymousTypeIndex","identifierName","compileIdentifier","identifierModuleUrl","viewClassName","compType","embeddedTemplateIndex","rendererTypeName","hostViewClassName","componentFactoryName","CompileSummaryKind","tokenName","tokenReference","CompileStylesheetMetadata","moduleUrl","styles","styleUrls","_normalizeArray","CompileTemplateMetadata","encapsulation","templateUrl","htmlAst","externalStylesheets","animations","ngContentSelectors","isInline","preserveWhitespaces","flatten","CompileDirectiveMetadata","isHost","isComponent","exportAs","hostListeners","hostProperties","hostAttributes","providers","viewProviders","queries","guards","viewQueries","entryComponents","componentViewType","rendererType","componentFactory","summaryKind","toSummary","matches","inputsMap","bindConfig","outputsMap","CompilePipeMetadata","CompileShallowModuleMetadata","CompileNgModuleMetadata","declaredDirectives","exportedDirectives","declaredPipes","exportedPipes","bootstrapComponents","importedModules","exportedModules","schemas","transitiveModule","module","modules","TransitiveCompileNgModuleMetadata","directivesSet","directives","exportedDirectivesSet","pipesSet","pipes","exportedPipesSet","modulesSet","entryComponentsSet","provider","ec","componentType","ProviderMeta","multi","dependencies","flat","flatItem","jitSourceUrl","templateSourceUrl","ngModuleType","compMeta","templateMeta","sharedStylesheetJitUrl","pathParts","baseName","ngModuleJitUrl","moduleMeta","templateJitUrl","makeTemplateObjectPolyfill","AbstractJsEmitterVisitor","pushClass","_visitClassConstructor","_visitClassGetter","_visitClassMethod","popClass","_visitParams","fnExpr","currentClass","ConcatArray","SubscribeObservable","Bind","policy","getPolicy","trustedTypes","createPolicy","createScript","trustedScriptFromString","script","newTrustedFunctionForJIT","fnArgs","fnBody","bind","JitEvaluator","reflector","createSourceMaps","converter","JitEmitterVisitor","createRoot","isUseStrictStatement","createReturnStmt","evaluateCode","getArgs","createSourceMap","toSource","fnArgNames","fnArgValues","argName","emptyFn","headerLines","toSourceMapGenerator","toJsComment","executeFunction","_evalArgNames","_evalArgValues","_evalExportedVars","resultVar","_emitReferenceToExternal","resolveExternalReference","hasModifier","Exported","statement","$EOF","$BSPACE","$TAB","$LF","$VTAB","$FF","$CR","$SPACE","$BANG","$DQ","$HASH","$$","$PERCENT","$AMPERSAND","$SQ","$LPAREN","$RPAREN","$STAR","$PLUS","$COMMA","$MINUS","$PERIOD","$SLASH","$COLON","$SEMICOLON","$LT","$EQ","$GT","$QUESTION","$0","$7","$9","$A","$E","$F","$X","$Z","$LBRACKET","$BACKSLASH","$RBRACKET","$CARET","$_","$a","$b","$e","$f","$n","$r","$t","$u","$v","$x","$z","$LBRACE","$BAR","$RBRACE","$NBSP","$PIPE","$TILDA","$AT","$BT","isWhitespace","code","isDigit","isAsciiLetter","isAsciiHexDigit","isNewLine","isOctalDigit","ParseLocation","offset","delta","ch","priorLine","lastIndexOf","fromCharCode","maxChars","maxLines","startOffset","endOffset","ctxChars","ctxLines","before","after","ParseSourceFile","ParseSourceSpan","fullStart","details","ParseErrorLevel","ParseError","level","ERROR","getContext","contextualMessage","typeSourceSpan","sourceFileName","sourceFile","r3JitTypeSourceSpan","typeName","compileInjector","definitionMap","imports","createInjectorType","R3JitReflector","typeOrFunc","lcProperty","cmpMetadata","compileNgModule","bootstrap","declarations","exports","containsForwardDecls","emitInline","setNgModuleScopeCall","generateSetNgModuleScopeCall","createNgModuleType","compileNgModuleDeclarationExpression","moduleType","tupleTypeOf","adjacentType","scopeMap","fnCall","guardedCall","iife","iifeCall","types","compilePipeFromMetadata","metadata","definitionMapValues","pipeName","createPipeType","ParserError","errLocation","ctxLocation","ParseSpan","absoluteOffset","AbsoluteSourceSpan","AST","ASTWithName","nameSpan","Quote","uninterpretedExpression","location","visitQuote","EmptyExpr","ImplicitReceiver","visitImplicitReceiver","ThisReceiver","visitThisReceiver","call","Chain","visitChain","Conditional","trueExp","falseExp","visitConditional","PropertyRead","visitPropertyRead","PropertyWrite","visitPropertyWrite","SafePropertyRead","visitSafePropertyRead","KeyedRead","visitKeyedRead","SafeKeyedRead","visitSafeKeyedRead","KeyedWrite","visitKeyedWrite","BindingPipe","visitPipe","LiteralPrimitive","visitLiteralPrimitive","LiteralArray","visitLiteralArray","LiteralMap","visitLiteralMap","Interpolation","visitInterpolation","Binary","operation","left","right","visitBinary","Unary","binaryOp","binaryLeft","binaryRight","visitUnary","PrefixNot","visitPrefixNot","NonNullAssert","visitNonNullAssert","MethodCall","argumentSpan","visitMethodCall","SafeMethodCall","visitSafeMethodCall","FunctionCall","visitFunctionCall","ASTWithSource","errors","visitASTWithSource","VariableBinding","ExpressionBinding","RecursiveAstVisitor$1","asts","AstTransformer$1","createPlus","createMinus","AstMemoryEfficientTransformer","modified","ParsedProperty","isLiteral","ParsedPropertyType","LITERAL_ATTR","isAnimation","ANIMATION","ParsedEvent","ParsedVariable","BoundElementProperty","CORE$1","Identifiers$1","ANALYZE_FOR_ENTRY_COMPONENTS","ElementRef","NgModuleRef","ViewContainerRef","ChangeDetectorRef","QueryList","TemplateRef","Renderer2","CodegenComponentFactoryResolver","ComponentFactoryResolver","ComponentFactory","ComponentRef","NgModuleFactory","createModuleFactory","moduleDef","moduleProviderDef","RegisterModuleFactoryFn","INJECTOR","Injector","LOCALE_ID","TRANSLATIONS_FORMAT","inlineInterpolate","interpolate","EMPTY_ARRAY","EMPTY_MAP","Renderer","viewDef","elementDef","anchorDef","textDef","directiveDef","providerDef","queryDef","pureArrayDef","pureObjectDef","purePipeDef","pipeDef","nodeValue","ngContentDef","unwrapValue","createRendererType2","RendererType2","ViewDefinition","createComponentFactory","createTokenForReference","createTokenForExternalReference","EventHandlerVars","ConvertActionBindingResult","allowDefault","render3Stmts","convertActionBinding","localResolver","implicitReceiver","action","bindingId","interpolationFunction","baseSourceSpan","implicitReceiverAccesses","globals","DefaultLocalResolver","actionWithoutBuiltins","convertPropertyBindingBuiltins","createLiteralArrayConverter","argCount","createLiteralMapConverter","createPipeConverter","_AstToIrVisitor","actionStmts","flattenStatements","_Mode","prependTemporaryDecls","temporaryCount","usesImplicitReceiver","notifyImplicitReceiverUse","preventDefaultVar","lastStatement","returnExpr","convertStmtIntoExpression","createPreventDefaultVar","cast","notIdentical","converterFactory","convertBuiltins","ConvertPropertyBindingResult","currValExpr","BindingForm","convertPropertyBinding","expressionWithoutBuiltins","form","outputExpr","getStatementsFromVisitor","TrySimple","createCurrValueExpr","convertUpdateArguments","contextVariableExpression","expressionWithArgumentsToExtract","temporaryDeclaration","_BuiltinAstConverter","temporaryName","temporaryNumber","unshift","ensureStatementMode","mode","ensureExpressionMode","convertToStatementIfNeeded","_converterFactory","BuiltinFunctionCall","_localResolver","_implicitReceiver","_nodeMap","_resultMap","_currentTemporary","op","_visit","convertSourceSpan","convertNullishCoalesce","conditional","convertedArgs","fnResult","leftMostSafe","leftMostSafeNode","convertSafeAccess","maybeRestoreView","getLocal","prevUsesImplicitReceiver","varExpr","_getLocal","addImplicitReceiverAccess","localExpr","temporary","needsTemporaryInSafeAccess","allocateTemporary","isBlank","access","delete","releaseTemporary","and","visitSome","tempNumber","moveBy","output","ShadowCss","strictStyling","cssText","hostSelector","commentsWithHash","extractCommentsWithHash","stripComments","_insertDirectives","scopedCssText","_scopeCssText","_insertPolyfillDirectivesInCssText","_insertPolyfillRulesInCssText","_cssContentNextSelectorRe","_cssContentRuleRe","rule","scopeSelector","unscopedRules","_extractUnscopedRulesFromCssText","_insertPolyfillHostInCssText","_convertColonHost","_convertColonHostContext","_convertShadowDOMSelectors","_scopeSelectors","_cssContentUnscopedRuleRe","_cssColonHostRe","_","hostSelectors","otherSelectors","convertedSelectors","hostSelectorArray","convertedSelector","_polyfillHostNoCombinator","_polyfillHost","_cssColonHostContextReGlobal","selectorText","contextSelectorGroups","_cssColonHostContextRe","newContextSelectors","contextSelectorGroupsLength","repeatGroups","contextSelectors","combineHostContextSelectors","_shadowDOMSelectorsRe","pattern","processRules","_scopeSelector","_stripScopingSelectors","CssRule","_shadowDeepSelectors","_polyfillHostNoCombinatorRe","strict","deepParts","shallowPart","otherParts","applyScope","_selectorNeedsScoping","_applyStrictSelectorScope","_applySelectorScope","re","_makeScopeMatcher","lre","rre","_selectorReSuffix","_applySimpleSelectorScope","_polyfillHostRe","replaceBy","hnc","colon","isRe","_scopeSelectorPart","scopedP","safeContent","SafeSelector","scopedSelector","startIndex","sep","hasHost","shouldScope","scopedPart","restore","_colonHostContextRe","_polyfillHostContext","_colonHostRe","_escapeRegexMatches","_content","pseudo","_ph","keep","_parenSuffix","_commentRe","_commentWithHashRe","BLOCK_PLACEHOLDER","QUOTE_PLACEHOLDER","_ruleRe","_quotedRe","CONTENT_PAIRS","QUOTE_PAIRS","ruleCallback","inputWithEscapedQuotes","escapeBlocks","inputWithEscapedBlocks","escapedString","nextBlockIndex","nextQuoteIndex","suffix","contentPrefix","blocks","StringWithEscapedBlocks","charPairs","placeholder","resultParts","escapedBlocks","openCharCount","nonBlockStartIndex","blockStartIndex","openChar","closeChar","hostMarker","otherSelectorsHasHost","combined","contextSelector","previousSelectors","groups","multiples","COMPONENT_VARIABLE","HOST_ATTR","CONTENT_ATTR","StylesCompileDependency","setValue","CompiledStylesheet","outputCtx","stylesVar","isShimmed","StyleCompiler","_urlResolver","_shadowCss","comp","_compileStyles","needsStyleShim","stylesheet","shim","Emulated","isComponentStylesheet","styleExpressions","plainStyle","_shimIfNeeded","styleUrl","exprIndex","getStylesVarName","Const","style","shimCssText","component","AstPath","path","position","ctor","NodeWithI18n","Text$3","Expansion","switchValue","switchValueSourceSpan","visitExpansion","ExpansionCase","valueSourceSpan","expSourceSpan","visitExpansionCase","Attribute","visitAttribute","Element$1","Comment$1","visitComment","visitAll$1","astResult","RecursiveVisitor$1","visitChildren","apply","spanOf","findNode","TokenType","Token","TokenError","errorMsg","tokenType","TokenizeResult","tokens","nonNormalizedIcuExpressions","tokenize","getTagDefinition","options","tokenizer","_Tokenizer","mergeTextTokens","_CR_OR_CRLF_REGEXP","_unexpectedCharacterErrorMsg","charCode","_unknownEntityErrorMsg","entitySrc","_unparsableEntityErrorMsg","entityStr","CharacterReferenceType","_ControlFlowError","_file","_getTagDefinition","_currentTokenStart","_currentTokenType","_expansionCaseStack","_inInterpolation","_tokenizeIcu","tokenizeExpansionForms","_interpolationConfig","interpolationConfig","_leadingTriviaCodePoints","leadingTriviaChars","codePointAt","endPos","startPos","_cursor","EscapedCharacterCursor","PlainCharacterCursor","_preserveLineEndings","preserveLineEndings","_escapedString","_i18nNormalizeLineEndingsInICUs","i18nNormalizeLineEndingsInICUs","init","handleError","peek","_attemptCharCode","_consumeCdata","_consumeComment","_consumeDocType","_consumeTagClose","_consumeTagOpen","_tokenizeExpansionForm","_consumeText","_beginToken","EOF","_endToken","isExpansionFormStart","_consumeExpansionFormStart","isExpansionCaseStart","_isInExpansionForm","_consumeExpansionCaseStart","_isInExpansionCase","_consumeExpansionCaseEnd","_consumeExpansionFormEnd","getSpan","CursorError","_createError","cursor","compareCharCodeCaseInsensitive","chars","charsLeft","initialPosition","_attemptCharCodeCaseInsensitive","_attemptStr","_attemptCharCodeUntilFn","diff","decodeEntities","_decodeEntity","fromCodePoint","isHex","codeStart","isDigitEntityEnd","entityType","HEX","DEC","getChars","strNum","parseInt","nameStart","isNamedEntityEnd","endMarkerPredicate","tagCloseStart","foundEndMarker","_readChar","_processCarriageReturns","COMMENT_START","_requireCharCode","_consumeRawText","COMMENT_END","_requireStr","CDATA_START","CDATA_END","DOC_TYPE","contentStart","_attemptUntilChar","nameOrPrefixStart","isPrefixEnd","_requireCharCodeUntilFn","isNameEnd","openTagToken","_consumeTagOpenStart","isNotWhitespace","_consumeAttributeName","_consumeAttributeValue","_consumeTagOpenEnd","INCOMPLETE_TAG_OPEN","TEXT","contentTokenType","getContentType","_consumeRawTextWithTagClose","_attemptStrCaseInsensitive","TAG_CLOSE","TAG_OPEN_START","_consumePrefixAndName","attrNameStart","ATTR_NAME","prefixAndName","ATTR_QUOTE","quoteChar","ATTR_VALUE","valueStart","TAG_OPEN_END_VOID","TAG_OPEN_END","EXPANSION_FORM_START","_readUntil","normalizedCondition","conditionToken","EXPANSION_CASE_VALUE","EXPANSION_CASE_EXP_START","EXPANSION_CASE_EXP_END","EXPANSION_FORM_END","_isTextEnd","_isTagStart","tmp","isInterpolation","code1","code2","toUpperCaseCharCode","srcTokens","dstTokens","lastDstToken","fileOrCursor","state","advanceState","updatePeek","leadingTriviaCodePoints","startLocation","locationFromCursor","endLocation","fullStartLocation","pos","currentChar","internalState","processEscapeSequence","digitStart","decodeHexDigits","octal","previous","isNaN","TreeError","ParseTreeResult","rootNodes","Parser","tokenizeResult","parser","_TreeBuilder","build","_index","_elementStack","_advance","_peek","_consumeStartTag","_consumeEndTag","_closeVoidElement","_consumeExpansion","prev","_startToken","_advanceIf","_addToParent","expCase","_parseExpansionCase","_collectExpansionExpTokens","expansionCaseParser","expansionFormStack","lastOnStack","_getParentElement","el","startTagToken","_consumeAttr","_getElementFullName","selfClosing","tagDef","startSpan","_pushElement","_popElement","parentEl","isClosedByChild","endTagToken","errMsg","unexpectedCloseTagDetected","stackIndex","splice","valueToken","quoteToken","parentElement","parentTagName","parentTagDefinition","stack","HtmlParser","PRESERVE_WS_ATTR_NAME","SKIP_WS_TRIM_TAGS","WS_CHARS","NO_WS_REGEXP","WS_REPLACE_REGEXP","hasPreserveWhitespacesAttr","replaceNgsp","WhitespaceVisitor","visitAllWithSiblings","isNotBlank","hasExpansionSibling","next","expansion","expansionCase","removeWhitespaces","htmlAstWithErrors","PLURAL_CASES","expandNodes","expander","_Expander","ExpansionResult","isExpanded","expanded","ExpansionError","_expandPluralForm","_expandDefaultForm","icuCase","expansionResult","switchAttr","TextAst","ngContentIndex","BoundTextAst","AttrAst","visitAttr","BoundPropertyMapping","BoundElementPropertyAst","visitElementProperty","BoundEventAst","calcFullName","visitEvent","ReferenceAst","originalValue","VariableAst","v","ElementAst","hasViewContainer","queryMatches","EmbeddedTemplateAst","visitEmbeddedTemplate","BoundDirectivePropertyAst","directiveName","templateName","visitDirectiveProperty","DirectiveAst","directive","hostEvents","contentQueryStartId","visitDirective","ProviderAst","multiProvider","eager","providerType","lifecycleHooks","isModule","ProviderAstType","NgContentAst","visitNgContent","NullTemplateVisitor","RecursiveTemplateAstVisitor","templateVisitAll","ProviderError","ProviderViewContext","_getViewQueries","ProviderElementContext","viewContext","_parent","_isViewRoot","_directiveAsts","isTemplate","_sourceSpan","_transformedProviders","_seenProviders","_queriedTokens","transformedHasViewContainer","_attrs","attrAst","directivesMeta","directiveAst","_allProviders","_resolveProvidersFromDirectives","_contentQueries","_getContentQueries","_addQueryReadsTo","templateRefId","refAst","defaultQueryValue","_getOrCreateLocalProvider","lazyProviders","eagerProviders","sortedProviderTypes","transformProviders","sortedDirectives","sort","dir1","dir2","allMatches","defaultValue","queryReadTokens","_getQueriesFor","queryValue","read","tokenRef","queryId","currentEl","distance","requestingProviderType","resolvedProvider","PublicService","PrivateService","Builtin","transformedProviderAst","transformedProviders","transformedUseValue","transformedUseExisting","transformedDeps","existingDiDep","_getDependency","diDeps","_transformProvider","_transformProviderAst","isAttribute","isValue","currElement","currEager","isSkipSelf","_getLocalDependency","isSelf","isOptional","prevElement","NgModuleProviderAnalyzer","extraProviders","_errors","ngModuleProvider","_resolveProviders","errorString","requestorSourceSpan","foundLocal","targetErrors","providersByToken","dirProvider","directivesWithComponentFirst","targetProvidersByToken","isUseValue","viewQueryId","_addQueryToTokenMap","contentQueryId","contentQueries","directiveIndex","StyleWithImports","isStyleUrlResolvable","schemeMatch","URL_WITH_SCHEMA_REGEXP","extractStyleUrls","resolver","baseUrl","foundUrls","modifiedCssText","CSS_STRIPPABLE_COMMENT_REGEXP","CSS_IMPORT_REGEXP","resolve","PROPERTY_PARTS_SEPARATOR","ATTRIBUTE_PREFIX","CLASS_PREFIX","STYLE_PREFIX","TEMPLATE_ATTR_PREFIX","ANIMATE_PROP_PREFIX","BindingParser","_exprParser","_schemaRegistry","pipesByName","_usedPipes","dirMeta","boundProps","propName","parsePropertyBinding","_reportError","elementSelector","createBoundHostProperties","createBoundElementProperty","targetEvents","parseEvent","sourceInfo","parseInterpolation","_reportExpressionParserErrors","_checkPipes","wrapLiteralPrimitive","parseInterpolationExpression","tplKey","tplValue","absoluteValueOffset","targetMatchableAttrs","targetProps","targetVars","isIvyAst","absoluteKeyOffset","bindings","_parseTemplateBindings","binding","bindingSpan","moveParseSourceSpan","srcSpan","_parsePropertyAst","parseLiteralAttr","bindingsResult","parseTemplateBindings","templateBindings","warnings","warning","WARNING","isAnimationLabel","_parseAnimation","isAnimationProp","_parseBinding","DEFAULT","isHostBinding","parseSimpleBinding","parseBinding","boundProp","skipValidation","mapPropertyName","NONE","bindingType","boundPropertyName","securityContexts","_validatePropertyOrAttributeName","calcPossibleSecurityContexts","nsSeparatorIdx","ns","STYLE","mappedPropName","getMappedPropName","_parseAnimationEvent","_parseRegularEvent","_parseAction","parseAction","collector","PipeCollector","pipeMeta","isAttr","report","validateAttribute","validateProperty","registry","ctxs","elementNames","allKnownElementNames","notElementNames","isElementSelector","possibleElementNames","absoluteSpan","startDiff","endDiff","NG_CONTENT_SELECT_ATTR","LINK_ELEMENT","LINK_STYLE_REL_ATTR","LINK_STYLE_HREF_ATTR","LINK_STYLE_REL_VALUE","STYLE_ELEMENT","SCRIPT_ELEMENT","NG_NON_BINDABLE_ATTR","NG_PROJECT_AS","preparseElement","selectAttr","hrefAttr","relAttr","nonBindable","projectAs","lcAttrName","normalizeNgContentSelect","nodeName","PreparsedElementType","OTHER","NG_CONTENT","SCRIPT","STYLESHEET","PreparsedElement","BIND_NAME_REGEXP","KW_BIND_IDX","KW_LET_IDX","KW_REF_IDX","KW_ON_IDX","KW_BINDON_IDX","KW_AT_IDX","IDENT_KW_IDX","IDENT_BANANA_BOX_IDX","IDENT_PROPERTY_IDX","IDENT_EVENT_IDX","TEMPLATE_ATTR_PREFIX$1","CLASS_ATTR","_TEXT_CSS_SELECTOR","TEXT_CSS_SELECTOR","TemplateParseError","TemplateParseResult","templateAst","usedPipes","TemplateParser","_config","_reflector","_htmlParser","_console","transforms","tryParse","warn","htmlParseResult","getInterpolationConfig","tryParseHtml","expandHtml","uniqDirectives","removeSummaryDuplicates","uniqPipes","providerViewContext","bindingParser","parseVisitor","TemplateParseVisitor","EMPTY_ELEMENT_CONTEXT","getUsedPipes","_assertNoReferenceDuplicationOnTemplate","transform","forced","expandedHtmlAst","fromArray","existingReferences","config","_bindingParser","_schemas","_targetErrors","selectorMatcher","directivesIndex","ngContentCount","findNgContentIndex","valueNoNgsp","queryStartIndex","elName","preparsedElement","matchableAttrs","elementOrDirectiveProps","elementOrDirectiveRefs","elementVars","events","templateElementOrDirectiveProps","templateMatchableAttrs","templateElementVars","hasInlineTemplates","isTemplateElement","parsedVariables","hasBinding","_parseAttr","fromParsedVariable","templateValue","templateKey","normalizedName","_normalizeAttributeName","hasTemplateBinding","parseInlineTemplateBinding","elementCssSelector","createElementCssSelector","_parseDirectives","directiveMetas","matchElement","boundDirectivePropNames","directiveAsts","_createDirectiveAsts","elementProps","_createElementPropertyAsts","isViewRoot","providerContext","NON_BINDABLE_VISITOR","ElementContext","afterElement","projectionSelector","parsedElement","_isEmptyTextNode","_assertAllEventsPublishedByDirectives","_assertNoComponentsNorElementBindingsOnTemplate","transformedDirectiveAsts","_assertElementExists","_assertOnlyOneComponent","templateQueryStartIndex","templateSelector","templateBoundDirectivePropNames","templateDirectiveAsts","templateElementProps","templateProviderContext","targetRefs","boundEvents","bindParts","_parseVariable","_parseReference","_parseAssignmentEvent","parsePropertyInterpolation","fromParsedEvent","ElementOrDirectiveRef","elementSourceSpan","targetReferences","targetBoundDirectivePropNames","matchedReferences","directiveProperties","boundProperties","createDirectiveHostPropertyAsts","fromBoundProperty","_checkPropertiesInSchema","parsedEvents","createDirectiveHostEventAsts","_createDirectivePropertyAsts","elOrDirRef","isReferenceToDirective","refToken","targetBoundDirectiveProps","boundPropsByName","prevValue","dirProp","elProp","isEmptyExpression","boundElementProps","_findComponentDirectives","componentTypeNames","_findComponentDirectiveNames","hasElement","allDirectiveEvents","hasProperty","NonBindableVisitor","attrNameAndValues","splitExportAs","splitClasses","classAttrValue","_ngContentIndexMatcher","_wildcardNgContentIndex","ngContentIndices","wildcardNgContentIndex","elNameNoNs","attrNameNoNs","items","parenDepth","propStart","currentProp","valueHasQuotes","hyphenate","styleVal","stripUnnecessaryQuotes","qS","qE","tempValue","IMPORTANT_FLAG","MIN_STYLING_BINDING_SLOTS_REQUIRED","StylingBuilder","_directiveExpr","_hasInitialValues","hasBindings","hasBindingsWithPipes","_classMapInput","_styleMapInput","_singleStyleInputs","_singleClassInputs","_lastStylingInput","_firstStylingInput","_stylesIndex","_classesIndex","_initialStyleValues","_initialClassValues","registerInputBasedOnName","registerStyleInput","registerClassInput","isStyle","isClass","isMapBased","isCssCustomProperty","parseProperty","hasOverrideFlag","bindingSuffix","registerIntoMap","_checkForPipes","populateInitialStylingAttrs","valueConverter","_buildMapBasedInstruction","isClassBased","stylingInput","totalBindingSlotsRequired","mapValue","getClassMapInterpolationExpression","getStyleMapInterpolationExpression","supportsInterpolation","allocateBindingSlots","convertFn","convertResult","getInterpolationExpressionFn","instructions","previousInstruction","referenceForCall","_buildSingleInputs","getStylePropInterpolationExpression","styleMapInstruction","buildStyleMapInstruction","classMapInstruction","buildClassMapInstruction","_buildStyleInputs","_buildClassInputs","overrideIndex","unitIndex","TokenType$1","KEYWORDS","Lexer","scanner","_Scanner","scanToken","Token$1","numValue","strValue","Character","Operator","Identifier","PrivateIdentifier","Keyword","newCharacterToken","newIdentifierToken","newPrivateIdentifierToken","newKeywordToken","newOperatorToken","newStringToken","newNumberToken","newErrorToken","isIdentifierStart","scanIdentifier","scanNumber","scanCharacter","scanString","scanPrivateIdentifier","scanOperator","scanQuestion","scanComplexOperator","twoCode","two","threeCode","three","isIdentifierPart","simple","isExponentStart","isExponentSign","parseIntAutoRadix","parseFloat","buffer","marker","unescapedCode","unescape","last","isIdentifier","isQuote","SplitInterpolation","offsets","TemplateBindingParseResult","Parser$1","_lexer","simpleExpressionChecker","SimpleExpressionChecker","_checkNoInterpolation","sourceToLex","_stripComments","_ParseAST","parseChain","_parseBindingAst","checker","checkSimpleExpression","_parseQuote","prefixSeparatorIndex","toAbsolute","splitInterpolation","expressionNodes","expressionText","createInterpolationAst","atInterpolation","extendLastString","interpStart","interpEnd","exprStart","exprEnd","_getInterpolationEndIndex","fullEnd","piece","_commentStart","outerQuote","nextChar","endIndex","_forEachUnquotedChar","charIndex","expressionEnd","currentQuote","escapeCount","IvyParser","IvySimpleExpressionChecker","ParseContextFlags","inputLength","rparensExpected","rbracketsExpected","rbracesExpected","sourceSpanCache","atEOF","currentEndIndex","curToken","inputIndex","artificialEndIndex","serial","ret","isCharacter","isKeywordLet","isKeywordAs","consumeOptionalCharacter","isOperator","consumeOptionalOperator","tok","isKeyword","isPrivateIdentifier","_reportErrorForPrivateIdentifier","prettyPrintToken","isString","parsePipe","artificialStart","artificialEnd","parseExpression","nameId","expectIdentifierOrKeyword","fullSpanEnd","parseConditional","parseLogicalOr","yes","no","parseLogicalAnd","parseNullishCoalescing","parseEquality","parseRelational","parseAdditive","parseMultiplicative","parsePrefix","parseCallChain","parsePrimary","parseAccessMemberOrMethodCall","parseKeyedReadOrWrite","parseCallArguments","expectCharacter","isKeywordNull","isKeywordUndefined","isKeywordTrue","isKeywordFalse","isKeywordThis","parseExpressionList","parseLiteralMap","isNumber","toNumber","literalValue","terminator","keyStart","expectIdentifierOrKeywordOrString","isSafe","withContext","Writable","argumentStart","positionals","operatorFound","currentAbsoluteOffset","parseDirectiveKeywordBindings","letBinding","parseLetBinding","expectTemplateBindingKey","parseAsBinding","consumeStatementTerminator","getDirectiveBoundTarget","spanEnd","asBinding","peekKeywordAs","peekKeywordLet","spanStart","locationText","skip","extraMessage","errorMessage","isError","mapLiteral","_SECURITY_SCHEMA","SECURITY_SCHEMA","registerContext","HTML","URL","RESOURCE_URL","specs","spec","ElementSchemaRegistry","BOOLEAN","NUMBER","STRING","OBJECT","SCHEMA","_ATTR_TO_PROP","_PROP_TO_ATTR","inverted","DomElementSchemaRegistry","_schema","encodedType","strType","strProperties","properties","typeNames","superName","superType","schemaMetas","schema","elementProperties","camelCaseProp","userProvidedProp","strVal","_isPixelDimensionStyle","valAndSuffixMatch","TRUSTED_TYPES_SINKS","isTrustedTypesSink","BIND_NAME_REGEXP$1","KW_BIND_IDX$1","KW_LET_IDX$1","KW_REF_IDX$1","KW_ON_IDX$1","KW_BINDON_IDX$1","KW_AT_IDX$1","IDENT_KW_IDX$1","BINDING_DELIMS","BANANA_BOX","PROPERTY","EVENT","TEMPLATE_ATTR_PREFIX$2","htmlAstToRender3Ast","htmlNodes","HtmlAstToIvyAst","ivyNodes","allErrors","collectCommentNodes","commentNodes","inI18nBlock","isI18nRootElement","reportError","contents","textContents","parsedProperties","i18nAttrsMeta","templateParsedProperties","templateVariables","elementHasInlineTemplate","normalizeAttributeName","isTemplateBinding","parseAttribute","NON_BINDABLE_VISITOR$1","isEmptyTextNode","isCommentNode","extractAttributes","bound","hoistedAttrs","_visitTextWithInterpolation","formattedKey","i18nPropsMeta","bep","fromBoundElementProperty","matchableAttributes","createKeySpan","normalizationAdjustment","keySpanStart","keySpanEnd","parseVariable","parseReference","addEvents","parseAssignmentEvent","delims","endsWith","NonBindableVisitor$1","TagType","setupRegistry","getUniqueId","icus","I18nContext","templateIndex","isEmitted","_unresolvedCtxCount","_registry","closed","serializePlaceholderValue","phs","appendTag","TEMPLATE","ELEMENT","findTemplateFn","childPhs","tmplIdx","findIndex","isCloseTag","isTemplateTag","tmpl","wrap","symbol","wrapTag","IcuSerializerVisitor","formatPh","serializer","serializeIcuNode","TAG_TO_PLACEHOLDER_NAMES","PlaceholderRegistry","_placeHolderNameCounts","_signatureToName","signature","_hashTag","upperTag","_generateUniqueName","_hashClosingTag","upperName","seen","_expParser","createI18nMessageFactory","_I18nVisitor","visitNodeFn","toI18nMessage","noopVisitNodeFn","_html","_expressionParser","isIcu","icuDepth","placeholderRegistry","placeholderToContent","i18nodes","startPhName","getStartTagPlaceholderName","closePhName","getCloseTagPlaceholderName","i18nIcuCases","i18nIcu","caze","expPh","getUniquePlaceholder","phName","getPlaceholderName","_icuCase","_context","previousI18n","_addText","_addPlaceholder","reusePreviousSourceSpans","textPiece","interpolationSpan","stringSpan","getOffsetSourceSpan","extractPlaceholderName","assertSingleContainerMessage","assertEquivalentNodes","previousNodes","_CUSTOM_PH_EXP","I18nError","setI18nRefs","htmlNode","i18nNode","previousMessage","I18nMetaVisitor","keepI18nAttrs","enableI18nLegacyMessageIdFormat","_createI18nMessage","_parseMetadata","_setMessageId","_setLegacyIds","attrsMeta","_generateI18nMessage","currentMessage","parseI18nMeta","I18N_MEANING_SEPARATOR","I18N_ID_SEPARATOR","idIndex","descIndex","meaningAndDesc","i18nMetaToJSDoc","GOOG_GET_MSG","createGoogleGetMsgStatements","variable$1","closureVar","messageString","serializeI18nMessageForGetMsg","googGetMsgStmt","toConstDecl","metaComment","addLeadingComment","i18nAssignmentStmt","GetMsgSerializerVisitor","serializerVisitor$1","createLocalizeStatements","serializeI18nMessageForLocalize","placeHolders","getSourceSpan","localizedString$1","variableInitialization","LocalizeSerializerVisitor","createPlaceholderPiece","serializerVisitor$2","pieces","processMessagePieces","startNode","endNode","createEmptyMessagePart","NG_CONTENT_SELECT_ATTR$1","NG_PROJECT_AS_ATTR_NAME","EVENT_BINDING_SCOPE_GLOBALS","GLOBAL_TARGET_RESOLVERS","LEADING_TRIVIA_CHARS","renderFlagCheckIfStmt","bitwiseAnd","prepareEventListenerParameters","eventAst","handlerName","scope","eventArgumentName","implicitReceiverExpr","bindingLevel","getOrCreateSharedContextVar","bindingExpr","variableDeclarations","restoreViewStatement","fnName","handlerFn","createComponentDefConsts","prepareStatements","constExpressions","i18nVarRefsCache","TemplateDefinitionBuilder","parentBindingScope","contextName","i18nContext","directiveMatcher","pipeTypeByName","_namespace","relativeContextFilePath","i18nUseExternalIds","_constants","_dataIndex","_bindingContext","_prefixCode","_creationCodeFns","_updateCodeFns","_currentIndex","_tempVariables","_nestedTemplateFns","_unsupported","_pureFunctionSlots","_bindingSlots","_ngContentReservedSlots","_ngContentSelectorsOffset","_implicitReceiverExpr","_bindingScope","nestedScope","fileBasedI18nSuffix","_valueConverter","ValueConverter","allocateDataSlot","numSlots","allocatePureFunctionSlots","slot","pipeType","creationInstruction","ngContentSelectorsOffset","registerContextVariables","initI18nContext","isSingleElementTemplate","selfClosingI18nInstruction","hasTextChildrenOnly","updatePipeSlotOffsets","buildTemplateFn","r3ReservedSlots","creationStatements","updateStatements","creationVariables","viewSnapshotStatements","updateVariables","creationBlock","updateBlock","retrievalLevel","localRefLookup","transformFn","_ref","i18nGenerateMainBlockVar","i18nGenerateClosureVar","getTranslationDeclStmts","scopedName","freshReferenceName","relativeLevel","isListenerScope","hasRestoreViewVariable","notifyRestoredViewContextUse","sharedCtxVar","getSharedContextName","generateNextContextExpr","appendBinding","label","i18nAppendBindings","messageId","uniqueSuffix","isRoot","isResolved","getSerializedPlaceholders","icuMapping","needsPostprocessing","instruction","i18nTranslate","forkChildContext","addToConsts","reconcileChildContext","i18nUpdateRef","chainBindings","updateInstructionChainWithAdvance","getConstCount","updateInstruction","nodeIndex","i18nAttrArgs","converted","constIndex","namespaceKey","nsInstruction","elementIndex","updateInstructionWithAdvance","getUpdateInstructionArguments","ngContent","projectionSlotIdx","nonContentSelectAttributes","getAttributeExpressions","appendProjection","stylingBuilder","isNonBindableMode","outputAttrs","isNgContainer$1","registerStyleAttr","registerClassAttr","matchDirectives","allOtherInputs","boundI18nAttrs","stylingInputWasSet","registerBoundInput","addAttrsToConsts","prepareRefsArray","wasInNamespace","currentNamespace","getNamespaceInstruction","addNamespaceInstruction","appendElement","hasChildren","createSelfClosingInstruction","createSelfClosingI18nInstruction","i18nAttributesInstruction","listeners","outputAst","prepareListenerParameter","creationInstructionChain","stylingInstructions","buildUpdateLevelInstructions","limit","processStylingUpdateInstruction","emptyValueBindInstruction","propertyBindings","attributeBindings","inputType","hasValue","attrNamespace","isAttributeBinding","sanitizationRef","resolveSanitizationFn","namespaceLiteral","interpolatedUpdateInstruction","getPropertyInterpolationExpression","getAttributeInterpolationExpression","boundValue","NG_TEMPLATE_TAG_NAME","appendTemplate","tagNameWithoutNamespace","attrsExprs","templateVisitor","templateFunctionExpr","buildTemplateFunction","getVarCount","templatePropertyBindings","i18nInputs","appendBoundText","getTextInterpolationExpression","initWasInvoked","i18nBindProps","formatted","appendIcu","fns","paramsOrFn","prepend","instructionFn","addAdvanceInstructionIfNecessary","fnParams","updateInstructionChain","originalSlots","convertedPropertyBinding","getImplicitReceiverExpr","bindingContext","valExpr","createCssSelector","staticType","renderAttributes","alreadySeen","attrExprs","ngProjectAsAttr","i18nVarRef","getAttributeNameLiterals","trustedConstAttribute","getNgProjectAsLiteral","addAttrExpr","attrsLengthBeforeInputs","consts","refsParam","variableName","nextContextStmt","refExpr","bindingFnName","allocateSlot","_pipeBindExprs","slotPseudoLocal","pureFunctionSlot","pipeBindingCallInfo","isVarLength","pipeBindExpr","bindingSlots","slotOffset","array","getLiteralFactory","pipeBindingIdentifiers","pureFunctionIdentifiers","pureFunctionCallInfo","relativeLevelDiff","literal$1","allocateSlots","startSlot","attributeNamespace","nameLiteral","SHARED_CONTEXT_KEY","BindingScope","referenceNameIndex","restoreViewVariable","usesRestoredViewContext","declareLocalCallback","declare","priority","localRef","maybeGenerateSharedContextVar","getComponentProperty","newScope","generateSharedContextVar","bindingKey","sharedCtxObj","componentValue","restoreCall","currentContextLevel","levelDiff","currStmts","elementNameNoNs","nameNoNs","parsedR3Selector","parseTemplate","makeBindingParser","htmlParser","parseResult","alwaysAttemptHtmlToR3AstConversion","parsedTemplate","i18nMetaVisitor","i18nMetaResult","visitAllWithErrors","elementRegistry","isTextNode","NG_I18N_CLOSURE_MODE","createClosureModeGuard","ATTR_REGEX","baseDirectiveFields","createContentQueriesFunction","createViewQueriesFunction","createHostBindingsFunction","addFeatures","features","usesInheritance","fullInheritance","lifecycle","usesOnChanges","compileDirectiveFromMetadata","createDirectiveType","compileComponentFromMetadata","firstSelector","selectorAttributes","getAttrs","templateTypeName","directivesUsed","pipesUsed","templateBuilder","createRootScope","templateFunctionExpression","getNgContentSelectors","getConsts","constsExpr","directivesList","directivesExpr","compileDeclarationList","declarationListEmitMode","pipesList","pipesExpr","styleValues","compileStyles","createComponentType","createDirectiveTypeParams","stringArrayAsType","resolvedList","prepareQueryParams","toQueryFlags","static","convertAttributesToExpressions","createStatements","tempAllocator","getQueryList","refresh","updateDirective","propertyName","contentQueriesFnName","stringAsType","stringMapAsType","mapValues","selectorForType","q","queryDefinition","viewQueryFnName","hostBindingsMetadata","styleBuilder","specialAttributes","styleAttr","hostBindingSourceSpan","directiveSummary","metadataAsSummary","eventBindings","createHostListeners","allOtherBindings","totalHostVarsCount","getValueConverter","hostVarsCountFn","originalVarsCount","syntheticHostBindings","bindingFn","getBindingNameAndInstruction","bindingName","sanitizerFn","instructionParams","hostAttrs","assignHostAttrs","convertStylingCall","hostBindingsFnName","implicit","attrMatches","syntheticListeners","HOST_REG_EXP$1","parseHostBindings","verifyHostBindings","summary","shadowCss","ResourceLoader","CompilerFacadeImpl","jitEvaluator","elementSchemaRegistry","angularCoreEnv","sourceMapUrl","facade","jitExpression","declaration","convertDeclarePipeFacadeToMetadata","computeProvidedIn","convertToProviderExpression","USE_CLASS","wrapExpression","USE_FACTORY","USE_VALUE","USE_EXISTING","convertR3DependencyMetadata","convertR3DeclareDependencyMetadata","convertDeclareInjectorFacadeToMetadata","convertDirectiveFacadeToMetadata","compileDirectiveFromMeta","createParseSourceSpan","convertDeclareDirectiveFacadeToMetadata","parseJitTemplate","getDefaultComponentElementName","jitExpressionSourceMap","compileComponentFromMeta","convertDeclareComponentFacadeToMetadata","factoryRes","convertR3DependencyMetadataArray","def","preStatements","evaluateStatements","convertToR3QueryMetadata","convertQueryDeclarationToMetadata","inputsFromMetadata","parseInputOutputs","outputsFromMetadata","propMetadata","inputsFromType","outputsFromType","field","ann","isInput","isOutput","extractHostBindings","_e","_f","_g","_h","convertHostDeclarationToMetadata","convertOpaqueValuesToExpressions","classAttribute","styleAttribute","components","convertUsedDirectiveDeclarationToMetadata","convertUsedPipesToMetadata","parsed","err","facades","isAttributeDep","rawToken","createR3DependencyMetadata","isHostListener","publishFacade","ng","ɵcompilerFacade","VERSION$1","CompilerConfig","defaultEncapsulation","useJit","jitDevMode","missingTranslation","strictInjectionParameters","preserveWhitespacesDefault","preserveWhitespacesOption","defaultSetting","DirectiveNormalizer","_resourceLoader","_resourceLoaderCache","clear","normalizedDirective","prenormData","_preParseTemplate","preparsedTemplate","_normalizeTemplateMetadata","prenomData","_fetch","_preparseLoadedTemplate","templateAbsUrl","rootNodesAndErrors","templateMetadataStyles","_normalizeStylesheet","TemplatePreparseVisitor","templateStyles","inlineStyleUrls","_loadMissingExternalStylesheets","_normalizeLoadedTemplateMetadata","stylesheets","_inlineStyles","targetStyles","loadedStylesheets","loadedStyle","allStyleUrls","allStyles","styleWithImports","ngNonBindableStackCount","textContent","QUERY_METADATA_IDENTIFIERS","DirectiveResolver","typeMetadata","annotations","isDirectiveMetadata","throwIfNotFound","findLast","propertyMetadata","_mergeWithPropertyMetadata","dm","directiveType","hostBindings","hostBinding","startWith","hostListener","_merge","names","publicNames","reversedResult","_extractPublicName","reverse","mergedInputs","_dedupeBindings","mergedOutputs","mergedHost","mergedQueries","moduleId","_I18N_ATTR","_I18N_ATTR_PREFIX","_I18N_COMMENT_PREFIX_REGEXP","i18nCommentsWarned","extractMessages","implicitTags","implicitAttrs","_Visitor$2","extract","mergeTranslations","translations","merge","ExtractionResult","_VisitorMode","_implicitTags","_implicitAttrs","_init","Extract","_inI18nBlock","_messages","Merge","_translations","wrapper","translatedNode","_mode","_mayBeAddBlockChildren","wasInIcu","_inIcu","_isInTranslatableSection","_addMessage","isOpening","_isOpeningComment","isClosing","_isClosingComment","_inI18nNode","console","_blockStartDepth","_depth","_blockChildren","_blockMeaningAndDesc","_openTranslatableSection","_closeTranslatableSection","_translateMessage","wasInI18nNode","wasInImplicitNode","_inImplicitNode","childNodes","translatedChildNodes","i18nAttr","_getI18nAttr","i18nMeta","isImplicit","isTopLevelImplicit","isTranslatable","visitNodes","visited","_visitAttributesOf","translatedAttrs","_translateAttributes","_msgCountAtSectionStart","explicitAttrNameToValue","implicitAttrNames","msgMeta","_parseMessageMeta","i18nParsedMessageMeta","translatedAttributes","directChildren","significantChildren","XmlTagDefinition","currentParent","_TAG_DEFINITION","getXmlTagDefinition","XmlParser","_VERSION","_XMLNS","_DEFAULT_SOURCE_LANG","_PLACEHOLDER_TAG$1","_MARKER_TAG","_FILE_TAG","_SOURCE_TAG$1","_SEGMENT_SOURCE_TAG","_ALT_TRANS_TAG","_TARGET_TAG","_UNIT_TAG","_CONTEXT_GROUP_TAG","_CONTEXT_TAG","Xliff","_WriteVisitor","transUnits","contextTags","contextGroupTag","purpose","transUnit","datatype","xliff","xmlns","xliffParser","XliffParser","msgIdToHtml","i18nNodesByMsgId","XmlToI18n","msgId","convert","i18nNodes","ctype","getCtypeForTag","equivText","_locale","_unitMlString","_msgIdToHtml","xml","idAttr","_addError","innerTextStart","innerTextEnd","innerText","localeAttr","xmlIcu","nameAttr","caseMap","_VERSION$1","_XMLNS$1","_DEFAULT_SOURCE_LANG$1","_PLACEHOLDER_TAG$2","_PLACEHOLDER_SPANNING_TAG","_MARKER_TAG$1","_XLIFF_TAG","_SOURCE_TAG$2","_TARGET_TAG$1","_UNIT_TAG$1","Xliff2","_WriteVisitor$1","units","notes","category","srcLang","xliff2Parser","Xliff2Parser","XmlToI18n$1","getTypeForTag","tagPh","_nextPlaceholderId","equiv","disp","tagPc","equivStart","equivEnd","dispStart","dispEnd","idStr","versionAttr","startAttr","endAttr","startId","endId","_TRANSLATIONS_TAG","_TRANSLATION_TAG","_PLACEHOLDER_TAG$3","Xtb","xtbParser","XtbParser","XmlToI18n$2","valueFn","createLazyProperty","defineProperty","configurable","enumerable","xtb","_bundleDepth","langAttr","TranslationBundle","_i18nNodesByMsgId","mapperFactory","missingTranslationStrategy","Warning","_i18nToHtml","I18nToHtmlVisitor","srcMsg","html","load","digestFn","createNameMapper","_digest","_mapperFactory","_missingTranslationStrategy","_contextStack","_convertToText","_srcMsg","_mapper","toInternalName","I18NHtmlParser","translationsFormat","createSerializer","_translationBundle","format","QUOTED_KEYS","convertValueToOutputAst","_ValueOutputAstTransformer","quotedSet","mapEntry$1","InjectableCompiler","alwaysGenerateDef","tokenInjector","tokenExpr","retValue","depsArray","depArgs","factoryFor","Static","injectableDef","STRIP_SRC_FILE_SUFFIXES","GENERATED_FILE","JIT_SUMMARY_FILE","JIT_SUMMARY_NAME","ngfactoryFilePath","forceSourceFile","urlWithSuffix","splitTypescriptSuffix","normalizeGenFileSuffix","stripGeneratedFileSuffix","isGeneratedFile","lastDot","srcFileSuffix","summaryFileName","fileName","fileNameWithoutSuffix","summaryForJitFileName","stripSummaryForJitFileSuffix","summaryForJitName","symbolName","stripSummaryForJitNameSuffix","LOWERED_SYMBOL","isLoweredSymbol","createLoweredSymbol","LifecycleHooks","LIFECYCLE_HOOKS_VALUES","OnInit","OnDestroy","DoCheck","OnChanges","AfterContentInit","AfterContentChecked","AfterViewInit","AfterViewChecked","hasLifecycleHook","hook","getHookName","getAllLifecycleHooks","unexpected","ERROR_COMPONENT_TYPE","MISSING_NG_MODULE_METADATA_ERROR_DATA","getMissingNgModuleMetadataErrorData","CompileMetadataResolver","_ngModuleResolver","_directiveResolver","_pipeResolver","_summaryResolver","_directiveNormalizer","_staticSymbolCache","_errorCollector","_nonNormalizedDirectiveCache","_directiveCache","_summaryCache","_pipeCache","_ngModuleCache","_ngModuleOfTypes","_shallowModuleCache","clearCacheFor","clearCache","baseType","proxyClass","setDelegate","dirType","_createProxyClass","getGeneratedClass","hostView","getHostComponentViewClass","typeSummary","resolveSummary","hostViewType","hostType","getHostComponentType","getMatchingElementTemplate","isSync","getNonNormalizedDirectiveMetadata","annotation","createDirectiveMetadata","templateMetadata","normalizedDirMeta","initComponentFactory","normalizeTemplate","componentModuleUrl","componentStillLoadingError","cacheEntry","nonNormalizedTemplateMetadata","changeDetectionStrategy","entryComponentMetadata","_getProvidersMetadata","stringifyType","flattenAndDedupeArray","_getEntryComponentMetadata","_getQueriesMetadata","_getTypeMetadata","getComponentViewClass","getRendererType","getComponentFactory","dirSummary","_loadSummary","isDirective","isPipe","isNgModule","alreadyCollecting","moduleSummary","getNgModuleMetadata","loading","promise","loadDirectiveMetadata","_loadPipeMetadata","compileMeta","ngModuleMeta","shallowAnnotations","rawExports","rawImports","rawProviders","exportedNonModuleIdentifiers","importedType","importedModuleType","isValidType","moduleWithProviders","_checkSelfImport","_getTypeDescriptor","importedModuleSummary","getNgModuleSummary","exportedType","exportedModuleSummary","_getIdentifierMetadata","_getTransitiveNgModuleMetadata","declaredType","declaredIdentifier","isAbstractDirective","addDirective","_addTypeToModule","addPipe","exportedId","addExportedDirective","addExportedPipe","addEntryComponent","addProvider","addModule","provide","oldModule","modulesByToken","modSummary","mod","addedTokens","prevModules","moduleRef","tryAnnotations","throwOnUnknownDeps","_getDependenciesMetadata","pipeSummary","pipeAnnotation","hasUnknownDeps","dependenciesMetadata","paramEntry","_getTokenMetadata","depsTokens","compileToken","targetEntryComponents","debugInfo","compileProviders","providerIdx","providerMeta","_validateProvider","providersInfo","soFar","seenProvider","seenProviderIdx","_getEntryComponentsFromProvider","getProviderMetadata","collectedIdentifiers","extractIdentifiers","compileDeps","compileTypeMetadata","compileFactoryMetadata","_getInjectableTypeMetadata","_getFactoryMetadata","_getQueryMetadata","_queryVarBindings","otherType","flattenArray","tree","dedupeArray","targetIdentifiers","_CompileValueConverter","providerAst","lifecycleHook","lifecycleHookToNodeFlag","multiProviderDef","singleProviderDef","providerExpr","providerFlags","depsExpr","allDepDefs","allParams","providerIndex","depExprs","convertDeps","instantiate","depIndex","paramName","depDef","tokenMeta","nodeFlag","componentFactoryResolverProviderDef","entryComponentFactories","entryComponent","classMeta","NgModuleCompileResult","ngModuleFactoryVar","LOG_VAR","NgModuleCompiler","providerParser","providerDefs","ngModuleDef","ngModuleDefFactory","_createNgModuleFactory","registerFactoryStmt","ngModuleReference","ngModuleFactoryStmt","NgModuleResolver","debugOutputAstAsTypeScript","_TsEmitterVisitor","TypeScriptEmitter","preamble","emitSourceMaps","referenceFilter","importFilter","preambleLines","reexports","exportedModuleName","reexportsCode","reexport","as","importsWithPrefixes","importedModuleName","sm","setPreambleLineCount","sourceText","emitStatementsAndContext","typeExpression","defaultType","_visitIdentifier","_printColonType","_visitClassField","Private","typeStr","suppliedParameters","PipeResolver","metas","TypeCheckCompiler","componentId","externalReferenceVars","embeddedViewCount","viewBuilderFactory","embeddedViewIndex","ViewBuilder","DYNAMIC_VAR_NAME","TypeCheckLocalResolver","defaultResolver","isHostComponent","refOutputVars","updates","actions","useIf","astNodes","targetStatements","viewStmts","bindingCount","preprocessUpdateExpression","nameResolver","getOutputVar","General","guardExpression","guardClause","viewName","viewFactory","astWithSource","inter","visitElementOrTemplate","fullTemplateTypeCheck","getTypeGuardExpressions","childVisitor","inputDefs","updateRendererExpressions","outputDefs","inputAst","dirAst","outputVarType","hostEventAst","currBuilder","varAst","pipeExpr","pipeOutputVar","CLASS_ATTR$1","STYLE_ATTR","IMPLICIT_TEMPLATE_VAR","ViewCompileResult","viewClassVar","rendererTypeVar","ViewCompiler","renderComponentVarName","customRenderData","renderComponentVar","ViewBuilder$1","LOG_VAR$1","VIEW_VAR","CHECK_VAR","COMP_VAR","EVENT_NAME_VAR","ALLOW_DEFAULT_VAR","purePipeNodeIndices","refNodeIndices","_createPipe","queryIndex","calcQueryFlags","nodeFlags","nodeDef","needsAdditionalRootNode","_createNodeExpressions","updateRendererStmts","updateDirectivesStmts","nodeDefExprs","updateRendererFn","_createUpdateFn","updateDirectivesFn","viewFlags","OnPush","updateStmts","updateFn","preStmts","checkIndex","bindingIndex","_preprocessUpdateExpression","updateRenderer","_visitElementOrTemplate","queryMatchesExpr","childCount","_createElementHandleEventFn","usedEvents","dirHostBindings","elementBindingDef","compAst","compRendererType","compView","fixedAttrsDef","elementEventNameAndTarget","elementEventFullName","_visitComponentFactoryResolverProvider","localDirAst","_visitDirective","dirHostEvents","_visitProvider","queryMatchExprs","_visitProviderOrDirective","updateDirectiveExpressions","dirContextExpr","updateDirectives","_addProviderNode","componentDirMeta","currViewExpr","refNodeIndex","varValue","valueExpr","callCheckStmt","compViewExpr","compBuilder","pipeNodeIndex","pipeValueExpr","callUnwrapValue","nodeValueExpr","diDep","_createLiteralArrayConverter","_createLiteralMapConverter","_createPipeConverter","updateBindingCount","createUpdateStatements","logWithNodeDef","allowEmptyExprs","handlers","handleEventStmts","handleEventBindingCount","trueStmts","eventTarget","fullEventName","identical","handleEventFn","lastAstNode","elementAst","mapResult","mergeAttributeValue","attrValue1","attrValue2","bindingIdx","MessageBundle","htmlParserResult","i18nParserResult","filterSources","mapperVisitor","MapPlaceholderNames","msgList","src","transformedMessage","write","GeneratedFile","srcFileUrl","genFileUrl","sourceOrStmts","toTypeScript","emitStatements","listLazyRoutes","allLazyRoutes","ROUTES","loadChildren","_collectLoadChildren","route","parseLazyRoute","routes","routePath","routeName","referencedModule","TS","ResolvedStaticSymbol","SUPPORTED_SCHEMA_VERSION","StaticSymbolResolver","staticSymbolCache","summaryResolver","errorRecorder","metadataCache","resolvedSymbols","importAs","symbolResourcePaths","symbolFromFile","knownFileNameToModuleNames","staticSymbol","_resolveSymbolMembers","resultFromSummary","_resolveSymbolFromSummary","resultFromCache","_createSymbolsOf","useSummaries","baseSymbol","getStaticSymbol","baseImportAs","getImportAs","summarizedFileName","summarizedName","resolvedSymbol","unwrapResolvedMetadata","resolveSymbol","arity","sourceSymbol","targetSymbol","assertNoMembers","symbols","recorder","baseResolvedSymbol","baseMetadata","__symbolic","statics","getModuleMetadata","metadataKey","decorators","summarySymbols","getSymbolsOf","moduleExport","export","exportSymbol","unescapeIdentifier","symName","resolvedModule","resolveModule","createExport","nestedExports","topLevelSymbolNames","origins","symbolMeta","origin","originFilePath","getOutputName","createResolvedSymbol","uniqueSymbols","topLevelPath","isTsFile","isLibraryFile","transformedMeta","_originalFileMemo","getOriginalName","ReferenceTransformer","functionParams","symbolic","oldLen","getMetadataFor","unwrappedTransformedMeta","moduleMetadata","moduleMetadatas","maxVersion","md","containingFile","moduleNameToFileName","serializeSummaries","srcFileName","forJitCtx","symbolResolver","createExternalSymbolReexports","toJsonSerializer","ToJsonSerializer","addSummary","json","forJitSerializer","ForJitSerializer","addSourceType","unprocessedSymbolSummariesBySymbol","addLibType","deserializeSummaries","symbolCache","libraryFileName","deserializer","FromJsonDeserializer","deserialize","createForJitStub","createSummaryForJitFunction","indexBySymbol","reexportedBy","processedSummaryBySymbol","processedSummaries","getKnownModuleName","unprocessedSummary","processedSummary","processValue","isCall","isFunctionCall","isMethodCallOnVariable","declarationSymbol","ngModuleSummary","summaries","reexportSymbol","__symbol","toSummaryFileName","visitStaticSymbol","loadSummary","isLibrary","exportAsArr","exportAsBySymbol","ngModuleSymbols","serializeSummaryWithDeps","ngModuleSymbol","jitExportAsName","serializeSummaryRef","serializeSummary","typeSymbol","jitImportedSymbol","Transformer","allImportAs","serializedSymbol","fromSummaryFileName","AotCompiler","_options","_host","_metadataResolver","_templateParser","_styleCompiler","_viewCompiler","_typeCheckCompiler","_ngModuleCompiler","_injectableCompiler","_outputEmitter","_symbolResolver","_templateAstCache","_analyzedFiles","_analyzedFilesForInjectables","rootFiles","analyzeResult","analyzeAndValidateNgModules","ngModules","loadNgModuleDirectiveAndPipeMetadata","analyzedFile","analyzeFile","analyzeFileForInjectables","genFileNames","_analyzeFile","allowEmptyCodegenFiles","injectables","exportsNonSourceFiles","enableSummariesForJit","fileSuffix","dirSymbol","normalizedUrl","resourceNameToFileName","needsShim","_stylesModuleUrl","genFileName","originalFileName","_createOutputContext","originalFile","_createNgFactoryStub","_createEmptyStub","_codegenSourceModule","fileNames","tsFiles","files","loadingPromises","analyzedInjectables","tsFile","_analyzeFileForInjectables","analyzedModules","mergeAndValidateNgFiles","emitFlags","ngModuleIndex","createStub","_externalIdentifierReferences","typeIndex","dirId","getDirectiveMetadata","_createTypeCheckBlock","getHostComponentMetadata","_parseTemplate","compileComponent","messageBundle","compMetas","updateFromTemplate","_emitPartialModule2","compile","ngModuleByPipeOrDirective","sourceModules","_compileImplFile","generatedFiles","_createSummary","_compileModule","componentStylesheet","stylesheetMeta","_codegenStyles","compViewVars","_compileComponent","_compileComponentFactory","srcModule","ngFactoryCtx","symbolSummaries","typeData","getDirectiveSummary","getPipeSummary","getPipeMetadata","getInjectableSummary","forJitOutputCtx","createExternalSymbolFactoryReexports","summaryJson","normalizedLocale","i18nFormat","hostMeta","hostViewFactoryVar","compFactoryVar","inputsExprs","outputsExprs","directiveIdentifiers","componentStyles","stylesExpr","viewResult","_resolveStyleStatements","importExpr$1","getTypeArity","importModule","_fileNameToModuleName","selfReference","suppliedTypeParams","missingTypeParamsCount","allTypeParams","memberName","importedFilePath","containingFilePath","fileNameToModuleName","stylesheetMetadata","compiledStylesheet","entryRoute","visitLazyRoute","lazyRoutes","lazyRoute","seenRoutes","compileResult","stylesheetUrl","analyzeNgModules","staticSymbolResolver","metadataResolver","_analyzeFilesIncludingNonProgramFiles","mergeAnalyzedFiles","validateAnalyzedModules","symbolsMissingModule","seenFiles","visitFile","isSourceFile","modMeta","abstractDirectives","hasDecorators","isDeclarationFile","isNgSymbol","isInjectable","getInjectableMetadata","isValueExportingNonSourceFile","shallowModules","getShallowModuleMetadata","Visitor","analyzedFiles","allNgModules","allPipesAndDirectives","af","FORMATTED_MESSAGE","indentStr","half","floor","formatChain","chain","kid","formattedError","isFormattedError","ANGULAR_CORE","ANGULAR_ROUTER","HIDDEN_KEY","IGNORE","USE_VALUE$1","PROVIDE","REFERENCE_SET","TYPEGUARD_POSTFIX","USE_IF","shouldIgnore","StaticReflector","knownMetadataClasses","knownMetadataFunctions","annotationCache","shallowAnnotationCache","propertyCache","parameterCache","methodCache","staticCache","conversionMap","resolvedExternalReferences","annotationForParentClassWithSummaryKind","initializeConversionMap","kc","_registerDecoratorOrConstructor","kf","_registerFunction","findSymbolDeclaration","getResourcePath","refSymbol","getSymbolByModule","recordModuleNameForFileName","recordImportAs","ignoreErrorsFor","findDeclaration","resolvedMetadata","originalRecorder","_annotations","simplify","classMetadata","getTypeMetadata","parentType","findParentType","parentAnnotations","ownAnnotations","requiredAnnotationTypes","typeHasRequiredAnnotation","requiredType","formatMetadataError","metadataError","parentPropMetadata","parentProp","propData","ctorData","rawParameterTypes","parameterDecorators","rawParamType","nestedResult","paramType","trySimplify","methodNames","parentMethodNames","_methodNames","isMethod","staticMembers","staticMemberData","_staticMembers","injectionToken","opaqueToken","tryFindDeclaration","lazy","BindingScope$1","empty","calling","rootContext","simplifyInContext","depth","resolveReferenceValue","simplifyEagerly","simplifyLazily","simplifyNested","nestedContext","isMetadataError","summaryMsg","errorSummary","advise","simplifyCall","functionSymbol","targetFunction","targetExpression","defaults","functionScope","define","oldScope","done","FUNCTION_CALL_NOT_SUPPORTED","isPrimitive","spreadArray","spreadItem","declarationValue","operand","indexTarget","member","selectContext","selectTarget","localValue","missing","argExpressions","mapStringMap","reportingContext","METADATA_ERROR","REFERENCE_TO_NONEXPORTED_CLASS","VARIABLE_NOT_INITIALIZED","DESTRUCTURE_NOT_SUPPORTED","COULD_NOT_RESOLVE_TYPE","REFERENCE_TO_LOCAL_SYMBOL","LAMBDA_NOT_SUPPORTED","expandedMessage","messageAdvise","PopulatedScope","formatMetadataMessageChain","nesting","AotSummaryResolver","summaryCache","loadedFilePaths","referringSrcFileName","referringLibFileName","rootSymbol","_loadSummaryFile","hasSummary","summaryFilePath","createAotUrlResolver","basePath","createAotCompiler","compilerHost","errorCollector","urlResolver","staticReflector","enableIvy","normalizer","loadResource","expressionParser","tmplParser","viewCompiler","typeCheckCompiler","compiler","SummaryResolver","JitSummaryResolver","_summaries","interpretStatements","_ExecutionContext","StatementInterpreter","exportName","_executeFunctionStatements","varValues","childCtx","createChildWihtLocalVars","instance","ReturnValue","createDynamicClass","_classStmt","_ctx","propertyDescriptors","instanceCtx","paramNames","writable","ctorParamNames","superClass","initialValue","currCtx","CATCH_ERROR_VAR$2","CATCH_STACK_VAR$2","subscribe","templateElements","_declareFn","JitCompiler","_jitEvaluator","_compilerConfig","getExtraNgModuleProviders","_compiledTemplateCache","_compiledHostTemplateCache","_compiledDirectiveWrapperCache","_compiledNgModuleCache","_sharedStylesheetCount","_addedAotSummaries","_compileModuleAndComponents","_compileModuleAndAllComponents","_addAotSummaries","ids","hasAotSummary","_loadModules","_compileComponents","componentFactories","ngModuleFactory","mainModule","mainNgModule","_filterJitIdentifiers","nestedNgModule","getOrLoadPipeMetadata","createOutputContext","_interpretOrJit","allComponentFactories","moduleByJitDirective","templates","transJitModules","localMod","localModuleMeta","dirRef","_createCompiledTemplate","_createCompiledHostTemplate","entryComponentType","_compileTemplate","compiledTemplate","assertComponent","viewDefFactory","CompiledTemplate","isCompiled","externalStylesheetsByModuleUrl","outputContext","_resolveStylesCompileResult","evalResult","viewClass","compiled","nestedCompileResult","nestedStylesArr","_resolveAndEvalStylesCompileResult","_viewClass","CompileReflector","createUrlResolverWithoutPackagePrefix","UrlResolver","createOfflineCompileUrlResolver","_packagePrefix","resolvedUrl","_resolveUrl","resolvedParts","_split","_ComponentIndex","Scheme","Path","getUrlScheme","_buildFromEncodedParts","opt_scheme","opt_userInfo","opt_domain","opt_port","opt_path","opt_queryData","opt_fragment","_splitRe","uri","_removeDotSegments","leadingSlash","trailingSlash","up","_joinAndCanonicalizePath","UserInfo","Domain","Port","QueryData","Fragment","encodeURI","baseParts","Extractor","extractor","FactoryTarget$1","R3TargetBinder","Scope","templateEntities","extractTemplateEntities","DirectiveBinder","TemplateBinder","nestingLevel","R3BoundTarget","parentScope","namedEntities","childScopes","ingest","maybeDeclare","thing","lookup","newRootScope","dirTarget","setAttributeBinding","ioType","hasBindingPropertyName","visitNode","childScope","getChildScope","binder","maybeMap","exprTargets","dirs","rootScope","entityMap","extractScopeEntities","currentEntities","scopesToProcess","entities","compileClassMetadata","ctorParameters","propDecorators","MINIMUM_PARTIAL_LINKER_VERSION","compileDeclareClassMetadata","MINIMUM_PARTIAL_LINKER_VERSION$1","compileDeclareDirectiveFromMetadata","createDirectiveDefinitionMap","compileHostMetadata","compileQuery","hostMetadata","compileDeclareComponentFromMetadata","additionalTemplateInfo","createComponentDefinitionMap","templateInfo","getTemplateExpression","compileUsedDirectiveMetadata","compileUsedPipeMetadata","inlineTemplateLiteralExpression","computeEndLocation","lineStart","lastLineStart","wrapType","MINIMUM_PARTIAL_LINKER_VERSION$2","compileDeclareFactoryFunction","MINIMUM_PARTIAL_LINKER_VERSION$3","compileDeclareInjectableFromMetadata","createInjectableDefinitionMap","convertFromProviderExpression","MINIMUM_PARTIAL_LINKER_VERSION$4","compileDeclareInjectorFromMetadata","createInjectorDefinitionMap","MINIMUM_PARTIAL_LINKER_VERSION$5","compileDeclareNgModuleFromMetadata","createNgModuleDefinitionMap","MINIMUM_PARTIAL_LINKER_VERSION$6","compileDeclarePipeFromMetadata","createPipeDefinitionMap","R3Identifiers","TmplAstBoundAttribute","TmplAstBoundEvent","TmplAstBoundText","TmplAstContent","TmplAstElement","TmplAstIcu","TmplAstRecursiveVisitor","TmplAstReference","TmplAstTemplate","TmplAstText","TmplAstTextAttribute","TmplAstVariable"],"mappings":"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GAFD,MAGK,IAAI2H,IAAI,YAAYI,eAApB,EAAqC;AACtC,WAAOJ,IAAI,CAAC5V,KAAZ;AACH;;AACD,SAAO,IAAP;AACH;;IACK2sD,mB;;;;;AACF,+BAAY3qB,IAAZ,EAAkBz2B,UAAlB,EAA8B/E,IAA9B,EAAoCkwC,SAApC,EAA+C;AAAA;;AAAA;;AAC3C,mCAAM1U,IAAN,EAAYz2B,UAAZ,EAAwB,IAAxB,EAA8B/E,IAA9B;AACA,aAAKA,IAAL,GAAYA,IAAZ;AACA,aAAKkwC,SAAL,GAAiBA,SAAjB;AAH2C;AAI9C;;;EAL6B8N,Y;AAQlC;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACMsK,S;AACF,uBAAc;AAAA;;AACV,SAAKC,aAAL,GAAqB,IAArB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;;;;WACI,qBAAYC,OAAZ,EAAqB3uD,QAArB,EAAkD;AAAA,UAAnB4uD,YAAmB,uEAAJ,EAAI;AAC9C,UAAMC,gBAAgB,GAAGC,uBAAuB,CAAC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AAvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,kCAAkC,GAAG,CAA3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACMC,c;AACF,0BAAYC,cAAZ,EAA4B;AAAA;;AACxB,SAAKA,cAAL,GAAsBA,cAAtB;AACA;;AACA,SAAKC,iBAAL,GAAyB,KAAzB;AACA;AACR;AACA;AACA;;AACQ,SAAKC,WAAL,GAAmB,KAAnB;AACA,SAAKC,oBAAL,GAA4B,KAA5B;AACA;;AACA,SAAKC,cAAL,GAAsB,IAAtB;AACA;;AACA,SAAKC,cAAL,GAAsB,IAAtB;AACA;;AACA,SAAKC,kBAAL,GAA0B,IAA1B;AACA;;AACA,SAAKC,kBAAL,GAA0B,IAA1B;AACA,SAAKC,iBAAL,GAAyB,IAAzB;AACA,SAAKC,kBAAL,GAA0B,IAA1B,CAnBwB,CAoBxB;AACA;;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKC,YAAL,GAAoB,IAAIzjF,GAAJ,EAApB;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAK0jF,aAAL,GAAqB,IAAI1jF,GAAJ,EAArB;AACA,SAAK2jF,mBAAL,GAA2B,EAA3B;AACA,SAAKC,mBAAL,GAA2B,EAA3B;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;;;WACI,4BAAmBn8D,KAAnB,EAA0B;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,UAAI8rD,OAAO,GAAG,IAAd;AACA,UAAIj3E,IAAI,GAAGmrB,KAAK,CAACnrB,IAAjB;;AACA,cAAQmrB,KAA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","sourcesContent":["/**\r\n * @license Angular v12.1.0\r\n * (c) 2010-2021 Google LLC. https://angular.io/\r\n * License: MIT\r\n */\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nvar TagContentType;\r\n(function (TagContentType) {\r\n    TagContentType[TagContentType[\"RAW_TEXT\"] = 0] = \"RAW_TEXT\";\r\n    TagContentType[TagContentType[\"ESCAPABLE_RAW_TEXT\"] = 1] = \"ESCAPABLE_RAW_TEXT\";\r\n    TagContentType[TagContentType[\"PARSABLE_DATA\"] = 2] = \"PARSABLE_DATA\";\r\n})(TagContentType || (TagContentType = {}));\r\nfunction splitNsName(elementName) {\r\n    if (elementName[0] != ':') {\r\n        return [null, elementName];\r\n    }\r\n    const colonIndex = elementName.indexOf(':', 1);\r\n    if (colonIndex == -1) {\r\n        throw new Error(`Unsupported format \"${elementName}\" expecting \":namespace:name\"`);\r\n    }\r\n    return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\r\n}\r\n// `<ng-container>` tags work the same regardless the namespace\r\nfunction isNgContainer(tagName) {\r\n    return splitNsName(tagName)[1] === 'ng-container';\r\n}\r\n// `<ng-content>` tags work the same regardless the namespace\r\nfunction isNgContent(tagName) {\r\n    return splitNsName(tagName)[1] === 'ng-content';\r\n}\r\n// `<ng-template>` tags work the same regardless the namespace\r\nfunction isNgTemplate(tagName) {\r\n    return splitNsName(tagName)[1] === 'ng-template';\r\n}\r\nfunction getNsPrefix(fullName) {\r\n    return fullName === null ? null : splitNsName(fullName)[0];\r\n}\r\nfunction mergeNsAndName(prefix, localName) {\r\n    return prefix ? `:${prefix}:${localName}` : localName;\r\n}\r\n// see https://www.w3.org/TR/html51/syntax.html#named-character-references\r\n// see https://html.spec.whatwg.org/multipage/entities.json\r\n// This list is not exhaustive to keep the compiler footprint low.\r\n// The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not\r\n// exist.\r\nconst NAMED_ENTITIES = {\r\n    'Aacute': '\\u00C1',\r\n    'aacute': '\\u00E1',\r\n    'Acirc': '\\u00C2',\r\n    'acirc': '\\u00E2',\r\n    'acute': '\\u00B4',\r\n    'AElig': '\\u00C6',\r\n    'aelig': '\\u00E6',\r\n    'Agrave': '\\u00C0',\r\n    'agrave': '\\u00E0',\r\n    'alefsym': '\\u2135',\r\n    'Alpha': '\\u0391',\r\n    'alpha': '\\u03B1',\r\n    'amp': '&',\r\n    'and': '\\u2227',\r\n    'ang': '\\u2220',\r\n    'apos': '\\u0027',\r\n    'Aring': '\\u00C5',\r\n    'aring': '\\u00E5',\r\n    'asymp': '\\u2248',\r\n    'Atilde': '\\u00C3',\r\n    'atilde': '\\u00E3',\r\n    'Auml': '\\u00C4',\r\n    'auml': '\\u00E4',\r\n    'bdquo': '\\u201E',\r\n    'Beta': '\\u0392',\r\n    'beta': '\\u03B2',\r\n    'brvbar': '\\u00A6',\r\n    'bull': '\\u2022',\r\n    'cap': '\\u2229',\r\n    'Ccedil': '\\u00C7',\r\n    'ccedil': '\\u00E7',\r\n    'cedil': '\\u00B8',\r\n    'cent': '\\u00A2',\r\n    'Chi': '\\u03A7',\r\n    'chi': '\\u03C7',\r\n    'circ': '\\u02C6',\r\n    'clubs': '\\u2663',\r\n    'cong': '\\u2245',\r\n    'copy': '\\u00A9',\r\n    'crarr': '\\u21B5',\r\n    'cup': '\\u222A',\r\n    'curren': '\\u00A4',\r\n    'dagger': '\\u2020',\r\n    'Dagger': '\\u2021',\r\n    'darr': '\\u2193',\r\n    'dArr': '\\u21D3',\r\n    'deg': '\\u00B0',\r\n    'Delta': '\\u0394',\r\n    'delta': '\\u03B4',\r\n    'diams': '\\u2666',\r\n    'divide': '\\u00F7',\r\n    'Eacute': '\\u00C9',\r\n    'eacute': '\\u00E9',\r\n    'Ecirc': '\\u00CA',\r\n    'ecirc': '\\u00EA',\r\n    'Egrave': '\\u00C8',\r\n    'egrave': '\\u00E8',\r\n    'empty': '\\u2205',\r\n    'emsp': '\\u2003',\r\n    'ensp': '\\u2002',\r\n    'Epsilon': '\\u0395',\r\n    'epsilon': '\\u03B5',\r\n    'equiv': '\\u2261',\r\n    'Eta': '\\u0397',\r\n    'eta': '\\u03B7',\r\n    'ETH': '\\u00D0',\r\n    'eth': '\\u00F0',\r\n    'Euml': '\\u00CB',\r\n    'euml': '\\u00EB',\r\n    'euro': '\\u20AC',\r\n    'exist': '\\u2203',\r\n    'fnof': '\\u0192',\r\n    'forall': '\\u2200',\r\n    'frac12': '\\u00BD',\r\n    'frac14': '\\u00BC',\r\n    'frac34': '\\u00BE',\r\n    'frasl': '\\u2044',\r\n    'Gamma': '\\u0393',\r\n    'gamma': '\\u03B3',\r\n    'ge': '\\u2265',\r\n    'gt': '>',\r\n    'harr': '\\u2194',\r\n    'hArr': '\\u21D4',\r\n    'hearts': '\\u2665',\r\n    'hellip': '\\u2026',\r\n    'Iacute': '\\u00CD',\r\n    'iacute': '\\u00ED',\r\n    'Icirc': '\\u00CE',\r\n    'icirc': '\\u00EE',\r\n    'iexcl': '\\u00A1',\r\n    'Igrave': '\\u00CC',\r\n    'igrave': '\\u00EC',\r\n    'image': '\\u2111',\r\n    'infin': '\\u221E',\r\n    'int': '\\u222B',\r\n    'Iota': '\\u0399',\r\n    'iota': '\\u03B9',\r\n    'iquest': '\\u00BF',\r\n    'isin': '\\u2208',\r\n    'Iuml': '\\u00CF',\r\n    'iuml': '\\u00EF',\r\n    'Kappa': '\\u039A',\r\n    'kappa': '\\u03BA',\r\n    'Lambda': '\\u039B',\r\n    'lambda': '\\u03BB',\r\n    'lang': '\\u27E8',\r\n    'laquo': '\\u00AB',\r\n    'larr': '\\u2190',\r\n    'lArr': '\\u21D0',\r\n    'lceil': '\\u2308',\r\n    'ldquo': '\\u201C',\r\n    'le': '\\u2264',\r\n    'lfloor': '\\u230A',\r\n    'lowast': '\\u2217',\r\n    'loz': '\\u25CA',\r\n    'lrm': '\\u200E',\r\n    'lsaquo': '\\u2039',\r\n    'lsquo': '\\u2018',\r\n    'lt': '<',\r\n    'macr': '\\u00AF',\r\n    'mdash': '\\u2014',\r\n    'micro': '\\u00B5',\r\n    'middot': '\\u00B7',\r\n    'minus': '\\u2212',\r\n    'Mu': '\\u039C',\r\n    'mu': '\\u03BC',\r\n    'nabla': '\\u2207',\r\n    'nbsp': '\\u00A0',\r\n    'ndash': '\\u2013',\r\n    'ne': '\\u2260',\r\n    'ni': '\\u220B',\r\n    'not': '\\u00AC',\r\n    'notin': '\\u2209',\r\n    'nsub': '\\u2284',\r\n    'Ntilde': '\\u00D1',\r\n    'ntilde': '\\u00F1',\r\n    'Nu': '\\u039D',\r\n    'nu': '\\u03BD',\r\n    'Oacute': '\\u00D3',\r\n    'oacute': '\\u00F3',\r\n    'Ocirc': '\\u00D4',\r\n    'ocirc': '\\u00F4',\r\n    'OElig': '\\u0152',\r\n    'oelig': '\\u0153',\r\n    'Ograve': '\\u00D2',\r\n    'ograve': '\\u00F2',\r\n    'oline': '\\u203E',\r\n    'Omega': '\\u03A9',\r\n    'omega': '\\u03C9',\r\n    'Omicron': '\\u039F',\r\n    'omicron': '\\u03BF',\r\n    'oplus': '\\u2295',\r\n    'or': '\\u2228',\r\n    'ordf': '\\u00AA',\r\n    'ordm': '\\u00BA',\r\n    'Oslash': '\\u00D8',\r\n    'oslash': '\\u00F8',\r\n    'Otilde': '\\u00D5',\r\n    'otilde': '\\u00F5',\r\n    'otimes': '\\u2297',\r\n    'Ouml': '\\u00D6',\r\n    'ouml': '\\u00F6',\r\n    'para': '\\u00B6',\r\n    'permil': '\\u2030',\r\n    'perp': '\\u22A5',\r\n    'Phi': '\\u03A6',\r\n    'phi': '\\u03C6',\r\n    'Pi': '\\u03A0',\r\n    'pi': '\\u03C0',\r\n    'piv': '\\u03D6',\r\n    'plusmn': '\\u00B1',\r\n    'pound': '\\u00A3',\r\n    'prime': '\\u2032',\r\n    'Prime': '\\u2033',\r\n    'prod': '\\u220F',\r\n    'prop': '\\u221D',\r\n    'Psi': '\\u03A8',\r\n    'psi': '\\u03C8',\r\n    'quot': '\\u0022',\r\n    'radic': '\\u221A',\r\n    'rang': '\\u27E9',\r\n    'raquo': '\\u00BB',\r\n    'rarr': '\\u2192',\r\n    'rArr': '\\u21D2',\r\n    'rceil': '\\u2309',\r\n    'rdquo': '\\u201D',\r\n    'real': '\\u211C',\r\n    'reg': '\\u00AE',\r\n    'rfloor': '\\u230B',\r\n    'Rho': '\\u03A1',\r\n    'rho': '\\u03C1',\r\n    'rlm': '\\u200F',\r\n    'rsaquo': '\\u203A',\r\n    'rsquo': '\\u2019',\r\n    'sbquo': '\\u201A',\r\n    'Scaron': '\\u0160',\r\n    'scaron': '\\u0161',\r\n    'sdot': '\\u22C5',\r\n    'sect': '\\u00A7',\r\n    'shy': '\\u00AD',\r\n    'Sigma': '\\u03A3',\r\n    'sigma': '\\u03C3',\r\n    'sigmaf': '\\u03C2',\r\n    'sim': '\\u223C',\r\n    'spades': '\\u2660',\r\n    'sub': '\\u2282',\r\n    'sube': '\\u2286',\r\n    'sum': '\\u2211',\r\n    'sup': '\\u2283',\r\n    'sup1': '\\u00B9',\r\n    'sup2': '\\u00B2',\r\n    'sup3': '\\u00B3',\r\n    'supe': '\\u2287',\r\n    'szlig': '\\u00DF',\r\n    'Tau': '\\u03A4',\r\n    'tau': '\\u03C4',\r\n    'there4': '\\u2234',\r\n    'Theta': '\\u0398',\r\n    'theta': '\\u03B8',\r\n    'thetasym': '\\u03D1',\r\n    'thinsp': '\\u2009',\r\n    'THORN': '\\u00DE',\r\n    'thorn': '\\u00FE',\r\n    'tilde': '\\u02DC',\r\n    'times': '\\u00D7',\r\n    'trade': '\\u2122',\r\n    'Uacute': '\\u00DA',\r\n    'uacute': '\\u00FA',\r\n    'uarr': '\\u2191',\r\n    'uArr': '\\u21D1',\r\n    'Ucirc': '\\u00DB',\r\n    'ucirc': '\\u00FB',\r\n    'Ugrave': '\\u00D9',\r\n    'ugrave': '\\u00F9',\r\n    'uml': '\\u00A8',\r\n    'upsih': '\\u03D2',\r\n    'Upsilon': '\\u03A5',\r\n    'upsilon': '\\u03C5',\r\n    'Uuml': '\\u00DC',\r\n    'uuml': '\\u00FC',\r\n    'weierp': '\\u2118',\r\n    'Xi': '\\u039E',\r\n    'xi': '\\u03BE',\r\n    'Yacute': '\\u00DD',\r\n    'yacute': '\\u00FD',\r\n    'yen': '\\u00A5',\r\n    'yuml': '\\u00FF',\r\n    'Yuml': '\\u0178',\r\n    'Zeta': '\\u0396',\r\n    'zeta': '\\u03B6',\r\n    'zwj': '\\u200D',\r\n    'zwnj': '\\u200C',\r\n};\r\n// The &ngsp; pseudo-entity is denoting a space. see:\r\n// https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart\r\nconst NGSP_UNICODE = '\\uE500';\r\nNAMED_ENTITIES['ngsp'] = NGSP_UNICODE;\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass HtmlTagDefinition {\r\n    constructor({ closedByChildren, implicitNamespacePrefix, contentType = TagContentType.PARSABLE_DATA, closedByParent = false, isVoid = false, ignoreFirstLf = false, preventNamespaceInheritance = false } = {}) {\r\n        this.closedByChildren = {};\r\n        this.closedByParent = false;\r\n        this.canSelfClose = false;\r\n        if (closedByChildren && closedByChildren.length > 0) {\r\n            closedByChildren.forEach(tagName => this.closedByChildren[tagName] = true);\r\n        }\r\n        this.isVoid = isVoid;\r\n        this.closedByParent = closedByParent || isVoid;\r\n        this.implicitNamespacePrefix = implicitNamespacePrefix || null;\r\n        this.contentType = contentType;\r\n        this.ignoreFirstLf = ignoreFirstLf;\r\n        this.preventNamespaceInheritance = preventNamespaceInheritance;\r\n    }\r\n    isClosedByChild(name) {\r\n        return this.isVoid || name.toLowerCase() in this.closedByChildren;\r\n    }\r\n    getContentType(prefix) {\r\n        if (typeof this.contentType === 'object') {\r\n            const overrideType = prefix == null ? undefined : this.contentType[prefix];\r\n            return overrideType !== null && overrideType !== void 0 ? overrideType : this.contentType.default;\r\n        }\r\n        return this.contentType;\r\n    }\r\n}\r\nlet _DEFAULT_TAG_DEFINITION;\r\n// see https://www.w3.org/TR/html51/syntax.html#optional-tags\r\n// This implementation does not fully conform to the HTML5 spec.\r\nlet TAG_DEFINITIONS;\r\nfunction getHtmlTagDefinition(tagName) {\r\n    var _a, _b;\r\n    if (!TAG_DEFINITIONS) {\r\n        _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\r\n        TAG_DEFINITIONS = {\r\n            'base': new HtmlTagDefinition({ isVoid: true }),\r\n            'meta': new HtmlTagDefinition({ isVoid: true }),\r\n            'area': new HtmlTagDefinition({ isVoid: true }),\r\n            'embed': new HtmlTagDefinition({ isVoid: true }),\r\n            'link': new HtmlTagDefinition({ isVoid: true }),\r\n            'img': new HtmlTagDefinition({ isVoid: true }),\r\n            'input': new HtmlTagDefinition({ isVoid: true }),\r\n            'param': new HtmlTagDefinition({ isVoid: true }),\r\n            'hr': new HtmlTagDefinition({ isVoid: true }),\r\n            'br': new HtmlTagDefinition({ isVoid: true }),\r\n            'source': new HtmlTagDefinition({ isVoid: true }),\r\n            'track': new HtmlTagDefinition({ isVoid: true }),\r\n            'wbr': new HtmlTagDefinition({ isVoid: true }),\r\n            'p': new HtmlTagDefinition({\r\n                closedByChildren: [\r\n                    'address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset',\r\n                    'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5',\r\n                    'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol',\r\n                    'p', 'pre', 'section', 'table', 'ul'\r\n                ],\r\n                closedByParent: true\r\n            }),\r\n            'thead': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'] }),\r\n            'tbody': new HtmlTagDefinition({ closedByChildren: ['tbody', 'tfoot'], closedByParent: true }),\r\n            'tfoot': new HtmlTagDefinition({ closedByChildren: ['tbody'], closedByParent: true }),\r\n            'tr': new HtmlTagDefinition({ closedByChildren: ['tr'], closedByParent: true }),\r\n            'td': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\r\n            'th': new HtmlTagDefinition({ closedByChildren: ['td', 'th'], closedByParent: true }),\r\n            'col': new HtmlTagDefinition({ isVoid: true }),\r\n            'svg': new HtmlTagDefinition({ implicitNamespacePrefix: 'svg' }),\r\n            'foreignObject': new HtmlTagDefinition({\r\n                // Usually the implicit namespace here would be redundant since it will be inherited from\r\n                // the parent `svg`, but we have to do it for `foreignObject`, because the way the parser\r\n                // works is that the parent node of an end tag is its own start tag which means that\r\n                // the `preventNamespaceInheritance` on `foreignObject` would have it default to the\r\n                // implicit namespace which is `html`, unless specified otherwise.\r\n                implicitNamespacePrefix: 'svg',\r\n                // We want to prevent children of foreignObject from inheriting its namespace, because\r\n                // the point of the element is to allow nodes from other namespaces to be inserted.\r\n                preventNamespaceInheritance: true,\r\n            }),\r\n            'math': new HtmlTagDefinition({ implicitNamespacePrefix: 'math' }),\r\n            'li': new HtmlTagDefinition({ closedByChildren: ['li'], closedByParent: true }),\r\n            'dt': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'] }),\r\n            'dd': new HtmlTagDefinition({ closedByChildren: ['dt', 'dd'], closedByParent: true }),\r\n            'rb': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\r\n            'rt': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\r\n            'rtc': new HtmlTagDefinition({ closedByChildren: ['rb', 'rtc', 'rp'], closedByParent: true }),\r\n            'rp': new HtmlTagDefinition({ closedByChildren: ['rb', 'rt', 'rtc', 'rp'], closedByParent: true }),\r\n            'optgroup': new HtmlTagDefinition({ closedByChildren: ['optgroup'], closedByParent: true }),\r\n            'option': new HtmlTagDefinition({ closedByChildren: ['option', 'optgroup'], closedByParent: true }),\r\n            'pre': new HtmlTagDefinition({ ignoreFirstLf: true }),\r\n            'listing': new HtmlTagDefinition({ ignoreFirstLf: true }),\r\n            'style': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\r\n            'script': new HtmlTagDefinition({ contentType: TagContentType.RAW_TEXT }),\r\n            'title': new HtmlTagDefinition({\r\n                // The browser supports two separate `title` tags which have to use\r\n                // a different content type: `HTMLTitleElement` and `SVGTitleElement`\r\n                contentType: { default: TagContentType.ESCAPABLE_RAW_TEXT, svg: TagContentType.PARSABLE_DATA }\r\n            }),\r\n            'textarea': new HtmlTagDefinition({ contentType: TagContentType.ESCAPABLE_RAW_TEXT, ignoreFirstLf: true }),\r\n        };\r\n    }\r\n    // We have to make both a case-sensitive and a case-insesitive lookup, because\r\n    // HTML tag names are case insensitive, whereas some SVG tags are case sensitive.\r\n    return (_b = (_a = TAG_DEFINITIONS[tagName]) !== null && _a !== void 0 ? _a : TAG_DEFINITIONS[tagName.toLowerCase()]) !== null && _b !== void 0 ? _b : _DEFAULT_TAG_DEFINITION;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst _SELECTOR_REGEXP = new RegExp('(\\\\:not\\\\()|' + // 1: \":not(\"\r\n    '(([\\\\.\\\\#]?)[-\\\\w]+)|' + // 2: \"tag\"; 3: \".\"/\"#\";\r\n    // \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\r\n    // 4: attribute; 5: attribute_string; 6: attribute_value\r\n    '(?:\\\\[([-.\\\\w*\\\\\\\\$]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' + // \"[name]\", \"[name=value]\",\r\n    // \"[name=\"value\"]\",\r\n    // \"[name='value']\"\r\n    '(\\\\))|' + // 7: \")\"\r\n    '(\\\\s*,\\\\s*)', // 8: \",\"\r\n'g');\r\n/**\r\n * A css selector contains an element name,\r\n * css classes and attribute/value pairs with the purpose\r\n * of selecting subsets out of them.\r\n */\r\nclass CssSelector {\r\n    constructor() {\r\n        this.element = null;\r\n        this.classNames = [];\r\n        /**\r\n         * The selectors are encoded in pairs where:\r\n         * - even locations are attribute names\r\n         * - odd locations are attribute values.\r\n         *\r\n         * Example:\r\n         * Selector: `[key1=value1][key2]` would parse to:\r\n         * ```\r\n         * ['key1', 'value1', 'key2', '']\r\n         * ```\r\n         */\r\n        this.attrs = [];\r\n        this.notSelectors = [];\r\n    }\r\n    static parse(selector) {\r\n        const results = [];\r\n        const _addResult = (res, cssSel) => {\r\n            if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 &&\r\n                cssSel.attrs.length == 0) {\r\n                cssSel.element = '*';\r\n            }\r\n            res.push(cssSel);\r\n        };\r\n        let cssSelector = new CssSelector();\r\n        let match;\r\n        let current = cssSelector;\r\n        let inNot = false;\r\n        _SELECTOR_REGEXP.lastIndex = 0;\r\n        while (match = _SELECTOR_REGEXP.exec(selector)) {\r\n            if (match[1 /* NOT */]) {\r\n                if (inNot) {\r\n                    throw new Error('Nesting :not in a selector is not allowed');\r\n                }\r\n                inNot = true;\r\n                current = new CssSelector();\r\n                cssSelector.notSelectors.push(current);\r\n            }\r\n            const tag = match[2 /* TAG */];\r\n            if (tag) {\r\n                const prefix = match[3 /* PREFIX */];\r\n                if (prefix === '#') {\r\n                    // #hash\r\n                    current.addAttribute('id', tag.substr(1));\r\n                }\r\n                else if (prefix === '.') {\r\n                    // Class\r\n                    current.addClassName(tag.substr(1));\r\n                }\r\n                else {\r\n                    // Element\r\n                    current.setElement(tag);\r\n                }\r\n            }\r\n            const attribute = match[4 /* ATTRIBUTE */];\r\n            if (attribute) {\r\n                current.addAttribute(current.unescapeAttribute(attribute), match[6 /* ATTRIBUTE_VALUE */]);\r\n            }\r\n            if (match[7 /* NOT_END */]) {\r\n                inNot = false;\r\n                current = cssSelector;\r\n            }\r\n            if (match[8 /* SEPARATOR */]) {\r\n                if (inNot) {\r\n                    throw new Error('Multiple selectors in :not are not supported');\r\n                }\r\n                _addResult(results, cssSelector);\r\n                cssSelector = current = new CssSelector();\r\n            }\r\n        }\r\n        _addResult(results, cssSelector);\r\n        return results;\r\n    }\r\n    /**\r\n     * Unescape `\\$` sequences from the CSS attribute selector.\r\n     *\r\n     * This is needed because `$` can have a special meaning in CSS selectors,\r\n     * but we might want to match an attribute that contains `$`.\r\n     * [MDN web link for more\r\n     * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\r\n     * @param attr the attribute to unescape.\r\n     * @returns the unescaped string.\r\n     */\r\n    unescapeAttribute(attr) {\r\n        let result = '';\r\n        let escaping = false;\r\n        for (let i = 0; i < attr.length; i++) {\r\n            const char = attr.charAt(i);\r\n            if (char === '\\\\') {\r\n                escaping = true;\r\n                continue;\r\n            }\r\n            if (char === '$' && !escaping) {\r\n                throw new Error(`Error in attribute selector \"${attr}\". ` +\r\n                    `Unescaped \"$\" is not supported. Please escape with \"\\\\$\".`);\r\n            }\r\n            escaping = false;\r\n            result += char;\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Escape `$` sequences from the CSS attribute selector.\r\n     *\r\n     * This is needed because `$` can have a special meaning in CSS selectors,\r\n     * with this method we are escaping `$` with `\\$'.\r\n     * [MDN web link for more\r\n     * info](https://developer.mozilla.org/en-US/docs/Web/CSS/Attribute_selectors).\r\n     * @param attr the attribute to escape.\r\n     * @returns the escaped string.\r\n     */\r\n    escapeAttribute(attr) {\r\n        return attr.replace(/\\\\/g, '\\\\\\\\').replace(/\\$/g, '\\\\$');\r\n    }\r\n    isElementSelector() {\r\n        return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 &&\r\n            this.notSelectors.length === 0;\r\n    }\r\n    hasElementSelector() {\r\n        return !!this.element;\r\n    }\r\n    setElement(element = null) {\r\n        this.element = element;\r\n    }\r\n    /** Gets a template string for an element that matches the selector. */\r\n    getMatchingElementTemplate() {\r\n        const tagName = this.element || 'div';\r\n        const classAttr = this.classNames.length > 0 ? ` class=\"${this.classNames.join(' ')}\"` : '';\r\n        let attrs = '';\r\n        for (let i = 0; i < this.attrs.length; i += 2) {\r\n            const attrName = this.attrs[i];\r\n            const attrValue = this.attrs[i + 1] !== '' ? `=\"${this.attrs[i + 1]}\"` : '';\r\n            attrs += ` ${attrName}${attrValue}`;\r\n        }\r\n        return getHtmlTagDefinition(tagName).isVoid ? `<${tagName}${classAttr}${attrs}/>` :\r\n            `<${tagName}${classAttr}${attrs}></${tagName}>`;\r\n    }\r\n    getAttrs() {\r\n        const result = [];\r\n        if (this.classNames.length > 0) {\r\n            result.push('class', this.classNames.join(' '));\r\n        }\r\n        return result.concat(this.attrs);\r\n    }\r\n    addAttribute(name, value = '') {\r\n        this.attrs.push(name, value && value.toLowerCase() || '');\r\n    }\r\n    addClassName(name) {\r\n        this.classNames.push(name.toLowerCase());\r\n    }\r\n    toString() {\r\n        let res = this.element || '';\r\n        if (this.classNames) {\r\n            this.classNames.forEach(klass => res += `.${klass}`);\r\n        }\r\n        if (this.attrs) {\r\n            for (let i = 0; i < this.attrs.length; i += 2) {\r\n                const name = this.escapeAttribute(this.attrs[i]);\r\n                const value = this.attrs[i + 1];\r\n                res += `[${name}${value ? '=' + value : ''}]`;\r\n            }\r\n        }\r\n        this.notSelectors.forEach(notSelector => res += `:not(${notSelector})`);\r\n        return res;\r\n    }\r\n}\r\n/**\r\n * Reads a list of CssSelectors and allows to calculate which ones\r\n * are contained in a given CssSelector.\r\n */\r\nclass SelectorMatcher {\r\n    constructor() {\r\n        this._elementMap = new Map();\r\n        this._elementPartialMap = new Map();\r\n        this._classMap = new Map();\r\n        this._classPartialMap = new Map();\r\n        this._attrValueMap = new Map();\r\n        this._attrValuePartialMap = new Map();\r\n        this._listContexts = [];\r\n    }\r\n    static createNotMatcher(notSelectors) {\r\n        const notMatcher = new SelectorMatcher();\r\n        notMatcher.addSelectables(notSelectors, null);\r\n        return notMatcher;\r\n    }\r\n    addSelectables(cssSelectors, callbackCtxt) {\r\n        let listContext = null;\r\n        if (cssSelectors.length > 1) {\r\n            listContext = new SelectorListContext(cssSelectors);\r\n            this._listContexts.push(listContext);\r\n        }\r\n        for (let i = 0; i < cssSelectors.length; i++) {\r\n            this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\r\n        }\r\n    }\r\n    /**\r\n     * Add an object that can be found later on by calling `match`.\r\n     * @param cssSelector A css selector\r\n     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\r\n     */\r\n    _addSelectable(cssSelector, callbackCtxt, listContext) {\r\n        let matcher = this;\r\n        const element = cssSelector.element;\r\n        const classNames = cssSelector.classNames;\r\n        const attrs = cssSelector.attrs;\r\n        const selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\r\n        if (element) {\r\n            const isTerminal = attrs.length === 0 && classNames.length === 0;\r\n            if (isTerminal) {\r\n                this._addTerminal(matcher._elementMap, element, selectable);\r\n            }\r\n            else {\r\n                matcher = this._addPartial(matcher._elementPartialMap, element);\r\n            }\r\n        }\r\n        if (classNames) {\r\n            for (let i = 0; i < classNames.length; i++) {\r\n                const isTerminal = attrs.length === 0 && i === classNames.length - 1;\r\n                const className = classNames[i];\r\n                if (isTerminal) {\r\n                    this._addTerminal(matcher._classMap, className, selectable);\r\n                }\r\n                else {\r\n                    matcher = this._addPartial(matcher._classPartialMap, className);\r\n                }\r\n            }\r\n        }\r\n        if (attrs) {\r\n            for (let i = 0; i < attrs.length; i += 2) {\r\n                const isTerminal = i === attrs.length - 2;\r\n                const name = attrs[i];\r\n                const value = attrs[i + 1];\r\n                if (isTerminal) {\r\n                    const terminalMap = matcher._attrValueMap;\r\n                    let terminalValuesMap = terminalMap.get(name);\r\n                    if (!terminalValuesMap) {\r\n                        terminalValuesMap = new Map();\r\n                        terminalMap.set(name, terminalValuesMap);\r\n                    }\r\n                    this._addTerminal(terminalValuesMap, value, selectable);\r\n                }\r\n                else {\r\n                    const partialMap = matcher._attrValuePartialMap;\r\n                    let partialValuesMap = partialMap.get(name);\r\n                    if (!partialValuesMap) {\r\n                        partialValuesMap = new Map();\r\n                        partialMap.set(name, partialValuesMap);\r\n                    }\r\n                    matcher = this._addPartial(partialValuesMap, value);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    _addTerminal(map, name, selectable) {\r\n        let terminalList = map.get(name);\r\n        if (!terminalList) {\r\n            terminalList = [];\r\n            map.set(name, terminalList);\r\n        }\r\n        terminalList.push(selectable);\r\n    }\r\n    _addPartial(map, name) {\r\n        let matcher = map.get(name);\r\n        if (!matcher) {\r\n            matcher = new SelectorMatcher();\r\n            map.set(name, matcher);\r\n        }\r\n        return matcher;\r\n    }\r\n    /**\r\n     * Find the objects that have been added via `addSelectable`\r\n     * whose css selector is contained in the given css selector.\r\n     * @param cssSelector A css selector\r\n     * @param matchedCallback This callback will be called with the object handed into `addSelectable`\r\n     * @return boolean true if a match was found\r\n     */\r\n    match(cssSelector, matchedCallback) {\r\n        let result = false;\r\n        const element = cssSelector.element;\r\n        const classNames = cssSelector.classNames;\r\n        const attrs = cssSelector.attrs;\r\n        for (let i = 0; i < this._listContexts.length; i++) {\r\n            this._listContexts[i].alreadyMatched = false;\r\n        }\r\n        result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\r\n        result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) ||\r\n            result;\r\n        if (classNames) {\r\n            for (let i = 0; i < classNames.length; i++) {\r\n                const className = classNames[i];\r\n                result =\r\n                    this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\r\n                result =\r\n                    this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) ||\r\n                        result;\r\n            }\r\n        }\r\n        if (attrs) {\r\n            for (let i = 0; i < attrs.length; i += 2) {\r\n                const name = attrs[i];\r\n                const value = attrs[i + 1];\r\n                const terminalValuesMap = this._attrValueMap.get(name);\r\n                if (value) {\r\n                    result =\r\n                        this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\r\n                }\r\n                result =\r\n                    this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\r\n                const partialValuesMap = this._attrValuePartialMap.get(name);\r\n                if (value) {\r\n                    result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\r\n                }\r\n                result =\r\n                    this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /** @internal */\r\n    _matchTerminal(map, name, cssSelector, matchedCallback) {\r\n        if (!map || typeof name !== 'string') {\r\n            return false;\r\n        }\r\n        let selectables = map.get(name) || [];\r\n        const starSelectables = map.get('*');\r\n        if (starSelectables) {\r\n            selectables = selectables.concat(starSelectables);\r\n        }\r\n        if (selectables.length === 0) {\r\n            return false;\r\n        }\r\n        let selectable;\r\n        let result = false;\r\n        for (let i = 0; i < selectables.length; i++) {\r\n            selectable = selectables[i];\r\n            result = selectable.finalize(cssSelector, matchedCallback) || result;\r\n        }\r\n        return result;\r\n    }\r\n    /** @internal */\r\n    _matchPartial(map, name, cssSelector, matchedCallback) {\r\n        if (!map || typeof name !== 'string') {\r\n            return false;\r\n        }\r\n        const nestedSelector = map.get(name);\r\n        if (!nestedSelector) {\r\n            return false;\r\n        }\r\n        // TODO(perf): get rid of recursion and measure again\r\n        // TODO(perf): don't pass the whole selector into the recursion,\r\n        // but only the not processed parts\r\n        return nestedSelector.match(cssSelector, matchedCallback);\r\n    }\r\n}\r\nclass SelectorListContext {\r\n    constructor(selectors) {\r\n        this.selectors = selectors;\r\n        this.alreadyMatched = false;\r\n    }\r\n}\r\n// Store context to pass back selector and context when a selector is matched\r\nclass SelectorContext {\r\n    constructor(selector, cbContext, listContext) {\r\n        this.selector = selector;\r\n        this.cbContext = cbContext;\r\n        this.listContext = listContext;\r\n        this.notSelectors = selector.notSelectors;\r\n    }\r\n    finalize(cssSelector, callback) {\r\n        let result = true;\r\n        if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\r\n            const notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\r\n            result = !notMatcher.match(cssSelector, null);\r\n        }\r\n        if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\r\n            if (this.listContext) {\r\n                this.listContext.alreadyMatched = true;\r\n            }\r\n            callback(this.selector, this.cbContext);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst createInject = makeMetadataFactory('Inject', (token) => ({ token }));\r\nconst createInjectionToken = makeMetadataFactory('InjectionToken', (desc) => ({ _desc: desc, ɵprov: undefined }));\r\nconst createAttribute = makeMetadataFactory('Attribute', (attributeName) => ({ attributeName }));\r\n// Stores the default value of `emitDistinctChangesOnly` when the `emitDistinctChangesOnly` is not\r\n// explicitly set.\r\nconst emitDistinctChangesOnlyDefaultValue = true;\r\nconst createContentChildren = makeMetadataFactory('ContentChildren', (selector, data = {}) => (Object.assign({ selector, first: false, isViewQuery: false, descendants: false, emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue }, data)));\r\nconst createContentChild = makeMetadataFactory('ContentChild', (selector, data = {}) => (Object.assign({ selector, first: true, isViewQuery: false, descendants: true }, data)));\r\nconst createViewChildren = makeMetadataFactory('ViewChildren', (selector, data = {}) => (Object.assign({ selector, first: false, isViewQuery: true, descendants: true, emitDistinctChangesOnly: emitDistinctChangesOnlyDefaultValue }, data)));\r\nconst createViewChild = makeMetadataFactory('ViewChild', (selector, data) => (Object.assign({ selector, first: true, isViewQuery: true, descendants: true }, data)));\r\nconst createDirective = makeMetadataFactory('Directive', (dir = {}) => dir);\r\nvar ViewEncapsulation;\r\n(function (ViewEncapsulation) {\r\n    ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\r\n    // Historically the 1 value was for `Native` encapsulation which has been removed as of v11.\r\n    ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\r\n    ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\r\n})(ViewEncapsulation || (ViewEncapsulation = {}));\r\nvar ChangeDetectionStrategy;\r\n(function (ChangeDetectionStrategy) {\r\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\r\n    ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\r\n})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));\r\nconst createComponent = makeMetadataFactory('Component', (c = {}) => (Object.assign({ changeDetection: ChangeDetectionStrategy.Default }, c)));\r\nconst createPipe = makeMetadataFactory('Pipe', (p) => (Object.assign({ pure: true }, p)));\r\nconst createInput = makeMetadataFactory('Input', (bindingPropertyName) => ({ bindingPropertyName }));\r\nconst createOutput = makeMetadataFactory('Output', (bindingPropertyName) => ({ bindingPropertyName }));\r\nconst createHostBinding = makeMetadataFactory('HostBinding', (hostPropertyName) => ({ hostPropertyName }));\r\nconst createHostListener = makeMetadataFactory('HostListener', (eventName, args) => ({ eventName, args }));\r\nconst createNgModule = makeMetadataFactory('NgModule', (ngModule) => ngModule);\r\nconst createInjectable = makeMetadataFactory('Injectable', (injectable = {}) => injectable);\r\nconst CUSTOM_ELEMENTS_SCHEMA = {\r\n    name: 'custom-elements'\r\n};\r\nconst NO_ERRORS_SCHEMA = {\r\n    name: 'no-errors-schema'\r\n};\r\nconst createOptional = makeMetadataFactory('Optional');\r\nconst createSelf = makeMetadataFactory('Self');\r\nconst createSkipSelf = makeMetadataFactory('SkipSelf');\r\nconst createHost = makeMetadataFactory('Host');\r\nconst Type = Function;\r\nvar SecurityContext;\r\n(function (SecurityContext) {\r\n    SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\r\n    SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\r\n    SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\r\n    SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\r\n    SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\r\n    SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\r\n})(SecurityContext || (SecurityContext = {}));\r\nvar MissingTranslationStrategy;\r\n(function (MissingTranslationStrategy) {\r\n    MissingTranslationStrategy[MissingTranslationStrategy[\"Error\"] = 0] = \"Error\";\r\n    MissingTranslationStrategy[MissingTranslationStrategy[\"Warning\"] = 1] = \"Warning\";\r\n    MissingTranslationStrategy[MissingTranslationStrategy[\"Ignore\"] = 2] = \"Ignore\";\r\n})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));\r\nfunction makeMetadataFactory(name, props) {\r\n    // This must be declared as a function, not a fat arrow, so that ES2015 devmode produces code\r\n    // that works with the static_reflector.ts in the ViewEngine compiler.\r\n    // In particular, `_registerDecoratorOrConstructor` assumes that the value returned here can be\r\n    // new'ed.\r\n    function factory(...args) {\r\n        const values = props ? props(...args) : {};\r\n        return Object.assign({ ngMetadataName: name }, values);\r\n    }\r\n    factory.isTypeOf = (obj) => obj && obj.ngMetadataName === name;\r\n    factory.ngMetadataName = name;\r\n    return factory;\r\n}\r\nfunction parserSelectorToSimpleSelector(selector) {\r\n    const classes = selector.classNames && selector.classNames.length ?\r\n        [8 /* CLASS */, ...selector.classNames] :\r\n        [];\r\n    const elementName = selector.element && selector.element !== '*' ? selector.element : '';\r\n    return [elementName, ...selector.attrs, ...classes];\r\n}\r\nfunction parserSelectorToNegativeSelector(selector) {\r\n    const classes = selector.classNames && selector.classNames.length ?\r\n        [8 /* CLASS */, ...selector.classNames] :\r\n        [];\r\n    if (selector.element) {\r\n        return [\r\n            1 /* NOT */ | 4 /* ELEMENT */, selector.element, ...selector.attrs, ...classes\r\n        ];\r\n    }\r\n    else if (selector.attrs.length) {\r\n        return [1 /* NOT */ | 2 /* ATTRIBUTE */, ...selector.attrs, ...classes];\r\n    }\r\n    else {\r\n        return selector.classNames && selector.classNames.length ?\r\n            [1 /* NOT */ | 8 /* CLASS */, ...selector.classNames] :\r\n            [];\r\n    }\r\n}\r\nfunction parserSelectorToR3Selector(selector) {\r\n    const positive = parserSelectorToSimpleSelector(selector);\r\n    const negative = selector.notSelectors && selector.notSelectors.length ?\r\n        selector.notSelectors.map(notSelector => parserSelectorToNegativeSelector(notSelector)) :\r\n        [];\r\n    return positive.concat(...negative);\r\n}\r\nfunction parseSelectorToR3Selector(selector) {\r\n    return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];\r\n}\r\n\r\nvar core = /*#__PURE__*/Object.freeze({\r\n    __proto__: null,\r\n    createInject: createInject,\r\n    createInjectionToken: createInjectionToken,\r\n    createAttribute: createAttribute,\r\n    emitDistinctChangesOnlyDefaultValue: emitDistinctChangesOnlyDefaultValue,\r\n    createContentChildren: createContentChildren,\r\n    createContentChild: createContentChild,\r\n    createViewChildren: createViewChildren,\r\n    createViewChild: createViewChild,\r\n    createDirective: createDirective,\r\n    get ViewEncapsulation () { return ViewEncapsulation; },\r\n    get ChangeDetectionStrategy () { return ChangeDetectionStrategy; },\r\n    createComponent: createComponent,\r\n    createPipe: createPipe,\r\n    createInput: createInput,\r\n    createOutput: createOutput,\r\n    createHostBinding: createHostBinding,\r\n    createHostListener: createHostListener,\r\n    createNgModule: createNgModule,\r\n    createInjectable: createInjectable,\r\n    CUSTOM_ELEMENTS_SCHEMA: CUSTOM_ELEMENTS_SCHEMA,\r\n    NO_ERRORS_SCHEMA: NO_ERRORS_SCHEMA,\r\n    createOptional: createOptional,\r\n    createSelf: createSelf,\r\n    createSkipSelf: createSkipSelf,\r\n    createHost: createHost,\r\n    Type: Type,\r\n    get SecurityContext () { return SecurityContext; },\r\n    get MissingTranslationStrategy () { return MissingTranslationStrategy; },\r\n    parseSelectorToR3Selector: parseSelectorToR3Selector\r\n});\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n//// Types\r\nvar TypeModifier;\r\n(function (TypeModifier) {\r\n    TypeModifier[TypeModifier[\"Const\"] = 0] = \"Const\";\r\n})(TypeModifier || (TypeModifier = {}));\r\nclass Type$1 {\r\n    constructor(modifiers = []) {\r\n        this.modifiers = modifiers;\r\n    }\r\n    hasModifier(modifier) {\r\n        return this.modifiers.indexOf(modifier) !== -1;\r\n    }\r\n}\r\nvar BuiltinTypeName;\r\n(function (BuiltinTypeName) {\r\n    BuiltinTypeName[BuiltinTypeName[\"Dynamic\"] = 0] = \"Dynamic\";\r\n    BuiltinTypeName[BuiltinTypeName[\"Bool\"] = 1] = \"Bool\";\r\n    BuiltinTypeName[BuiltinTypeName[\"String\"] = 2] = \"String\";\r\n    BuiltinTypeName[BuiltinTypeName[\"Int\"] = 3] = \"Int\";\r\n    BuiltinTypeName[BuiltinTypeName[\"Number\"] = 4] = \"Number\";\r\n    BuiltinTypeName[BuiltinTypeName[\"Function\"] = 5] = \"Function\";\r\n    BuiltinTypeName[BuiltinTypeName[\"Inferred\"] = 6] = \"Inferred\";\r\n    BuiltinTypeName[BuiltinTypeName[\"None\"] = 7] = \"None\";\r\n})(BuiltinTypeName || (BuiltinTypeName = {}));\r\nclass BuiltinType extends Type$1 {\r\n    constructor(name, modifiers) {\r\n        super(modifiers);\r\n        this.name = name;\r\n    }\r\n    visitType(visitor, context) {\r\n        return visitor.visitBuiltinType(this, context);\r\n    }\r\n}\r\nclass ExpressionType extends Type$1 {\r\n    constructor(value, modifiers, typeParams = null) {\r\n        super(modifiers);\r\n        this.value = value;\r\n        this.typeParams = typeParams;\r\n    }\r\n    visitType(visitor, context) {\r\n        return visitor.visitExpressionType(this, context);\r\n    }\r\n}\r\nclass ArrayType extends Type$1 {\r\n    constructor(of, modifiers) {\r\n        super(modifiers);\r\n        this.of = of;\r\n    }\r\n    visitType(visitor, context) {\r\n        return visitor.visitArrayType(this, context);\r\n    }\r\n}\r\nclass MapType extends Type$1 {\r\n    constructor(valueType, modifiers) {\r\n        super(modifiers);\r\n        this.valueType = valueType || null;\r\n    }\r\n    visitType(visitor, context) {\r\n        return visitor.visitMapType(this, context);\r\n    }\r\n}\r\nconst DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\r\nconst INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\r\nconst BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\r\nconst INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\r\nconst NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\r\nconst STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\r\nconst FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\r\nconst NONE_TYPE = new BuiltinType(BuiltinTypeName.None);\r\n///// Expressions\r\nvar UnaryOperator;\r\n(function (UnaryOperator) {\r\n    UnaryOperator[UnaryOperator[\"Minus\"] = 0] = \"Minus\";\r\n    UnaryOperator[UnaryOperator[\"Plus\"] = 1] = \"Plus\";\r\n})(UnaryOperator || (UnaryOperator = {}));\r\nvar BinaryOperator;\r\n(function (BinaryOperator) {\r\n    BinaryOperator[BinaryOperator[\"Equals\"] = 0] = \"Equals\";\r\n    BinaryOperator[BinaryOperator[\"NotEquals\"] = 1] = \"NotEquals\";\r\n    BinaryOperator[BinaryOperator[\"Identical\"] = 2] = \"Identical\";\r\n    BinaryOperator[BinaryOperator[\"NotIdentical\"] = 3] = \"NotIdentical\";\r\n    BinaryOperator[BinaryOperator[\"Minus\"] = 4] = \"Minus\";\r\n    BinaryOperator[BinaryOperator[\"Plus\"] = 5] = \"Plus\";\r\n    BinaryOperator[BinaryOperator[\"Divide\"] = 6] = \"Divide\";\r\n    BinaryOperator[BinaryOperator[\"Multiply\"] = 7] = \"Multiply\";\r\n    BinaryOperator[BinaryOperator[\"Modulo\"] = 8] = \"Modulo\";\r\n    BinaryOperator[BinaryOperator[\"And\"] = 9] = \"And\";\r\n    BinaryOperator[BinaryOperator[\"Or\"] = 10] = \"Or\";\r\n    BinaryOperator[BinaryOperator[\"BitwiseAnd\"] = 11] = \"BitwiseAnd\";\r\n    BinaryOperator[BinaryOperator[\"Lower\"] = 12] = \"Lower\";\r\n    BinaryOperator[BinaryOperator[\"LowerEquals\"] = 13] = \"LowerEquals\";\r\n    BinaryOperator[BinaryOperator[\"Bigger\"] = 14] = \"Bigger\";\r\n    BinaryOperator[BinaryOperator[\"BiggerEquals\"] = 15] = \"BiggerEquals\";\r\n    BinaryOperator[BinaryOperator[\"NullishCoalesce\"] = 16] = \"NullishCoalesce\";\r\n})(BinaryOperator || (BinaryOperator = {}));\r\nfunction nullSafeIsEquivalent(base, other) {\r\n    if (base == null || other == null) {\r\n        return base == other;\r\n    }\r\n    return base.isEquivalent(other);\r\n}\r\nfunction areAllEquivalentPredicate(base, other, equivalentPredicate) {\r\n    const len = base.length;\r\n    if (len !== other.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < len; i++) {\r\n        if (!equivalentPredicate(base[i], other[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction areAllEquivalent(base, other) {\r\n    return areAllEquivalentPredicate(base, other, (baseElement, otherElement) => baseElement.isEquivalent(otherElement));\r\n}\r\nclass Expression {\r\n    constructor(type, sourceSpan) {\r\n        this.type = type || null;\r\n        this.sourceSpan = sourceSpan || null;\r\n    }\r\n    prop(name, sourceSpan) {\r\n        return new ReadPropExpr(this, name, null, sourceSpan);\r\n    }\r\n    key(index, type, sourceSpan) {\r\n        return new ReadKeyExpr(this, index, type, sourceSpan);\r\n    }\r\n    callMethod(name, params, sourceSpan) {\r\n        return new InvokeMethodExpr(this, name, params, null, sourceSpan);\r\n    }\r\n    callFn(params, sourceSpan, pure) {\r\n        return new InvokeFunctionExpr(this, params, null, sourceSpan, pure);\r\n    }\r\n    instantiate(params, type, sourceSpan) {\r\n        return new InstantiateExpr(this, params, type, sourceSpan);\r\n    }\r\n    conditional(trueCase, falseCase = null, sourceSpan) {\r\n        return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\r\n    }\r\n    equals(rhs, sourceSpan) {\r\n        return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\r\n    }\r\n    notEquals(rhs, sourceSpan) {\r\n        return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\r\n    }\r\n    identical(rhs, sourceSpan) {\r\n        return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\r\n    }\r\n    notIdentical(rhs, sourceSpan) {\r\n        return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\r\n    }\r\n    minus(rhs, sourceSpan) {\r\n        return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\r\n    }\r\n    plus(rhs, sourceSpan) {\r\n        return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\r\n    }\r\n    divide(rhs, sourceSpan) {\r\n        return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\r\n    }\r\n    multiply(rhs, sourceSpan) {\r\n        return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\r\n    }\r\n    modulo(rhs, sourceSpan) {\r\n        return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\r\n    }\r\n    and(rhs, sourceSpan) {\r\n        return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\r\n    }\r\n    bitwiseAnd(rhs, sourceSpan, parens = true) {\r\n        return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);\r\n    }\r\n    or(rhs, sourceSpan) {\r\n        return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\r\n    }\r\n    lower(rhs, sourceSpan) {\r\n        return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\r\n    }\r\n    lowerEquals(rhs, sourceSpan) {\r\n        return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\r\n    }\r\n    bigger(rhs, sourceSpan) {\r\n        return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\r\n    }\r\n    biggerEquals(rhs, sourceSpan) {\r\n        return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\r\n    }\r\n    isBlank(sourceSpan) {\r\n        // Note: We use equals by purpose here to compare to null and undefined in JS.\r\n        // We use the typed null to allow strictNullChecks to narrow types.\r\n        return this.equals(TYPED_NULL_EXPR, sourceSpan);\r\n    }\r\n    cast(type, sourceSpan) {\r\n        return new CastExpr(this, type, sourceSpan);\r\n    }\r\n    nullishCoalesce(rhs, sourceSpan) {\r\n        return new BinaryOperatorExpr(BinaryOperator.NullishCoalesce, this, rhs, null, sourceSpan);\r\n    }\r\n    toStmt() {\r\n        return new ExpressionStatement(this, null);\r\n    }\r\n}\r\nvar BuiltinVar;\r\n(function (BuiltinVar) {\r\n    BuiltinVar[BuiltinVar[\"This\"] = 0] = \"This\";\r\n    BuiltinVar[BuiltinVar[\"Super\"] = 1] = \"Super\";\r\n    BuiltinVar[BuiltinVar[\"CatchError\"] = 2] = \"CatchError\";\r\n    BuiltinVar[BuiltinVar[\"CatchStack\"] = 3] = \"CatchStack\";\r\n})(BuiltinVar || (BuiltinVar = {}));\r\nclass ReadVarExpr extends Expression {\r\n    constructor(name, type, sourceSpan) {\r\n        super(type, sourceSpan);\r\n        if (typeof name === 'string') {\r\n            this.name = name;\r\n            this.builtin = null;\r\n        }\r\n        else {\r\n            this.name = null;\r\n            this.builtin = name;\r\n        }\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof ReadVarExpr && this.name === e.name && this.builtin === e.builtin;\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitReadVarExpr(this, context);\r\n    }\r\n    set(value) {\r\n        if (!this.name) {\r\n            throw new Error(`Built in variable ${this.builtin} can not be assigned to.`);\r\n        }\r\n        return new WriteVarExpr(this.name, value, null, this.sourceSpan);\r\n    }\r\n}\r\nclass TypeofExpr extends Expression {\r\n    constructor(expr, type, sourceSpan) {\r\n        super(type, sourceSpan);\r\n        this.expr = expr;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitTypeofExpr(this, context);\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\r\n    }\r\n    isConstant() {\r\n        return this.expr.isConstant();\r\n    }\r\n}\r\nclass WrappedNodeExpr extends Expression {\r\n    constructor(node, type, sourceSpan) {\r\n        super(type, sourceSpan);\r\n        this.node = node;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof WrappedNodeExpr && this.node === e.node;\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitWrappedNodeExpr(this, context);\r\n    }\r\n}\r\nclass WriteVarExpr extends Expression {\r\n    constructor(name, value, type, sourceSpan) {\r\n        super(type || value.type, sourceSpan);\r\n        this.name = name;\r\n        this.value = value;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitWriteVarExpr(this, context);\r\n    }\r\n    toDeclStmt(type, modifiers) {\r\n        return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\r\n    }\r\n    toConstDecl() {\r\n        return this.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]);\r\n    }\r\n}\r\nclass WriteKeyExpr extends Expression {\r\n    constructor(receiver, index, value, type, sourceSpan) {\r\n        super(type || value.type, sourceSpan);\r\n        this.receiver = receiver;\r\n        this.index = index;\r\n        this.value = value;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) &&\r\n            this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitWriteKeyExpr(this, context);\r\n    }\r\n}\r\nclass WritePropExpr extends Expression {\r\n    constructor(receiver, name, value, type, sourceSpan) {\r\n        super(type || value.type, sourceSpan);\r\n        this.receiver = receiver;\r\n        this.name = name;\r\n        this.value = value;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) &&\r\n            this.name === e.name && this.value.isEquivalent(e.value);\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitWritePropExpr(this, context);\r\n    }\r\n}\r\nvar BuiltinMethod;\r\n(function (BuiltinMethod) {\r\n    BuiltinMethod[BuiltinMethod[\"ConcatArray\"] = 0] = \"ConcatArray\";\r\n    BuiltinMethod[BuiltinMethod[\"SubscribeObservable\"] = 1] = \"SubscribeObservable\";\r\n    BuiltinMethod[BuiltinMethod[\"Bind\"] = 2] = \"Bind\";\r\n})(BuiltinMethod || (BuiltinMethod = {}));\r\nclass InvokeMethodExpr extends Expression {\r\n    constructor(receiver, method, args, type, sourceSpan) {\r\n        super(type, sourceSpan);\r\n        this.receiver = receiver;\r\n        this.args = args;\r\n        if (typeof method === 'string') {\r\n            this.name = method;\r\n            this.builtin = null;\r\n        }\r\n        else {\r\n            this.name = null;\r\n            this.builtin = method;\r\n        }\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof InvokeMethodExpr && this.receiver.isEquivalent(e.receiver) &&\r\n            this.name === e.name && this.builtin === e.builtin && areAllEquivalent(this.args, e.args);\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitInvokeMethodExpr(this, context);\r\n    }\r\n}\r\nclass InvokeFunctionExpr extends Expression {\r\n    constructor(fn, args, type, sourceSpan, pure = false) {\r\n        super(type, sourceSpan);\r\n        this.fn = fn;\r\n        this.args = args;\r\n        this.pure = pure;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) &&\r\n            areAllEquivalent(this.args, e.args) && this.pure === e.pure;\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitInvokeFunctionExpr(this, context);\r\n    }\r\n}\r\nclass TaggedTemplateExpr extends Expression {\r\n    constructor(tag, template, type, sourceSpan) {\r\n        super(type, sourceSpan);\r\n        this.tag = tag;\r\n        this.template = template;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof TaggedTemplateExpr && this.tag.isEquivalent(e.tag) &&\r\n            areAllEquivalentPredicate(this.template.elements, e.template.elements, (a, b) => a.text === b.text) &&\r\n            areAllEquivalent(this.template.expressions, e.template.expressions);\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitTaggedTemplateExpr(this, context);\r\n    }\r\n}\r\nclass InstantiateExpr extends Expression {\r\n    constructor(classExpr, args, type, sourceSpan) {\r\n        super(type, sourceSpan);\r\n        this.classExpr = classExpr;\r\n        this.args = args;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) &&\r\n            areAllEquivalent(this.args, e.args);\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitInstantiateExpr(this, context);\r\n    }\r\n}\r\nclass LiteralExpr extends Expression {\r\n    constructor(value, type, sourceSpan) {\r\n        super(type, sourceSpan);\r\n        this.value = value;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof LiteralExpr && this.value === e.value;\r\n    }\r\n    isConstant() {\r\n        return true;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitLiteralExpr(this, context);\r\n    }\r\n}\r\nclass TemplateLiteral {\r\n    constructor(elements, expressions) {\r\n        this.elements = elements;\r\n        this.expressions = expressions;\r\n    }\r\n}\r\nclass TemplateLiteralElement {\r\n    constructor(text, sourceSpan, rawText) {\r\n        var _a;\r\n        this.text = text;\r\n        this.sourceSpan = sourceSpan;\r\n        // If `rawText` is not provided, try to extract the raw string from its\r\n        // associated `sourceSpan`. If that is also not available, \"fake\" the raw\r\n        // string instead by escaping the following control sequences:\r\n        // - \"\\\" would otherwise indicate that the next character is a control character.\r\n        // - \"`\" and \"${\" are template string control sequences that would otherwise prematurely\r\n        // indicate the end of the template literal element.\r\n        this.rawText =\r\n            (_a = rawText !== null && rawText !== void 0 ? rawText : sourceSpan === null || sourceSpan === void 0 ? void 0 : sourceSpan.toString()) !== null && _a !== void 0 ? _a : escapeForTemplateLiteral(escapeSlashes(text));\r\n    }\r\n}\r\nclass MessagePiece {\r\n    constructor(text, sourceSpan) {\r\n        this.text = text;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n}\r\nclass LiteralPiece extends MessagePiece {\r\n}\r\nclass PlaceholderPiece extends MessagePiece {\r\n}\r\nclass LocalizedString extends Expression {\r\n    constructor(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {\r\n        super(STRING_TYPE, sourceSpan);\r\n        this.metaBlock = metaBlock;\r\n        this.messageParts = messageParts;\r\n        this.placeHolderNames = placeHolderNames;\r\n        this.expressions = expressions;\r\n    }\r\n    isEquivalent(e) {\r\n        // return e instanceof LocalizedString && this.message === e.message;\r\n        return false;\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitLocalizedString(this, context);\r\n    }\r\n    /**\r\n     * Serialize the given `meta` and `messagePart` into \"cooked\" and \"raw\" strings that can be used\r\n     * in a `$localize` tagged string. The format of the metadata is the same as that parsed by\r\n     * `parseI18nMeta()`.\r\n     *\r\n     * @param meta The metadata to serialize\r\n     * @param messagePart The first part of the tagged string\r\n     */\r\n    serializeI18nHead() {\r\n        const MEANING_SEPARATOR = '|';\r\n        const ID_SEPARATOR = '@@';\r\n        const LEGACY_ID_INDICATOR = '␟';\r\n        let metaBlock = this.metaBlock.description || '';\r\n        if (this.metaBlock.meaning) {\r\n            metaBlock = `${this.metaBlock.meaning}${MEANING_SEPARATOR}${metaBlock}`;\r\n        }\r\n        if (this.metaBlock.customId) {\r\n            metaBlock = `${metaBlock}${ID_SEPARATOR}${this.metaBlock.customId}`;\r\n        }\r\n        if (this.metaBlock.legacyIds) {\r\n            this.metaBlock.legacyIds.forEach(legacyId => {\r\n                metaBlock = `${metaBlock}${LEGACY_ID_INDICATOR}${legacyId}`;\r\n            });\r\n        }\r\n        return createCookedRawString(metaBlock, this.messageParts[0].text, this.getMessagePartSourceSpan(0));\r\n    }\r\n    getMessagePartSourceSpan(i) {\r\n        var _a, _b;\r\n        return (_b = (_a = this.messageParts[i]) === null || _a === void 0 ? void 0 : _a.sourceSpan) !== null && _b !== void 0 ? _b : this.sourceSpan;\r\n    }\r\n    getPlaceholderSourceSpan(i) {\r\n        var _a, _b, _c, _d;\r\n        return (_d = (_b = (_a = this.placeHolderNames[i]) === null || _a === void 0 ? void 0 : _a.sourceSpan) !== null && _b !== void 0 ? _b : (_c = this.expressions[i]) === null || _c === void 0 ? void 0 : _c.sourceSpan) !== null && _d !== void 0 ? _d : this.sourceSpan;\r\n    }\r\n    /**\r\n     * Serialize the given `placeholderName` and `messagePart` into \"cooked\" and \"raw\" strings that\r\n     * can be used in a `$localize` tagged string.\r\n     *\r\n     * @param placeholderName The placeholder name to serialize\r\n     * @param messagePart The following message string after this placeholder\r\n     */\r\n    serializeI18nTemplatePart(partIndex) {\r\n        const placeholderName = this.placeHolderNames[partIndex - 1].text;\r\n        const messagePart = this.messageParts[partIndex];\r\n        return createCookedRawString(placeholderName, messagePart.text, this.getMessagePartSourceSpan(partIndex));\r\n    }\r\n}\r\nconst escapeSlashes = (str) => str.replace(/\\\\/g, '\\\\\\\\');\r\nconst escapeStartingColon = (str) => str.replace(/^:/, '\\\\:');\r\nconst escapeColons = (str) => str.replace(/:/g, '\\\\:');\r\nconst escapeForTemplateLiteral = (str) => str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\r\n/**\r\n * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.\r\n *\r\n * The `raw` text must have various character sequences escaped:\r\n * * \"\\\" would otherwise indicate that the next character is a control character.\r\n * * \"`\" and \"${\" are template string control sequences that would otherwise prematurely indicate\r\n *   the end of a message part.\r\n * * \":\" inside a metablock would prematurely indicate the end of the metablock.\r\n * * \":\" at the start of a messagePart with no metablock would erroneously indicate the start of a\r\n *   metablock.\r\n *\r\n * @param metaBlock Any metadata that should be prepended to the string\r\n * @param messagePart The message part of the string\r\n */\r\nfunction createCookedRawString(metaBlock, messagePart, range) {\r\n    if (metaBlock === '') {\r\n        return {\r\n            cooked: messagePart,\r\n            raw: escapeForTemplateLiteral(escapeStartingColon(escapeSlashes(messagePart))),\r\n            range,\r\n        };\r\n    }\r\n    else {\r\n        return {\r\n            cooked: `:${metaBlock}:${messagePart}`,\r\n            raw: escapeForTemplateLiteral(`:${escapeColons(escapeSlashes(metaBlock))}:${escapeSlashes(messagePart)}`),\r\n            range,\r\n        };\r\n    }\r\n}\r\nclass ExternalExpr extends Expression {\r\n    constructor(value, type, typeParams = null, sourceSpan) {\r\n        super(type, sourceSpan);\r\n        this.value = value;\r\n        this.typeParams = typeParams;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof ExternalExpr && this.value.name === e.value.name &&\r\n            this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitExternalExpr(this, context);\r\n    }\r\n}\r\nclass ExternalReference {\r\n    constructor(moduleName, name, runtime) {\r\n        this.moduleName = moduleName;\r\n        this.name = name;\r\n        this.runtime = runtime;\r\n    }\r\n}\r\nclass ConditionalExpr extends Expression {\r\n    constructor(condition, trueCase, falseCase = null, type, sourceSpan) {\r\n        super(type || trueCase.type, sourceSpan);\r\n        this.condition = condition;\r\n        this.falseCase = falseCase;\r\n        this.trueCase = trueCase;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) &&\r\n            this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitConditionalExpr(this, context);\r\n    }\r\n}\r\nclass NotExpr extends Expression {\r\n    constructor(condition, sourceSpan) {\r\n        super(BOOL_TYPE, sourceSpan);\r\n        this.condition = condition;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitNotExpr(this, context);\r\n    }\r\n}\r\nclass AssertNotNull extends Expression {\r\n    constructor(condition, sourceSpan) {\r\n        super(condition.type, sourceSpan);\r\n        this.condition = condition;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof AssertNotNull && this.condition.isEquivalent(e.condition);\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitAssertNotNullExpr(this, context);\r\n    }\r\n}\r\nclass CastExpr extends Expression {\r\n    constructor(value, type, sourceSpan) {\r\n        super(type, sourceSpan);\r\n        this.value = value;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof CastExpr && this.value.isEquivalent(e.value);\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitCastExpr(this, context);\r\n    }\r\n}\r\nclass FnParam {\r\n    constructor(name, type = null) {\r\n        this.name = name;\r\n        this.type = type;\r\n    }\r\n    isEquivalent(param) {\r\n        return this.name === param.name;\r\n    }\r\n}\r\nclass FunctionExpr extends Expression {\r\n    constructor(params, statements, type, sourceSpan, name) {\r\n        super(type, sourceSpan);\r\n        this.params = params;\r\n        this.statements = statements;\r\n        this.name = name;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) &&\r\n            areAllEquivalent(this.statements, e.statements);\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitFunctionExpr(this, context);\r\n    }\r\n    toDeclStmt(name, modifiers) {\r\n        return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\r\n    }\r\n}\r\nclass UnaryOperatorExpr extends Expression {\r\n    constructor(operator, expr, type, sourceSpan, parens = true) {\r\n        super(type || NUMBER_TYPE, sourceSpan);\r\n        this.operator = operator;\r\n        this.expr = expr;\r\n        this.parens = parens;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof UnaryOperatorExpr && this.operator === e.operator &&\r\n            this.expr.isEquivalent(e.expr);\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitUnaryOperatorExpr(this, context);\r\n    }\r\n}\r\nclass BinaryOperatorExpr extends Expression {\r\n    constructor(operator, lhs, rhs, type, sourceSpan, parens = true) {\r\n        super(type || lhs.type, sourceSpan);\r\n        this.operator = operator;\r\n        this.rhs = rhs;\r\n        this.parens = parens;\r\n        this.lhs = lhs;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof BinaryOperatorExpr && this.operator === e.operator &&\r\n            this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitBinaryOperatorExpr(this, context);\r\n    }\r\n}\r\nclass ReadPropExpr extends Expression {\r\n    constructor(receiver, name, type, sourceSpan) {\r\n        super(type, sourceSpan);\r\n        this.receiver = receiver;\r\n        this.name = name;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) &&\r\n            this.name === e.name;\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitReadPropExpr(this, context);\r\n    }\r\n    set(value) {\r\n        return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\r\n    }\r\n}\r\nclass ReadKeyExpr extends Expression {\r\n    constructor(receiver, index, type, sourceSpan) {\r\n        super(type, sourceSpan);\r\n        this.receiver = receiver;\r\n        this.index = index;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) &&\r\n            this.index.isEquivalent(e.index);\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitReadKeyExpr(this, context);\r\n    }\r\n    set(value) {\r\n        return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\r\n    }\r\n}\r\nclass LiteralArrayExpr extends Expression {\r\n    constructor(entries, type, sourceSpan) {\r\n        super(type, sourceSpan);\r\n        this.entries = entries;\r\n    }\r\n    isConstant() {\r\n        return this.entries.every(e => e.isConstant());\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitLiteralArrayExpr(this, context);\r\n    }\r\n}\r\nclass LiteralMapEntry {\r\n    constructor(key, value, quoted) {\r\n        this.key = key;\r\n        this.value = value;\r\n        this.quoted = quoted;\r\n    }\r\n    isEquivalent(e) {\r\n        return this.key === e.key && this.value.isEquivalent(e.value);\r\n    }\r\n}\r\nclass LiteralMapExpr extends Expression {\r\n    constructor(entries, type, sourceSpan) {\r\n        super(type, sourceSpan);\r\n        this.entries = entries;\r\n        this.valueType = null;\r\n        if (type) {\r\n            this.valueType = type.valueType;\r\n        }\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\r\n    }\r\n    isConstant() {\r\n        return this.entries.every(e => e.value.isConstant());\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitLiteralMapExpr(this, context);\r\n    }\r\n}\r\nclass CommaExpr extends Expression {\r\n    constructor(parts, sourceSpan) {\r\n        super(parts[parts.length - 1].type, sourceSpan);\r\n        this.parts = parts;\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\r\n    }\r\n    isConstant() {\r\n        return false;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        return visitor.visitCommaExpr(this, context);\r\n    }\r\n}\r\nconst THIS_EXPR = new ReadVarExpr(BuiltinVar.This, null, null);\r\nconst SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super, null, null);\r\nconst CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError, null, null);\r\nconst CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack, null, null);\r\nconst NULL_EXPR = new LiteralExpr(null, null, null);\r\nconst TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null);\r\n//// Statements\r\nvar StmtModifier;\r\n(function (StmtModifier) {\r\n    StmtModifier[StmtModifier[\"Final\"] = 0] = \"Final\";\r\n    StmtModifier[StmtModifier[\"Private\"] = 1] = \"Private\";\r\n    StmtModifier[StmtModifier[\"Exported\"] = 2] = \"Exported\";\r\n    StmtModifier[StmtModifier[\"Static\"] = 3] = \"Static\";\r\n})(StmtModifier || (StmtModifier = {}));\r\nclass LeadingComment {\r\n    constructor(text, multiline, trailingNewline) {\r\n        this.text = text;\r\n        this.multiline = multiline;\r\n        this.trailingNewline = trailingNewline;\r\n    }\r\n    toString() {\r\n        return this.multiline ? ` ${this.text} ` : this.text;\r\n    }\r\n}\r\nclass JSDocComment extends LeadingComment {\r\n    constructor(tags) {\r\n        super('', /* multiline */ true, /* trailingNewline */ true);\r\n        this.tags = tags;\r\n    }\r\n    toString() {\r\n        return serializeTags(this.tags);\r\n    }\r\n}\r\nclass Statement {\r\n    constructor(modifiers = [], sourceSpan = null, leadingComments) {\r\n        this.modifiers = modifiers;\r\n        this.sourceSpan = sourceSpan;\r\n        this.leadingComments = leadingComments;\r\n    }\r\n    hasModifier(modifier) {\r\n        return this.modifiers.indexOf(modifier) !== -1;\r\n    }\r\n    addLeadingComment(leadingComment) {\r\n        var _a;\r\n        this.leadingComments = (_a = this.leadingComments) !== null && _a !== void 0 ? _a : [];\r\n        this.leadingComments.push(leadingComment);\r\n    }\r\n}\r\nclass DeclareVarStmt extends Statement {\r\n    constructor(name, value, type, modifiers, sourceSpan, leadingComments) {\r\n        super(modifiers, sourceSpan, leadingComments);\r\n        this.name = name;\r\n        this.value = value;\r\n        this.type = type || (value && value.type) || null;\r\n    }\r\n    isEquivalent(stmt) {\r\n        return stmt instanceof DeclareVarStmt && this.name === stmt.name &&\r\n            (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);\r\n    }\r\n    visitStatement(visitor, context) {\r\n        return visitor.visitDeclareVarStmt(this, context);\r\n    }\r\n}\r\nclass DeclareFunctionStmt extends Statement {\r\n    constructor(name, params, statements, type, modifiers, sourceSpan, leadingComments) {\r\n        super(modifiers, sourceSpan, leadingComments);\r\n        this.name = name;\r\n        this.params = params;\r\n        this.statements = statements;\r\n        this.type = type || null;\r\n    }\r\n    isEquivalent(stmt) {\r\n        return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) &&\r\n            areAllEquivalent(this.statements, stmt.statements);\r\n    }\r\n    visitStatement(visitor, context) {\r\n        return visitor.visitDeclareFunctionStmt(this, context);\r\n    }\r\n}\r\nclass ExpressionStatement extends Statement {\r\n    constructor(expr, sourceSpan, leadingComments) {\r\n        super([], sourceSpan, leadingComments);\r\n        this.expr = expr;\r\n    }\r\n    isEquivalent(stmt) {\r\n        return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\r\n    }\r\n    visitStatement(visitor, context) {\r\n        return visitor.visitExpressionStmt(this, context);\r\n    }\r\n}\r\nclass ReturnStatement extends Statement {\r\n    constructor(value, sourceSpan = null, leadingComments) {\r\n        super([], sourceSpan, leadingComments);\r\n        this.value = value;\r\n    }\r\n    isEquivalent(stmt) {\r\n        return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\r\n    }\r\n    visitStatement(visitor, context) {\r\n        return visitor.visitReturnStmt(this, context);\r\n    }\r\n}\r\nclass AbstractClassPart {\r\n    constructor(type = null, modifiers = []) {\r\n        this.type = type;\r\n        this.modifiers = modifiers;\r\n    }\r\n    hasModifier(modifier) {\r\n        return this.modifiers.indexOf(modifier) !== -1;\r\n    }\r\n}\r\nclass ClassField extends AbstractClassPart {\r\n    constructor(name, type, modifiers, initializer) {\r\n        super(type, modifiers);\r\n        this.name = name;\r\n        this.initializer = initializer;\r\n    }\r\n    isEquivalent(f) {\r\n        return this.name === f.name;\r\n    }\r\n}\r\nclass ClassMethod extends AbstractClassPart {\r\n    constructor(name, params, body, type, modifiers) {\r\n        super(type, modifiers);\r\n        this.name = name;\r\n        this.params = params;\r\n        this.body = body;\r\n    }\r\n    isEquivalent(m) {\r\n        return this.name === m.name && areAllEquivalent(this.body, m.body);\r\n    }\r\n}\r\nclass ClassGetter extends AbstractClassPart {\r\n    constructor(name, body, type, modifiers) {\r\n        super(type, modifiers);\r\n        this.name = name;\r\n        this.body = body;\r\n    }\r\n    isEquivalent(m) {\r\n        return this.name === m.name && areAllEquivalent(this.body, m.body);\r\n    }\r\n}\r\nclass ClassStmt extends Statement {\r\n    constructor(name, parent, fields, getters, constructorMethod, methods, modifiers, sourceSpan, leadingComments) {\r\n        super(modifiers, sourceSpan, leadingComments);\r\n        this.name = name;\r\n        this.parent = parent;\r\n        this.fields = fields;\r\n        this.getters = getters;\r\n        this.constructorMethod = constructorMethod;\r\n        this.methods = methods;\r\n    }\r\n    isEquivalent(stmt) {\r\n        return stmt instanceof ClassStmt && this.name === stmt.name &&\r\n            nullSafeIsEquivalent(this.parent, stmt.parent) &&\r\n            areAllEquivalent(this.fields, stmt.fields) &&\r\n            areAllEquivalent(this.getters, stmt.getters) &&\r\n            this.constructorMethod.isEquivalent(stmt.constructorMethod) &&\r\n            areAllEquivalent(this.methods, stmt.methods);\r\n    }\r\n    visitStatement(visitor, context) {\r\n        return visitor.visitDeclareClassStmt(this, context);\r\n    }\r\n}\r\nclass IfStmt extends Statement {\r\n    constructor(condition, trueCase, falseCase = [], sourceSpan, leadingComments) {\r\n        super([], sourceSpan, leadingComments);\r\n        this.condition = condition;\r\n        this.trueCase = trueCase;\r\n        this.falseCase = falseCase;\r\n    }\r\n    isEquivalent(stmt) {\r\n        return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) &&\r\n            areAllEquivalent(this.trueCase, stmt.trueCase) &&\r\n            areAllEquivalent(this.falseCase, stmt.falseCase);\r\n    }\r\n    visitStatement(visitor, context) {\r\n        return visitor.visitIfStmt(this, context);\r\n    }\r\n}\r\nclass TryCatchStmt extends Statement {\r\n    constructor(bodyStmts, catchStmts, sourceSpan = null, leadingComments) {\r\n        super([], sourceSpan, leadingComments);\r\n        this.bodyStmts = bodyStmts;\r\n        this.catchStmts = catchStmts;\r\n    }\r\n    isEquivalent(stmt) {\r\n        return stmt instanceof TryCatchStmt && areAllEquivalent(this.bodyStmts, stmt.bodyStmts) &&\r\n            areAllEquivalent(this.catchStmts, stmt.catchStmts);\r\n    }\r\n    visitStatement(visitor, context) {\r\n        return visitor.visitTryCatchStmt(this, context);\r\n    }\r\n}\r\nclass ThrowStmt extends Statement {\r\n    constructor(error, sourceSpan = null, leadingComments) {\r\n        super([], sourceSpan, leadingComments);\r\n        this.error = error;\r\n    }\r\n    isEquivalent(stmt) {\r\n        return stmt instanceof TryCatchStmt && this.error.isEquivalent(stmt.error);\r\n    }\r\n    visitStatement(visitor, context) {\r\n        return visitor.visitThrowStmt(this, context);\r\n    }\r\n}\r\nclass AstTransformer {\r\n    transformExpr(expr, context) {\r\n        return expr;\r\n    }\r\n    transformStmt(stmt, context) {\r\n        return stmt;\r\n    }\r\n    visitReadVarExpr(ast, context) {\r\n        return this.transformExpr(ast, context);\r\n    }\r\n    visitWrappedNodeExpr(ast, context) {\r\n        return this.transformExpr(ast, context);\r\n    }\r\n    visitTypeofExpr(expr, context) {\r\n        return this.transformExpr(new TypeofExpr(expr.expr.visitExpression(this, context), expr.type, expr.sourceSpan), context);\r\n    }\r\n    visitWriteVarExpr(expr, context) {\r\n        return this.transformExpr(new WriteVarExpr(expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\r\n    }\r\n    visitWriteKeyExpr(expr, context) {\r\n        return this.transformExpr(new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\r\n    }\r\n    visitWritePropExpr(expr, context) {\r\n        return this.transformExpr(new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\r\n    }\r\n    visitInvokeMethodExpr(ast, context) {\r\n        const method = ast.builtin || ast.name;\r\n        return this.transformExpr(new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\r\n    }\r\n    visitInvokeFunctionExpr(ast, context) {\r\n        return this.transformExpr(new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\r\n    }\r\n    visitTaggedTemplateExpr(ast, context) {\r\n        return this.transformExpr(new TaggedTemplateExpr(ast.tag.visitExpression(this, context), new TemplateLiteral(ast.template.elements, ast.template.expressions.map((e) => e.visitExpression(this, context))), ast.type, ast.sourceSpan), context);\r\n    }\r\n    visitInstantiateExpr(ast, context) {\r\n        return this.transformExpr(new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\r\n    }\r\n    visitLiteralExpr(ast, context) {\r\n        return this.transformExpr(ast, context);\r\n    }\r\n    visitLocalizedString(ast, context) {\r\n        return this.transformExpr(new LocalizedString(ast.metaBlock, ast.messageParts, ast.placeHolderNames, this.visitAllExpressions(ast.expressions, context), ast.sourceSpan), context);\r\n    }\r\n    visitExternalExpr(ast, context) {\r\n        return this.transformExpr(ast, context);\r\n    }\r\n    visitConditionalExpr(ast, context) {\r\n        return this.transformExpr(new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context), ast.type, ast.sourceSpan), context);\r\n    }\r\n    visitNotExpr(ast, context) {\r\n        return this.transformExpr(new NotExpr(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\r\n    }\r\n    visitAssertNotNullExpr(ast, context) {\r\n        return this.transformExpr(new AssertNotNull(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\r\n    }\r\n    visitCastExpr(ast, context) {\r\n        return this.transformExpr(new CastExpr(ast.value.visitExpression(this, context), ast.type, ast.sourceSpan), context);\r\n    }\r\n    visitFunctionExpr(ast, context) {\r\n        return this.transformExpr(new FunctionExpr(ast.params, this.visitAllStatements(ast.statements, context), ast.type, ast.sourceSpan), context);\r\n    }\r\n    visitUnaryOperatorExpr(ast, context) {\r\n        return this.transformExpr(new UnaryOperatorExpr(ast.operator, ast.expr.visitExpression(this, context), ast.type, ast.sourceSpan), context);\r\n    }\r\n    visitBinaryOperatorExpr(ast, context) {\r\n        return this.transformExpr(new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type, ast.sourceSpan), context);\r\n    }\r\n    visitReadPropExpr(ast, context) {\r\n        return this.transformExpr(new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type, ast.sourceSpan), context);\r\n    }\r\n    visitReadKeyExpr(ast, context) {\r\n        return this.transformExpr(new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type, ast.sourceSpan), context);\r\n    }\r\n    visitLiteralArrayExpr(ast, context) {\r\n        return this.transformExpr(new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context), ast.type, ast.sourceSpan), context);\r\n    }\r\n    visitLiteralMapExpr(ast, context) {\r\n        const entries = ast.entries.map((entry) => new LiteralMapEntry(entry.key, entry.value.visitExpression(this, context), entry.quoted));\r\n        const mapType = new MapType(ast.valueType);\r\n        return this.transformExpr(new LiteralMapExpr(entries, mapType, ast.sourceSpan), context);\r\n    }\r\n    visitCommaExpr(ast, context) {\r\n        return this.transformExpr(new CommaExpr(this.visitAllExpressions(ast.parts, context), ast.sourceSpan), context);\r\n    }\r\n    visitAllExpressions(exprs, context) {\r\n        return exprs.map(expr => expr.visitExpression(this, context));\r\n    }\r\n    visitDeclareVarStmt(stmt, context) {\r\n        const value = stmt.value && stmt.value.visitExpression(this, context);\r\n        return this.transformStmt(new DeclareVarStmt(stmt.name, value, stmt.type, stmt.modifiers, stmt.sourceSpan, stmt.leadingComments), context);\r\n    }\r\n    visitDeclareFunctionStmt(stmt, context) {\r\n        return this.transformStmt(new DeclareFunctionStmt(stmt.name, stmt.params, this.visitAllStatements(stmt.statements, context), stmt.type, stmt.modifiers, stmt.sourceSpan, stmt.leadingComments), context);\r\n    }\r\n    visitExpressionStmt(stmt, context) {\r\n        return this.transformStmt(new ExpressionStatement(stmt.expr.visitExpression(this, context), stmt.sourceSpan, stmt.leadingComments), context);\r\n    }\r\n    visitReturnStmt(stmt, context) {\r\n        return this.transformStmt(new ReturnStatement(stmt.value.visitExpression(this, context), stmt.sourceSpan, stmt.leadingComments), context);\r\n    }\r\n    visitDeclareClassStmt(stmt, context) {\r\n        const parent = stmt.parent.visitExpression(this, context);\r\n        const getters = stmt.getters.map(getter => new ClassGetter(getter.name, this.visitAllStatements(getter.body, context), getter.type, getter.modifiers));\r\n        const ctorMethod = stmt.constructorMethod &&\r\n            new ClassMethod(stmt.constructorMethod.name, stmt.constructorMethod.params, this.visitAllStatements(stmt.constructorMethod.body, context), stmt.constructorMethod.type, stmt.constructorMethod.modifiers);\r\n        const methods = stmt.methods.map(method => new ClassMethod(method.name, method.params, this.visitAllStatements(method.body, context), method.type, method.modifiers));\r\n        return this.transformStmt(new ClassStmt(stmt.name, parent, stmt.fields, getters, ctorMethod, methods, stmt.modifiers, stmt.sourceSpan), context);\r\n    }\r\n    visitIfStmt(stmt, context) {\r\n        return this.transformStmt(new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan, stmt.leadingComments), context);\r\n    }\r\n    visitTryCatchStmt(stmt, context) {\r\n        return this.transformStmt(new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context), stmt.sourceSpan, stmt.leadingComments), context);\r\n    }\r\n    visitThrowStmt(stmt, context) {\r\n        return this.transformStmt(new ThrowStmt(stmt.error.visitExpression(this, context), stmt.sourceSpan, stmt.leadingComments), context);\r\n    }\r\n    visitAllStatements(stmts, context) {\r\n        return stmts.map(stmt => stmt.visitStatement(this, context));\r\n    }\r\n}\r\nclass RecursiveAstVisitor {\r\n    visitType(ast, context) {\r\n        return ast;\r\n    }\r\n    visitExpression(ast, context) {\r\n        if (ast.type) {\r\n            ast.type.visitType(this, context);\r\n        }\r\n        return ast;\r\n    }\r\n    visitBuiltinType(type, context) {\r\n        return this.visitType(type, context);\r\n    }\r\n    visitExpressionType(type, context) {\r\n        type.value.visitExpression(this, context);\r\n        if (type.typeParams !== null) {\r\n            type.typeParams.forEach(param => this.visitType(param, context));\r\n        }\r\n        return this.visitType(type, context);\r\n    }\r\n    visitArrayType(type, context) {\r\n        return this.visitType(type, context);\r\n    }\r\n    visitMapType(type, context) {\r\n        return this.visitType(type, context);\r\n    }\r\n    visitWrappedNodeExpr(ast, context) {\r\n        return ast;\r\n    }\r\n    visitTypeofExpr(ast, context) {\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitReadVarExpr(ast, context) {\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitWriteVarExpr(ast, context) {\r\n        ast.value.visitExpression(this, context);\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitWriteKeyExpr(ast, context) {\r\n        ast.receiver.visitExpression(this, context);\r\n        ast.index.visitExpression(this, context);\r\n        ast.value.visitExpression(this, context);\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitWritePropExpr(ast, context) {\r\n        ast.receiver.visitExpression(this, context);\r\n        ast.value.visitExpression(this, context);\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitInvokeMethodExpr(ast, context) {\r\n        ast.receiver.visitExpression(this, context);\r\n        this.visitAllExpressions(ast.args, context);\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitInvokeFunctionExpr(ast, context) {\r\n        ast.fn.visitExpression(this, context);\r\n        this.visitAllExpressions(ast.args, context);\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitTaggedTemplateExpr(ast, context) {\r\n        ast.tag.visitExpression(this, context);\r\n        this.visitAllExpressions(ast.template.expressions, context);\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitInstantiateExpr(ast, context) {\r\n        ast.classExpr.visitExpression(this, context);\r\n        this.visitAllExpressions(ast.args, context);\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitLiteralExpr(ast, context) {\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitLocalizedString(ast, context) {\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitExternalExpr(ast, context) {\r\n        if (ast.typeParams) {\r\n            ast.typeParams.forEach(type => type.visitType(this, context));\r\n        }\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitConditionalExpr(ast, context) {\r\n        ast.condition.visitExpression(this, context);\r\n        ast.trueCase.visitExpression(this, context);\r\n        ast.falseCase.visitExpression(this, context);\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitNotExpr(ast, context) {\r\n        ast.condition.visitExpression(this, context);\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitAssertNotNullExpr(ast, context) {\r\n        ast.condition.visitExpression(this, context);\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitCastExpr(ast, context) {\r\n        ast.value.visitExpression(this, context);\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitFunctionExpr(ast, context) {\r\n        this.visitAllStatements(ast.statements, context);\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitUnaryOperatorExpr(ast, context) {\r\n        ast.expr.visitExpression(this, context);\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitBinaryOperatorExpr(ast, context) {\r\n        ast.lhs.visitExpression(this, context);\r\n        ast.rhs.visitExpression(this, context);\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitReadPropExpr(ast, context) {\r\n        ast.receiver.visitExpression(this, context);\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitReadKeyExpr(ast, context) {\r\n        ast.receiver.visitExpression(this, context);\r\n        ast.index.visitExpression(this, context);\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitLiteralArrayExpr(ast, context) {\r\n        this.visitAllExpressions(ast.entries, context);\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitLiteralMapExpr(ast, context) {\r\n        ast.entries.forEach((entry) => entry.value.visitExpression(this, context));\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitCommaExpr(ast, context) {\r\n        this.visitAllExpressions(ast.parts, context);\r\n        return this.visitExpression(ast, context);\r\n    }\r\n    visitAllExpressions(exprs, context) {\r\n        exprs.forEach(expr => expr.visitExpression(this, context));\r\n    }\r\n    visitDeclareVarStmt(stmt, context) {\r\n        if (stmt.value) {\r\n            stmt.value.visitExpression(this, context);\r\n        }\r\n        if (stmt.type) {\r\n            stmt.type.visitType(this, context);\r\n        }\r\n        return stmt;\r\n    }\r\n    visitDeclareFunctionStmt(stmt, context) {\r\n        this.visitAllStatements(stmt.statements, context);\r\n        if (stmt.type) {\r\n            stmt.type.visitType(this, context);\r\n        }\r\n        return stmt;\r\n    }\r\n    visitExpressionStmt(stmt, context) {\r\n        stmt.expr.visitExpression(this, context);\r\n        return stmt;\r\n    }\r\n    visitReturnStmt(stmt, context) {\r\n        stmt.value.visitExpression(this, context);\r\n        return stmt;\r\n    }\r\n    visitDeclareClassStmt(stmt, context) {\r\n        stmt.parent.visitExpression(this, context);\r\n        stmt.getters.forEach(getter => this.visitAllStatements(getter.body, context));\r\n        if (stmt.constructorMethod) {\r\n            this.visitAllStatements(stmt.constructorMethod.body, context);\r\n        }\r\n        stmt.methods.forEach(method => this.visitAllStatements(method.body, context));\r\n        return stmt;\r\n    }\r\n    visitIfStmt(stmt, context) {\r\n        stmt.condition.visitExpression(this, context);\r\n        this.visitAllStatements(stmt.trueCase, context);\r\n        this.visitAllStatements(stmt.falseCase, context);\r\n        return stmt;\r\n    }\r\n    visitTryCatchStmt(stmt, context) {\r\n        this.visitAllStatements(stmt.bodyStmts, context);\r\n        this.visitAllStatements(stmt.catchStmts, context);\r\n        return stmt;\r\n    }\r\n    visitThrowStmt(stmt, context) {\r\n        stmt.error.visitExpression(this, context);\r\n        return stmt;\r\n    }\r\n    visitAllStatements(stmts, context) {\r\n        stmts.forEach(stmt => stmt.visitStatement(this, context));\r\n    }\r\n}\r\nfunction findReadVarNames(stmts) {\r\n    const visitor = new _ReadVarVisitor();\r\n    visitor.visitAllStatements(stmts, null);\r\n    return visitor.varNames;\r\n}\r\nclass _ReadVarVisitor extends RecursiveAstVisitor {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.varNames = new Set();\r\n    }\r\n    visitDeclareFunctionStmt(stmt, context) {\r\n        // Don't descend into nested functions\r\n        return stmt;\r\n    }\r\n    visitDeclareClassStmt(stmt, context) {\r\n        // Don't descend into nested classes\r\n        return stmt;\r\n    }\r\n    visitReadVarExpr(ast, context) {\r\n        if (ast.name) {\r\n            this.varNames.add(ast.name);\r\n        }\r\n        return null;\r\n    }\r\n}\r\nfunction collectExternalReferences(stmts) {\r\n    const visitor = new _FindExternalReferencesVisitor();\r\n    visitor.visitAllStatements(stmts, null);\r\n    return visitor.externalReferences;\r\n}\r\nclass _FindExternalReferencesVisitor extends RecursiveAstVisitor {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.externalReferences = [];\r\n    }\r\n    visitExternalExpr(e, context) {\r\n        this.externalReferences.push(e.value);\r\n        return super.visitExternalExpr(e, context);\r\n    }\r\n}\r\nfunction applySourceSpanToStatementIfNeeded(stmt, sourceSpan) {\r\n    if (!sourceSpan) {\r\n        return stmt;\r\n    }\r\n    const transformer = new _ApplySourceSpanTransformer(sourceSpan);\r\n    return stmt.visitStatement(transformer, null);\r\n}\r\nfunction applySourceSpanToExpressionIfNeeded(expr, sourceSpan) {\r\n    if (!sourceSpan) {\r\n        return expr;\r\n    }\r\n    const transformer = new _ApplySourceSpanTransformer(sourceSpan);\r\n    return expr.visitExpression(transformer, null);\r\n}\r\nclass _ApplySourceSpanTransformer extends AstTransformer {\r\n    constructor(sourceSpan) {\r\n        super();\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    _clone(obj) {\r\n        const clone = Object.create(obj.constructor.prototype);\r\n        for (let prop of Object.keys(obj)) {\r\n            clone[prop] = obj[prop];\r\n        }\r\n        return clone;\r\n    }\r\n    transformExpr(expr, context) {\r\n        if (!expr.sourceSpan) {\r\n            expr = this._clone(expr);\r\n            expr.sourceSpan = this.sourceSpan;\r\n        }\r\n        return expr;\r\n    }\r\n    transformStmt(stmt, context) {\r\n        if (!stmt.sourceSpan) {\r\n            stmt = this._clone(stmt);\r\n            stmt.sourceSpan = this.sourceSpan;\r\n        }\r\n        return stmt;\r\n    }\r\n}\r\nfunction leadingComment(text, multiline = false, trailingNewline = true) {\r\n    return new LeadingComment(text, multiline, trailingNewline);\r\n}\r\nfunction jsDocComment(tags = []) {\r\n    return new JSDocComment(tags);\r\n}\r\nfunction variable(name, type, sourceSpan) {\r\n    return new ReadVarExpr(name, type, sourceSpan);\r\n}\r\nfunction importExpr(id, typeParams = null, sourceSpan) {\r\n    return new ExternalExpr(id, null, typeParams, sourceSpan);\r\n}\r\nfunction importType(id, typeParams, typeModifiers) {\r\n    return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\r\n}\r\nfunction expressionType(expr, typeModifiers, typeParams) {\r\n    return new ExpressionType(expr, typeModifiers, typeParams);\r\n}\r\nfunction typeofExpr(expr) {\r\n    return new TypeofExpr(expr);\r\n}\r\nfunction literalArr(values, type, sourceSpan) {\r\n    return new LiteralArrayExpr(values, type, sourceSpan);\r\n}\r\nfunction literalMap(values, type = null) {\r\n    return new LiteralMapExpr(values.map(e => new LiteralMapEntry(e.key, e.value, e.quoted)), type, null);\r\n}\r\nfunction unary(operator, expr, type, sourceSpan) {\r\n    return new UnaryOperatorExpr(operator, expr, type, sourceSpan);\r\n}\r\nfunction not(expr, sourceSpan) {\r\n    return new NotExpr(expr, sourceSpan);\r\n}\r\nfunction assertNotNull(expr, sourceSpan) {\r\n    return new AssertNotNull(expr, sourceSpan);\r\n}\r\nfunction fn(params, body, type, sourceSpan, name) {\r\n    return new FunctionExpr(params, body, type, sourceSpan, name);\r\n}\r\nfunction ifStmt(condition, thenClause, elseClause, sourceSpan, leadingComments) {\r\n    return new IfStmt(condition, thenClause, elseClause, sourceSpan, leadingComments);\r\n}\r\nfunction taggedTemplate(tag, template, type, sourceSpan) {\r\n    return new TaggedTemplateExpr(tag, template, type, sourceSpan);\r\n}\r\nfunction literal(value, type, sourceSpan) {\r\n    return new LiteralExpr(value, type, sourceSpan);\r\n}\r\nfunction localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {\r\n    return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\r\n}\r\nfunction isNull(exp) {\r\n    return exp instanceof LiteralExpr && exp.value === null;\r\n}\r\n/*\r\n * Serializes a `Tag` into a string.\r\n * Returns a string like \" @foo {bar} baz\" (note the leading whitespace before `@foo`).\r\n */\r\nfunction tagToString(tag) {\r\n    let out = '';\r\n    if (tag.tagName) {\r\n        out += ` @${tag.tagName}`;\r\n    }\r\n    if (tag.text) {\r\n        if (tag.text.match(/\\/\\*|\\*\\//)) {\r\n            throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\r\n        }\r\n        out += ' ' + tag.text.replace(/@/g, '\\\\@');\r\n    }\r\n    return out;\r\n}\r\nfunction serializeTags(tags) {\r\n    if (tags.length === 0)\r\n        return '';\r\n    if (tags.length === 1 && tags[0].tagName && !tags[0].text) {\r\n        // The JSDOC comment is a single simple tag: e.g `/** @tagname */`.\r\n        return `*${tagToString(tags[0])} `;\r\n    }\r\n    let out = '*\\n';\r\n    for (const tag of tags) {\r\n        out += ' *';\r\n        // If the tagToString is multi-line, insert \" * \" prefixes on lines.\r\n        out += tagToString(tag).replace(/\\n/g, '\\n * ');\r\n        out += '\\n';\r\n    }\r\n    out += ' ';\r\n    return out;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst CONSTANT_PREFIX = '_c';\r\n/**\r\n * `ConstantPool` tries to reuse literal factories when two or more literals are identical.\r\n * We determine whether literals are identical by creating a key out of their AST using the\r\n * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely\r\n * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what\r\n * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note\r\n * that we use a variable, rather than something like `null` in order to avoid collisions.\r\n */\r\nconst UNKNOWN_VALUE_KEY = variable('<unknown>');\r\n/**\r\n * Context to use when producing a key.\r\n *\r\n * This ensures we see the constant not the reference variable when producing\r\n * a key.\r\n */\r\nconst KEY_CONTEXT = {};\r\n/**\r\n * Generally all primitive values are excluded from the `ConstantPool`, but there is an exclusion\r\n * for strings that reach a certain length threshold. This constant defines the length threshold for\r\n * strings.\r\n */\r\nconst POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS = 50;\r\n/**\r\n * A node that is a place-holder that allows the node to be replaced when the actual\r\n * node is known.\r\n *\r\n * This allows the constant pool to change an expression from a direct reference to\r\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\r\n * change the referenced expression.\r\n */\r\nclass FixupExpression extends Expression {\r\n    constructor(resolved) {\r\n        super(resolved.type);\r\n        this.resolved = resolved;\r\n        this.original = resolved;\r\n    }\r\n    visitExpression(visitor, context) {\r\n        if (context === KEY_CONTEXT) {\r\n            // When producing a key we want to traverse the constant not the\r\n            // variable used to refer to it.\r\n            return this.original.visitExpression(visitor, context);\r\n        }\r\n        else {\r\n            return this.resolved.visitExpression(visitor, context);\r\n        }\r\n    }\r\n    isEquivalent(e) {\r\n        return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\r\n    }\r\n    isConstant() {\r\n        return true;\r\n    }\r\n    fixup(expression) {\r\n        this.resolved = expression;\r\n        this.shared = true;\r\n    }\r\n}\r\n/**\r\n * A constant pool allows a code emitter to share constant in an output context.\r\n *\r\n * The constant pool also supports sharing access to ivy definitions references.\r\n */\r\nclass ConstantPool {\r\n    constructor(isClosureCompilerEnabled = false) {\r\n        this.isClosureCompilerEnabled = isClosureCompilerEnabled;\r\n        this.statements = [];\r\n        this.literals = new Map();\r\n        this.literalFactories = new Map();\r\n        this.injectorDefinitions = new Map();\r\n        this.directiveDefinitions = new Map();\r\n        this.componentDefinitions = new Map();\r\n        this.pipeDefinitions = new Map();\r\n        this.nextNameIndex = 0;\r\n    }\r\n    getConstLiteral(literal, forceShared) {\r\n        if ((literal instanceof LiteralExpr && !isLongStringLiteral(literal)) ||\r\n            literal instanceof FixupExpression) {\r\n            // Do no put simple literals into the constant pool or try to produce a constant for a\r\n            // reference to a constant.\r\n            return literal;\r\n        }\r\n        const key = this.keyOf(literal);\r\n        let fixup = this.literals.get(key);\r\n        let newValue = false;\r\n        if (!fixup) {\r\n            fixup = new FixupExpression(literal);\r\n            this.literals.set(key, fixup);\r\n            newValue = true;\r\n        }\r\n        if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\r\n            // Replace the expression with a variable\r\n            const name = this.freshName();\r\n            let definition;\r\n            let usage;\r\n            if (this.isClosureCompilerEnabled && isLongStringLiteral(literal)) {\r\n                // For string literals, Closure will **always** inline the string at\r\n                // **all** usages, duplicating it each time. For large strings, this\r\n                // unnecessarily bloats bundle size. To work around this restriction, we\r\n                // wrap the string in a function, and call that function for each usage.\r\n                // This tricks Closure into using inline logic for functions instead of\r\n                // string literals. Function calls are only inlined if the body is small\r\n                // enough to be worth it. By doing this, very large strings will be\r\n                // shared across multiple usages, rather than duplicating the string at\r\n                // each usage site.\r\n                //\r\n                // const myStr = function() { return \"very very very long string\"; };\r\n                // const usage1 = myStr();\r\n                // const usage2 = myStr();\r\n                definition = variable(name).set(new FunctionExpr([], // Params.\r\n                [\r\n                    // Statements.\r\n                    new ReturnStatement(literal),\r\n                ]));\r\n                usage = variable(name).callFn([]);\r\n            }\r\n            else {\r\n                // Just declare and use the variable directly, without a function call\r\n                // indirection. This saves a few bytes and avoids an unncessary call.\r\n                definition = variable(name).set(literal);\r\n                usage = variable(name);\r\n            }\r\n            this.statements.push(definition.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));\r\n            fixup.fixup(usage);\r\n        }\r\n        return fixup;\r\n    }\r\n    getDefinition(type, kind, ctx, forceShared = false) {\r\n        const definitions = this.definitionsOf(kind);\r\n        let fixup = definitions.get(type);\r\n        let newValue = false;\r\n        if (!fixup) {\r\n            const property = this.propertyNameOf(kind);\r\n            fixup = new FixupExpression(ctx.importExpr(type).prop(property));\r\n            definitions.set(type, fixup);\r\n            newValue = true;\r\n        }\r\n        if ((!newValue && !fixup.shared) || (newValue && forceShared)) {\r\n            const name = this.freshName();\r\n            this.statements.push(variable(name).set(fixup.resolved).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));\r\n            fixup.fixup(variable(name));\r\n        }\r\n        return fixup;\r\n    }\r\n    getLiteralFactory(literal) {\r\n        // Create a pure function that builds an array of a mix of constant and variable expressions\r\n        if (literal instanceof LiteralArrayExpr) {\r\n            const argumentsForKey = literal.entries.map(e => e.isConstant() ? e : UNKNOWN_VALUE_KEY);\r\n            const key = this.keyOf(literalArr(argumentsForKey));\r\n            return this._getLiteralFactory(key, literal.entries, entries => literalArr(entries));\r\n        }\r\n        else {\r\n            const expressionForKey = literalMap(literal.entries.map(e => ({\r\n                key: e.key,\r\n                value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,\r\n                quoted: e.quoted\r\n            })));\r\n            const key = this.keyOf(expressionForKey);\r\n            return this._getLiteralFactory(key, literal.entries.map(e => e.value), entries => literalMap(entries.map((value, index) => ({\r\n                key: literal.entries[index].key,\r\n                value,\r\n                quoted: literal.entries[index].quoted\r\n            }))));\r\n        }\r\n    }\r\n    _getLiteralFactory(key, values, resultMap) {\r\n        let literalFactory = this.literalFactories.get(key);\r\n        const literalFactoryArguments = values.filter((e => !e.isConstant()));\r\n        if (!literalFactory) {\r\n            const resultExpressions = values.map((e, index) => e.isConstant() ? this.getConstLiteral(e, true) : variable(`a${index}`));\r\n            const parameters = resultExpressions.filter(isVariable).map(e => new FnParam(e.name, DYNAMIC_TYPE));\r\n            const pureFunctionDeclaration = fn(parameters, [new ReturnStatement(resultMap(resultExpressions))], INFERRED_TYPE);\r\n            const name = this.freshName();\r\n            this.statements.push(variable(name).set(pureFunctionDeclaration).toDeclStmt(INFERRED_TYPE, [\r\n                StmtModifier.Final\r\n            ]));\r\n            literalFactory = variable(name);\r\n            this.literalFactories.set(key, literalFactory);\r\n        }\r\n        return { literalFactory, literalFactoryArguments };\r\n    }\r\n    /**\r\n     * Produce a unique name.\r\n     *\r\n     * The name might be unique among different prefixes if any of the prefixes end in\r\n     * a digit so the prefix should be a constant string (not based on user input) and\r\n     * must not end in a digit.\r\n     */\r\n    uniqueName(prefix) {\r\n        return `${prefix}${this.nextNameIndex++}`;\r\n    }\r\n    definitionsOf(kind) {\r\n        switch (kind) {\r\n            case 2 /* Component */:\r\n                return this.componentDefinitions;\r\n            case 1 /* Directive */:\r\n                return this.directiveDefinitions;\r\n            case 0 /* Injector */:\r\n                return this.injectorDefinitions;\r\n            case 3 /* Pipe */:\r\n                return this.pipeDefinitions;\r\n        }\r\n    }\r\n    propertyNameOf(kind) {\r\n        switch (kind) {\r\n            case 2 /* Component */:\r\n                return 'ɵcmp';\r\n            case 1 /* Directive */:\r\n                return 'ɵdir';\r\n            case 0 /* Injector */:\r\n                return 'ɵinj';\r\n            case 3 /* Pipe */:\r\n                return 'ɵpipe';\r\n        }\r\n    }\r\n    freshName() {\r\n        return this.uniqueName(CONSTANT_PREFIX);\r\n    }\r\n    keyOf(expression) {\r\n        return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\r\n    }\r\n}\r\n/**\r\n * Visitor used to determine if 2 expressions are equivalent and can be shared in the\r\n * `ConstantPool`.\r\n *\r\n * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\r\n */\r\nclass KeyVisitor {\r\n    constructor() {\r\n        this.visitWrappedNodeExpr = invalid;\r\n        this.visitWriteVarExpr = invalid;\r\n        this.visitWriteKeyExpr = invalid;\r\n        this.visitWritePropExpr = invalid;\r\n        this.visitInvokeMethodExpr = invalid;\r\n        this.visitInvokeFunctionExpr = invalid;\r\n        this.visitTaggedTemplateExpr = invalid;\r\n        this.visitInstantiateExpr = invalid;\r\n        this.visitConditionalExpr = invalid;\r\n        this.visitNotExpr = invalid;\r\n        this.visitAssertNotNullExpr = invalid;\r\n        this.visitCastExpr = invalid;\r\n        this.visitFunctionExpr = invalid;\r\n        this.visitUnaryOperatorExpr = invalid;\r\n        this.visitBinaryOperatorExpr = invalid;\r\n        this.visitReadPropExpr = invalid;\r\n        this.visitReadKeyExpr = invalid;\r\n        this.visitCommaExpr = invalid;\r\n        this.visitLocalizedString = invalid;\r\n    }\r\n    visitLiteralExpr(ast) {\r\n        return `${typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value}`;\r\n    }\r\n    visitLiteralArrayExpr(ast, context) {\r\n        return `[${ast.entries.map(entry => entry.visitExpression(this, context)).join(',')}]`;\r\n    }\r\n    visitLiteralMapExpr(ast, context) {\r\n        const mapKey = (entry) => {\r\n            const quote = entry.quoted ? '\"' : '';\r\n            return `${quote}${entry.key}${quote}`;\r\n        };\r\n        const mapEntry = (entry) => `${mapKey(entry)}:${entry.value.visitExpression(this, context)}`;\r\n        return `{${ast.entries.map(mapEntry).join(',')}`;\r\n    }\r\n    visitExternalExpr(ast) {\r\n        return ast.value.moduleName ? `EX:${ast.value.moduleName}:${ast.value.name}` :\r\n            `EX:${ast.value.runtime.name}`;\r\n    }\r\n    visitReadVarExpr(node) {\r\n        return `VAR:${node.name}`;\r\n    }\r\n    visitTypeofExpr(node, context) {\r\n        return `TYPEOF:${node.expr.visitExpression(this, context)}`;\r\n    }\r\n}\r\nfunction invalid(arg) {\r\n    throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\r\n}\r\nfunction isVariable(e) {\r\n    return e instanceof ReadVarExpr;\r\n}\r\nfunction isLongStringLiteral(expr) {\r\n    return expr instanceof LiteralExpr && typeof expr.value === 'string' &&\r\n        expr.value.length >= POOL_INCLUSION_LENGTH_THRESHOLD_FOR_STRINGS;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst CORE = '@angular/core';\r\nclass Identifiers {\r\n}\r\n/* Methods */\r\nIdentifiers.NEW_METHOD = 'factory';\r\nIdentifiers.TRANSFORM_METHOD = 'transform';\r\nIdentifiers.PATCH_DEPS = 'patchedDeps';\r\nIdentifiers.core = { name: null, moduleName: CORE };\r\n/* Instructions */\r\nIdentifiers.namespaceHTML = { name: 'ɵɵnamespaceHTML', moduleName: CORE };\r\nIdentifiers.namespaceMathML = { name: 'ɵɵnamespaceMathML', moduleName: CORE };\r\nIdentifiers.namespaceSVG = { name: 'ɵɵnamespaceSVG', moduleName: CORE };\r\nIdentifiers.element = { name: 'ɵɵelement', moduleName: CORE };\r\nIdentifiers.elementStart = { name: 'ɵɵelementStart', moduleName: CORE };\r\nIdentifiers.elementEnd = { name: 'ɵɵelementEnd', moduleName: CORE };\r\nIdentifiers.advance = { name: 'ɵɵadvance', moduleName: CORE };\r\nIdentifiers.syntheticHostProperty = { name: 'ɵɵsyntheticHostProperty', moduleName: CORE };\r\nIdentifiers.syntheticHostListener = { name: 'ɵɵsyntheticHostListener', moduleName: CORE };\r\nIdentifiers.attribute = { name: 'ɵɵattribute', moduleName: CORE };\r\nIdentifiers.attributeInterpolate1 = { name: 'ɵɵattributeInterpolate1', moduleName: CORE };\r\nIdentifiers.attributeInterpolate2 = { name: 'ɵɵattributeInterpolate2', moduleName: CORE };\r\nIdentifiers.attributeInterpolate3 = { name: 'ɵɵattributeInterpolate3', moduleName: CORE };\r\nIdentifiers.attributeInterpolate4 = { name: 'ɵɵattributeInterpolate4', moduleName: CORE };\r\nIdentifiers.attributeInterpolate5 = { name: 'ɵɵattributeInterpolate5', moduleName: CORE };\r\nIdentifiers.attributeInterpolate6 = { name: 'ɵɵattributeInterpolate6', moduleName: CORE };\r\nIdentifiers.attributeInterpolate7 = { name: 'ɵɵattributeInterpolate7', moduleName: CORE };\r\nIdentifiers.attributeInterpolate8 = { name: 'ɵɵattributeInterpolate8', moduleName: CORE };\r\nIdentifiers.attributeInterpolateV = { name: 'ɵɵattributeInterpolateV', moduleName: CORE };\r\nIdentifiers.classProp = { name: 'ɵɵclassProp', moduleName: CORE };\r\nIdentifiers.elementContainerStart = { name: 'ɵɵelementContainerStart', moduleName: CORE };\r\nIdentifiers.elementContainerEnd = { name: 'ɵɵelementContainerEnd', moduleName: CORE };\r\nIdentifiers.elementContainer = { name: 'ɵɵelementContainer', moduleName: CORE };\r\nIdentifiers.styleMap = { name: 'ɵɵstyleMap', moduleName: CORE };\r\nIdentifiers.styleMapInterpolate1 = { name: 'ɵɵstyleMapInterpolate1', moduleName: CORE };\r\nIdentifiers.styleMapInterpolate2 = { name: 'ɵɵstyleMapInterpolate2', moduleName: CORE };\r\nIdentifiers.styleMapInterpolate3 = { name: 'ɵɵstyleMapInterpolate3', moduleName: CORE };\r\nIdentifiers.styleMapInterpolate4 = { name: 'ɵɵstyleMapInterpolate4', moduleName: CORE };\r\nIdentifiers.styleMapInterpolate5 = { name: 'ɵɵstyleMapInterpolate5', moduleName: CORE };\r\nIdentifiers.styleMapInterpolate6 = { name: 'ɵɵstyleMapInterpolate6', moduleName: CORE };\r\nIdentifiers.styleMapInterpolate7 = { name: 'ɵɵstyleMapInterpolate7', moduleName: CORE };\r\nIdentifiers.styleMapInterpolate8 = { name: 'ɵɵstyleMapInterpolate8', moduleName: CORE };\r\nIdentifiers.styleMapInterpolateV = { name: 'ɵɵstyleMapInterpolateV', moduleName: CORE };\r\nIdentifiers.classMap = { name: 'ɵɵclassMap', moduleName: CORE };\r\nIdentifiers.classMapInterpolate1 = { name: 'ɵɵclassMapInterpolate1', moduleName: CORE };\r\nIdentifiers.classMapInterpolate2 = { name: 'ɵɵclassMapInterpolate2', moduleName: CORE };\r\nIdentifiers.classMapInterpolate3 = { name: 'ɵɵclassMapInterpolate3', moduleName: CORE };\r\nIdentifiers.classMapInterpolate4 = { name: 'ɵɵclassMapInterpolate4', moduleName: CORE };\r\nIdentifiers.classMapInterpolate5 = { name: 'ɵɵclassMapInterpolate5', moduleName: CORE };\r\nIdentifiers.classMapInterpolate6 = { name: 'ɵɵclassMapInterpolate6', moduleName: CORE };\r\nIdentifiers.classMapInterpolate7 = { name: 'ɵɵclassMapInterpolate7', moduleName: CORE };\r\nIdentifiers.classMapInterpolate8 = { name: 'ɵɵclassMapInterpolate8', moduleName: CORE };\r\nIdentifiers.classMapInterpolateV = { name: 'ɵɵclassMapInterpolateV', moduleName: CORE };\r\nIdentifiers.styleProp = { name: 'ɵɵstyleProp', moduleName: CORE };\r\nIdentifiers.stylePropInterpolate1 = { name: 'ɵɵstylePropInterpolate1', moduleName: CORE };\r\nIdentifiers.stylePropInterpolate2 = { name: 'ɵɵstylePropInterpolate2', moduleName: CORE };\r\nIdentifiers.stylePropInterpolate3 = { name: 'ɵɵstylePropInterpolate3', moduleName: CORE };\r\nIdentifiers.stylePropInterpolate4 = { name: 'ɵɵstylePropInterpolate4', moduleName: CORE };\r\nIdentifiers.stylePropInterpolate5 = { name: 'ɵɵstylePropInterpolate5', moduleName: CORE };\r\nIdentifiers.stylePropInterpolate6 = { name: 'ɵɵstylePropInterpolate6', moduleName: CORE };\r\nIdentifiers.stylePropInterpolate7 = { name: 'ɵɵstylePropInterpolate7', moduleName: CORE };\r\nIdentifiers.stylePropInterpolate8 = { name: 'ɵɵstylePropInterpolate8', moduleName: CORE };\r\nIdentifiers.stylePropInterpolateV = { name: 'ɵɵstylePropInterpolateV', moduleName: CORE };\r\nIdentifiers.nextContext = { name: 'ɵɵnextContext', moduleName: CORE };\r\nIdentifiers.templateCreate = { name: 'ɵɵtemplate', moduleName: CORE };\r\nIdentifiers.text = { name: 'ɵɵtext', moduleName: CORE };\r\nIdentifiers.enableBindings = { name: 'ɵɵenableBindings', moduleName: CORE };\r\nIdentifiers.disableBindings = { name: 'ɵɵdisableBindings', moduleName: CORE };\r\nIdentifiers.getCurrentView = { name: 'ɵɵgetCurrentView', moduleName: CORE };\r\nIdentifiers.textInterpolate = { name: 'ɵɵtextInterpolate', moduleName: CORE };\r\nIdentifiers.textInterpolate1 = { name: 'ɵɵtextInterpolate1', moduleName: CORE };\r\nIdentifiers.textInterpolate2 = { name: 'ɵɵtextInterpolate2', moduleName: CORE };\r\nIdentifiers.textInterpolate3 = { name: 'ɵɵtextInterpolate3', moduleName: CORE };\r\nIdentifiers.textInterpolate4 = { name: 'ɵɵtextInterpolate4', moduleName: CORE };\r\nIdentifiers.textInterpolate5 = { name: 'ɵɵtextInterpolate5', moduleName: CORE };\r\nIdentifiers.textInterpolate6 = { name: 'ɵɵtextInterpolate6', moduleName: CORE };\r\nIdentifiers.textInterpolate7 = { name: 'ɵɵtextInterpolate7', moduleName: CORE };\r\nIdentifiers.textInterpolate8 = { name: 'ɵɵtextInterpolate8', moduleName: CORE };\r\nIdentifiers.textInterpolateV = { name: 'ɵɵtextInterpolateV', moduleName: CORE };\r\nIdentifiers.restoreView = { name: 'ɵɵrestoreView', moduleName: CORE };\r\nIdentifiers.pureFunction0 = { name: 'ɵɵpureFunction0', moduleName: CORE };\r\nIdentifiers.pureFunction1 = { name: 'ɵɵpureFunction1', moduleName: CORE };\r\nIdentifiers.pureFunction2 = { name: 'ɵɵpureFunction2', moduleName: CORE };\r\nIdentifiers.pureFunction3 = { name: 'ɵɵpureFunction3', moduleName: CORE };\r\nIdentifiers.pureFunction4 = { name: 'ɵɵpureFunction4', moduleName: CORE };\r\nIdentifiers.pureFunction5 = { name: 'ɵɵpureFunction5', moduleName: CORE };\r\nIdentifiers.pureFunction6 = { name: 'ɵɵpureFunction6', moduleName: CORE };\r\nIdentifiers.pureFunction7 = { name: 'ɵɵpureFunction7', moduleName: CORE };\r\nIdentifiers.pureFunction8 = { name: 'ɵɵpureFunction8', moduleName: CORE };\r\nIdentifiers.pureFunctionV = { name: 'ɵɵpureFunctionV', moduleName: CORE };\r\nIdentifiers.pipeBind1 = { name: 'ɵɵpipeBind1', moduleName: CORE };\r\nIdentifiers.pipeBind2 = { name: 'ɵɵpipeBind2', moduleName: CORE };\r\nIdentifiers.pipeBind3 = { name: 'ɵɵpipeBind3', moduleName: CORE };\r\nIdentifiers.pipeBind4 = { name: 'ɵɵpipeBind4', moduleName: CORE };\r\nIdentifiers.pipeBindV = { name: 'ɵɵpipeBindV', moduleName: CORE };\r\nIdentifiers.hostProperty = { name: 'ɵɵhostProperty', moduleName: CORE };\r\nIdentifiers.property = { name: 'ɵɵproperty', moduleName: CORE };\r\nIdentifiers.propertyInterpolate = { name: 'ɵɵpropertyInterpolate', moduleName: CORE };\r\nIdentifiers.propertyInterpolate1 = { name: 'ɵɵpropertyInterpolate1', moduleName: CORE };\r\nIdentifiers.propertyInterpolate2 = { name: 'ɵɵpropertyInterpolate2', moduleName: CORE };\r\nIdentifiers.propertyInterpolate3 = { name: 'ɵɵpropertyInterpolate3', moduleName: CORE };\r\nIdentifiers.propertyInterpolate4 = { name: 'ɵɵpropertyInterpolate4', moduleName: CORE };\r\nIdentifiers.propertyInterpolate5 = { name: 'ɵɵpropertyInterpolate5', moduleName: CORE };\r\nIdentifiers.propertyInterpolate6 = { name: 'ɵɵpropertyInterpolate6', moduleName: CORE };\r\nIdentifiers.propertyInterpolate7 = { name: 'ɵɵpropertyInterpolate7', moduleName: CORE };\r\nIdentifiers.propertyInterpolate8 = { name: 'ɵɵpropertyInterpolate8', moduleName: CORE };\r\nIdentifiers.propertyInterpolateV = { name: 'ɵɵpropertyInterpolateV', moduleName: CORE };\r\nIdentifiers.i18n = { name: 'ɵɵi18n', moduleName: CORE };\r\nIdentifiers.i18nAttributes = { name: 'ɵɵi18nAttributes', moduleName: CORE };\r\nIdentifiers.i18nExp = { name: 'ɵɵi18nExp', moduleName: CORE };\r\nIdentifiers.i18nStart = { name: 'ɵɵi18nStart', moduleName: CORE };\r\nIdentifiers.i18nEnd = { name: 'ɵɵi18nEnd', moduleName: CORE };\r\nIdentifiers.i18nApply = { name: 'ɵɵi18nApply', moduleName: CORE };\r\nIdentifiers.i18nPostprocess = { name: 'ɵɵi18nPostprocess', moduleName: CORE };\r\nIdentifiers.pipe = { name: 'ɵɵpipe', moduleName: CORE };\r\nIdentifiers.projection = { name: 'ɵɵprojection', moduleName: CORE };\r\nIdentifiers.projectionDef = { name: 'ɵɵprojectionDef', moduleName: CORE };\r\nIdentifiers.reference = { name: 'ɵɵreference', moduleName: CORE };\r\nIdentifiers.inject = { name: 'ɵɵinject', moduleName: CORE };\r\nIdentifiers.injectAttribute = { name: 'ɵɵinjectAttribute', moduleName: CORE };\r\nIdentifiers.directiveInject = { name: 'ɵɵdirectiveInject', moduleName: CORE };\r\nIdentifiers.invalidFactory = { name: 'ɵɵinvalidFactory', moduleName: CORE };\r\nIdentifiers.invalidFactoryDep = { name: 'ɵɵinvalidFactoryDep', moduleName: CORE };\r\nIdentifiers.templateRefExtractor = { name: 'ɵɵtemplateRefExtractor', moduleName: CORE };\r\nIdentifiers.forwardRef = { name: 'forwardRef', moduleName: CORE };\r\nIdentifiers.resolveForwardRef = { name: 'resolveForwardRef', moduleName: CORE };\r\nIdentifiers.ɵɵdefineInjectable = { name: 'ɵɵdefineInjectable', moduleName: CORE };\r\nIdentifiers.declareInjectable = { name: 'ɵɵngDeclareInjectable', moduleName: CORE };\r\nIdentifiers.InjectableDeclaration = { name: 'ɵɵInjectableDeclaration', moduleName: CORE };\r\nIdentifiers.resolveWindow = { name: 'ɵɵresolveWindow', moduleName: CORE };\r\nIdentifiers.resolveDocument = { name: 'ɵɵresolveDocument', moduleName: CORE };\r\nIdentifiers.resolveBody = { name: 'ɵɵresolveBody', moduleName: CORE };\r\nIdentifiers.defineComponent = { name: 'ɵɵdefineComponent', moduleName: CORE };\r\nIdentifiers.declareComponent = { name: 'ɵɵngDeclareComponent', moduleName: CORE };\r\nIdentifiers.setComponentScope = { name: 'ɵɵsetComponentScope', moduleName: CORE };\r\nIdentifiers.ChangeDetectionStrategy = {\r\n    name: 'ChangeDetectionStrategy',\r\n    moduleName: CORE,\r\n};\r\nIdentifiers.ViewEncapsulation = {\r\n    name: 'ViewEncapsulation',\r\n    moduleName: CORE,\r\n};\r\nIdentifiers.ComponentDeclaration = {\r\n    name: 'ɵɵComponentDeclaration',\r\n    moduleName: CORE,\r\n};\r\nIdentifiers.FactoryDeclaration = {\r\n    name: 'ɵɵFactoryDeclaration',\r\n    moduleName: CORE,\r\n};\r\nIdentifiers.declareFactory = { name: 'ɵɵngDeclareFactory', moduleName: CORE };\r\nIdentifiers.FactoryTarget = { name: 'ɵɵFactoryTarget', moduleName: CORE };\r\nIdentifiers.defineDirective = { name: 'ɵɵdefineDirective', moduleName: CORE };\r\nIdentifiers.declareDirective = { name: 'ɵɵngDeclareDirective', moduleName: CORE };\r\nIdentifiers.DirectiveDeclaration = {\r\n    name: 'ɵɵDirectiveDeclaration',\r\n    moduleName: CORE,\r\n};\r\nIdentifiers.InjectorDef = { name: 'ɵɵInjectorDef', moduleName: CORE };\r\nIdentifiers.InjectorDeclaration = { name: 'ɵɵInjectorDeclaration', moduleName: CORE };\r\nIdentifiers.defineInjector = { name: 'ɵɵdefineInjector', moduleName: CORE };\r\nIdentifiers.declareInjector = { name: 'ɵɵngDeclareInjector', moduleName: CORE };\r\nIdentifiers.NgModuleDeclaration = {\r\n    name: 'ɵɵNgModuleDeclaration',\r\n    moduleName: CORE,\r\n};\r\nIdentifiers.ModuleWithProviders = {\r\n    name: 'ModuleWithProviders',\r\n    moduleName: CORE,\r\n};\r\nIdentifiers.defineNgModule = { name: 'ɵɵdefineNgModule', moduleName: CORE };\r\nIdentifiers.declareNgModule = { name: 'ɵɵngDeclareNgModule', moduleName: CORE };\r\nIdentifiers.setNgModuleScope = { name: 'ɵɵsetNgModuleScope', moduleName: CORE };\r\nIdentifiers.PipeDeclaration = { name: 'ɵɵPipeDeclaration', moduleName: CORE };\r\nIdentifiers.definePipe = { name: 'ɵɵdefinePipe', moduleName: CORE };\r\nIdentifiers.declarePipe = { name: 'ɵɵngDeclarePipe', moduleName: CORE };\r\nIdentifiers.declareClassMetadata = { name: 'ɵɵngDeclareClassMetadata', moduleName: CORE };\r\nIdentifiers.setClassMetadata = { name: 'ɵsetClassMetadata', moduleName: CORE };\r\nIdentifiers.queryRefresh = { name: 'ɵɵqueryRefresh', moduleName: CORE };\r\nIdentifiers.viewQuery = { name: 'ɵɵviewQuery', moduleName: CORE };\r\nIdentifiers.loadQuery = { name: 'ɵɵloadQuery', moduleName: CORE };\r\nIdentifiers.contentQuery = { name: 'ɵɵcontentQuery', moduleName: CORE };\r\nIdentifiers.NgOnChangesFeature = { name: 'ɵɵNgOnChangesFeature', moduleName: CORE };\r\nIdentifiers.InheritDefinitionFeature = { name: 'ɵɵInheritDefinitionFeature', moduleName: CORE };\r\nIdentifiers.CopyDefinitionFeature = { name: 'ɵɵCopyDefinitionFeature', moduleName: CORE };\r\nIdentifiers.ProvidersFeature = { name: 'ɵɵProvidersFeature', moduleName: CORE };\r\nIdentifiers.listener = { name: 'ɵɵlistener', moduleName: CORE };\r\nIdentifiers.getInheritedFactory = {\r\n    name: 'ɵɵgetInheritedFactory',\r\n    moduleName: CORE,\r\n};\r\n// sanitization-related functions\r\nIdentifiers.sanitizeHtml = { name: 'ɵɵsanitizeHtml', moduleName: CORE };\r\nIdentifiers.sanitizeStyle = { name: 'ɵɵsanitizeStyle', moduleName: CORE };\r\nIdentifiers.sanitizeResourceUrl = { name: 'ɵɵsanitizeResourceUrl', moduleName: CORE };\r\nIdentifiers.sanitizeScript = { name: 'ɵɵsanitizeScript', moduleName: CORE };\r\nIdentifiers.sanitizeUrl = { name: 'ɵɵsanitizeUrl', moduleName: CORE };\r\nIdentifiers.sanitizeUrlOrResourceUrl = { name: 'ɵɵsanitizeUrlOrResourceUrl', moduleName: CORE };\r\nIdentifiers.trustConstantHtml = { name: 'ɵɵtrustConstantHtml', moduleName: CORE };\r\nIdentifiers.trustConstantResourceUrl = { name: 'ɵɵtrustConstantResourceUrl', moduleName: CORE };\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst DASH_CASE_REGEXP = /-+([a-z0-9])/g;\r\nfunction dashCaseToCamelCase(input) {\r\n    return input.replace(DASH_CASE_REGEXP, (...m) => m[1].toUpperCase());\r\n}\r\nfunction splitAtColon(input, defaultValues) {\r\n    return _splitAt(input, ':', defaultValues);\r\n}\r\nfunction splitAtPeriod(input, defaultValues) {\r\n    return _splitAt(input, '.', defaultValues);\r\n}\r\nfunction _splitAt(input, character, defaultValues) {\r\n    const characterIndex = input.indexOf(character);\r\n    if (characterIndex == -1)\r\n        return defaultValues;\r\n    return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\r\n}\r\nfunction visitValue(value, visitor, context) {\r\n    if (Array.isArray(value)) {\r\n        return visitor.visitArray(value, context);\r\n    }\r\n    if (isStrictStringMap(value)) {\r\n        return visitor.visitStringMap(value, context);\r\n    }\r\n    if (value == null || typeof value == 'string' || typeof value == 'number' ||\r\n        typeof value == 'boolean') {\r\n        return visitor.visitPrimitive(value, context);\r\n    }\r\n    return visitor.visitOther(value, context);\r\n}\r\nfunction isDefined(val) {\r\n    return val !== null && val !== undefined;\r\n}\r\nfunction noUndefined(val) {\r\n    return val === undefined ? null : val;\r\n}\r\nclass ValueTransformer {\r\n    visitArray(arr, context) {\r\n        return arr.map(value => visitValue(value, this, context));\r\n    }\r\n    visitStringMap(map, context) {\r\n        const result = {};\r\n        Object.keys(map).forEach(key => {\r\n            result[key] = visitValue(map[key], this, context);\r\n        });\r\n        return result;\r\n    }\r\n    visitPrimitive(value, context) {\r\n        return value;\r\n    }\r\n    visitOther(value, context) {\r\n        return value;\r\n    }\r\n}\r\nconst SyncAsync = {\r\n    assertSync: (value) => {\r\n        if (isPromise(value)) {\r\n            throw new Error(`Illegal state: value cannot be a promise`);\r\n        }\r\n        return value;\r\n    },\r\n    then: (value, cb) => {\r\n        return isPromise(value) ? value.then(cb) : cb(value);\r\n    },\r\n    all: (syncAsyncValues) => {\r\n        return syncAsyncValues.some(isPromise) ? Promise.all(syncAsyncValues) : syncAsyncValues;\r\n    }\r\n};\r\nfunction error(msg) {\r\n    throw new Error(`Internal Error: ${msg}`);\r\n}\r\nfunction syntaxError(msg, parseErrors) {\r\n    const error = Error(msg);\r\n    error[ERROR_SYNTAX_ERROR] = true;\r\n    if (parseErrors)\r\n        error[ERROR_PARSE_ERRORS] = parseErrors;\r\n    return error;\r\n}\r\nconst ERROR_SYNTAX_ERROR = 'ngSyntaxError';\r\nconst ERROR_PARSE_ERRORS = 'ngParseErrors';\r\nfunction isSyntaxError(error) {\r\n    return error[ERROR_SYNTAX_ERROR];\r\n}\r\nfunction getParseErrors(error) {\r\n    return error[ERROR_PARSE_ERRORS] || [];\r\n}\r\n// Escape characters that have a special meaning in Regular Expressions\r\nfunction escapeRegExp(s) {\r\n    return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\r\n}\r\nconst STRING_MAP_PROTO = Object.getPrototypeOf({});\r\nfunction isStrictStringMap(obj) {\r\n    return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\r\n}\r\nfunction utf8Encode(str) {\r\n    let encoded = [];\r\n    for (let index = 0; index < str.length; index++) {\r\n        let codePoint = str.charCodeAt(index);\r\n        // decode surrogate\r\n        // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\r\n        if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {\r\n            const low = str.charCodeAt(index + 1);\r\n            if (low >= 0xdc00 && low <= 0xdfff) {\r\n                index++;\r\n                codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\r\n            }\r\n        }\r\n        if (codePoint <= 0x7f) {\r\n            encoded.push(codePoint);\r\n        }\r\n        else if (codePoint <= 0x7ff) {\r\n            encoded.push(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\r\n        }\r\n        else if (codePoint <= 0xffff) {\r\n            encoded.push((codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\r\n        }\r\n        else if (codePoint <= 0x1fffff) {\r\n            encoded.push(((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\r\n        }\r\n    }\r\n    return encoded;\r\n}\r\nfunction stringify(token) {\r\n    if (typeof token === 'string') {\r\n        return token;\r\n    }\r\n    if (Array.isArray(token)) {\r\n        return '[' + token.map(stringify).join(', ') + ']';\r\n    }\r\n    if (token == null) {\r\n        return '' + token;\r\n    }\r\n    if (token.overriddenName) {\r\n        return `${token.overriddenName}`;\r\n    }\r\n    if (token.name) {\r\n        return `${token.name}`;\r\n    }\r\n    if (!token.toString) {\r\n        return 'object';\r\n    }\r\n    // WARNING: do not try to `JSON.stringify(token)` here\r\n    // see https://github.com/angular/angular/issues/23440\r\n    const res = token.toString();\r\n    if (res == null) {\r\n        return '' + res;\r\n    }\r\n    const newLineIndex = res.indexOf('\\n');\r\n    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\r\n}\r\n/**\r\n * Lazily retrieves the reference value from a forwardRef.\r\n */\r\nfunction resolveForwardRef(type) {\r\n    if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__')) {\r\n        return type();\r\n    }\r\n    else {\r\n        return type;\r\n    }\r\n}\r\n/**\r\n * Determine if the argument is shaped like a Promise\r\n */\r\nfunction isPromise(obj) {\r\n    // allow any Promise/A+ compliant thenable.\r\n    // It's up to the caller to ensure that obj.then conforms to the spec\r\n    return !!obj && typeof obj.then === 'function';\r\n}\r\nclass Version {\r\n    constructor(full) {\r\n        this.full = full;\r\n        const splits = full.split('.');\r\n        this.major = splits[0];\r\n        this.minor = splits[1];\r\n        this.patch = splits.slice(2).join('.');\r\n    }\r\n}\r\nconst __window = typeof window !== 'undefined' && window;\r\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\r\n    self instanceof WorkerGlobalScope && self;\r\nconst __global = typeof global !== 'undefined' && global;\r\n// Check __global first, because in Node tests both __global and __window may be defined and _global\r\n// should be __global in that case.\r\nconst _global = __global || __window || __self;\r\nfunction newArray(size, value) {\r\n    const list = [];\r\n    for (let i = 0; i < size; i++) {\r\n        list.push(value);\r\n    }\r\n    return list;\r\n}\r\n/**\r\n * Partitions a given array into 2 arrays, based on a boolean value returned by the condition\r\n * function.\r\n *\r\n * @param arr Input array that should be partitioned\r\n * @param conditionFn Condition function that is called for each item in a given array and returns a\r\n * boolean value.\r\n */\r\nfunction partitionArray(arr, conditionFn) {\r\n    const truthy = [];\r\n    const falsy = [];\r\n    for (const item of arr) {\r\n        (conditionFn(item) ? truthy : falsy).push(item);\r\n    }\r\n    return [truthy, falsy];\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * This is an R3 `Node`-like wrapper for a raw `html.Comment` node. We do not currently\r\n * require the implementation of a visitor for Comments as they are only collected at\r\n * the top-level of the R3 AST, and only if `Render3ParseOptions['collectCommentNodes']`\r\n * is true.\r\n */\r\nclass Comment {\r\n    constructor(value, sourceSpan) {\r\n        this.value = value;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    visit(_visitor) {\r\n        throw new Error('visit() not implemented for Comment');\r\n    }\r\n}\r\nclass Text {\r\n    constructor(value, sourceSpan) {\r\n        this.value = value;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    visit(visitor) {\r\n        return visitor.visitText(this);\r\n    }\r\n}\r\nclass BoundText {\r\n    constructor(value, sourceSpan, i18n) {\r\n        this.value = value;\r\n        this.sourceSpan = sourceSpan;\r\n        this.i18n = i18n;\r\n    }\r\n    visit(visitor) {\r\n        return visitor.visitBoundText(this);\r\n    }\r\n}\r\n/**\r\n * Represents a text attribute in the template.\r\n *\r\n * `valueSpan` may not be present in cases where there is no value `<div a></div>`.\r\n * `keySpan` may also not be present for synthetic attributes from ICU expansions.\r\n */\r\nclass TextAttribute {\r\n    constructor(name, value, sourceSpan, keySpan, valueSpan, i18n) {\r\n        this.name = name;\r\n        this.value = value;\r\n        this.sourceSpan = sourceSpan;\r\n        this.keySpan = keySpan;\r\n        this.valueSpan = valueSpan;\r\n        this.i18n = i18n;\r\n    }\r\n    visit(visitor) {\r\n        return visitor.visitTextAttribute(this);\r\n    }\r\n}\r\nclass BoundAttribute {\r\n    constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan, i18n) {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.securityContext = securityContext;\r\n        this.value = value;\r\n        this.unit = unit;\r\n        this.sourceSpan = sourceSpan;\r\n        this.keySpan = keySpan;\r\n        this.valueSpan = valueSpan;\r\n        this.i18n = i18n;\r\n    }\r\n    static fromBoundElementProperty(prop, i18n) {\r\n        if (prop.keySpan === undefined) {\r\n            throw new Error(`Unexpected state: keySpan must be defined for bound attributes but was not for ${prop.name}: ${prop.sourceSpan}`);\r\n        }\r\n        return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n);\r\n    }\r\n    visit(visitor) {\r\n        return visitor.visitBoundAttribute(this);\r\n    }\r\n}\r\nclass BoundEvent {\r\n    constructor(name, type, handler, target, phase, sourceSpan, handlerSpan, keySpan) {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.handler = handler;\r\n        this.target = target;\r\n        this.phase = phase;\r\n        this.sourceSpan = sourceSpan;\r\n        this.handlerSpan = handlerSpan;\r\n        this.keySpan = keySpan;\r\n    }\r\n    static fromParsedEvent(event) {\r\n        const target = event.type === 0 /* Regular */ ? event.targetOrPhase : null;\r\n        const phase = event.type === 1 /* Animation */ ? event.targetOrPhase : null;\r\n        if (event.keySpan === undefined) {\r\n            throw new Error(`Unexpected state: keySpan must be defined for bound event but was not for ${event.name}: ${event.sourceSpan}`);\r\n        }\r\n        return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan, event.keySpan);\r\n    }\r\n    visit(visitor) {\r\n        return visitor.visitBoundEvent(this);\r\n    }\r\n}\r\nclass Element {\r\n    constructor(name, attributes, inputs, outputs, children, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\r\n        this.name = name;\r\n        this.attributes = attributes;\r\n        this.inputs = inputs;\r\n        this.outputs = outputs;\r\n        this.children = children;\r\n        this.references = references;\r\n        this.sourceSpan = sourceSpan;\r\n        this.startSourceSpan = startSourceSpan;\r\n        this.endSourceSpan = endSourceSpan;\r\n        this.i18n = i18n;\r\n    }\r\n    visit(visitor) {\r\n        return visitor.visitElement(this);\r\n    }\r\n}\r\nclass Template {\r\n    constructor(tagName, attributes, inputs, outputs, templateAttrs, children, references, variables, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\r\n        this.tagName = tagName;\r\n        this.attributes = attributes;\r\n        this.inputs = inputs;\r\n        this.outputs = outputs;\r\n        this.templateAttrs = templateAttrs;\r\n        this.children = children;\r\n        this.references = references;\r\n        this.variables = variables;\r\n        this.sourceSpan = sourceSpan;\r\n        this.startSourceSpan = startSourceSpan;\r\n        this.endSourceSpan = endSourceSpan;\r\n        this.i18n = i18n;\r\n    }\r\n    visit(visitor) {\r\n        return visitor.visitTemplate(this);\r\n    }\r\n}\r\nclass Content {\r\n    constructor(selector, attributes, sourceSpan, i18n) {\r\n        this.selector = selector;\r\n        this.attributes = attributes;\r\n        this.sourceSpan = sourceSpan;\r\n        this.i18n = i18n;\r\n        this.name = 'ng-content';\r\n    }\r\n    visit(visitor) {\r\n        return visitor.visitContent(this);\r\n    }\r\n}\r\nclass Variable {\r\n    constructor(name, value, sourceSpan, keySpan, valueSpan) {\r\n        this.name = name;\r\n        this.value = value;\r\n        this.sourceSpan = sourceSpan;\r\n        this.keySpan = keySpan;\r\n        this.valueSpan = valueSpan;\r\n    }\r\n    visit(visitor) {\r\n        return visitor.visitVariable(this);\r\n    }\r\n}\r\nclass Reference {\r\n    constructor(name, value, sourceSpan, keySpan, valueSpan) {\r\n        this.name = name;\r\n        this.value = value;\r\n        this.sourceSpan = sourceSpan;\r\n        this.keySpan = keySpan;\r\n        this.valueSpan = valueSpan;\r\n    }\r\n    visit(visitor) {\r\n        return visitor.visitReference(this);\r\n    }\r\n}\r\nclass Icu {\r\n    constructor(vars, placeholders, sourceSpan, i18n) {\r\n        this.vars = vars;\r\n        this.placeholders = placeholders;\r\n        this.sourceSpan = sourceSpan;\r\n        this.i18n = i18n;\r\n    }\r\n    visit(visitor) {\r\n        return visitor.visitIcu(this);\r\n    }\r\n}\r\nclass NullVisitor {\r\n    visitElement(element) { }\r\n    visitTemplate(template) { }\r\n    visitContent(content) { }\r\n    visitVariable(variable) { }\r\n    visitReference(reference) { }\r\n    visitTextAttribute(attribute) { }\r\n    visitBoundAttribute(attribute) { }\r\n    visitBoundEvent(attribute) { }\r\n    visitText(text) { }\r\n    visitBoundText(text) { }\r\n    visitIcu(icu) { }\r\n}\r\nclass RecursiveVisitor {\r\n    visitElement(element) {\r\n        visitAll(this, element.attributes);\r\n        visitAll(this, element.children);\r\n        visitAll(this, element.references);\r\n    }\r\n    visitTemplate(template) {\r\n        visitAll(this, template.attributes);\r\n        visitAll(this, template.children);\r\n        visitAll(this, template.references);\r\n        visitAll(this, template.variables);\r\n    }\r\n    visitContent(content) { }\r\n    visitVariable(variable) { }\r\n    visitReference(reference) { }\r\n    visitTextAttribute(attribute) { }\r\n    visitBoundAttribute(attribute) { }\r\n    visitBoundEvent(attribute) { }\r\n    visitText(text) { }\r\n    visitBoundText(text) { }\r\n    visitIcu(icu) { }\r\n}\r\nclass TransformVisitor {\r\n    visitElement(element) {\r\n        const newAttributes = transformAll(this, element.attributes);\r\n        const newInputs = transformAll(this, element.inputs);\r\n        const newOutputs = transformAll(this, element.outputs);\r\n        const newChildren = transformAll(this, element.children);\r\n        const newReferences = transformAll(this, element.references);\r\n        if (newAttributes != element.attributes || newInputs != element.inputs ||\r\n            newOutputs != element.outputs || newChildren != element.children ||\r\n            newReferences != element.references) {\r\n            return new Element(element.name, newAttributes, newInputs, newOutputs, newChildren, newReferences, element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\r\n        }\r\n        return element;\r\n    }\r\n    visitTemplate(template) {\r\n        const newAttributes = transformAll(this, template.attributes);\r\n        const newInputs = transformAll(this, template.inputs);\r\n        const newOutputs = transformAll(this, template.outputs);\r\n        const newTemplateAttrs = transformAll(this, template.templateAttrs);\r\n        const newChildren = transformAll(this, template.children);\r\n        const newReferences = transformAll(this, template.references);\r\n        const newVariables = transformAll(this, template.variables);\r\n        if (newAttributes != template.attributes || newInputs != template.inputs ||\r\n            newOutputs != template.outputs || newTemplateAttrs != template.templateAttrs ||\r\n            newChildren != template.children || newReferences != template.references ||\r\n            newVariables != template.variables) {\r\n            return new Template(template.tagName, newAttributes, newInputs, newOutputs, newTemplateAttrs, newChildren, newReferences, newVariables, template.sourceSpan, template.startSourceSpan, template.endSourceSpan);\r\n        }\r\n        return template;\r\n    }\r\n    visitContent(content) {\r\n        return content;\r\n    }\r\n    visitVariable(variable) {\r\n        return variable;\r\n    }\r\n    visitReference(reference) {\r\n        return reference;\r\n    }\r\n    visitTextAttribute(attribute) {\r\n        return attribute;\r\n    }\r\n    visitBoundAttribute(attribute) {\r\n        return attribute;\r\n    }\r\n    visitBoundEvent(attribute) {\r\n        return attribute;\r\n    }\r\n    visitText(text) {\r\n        return text;\r\n    }\r\n    visitBoundText(text) {\r\n        return text;\r\n    }\r\n    visitIcu(icu) {\r\n        return icu;\r\n    }\r\n}\r\nfunction visitAll(visitor, nodes) {\r\n    const result = [];\r\n    if (visitor.visit) {\r\n        for (const node of nodes) {\r\n            const newNode = visitor.visit(node) || node.visit(visitor);\r\n        }\r\n    }\r\n    else {\r\n        for (const node of nodes) {\r\n            const newNode = node.visit(visitor);\r\n            if (newNode) {\r\n                result.push(newNode);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction transformAll(visitor, nodes) {\r\n    const result = [];\r\n    let changed = false;\r\n    for (const node of nodes) {\r\n        const newNode = node.visit(visitor);\r\n        if (newNode) {\r\n            result.push(newNode);\r\n        }\r\n        changed = changed || newNode != node;\r\n    }\r\n    return changed ? result : nodes;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass Message {\r\n    /**\r\n     * @param nodes message AST\r\n     * @param placeholders maps placeholder names to static content and their source spans\r\n     * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\r\n     * @param meaning\r\n     * @param description\r\n     * @param customId\r\n     */\r\n    constructor(nodes, placeholders, placeholderToMessage, meaning, description, customId) {\r\n        this.nodes = nodes;\r\n        this.placeholders = placeholders;\r\n        this.placeholderToMessage = placeholderToMessage;\r\n        this.meaning = meaning;\r\n        this.description = description;\r\n        this.customId = customId;\r\n        this.id = this.customId;\r\n        /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */\r\n        this.legacyIds = [];\r\n        if (nodes.length) {\r\n            this.sources = [{\r\n                    filePath: nodes[0].sourceSpan.start.file.url,\r\n                    startLine: nodes[0].sourceSpan.start.line + 1,\r\n                    startCol: nodes[0].sourceSpan.start.col + 1,\r\n                    endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\r\n                    endCol: nodes[0].sourceSpan.start.col + 1\r\n                }];\r\n        }\r\n        else {\r\n            this.sources = [];\r\n        }\r\n    }\r\n}\r\nclass Text$1 {\r\n    constructor(value, sourceSpan) {\r\n        this.value = value;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitText(this, context);\r\n    }\r\n}\r\n// TODO(vicb): do we really need this node (vs an array) ?\r\nclass Container {\r\n    constructor(children, sourceSpan) {\r\n        this.children = children;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitContainer(this, context);\r\n    }\r\n}\r\nclass Icu$1 {\r\n    constructor(expression, type, cases, sourceSpan) {\r\n        this.expression = expression;\r\n        this.type = type;\r\n        this.cases = cases;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitIcu(this, context);\r\n    }\r\n}\r\nclass TagPlaceholder {\r\n    constructor(tag, attrs, startName, closeName, children, isVoid, \r\n    // TODO sourceSpan should cover all (we need a startSourceSpan and endSourceSpan)\r\n    sourceSpan, startSourceSpan, endSourceSpan) {\r\n        this.tag = tag;\r\n        this.attrs = attrs;\r\n        this.startName = startName;\r\n        this.closeName = closeName;\r\n        this.children = children;\r\n        this.isVoid = isVoid;\r\n        this.sourceSpan = sourceSpan;\r\n        this.startSourceSpan = startSourceSpan;\r\n        this.endSourceSpan = endSourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitTagPlaceholder(this, context);\r\n    }\r\n}\r\nclass Placeholder {\r\n    constructor(value, name, sourceSpan) {\r\n        this.value = value;\r\n        this.name = name;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitPlaceholder(this, context);\r\n    }\r\n}\r\nclass IcuPlaceholder {\r\n    constructor(value, name, sourceSpan) {\r\n        this.value = value;\r\n        this.name = name;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitIcuPlaceholder(this, context);\r\n    }\r\n}\r\n// Clone the AST\r\nclass CloneVisitor {\r\n    visitText(text, context) {\r\n        return new Text$1(text.value, text.sourceSpan);\r\n    }\r\n    visitContainer(container, context) {\r\n        const children = container.children.map(n => n.visit(this, context));\r\n        return new Container(children, container.sourceSpan);\r\n    }\r\n    visitIcu(icu, context) {\r\n        const cases = {};\r\n        Object.keys(icu.cases).forEach(key => cases[key] = icu.cases[key].visit(this, context));\r\n        const msg = new Icu$1(icu.expression, icu.type, cases, icu.sourceSpan);\r\n        msg.expressionPlaceholder = icu.expressionPlaceholder;\r\n        return msg;\r\n    }\r\n    visitTagPlaceholder(ph, context) {\r\n        const children = ph.children.map(n => n.visit(this, context));\r\n        return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\r\n    }\r\n    visitPlaceholder(ph, context) {\r\n        return new Placeholder(ph.value, ph.name, ph.sourceSpan);\r\n    }\r\n    visitIcuPlaceholder(ph, context) {\r\n        return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\r\n    }\r\n}\r\n// Visit all the nodes recursively\r\nclass RecurseVisitor {\r\n    visitText(text, context) { }\r\n    visitContainer(container, context) {\r\n        container.children.forEach(child => child.visit(this));\r\n    }\r\n    visitIcu(icu, context) {\r\n        Object.keys(icu.cases).forEach(k => {\r\n            icu.cases[k].visit(this);\r\n        });\r\n    }\r\n    visitTagPlaceholder(ph, context) {\r\n        ph.children.forEach(child => child.visit(this));\r\n    }\r\n    visitPlaceholder(ph, context) { }\r\n    visitIcuPlaceholder(ph, context) { }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Represents a big integer using a buffer of its individual digits, with the least significant\r\n * digit stored at the beginning of the array (little endian).\r\n *\r\n * For performance reasons, each instance is mutable. The addition operation can be done in-place\r\n * to reduce memory pressure of allocation for the digits array.\r\n */\r\nclass BigInteger {\r\n    /**\r\n     * Creates a big integer using its individual digits in little endian storage.\r\n     */\r\n    constructor(digits) {\r\n        this.digits = digits;\r\n    }\r\n    static zero() {\r\n        return new BigInteger([0]);\r\n    }\r\n    static one() {\r\n        return new BigInteger([1]);\r\n    }\r\n    /**\r\n     * Creates a clone of this instance.\r\n     */\r\n    clone() {\r\n        return new BigInteger(this.digits.slice());\r\n    }\r\n    /**\r\n     * Returns a new big integer with the sum of `this` and `other` as its value. This does not mutate\r\n     * `this` but instead returns a new instance, unlike `addToSelf`.\r\n     */\r\n    add(other) {\r\n        const result = this.clone();\r\n        result.addToSelf(other);\r\n        return result;\r\n    }\r\n    /**\r\n     * Adds `other` to the instance itself, thereby mutating its value.\r\n     */\r\n    addToSelf(other) {\r\n        const maxNrOfDigits = Math.max(this.digits.length, other.digits.length);\r\n        let carry = 0;\r\n        for (let i = 0; i < maxNrOfDigits; i++) {\r\n            let digitSum = carry;\r\n            if (i < this.digits.length) {\r\n                digitSum += this.digits[i];\r\n            }\r\n            if (i < other.digits.length) {\r\n                digitSum += other.digits[i];\r\n            }\r\n            if (digitSum >= 10) {\r\n                this.digits[i] = digitSum - 10;\r\n                carry = 1;\r\n            }\r\n            else {\r\n                this.digits[i] = digitSum;\r\n                carry = 0;\r\n            }\r\n        }\r\n        // Apply a remaining carry if needed.\r\n        if (carry > 0) {\r\n            this.digits[maxNrOfDigits] = 1;\r\n        }\r\n    }\r\n    /**\r\n     * Builds the decimal string representation of the big integer. As this is stored in\r\n     * little endian, the digits are concatenated in reverse order.\r\n     */\r\n    toString() {\r\n        let res = '';\r\n        for (let i = this.digits.length - 1; i >= 0; i--) {\r\n            res += this.digits[i];\r\n        }\r\n        return res;\r\n    }\r\n}\r\n/**\r\n * Represents a big integer which is optimized for multiplication operations, as its power-of-twos\r\n * are memoized. See `multiplyBy()` for details on the multiplication algorithm.\r\n */\r\nclass BigIntForMultiplication {\r\n    constructor(value) {\r\n        this.powerOfTwos = [value];\r\n    }\r\n    /**\r\n     * Returns the big integer itself.\r\n     */\r\n    getValue() {\r\n        return this.powerOfTwos[0];\r\n    }\r\n    /**\r\n     * Computes the value for `num * b`, where `num` is a JS number and `b` is a big integer. The\r\n     * value for `b` is represented by a storage model that is optimized for this computation.\r\n     *\r\n     * This operation is implemented in N(log2(num)) by continuous halving of the number, where the\r\n     * least-significant bit (LSB) is tested in each iteration. If the bit is set, the bit's index is\r\n     * used as exponent into the power-of-two multiplication of `b`.\r\n     *\r\n     * As an example, consider the multiplication num=42, b=1337. In binary 42 is 0b00101010 and the\r\n     * algorithm unrolls into the following iterations:\r\n     *\r\n     *  Iteration | num        | LSB  | b * 2^iter | Add? | product\r\n     * -----------|------------|------|------------|------|--------\r\n     *  0         | 0b00101010 | 0    | 1337       | No   | 0\r\n     *  1         | 0b00010101 | 1    | 2674       | Yes  | 2674\r\n     *  2         | 0b00001010 | 0    | 5348       | No   | 2674\r\n     *  3         | 0b00000101 | 1    | 10696      | Yes  | 13370\r\n     *  4         | 0b00000010 | 0    | 21392      | No   | 13370\r\n     *  5         | 0b00000001 | 1    | 42784      | Yes  | 56154\r\n     *  6         | 0b00000000 | 0    | 85568      | No   | 56154\r\n     *\r\n     * The computed product of 56154 is indeed the correct result.\r\n     *\r\n     * The `BigIntForMultiplication` representation for a big integer provides memoized access to the\r\n     * power-of-two values to reduce the workload in computing those values.\r\n     */\r\n    multiplyBy(num) {\r\n        const product = BigInteger.zero();\r\n        this.multiplyByAndAddTo(num, product);\r\n        return product;\r\n    }\r\n    /**\r\n     * See `multiplyBy()` for details. This function allows for the computed product to be added\r\n     * directly to the provided result big integer.\r\n     */\r\n    multiplyByAndAddTo(num, result) {\r\n        for (let exponent = 0; num !== 0; num = num >>> 1, exponent++) {\r\n            if (num & 1) {\r\n                const value = this.getMultipliedByPowerOfTwo(exponent);\r\n                result.addToSelf(value);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Computes and memoizes the big integer value for `this.number * 2^exponent`.\r\n     */\r\n    getMultipliedByPowerOfTwo(exponent) {\r\n        // Compute the powers up until the requested exponent, where each value is computed from its\r\n        // predecessor. This is simple as `this.number * 2^(exponent - 1)` only has to be doubled (i.e.\r\n        // added to itself) to reach `this.number * 2^exponent`.\r\n        for (let i = this.powerOfTwos.length; i <= exponent; i++) {\r\n            const previousPower = this.powerOfTwos[i - 1];\r\n            this.powerOfTwos[i] = previousPower.add(previousPower);\r\n        }\r\n        return this.powerOfTwos[exponent];\r\n    }\r\n}\r\n/**\r\n * Represents an exponentiation operation for the provided base, of which exponents are computed and\r\n * memoized. The results are represented by a `BigIntForMultiplication` which is tailored for\r\n * multiplication operations by memoizing the power-of-twos. This effectively results in a matrix\r\n * representation that is lazily computed upon request.\r\n */\r\nclass BigIntExponentiation {\r\n    constructor(base) {\r\n        this.base = base;\r\n        this.exponents = [new BigIntForMultiplication(BigInteger.one())];\r\n    }\r\n    /**\r\n     * Compute the value for `this.base^exponent`, resulting in a big integer that is optimized for\r\n     * further multiplication operations.\r\n     */\r\n    toThePowerOf(exponent) {\r\n        // Compute the results up until the requested exponent, where every value is computed from its\r\n        // predecessor. This is because `this.base^(exponent - 1)` only has to be multiplied by `base`\r\n        // to reach `this.base^exponent`.\r\n        for (let i = this.exponents.length; i <= exponent; i++) {\r\n            const value = this.exponents[i - 1].multiplyBy(this.base);\r\n            this.exponents[i] = new BigIntForMultiplication(value);\r\n        }\r\n        return this.exponents[exponent];\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Return the message id or compute it using the XLIFF1 digest.\r\n */\r\nfunction digest(message) {\r\n    return message.id || computeDigest(message);\r\n}\r\n/**\r\n * Compute the message id using the XLIFF1 digest.\r\n */\r\nfunction computeDigest(message) {\r\n    return sha1(serializeNodes(message.nodes).join('') + `[${message.meaning}]`);\r\n}\r\n/**\r\n * Return the message id or compute it using the XLIFF2/XMB/$localize digest.\r\n */\r\nfunction decimalDigest(message) {\r\n    return message.id || computeDecimalDigest(message);\r\n}\r\n/**\r\n * Compute the message id using the XLIFF2/XMB/$localize digest.\r\n */\r\nfunction computeDecimalDigest(message) {\r\n    const visitor = new _SerializerIgnoreIcuExpVisitor();\r\n    const parts = message.nodes.map(a => a.visit(visitor, null));\r\n    return computeMsgId(parts.join(''), message.meaning);\r\n}\r\n/**\r\n * Serialize the i18n ast to something xml-like in order to generate an UID.\r\n *\r\n * The visitor is also used in the i18n parser tests\r\n *\r\n * @internal\r\n */\r\nclass _SerializerVisitor {\r\n    visitText(text, context) {\r\n        return text.value;\r\n    }\r\n    visitContainer(container, context) {\r\n        return `[${container.children.map(child => child.visit(this)).join(', ')}]`;\r\n    }\r\n    visitIcu(icu, context) {\r\n        const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);\r\n        return `{${icu.expression}, ${icu.type}, ${strCases.join(', ')}}`;\r\n    }\r\n    visitTagPlaceholder(ph, context) {\r\n        return ph.isVoid ?\r\n            `<ph tag name=\"${ph.startName}\"/>` :\r\n            `<ph tag name=\"${ph.startName}\">${ph.children.map(child => child.visit(this)).join(', ')}</ph name=\"${ph.closeName}\">`;\r\n    }\r\n    visitPlaceholder(ph, context) {\r\n        return ph.value ? `<ph name=\"${ph.name}\">${ph.value}</ph>` : `<ph name=\"${ph.name}\"/>`;\r\n    }\r\n    visitIcuPlaceholder(ph, context) {\r\n        return `<ph icu name=\"${ph.name}\">${ph.value.visit(this)}</ph>`;\r\n    }\r\n}\r\nconst serializerVisitor = new _SerializerVisitor();\r\nfunction serializeNodes(nodes) {\r\n    return nodes.map(a => a.visit(serializerVisitor, null));\r\n}\r\n/**\r\n * Serialize the i18n ast to something xml-like in order to generate an UID.\r\n *\r\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\r\n *\r\n * @internal\r\n */\r\nclass _SerializerIgnoreIcuExpVisitor extends _SerializerVisitor {\r\n    visitIcu(icu, context) {\r\n        let strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);\r\n        // Do not take the expression into account\r\n        return `{${icu.type}, ${strCases.join(', ')}}`;\r\n    }\r\n}\r\n/**\r\n * Compute the SHA1 of the given string\r\n *\r\n * see https://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\r\n *\r\n * WARNING: this function has not been designed not tested with security in mind.\r\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\r\n */\r\nfunction sha1(str) {\r\n    const utf8 = utf8Encode(str);\r\n    const words32 = bytesToWords32(utf8, Endian.Big);\r\n    const len = utf8.length * 8;\r\n    const w = newArray(80);\r\n    let a = 0x67452301, b = 0xefcdab89, c = 0x98badcfe, d = 0x10325476, e = 0xc3d2e1f0;\r\n    words32[len >> 5] |= 0x80 << (24 - len % 32);\r\n    words32[((len + 64 >> 9) << 4) + 15] = len;\r\n    for (let i = 0; i < words32.length; i += 16) {\r\n        const h0 = a, h1 = b, h2 = c, h3 = d, h4 = e;\r\n        for (let j = 0; j < 80; j++) {\r\n            if (j < 16) {\r\n                w[j] = words32[i + j];\r\n            }\r\n            else {\r\n                w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\r\n            }\r\n            const fkVal = fk(j, b, c, d);\r\n            const f = fkVal[0];\r\n            const k = fkVal[1];\r\n            const temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\r\n            e = d;\r\n            d = c;\r\n            c = rol32(b, 30);\r\n            b = a;\r\n            a = temp;\r\n        }\r\n        a = add32(a, h0);\r\n        b = add32(b, h1);\r\n        c = add32(c, h2);\r\n        d = add32(d, h3);\r\n        e = add32(e, h4);\r\n    }\r\n    return bytesToHexString(words32ToByteString([a, b, c, d, e]));\r\n}\r\nfunction fk(index, b, c, d) {\r\n    if (index < 20) {\r\n        return [(b & c) | (~b & d), 0x5a827999];\r\n    }\r\n    if (index < 40) {\r\n        return [b ^ c ^ d, 0x6ed9eba1];\r\n    }\r\n    if (index < 60) {\r\n        return [(b & c) | (b & d) | (c & d), 0x8f1bbcdc];\r\n    }\r\n    return [b ^ c ^ d, 0xca62c1d6];\r\n}\r\n/**\r\n * Compute the fingerprint of the given string\r\n *\r\n * The output is 64 bit number encoded as a decimal string\r\n *\r\n * based on:\r\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\r\n */\r\nfunction fingerprint(str) {\r\n    const utf8 = utf8Encode(str);\r\n    let hi = hash32(utf8, 0);\r\n    let lo = hash32(utf8, 102072);\r\n    if (hi == 0 && (lo == 0 || lo == 1)) {\r\n        hi = hi ^ 0x130f9bef;\r\n        lo = lo ^ -0x6b5f56d8;\r\n    }\r\n    return [hi, lo];\r\n}\r\nfunction computeMsgId(msg, meaning = '') {\r\n    let msgFingerprint = fingerprint(msg);\r\n    if (meaning) {\r\n        const meaningFingerprint = fingerprint(meaning);\r\n        msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);\r\n    }\r\n    const hi = msgFingerprint[0];\r\n    const lo = msgFingerprint[1];\r\n    return wordsToDecimalString(hi & 0x7fffffff, lo);\r\n}\r\nfunction hash32(bytes, c) {\r\n    let a = 0x9e3779b9, b = 0x9e3779b9;\r\n    let i;\r\n    const len = bytes.length;\r\n    for (i = 0; i + 12 <= len; i += 12) {\r\n        a = add32(a, wordAt(bytes, i, Endian.Little));\r\n        b = add32(b, wordAt(bytes, i + 4, Endian.Little));\r\n        c = add32(c, wordAt(bytes, i + 8, Endian.Little));\r\n        const res = mix(a, b, c);\r\n        a = res[0], b = res[1], c = res[2];\r\n    }\r\n    a = add32(a, wordAt(bytes, i, Endian.Little));\r\n    b = add32(b, wordAt(bytes, i + 4, Endian.Little));\r\n    // the first byte of c is reserved for the length\r\n    c = add32(c, len);\r\n    c = add32(c, wordAt(bytes, i + 8, Endian.Little) << 8);\r\n    return mix(a, b, c)[2];\r\n}\r\n// clang-format off\r\nfunction mix(a, b, c) {\r\n    a = sub32(a, b);\r\n    a = sub32(a, c);\r\n    a ^= c >>> 13;\r\n    b = sub32(b, c);\r\n    b = sub32(b, a);\r\n    b ^= a << 8;\r\n    c = sub32(c, a);\r\n    c = sub32(c, b);\r\n    c ^= b >>> 13;\r\n    a = sub32(a, b);\r\n    a = sub32(a, c);\r\n    a ^= c >>> 12;\r\n    b = sub32(b, c);\r\n    b = sub32(b, a);\r\n    b ^= a << 16;\r\n    c = sub32(c, a);\r\n    c = sub32(c, b);\r\n    c ^= b >>> 5;\r\n    a = sub32(a, b);\r\n    a = sub32(a, c);\r\n    a ^= c >>> 3;\r\n    b = sub32(b, c);\r\n    b = sub32(b, a);\r\n    b ^= a << 10;\r\n    c = sub32(c, a);\r\n    c = sub32(c, b);\r\n    c ^= b >>> 15;\r\n    return [a, b, c];\r\n}\r\n// clang-format on\r\n// Utils\r\nvar Endian;\r\n(function (Endian) {\r\n    Endian[Endian[\"Little\"] = 0] = \"Little\";\r\n    Endian[Endian[\"Big\"] = 1] = \"Big\";\r\n})(Endian || (Endian = {}));\r\nfunction add32(a, b) {\r\n    return add32to64(a, b)[1];\r\n}\r\nfunction add32to64(a, b) {\r\n    const low = (a & 0xffff) + (b & 0xffff);\r\n    const high = (a >>> 16) + (b >>> 16) + (low >>> 16);\r\n    return [high >>> 16, (high << 16) | (low & 0xffff)];\r\n}\r\nfunction add64(a, b) {\r\n    const ah = a[0], al = a[1];\r\n    const bh = b[0], bl = b[1];\r\n    const result = add32to64(al, bl);\r\n    const carry = result[0];\r\n    const l = result[1];\r\n    const h = add32(add32(ah, bh), carry);\r\n    return [h, l];\r\n}\r\nfunction sub32(a, b) {\r\n    const low = (a & 0xffff) - (b & 0xffff);\r\n    const high = (a >> 16) - (b >> 16) + (low >> 16);\r\n    return (high << 16) | (low & 0xffff);\r\n}\r\n// Rotate a 32b number left `count` position\r\nfunction rol32(a, count) {\r\n    return (a << count) | (a >>> (32 - count));\r\n}\r\n// Rotate a 64b number left `count` position\r\nfunction rol64(num, count) {\r\n    const hi = num[0], lo = num[1];\r\n    const h = (hi << count) | (lo >>> (32 - count));\r\n    const l = (lo << count) | (hi >>> (32 - count));\r\n    return [h, l];\r\n}\r\nfunction bytesToWords32(bytes, endian) {\r\n    const size = (bytes.length + 3) >>> 2;\r\n    const words32 = [];\r\n    for (let i = 0; i < size; i++) {\r\n        words32[i] = wordAt(bytes, i * 4, endian);\r\n    }\r\n    return words32;\r\n}\r\nfunction byteAt(bytes, index) {\r\n    return index >= bytes.length ? 0 : bytes[index];\r\n}\r\nfunction wordAt(bytes, index, endian) {\r\n    let word = 0;\r\n    if (endian === Endian.Big) {\r\n        for (let i = 0; i < 4; i++) {\r\n            word += byteAt(bytes, index + i) << (24 - 8 * i);\r\n        }\r\n    }\r\n    else {\r\n        for (let i = 0; i < 4; i++) {\r\n            word += byteAt(bytes, index + i) << 8 * i;\r\n        }\r\n    }\r\n    return word;\r\n}\r\nfunction words32ToByteString(words32) {\r\n    return words32.reduce((bytes, word) => bytes.concat(word32ToByteString(word)), []);\r\n}\r\nfunction word32ToByteString(word) {\r\n    let bytes = [];\r\n    for (let i = 0; i < 4; i++) {\r\n        bytes.push((word >>> 8 * (3 - i)) & 0xff);\r\n    }\r\n    return bytes;\r\n}\r\nfunction bytesToHexString(bytes) {\r\n    let hex = '';\r\n    for (let i = 0; i < bytes.length; i++) {\r\n        const b = byteAt(bytes, i);\r\n        hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\r\n    }\r\n    return hex.toLowerCase();\r\n}\r\n/**\r\n * Create a shared exponentiation pool for base-256 computations. This shared pool provides memoized\r\n * power-of-256 results with memoized power-of-two computations for efficient multiplication.\r\n *\r\n * For our purposes, this can be safely stored as a global without memory concerns. The reason is\r\n * that we encode two words, so only need the 0th (for the low word) and 4th (for the high word)\r\n * exponent.\r\n */\r\nconst base256 = new BigIntExponentiation(256);\r\n/**\r\n * Represents two 32-bit words as a single decimal number. This requires a big integer storage\r\n * model as JS numbers are not accurate enough to represent the 64-bit number.\r\n *\r\n * Based on https://www.danvk.org/hex2dec.html\r\n */\r\nfunction wordsToDecimalString(hi, lo) {\r\n    // Encode the four bytes in lo in the lower digits of the decimal number.\r\n    // Note: the multiplication results in lo itself but represented by a big integer using its\r\n    // decimal digits.\r\n    const decimal = base256.toThePowerOf(0).multiplyBy(lo);\r\n    // Encode the four bytes in hi above the four lo bytes. lo is a maximum of (2^8)^4, which is why\r\n    // this multiplication factor is applied.\r\n    base256.toThePowerOf(4).multiplyByAndAddTo(hi, decimal);\r\n    return decimal.toString();\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass Serializer {\r\n    // Creates a name mapper, see `PlaceholderMapper`\r\n    // Returning `null` means that no name mapping is used.\r\n    createNameMapper(message) {\r\n        return null;\r\n    }\r\n}\r\n/**\r\n * A simple mapper that take a function to transform an internal name to a public name\r\n */\r\nclass SimplePlaceholderMapper extends RecurseVisitor {\r\n    // create a mapping from the message\r\n    constructor(message, mapName) {\r\n        super();\r\n        this.mapName = mapName;\r\n        this.internalToPublic = {};\r\n        this.publicToNextId = {};\r\n        this.publicToInternal = {};\r\n        message.nodes.forEach(node => node.visit(this));\r\n    }\r\n    toPublicName(internalName) {\r\n        return this.internalToPublic.hasOwnProperty(internalName) ?\r\n            this.internalToPublic[internalName] :\r\n            null;\r\n    }\r\n    toInternalName(publicName) {\r\n        return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] :\r\n            null;\r\n    }\r\n    visitText(text, context) {\r\n        return null;\r\n    }\r\n    visitTagPlaceholder(ph, context) {\r\n        this.visitPlaceholderName(ph.startName);\r\n        super.visitTagPlaceholder(ph, context);\r\n        this.visitPlaceholderName(ph.closeName);\r\n    }\r\n    visitPlaceholder(ph, context) {\r\n        this.visitPlaceholderName(ph.name);\r\n    }\r\n    visitIcuPlaceholder(ph, context) {\r\n        this.visitPlaceholderName(ph.name);\r\n    }\r\n    // XMB placeholders could only contains A-Z, 0-9 and _\r\n    visitPlaceholderName(internalName) {\r\n        if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\r\n            return;\r\n        }\r\n        let publicName = this.mapName(internalName);\r\n        if (this.publicToInternal.hasOwnProperty(publicName)) {\r\n            // Create a new XMB when it has already been used\r\n            const nextId = this.publicToNextId[publicName];\r\n            this.publicToNextId[publicName] = nextId + 1;\r\n            publicName = `${publicName}_${nextId}`;\r\n        }\r\n        else {\r\n            this.publicToNextId[publicName] = 1;\r\n        }\r\n        this.internalToPublic[internalName] = publicName;\r\n        this.publicToInternal[publicName] = internalName;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass _Visitor {\r\n    visitTag(tag) {\r\n        const strAttrs = this._serializeAttributes(tag.attrs);\r\n        if (tag.children.length == 0) {\r\n            return `<${tag.name}${strAttrs}/>`;\r\n        }\r\n        const strChildren = tag.children.map(node => node.visit(this));\r\n        return `<${tag.name}${strAttrs}>${strChildren.join('')}</${tag.name}>`;\r\n    }\r\n    visitText(text) {\r\n        return text.value;\r\n    }\r\n    visitDeclaration(decl) {\r\n        return `<?xml${this._serializeAttributes(decl.attrs)} ?>`;\r\n    }\r\n    _serializeAttributes(attrs) {\r\n        const strAttrs = Object.keys(attrs).map((name) => `${name}=\"${attrs[name]}\"`).join(' ');\r\n        return strAttrs.length > 0 ? ' ' + strAttrs : '';\r\n    }\r\n    visitDoctype(doctype) {\r\n        return `<!DOCTYPE ${doctype.rootTag} [\\n${doctype.dtd}\\n]>`;\r\n    }\r\n}\r\nconst _visitor = new _Visitor();\r\nfunction serialize(nodes) {\r\n    return nodes.map((node) => node.visit(_visitor)).join('');\r\n}\r\nclass Declaration {\r\n    constructor(unescapedAttrs) {\r\n        this.attrs = {};\r\n        Object.keys(unescapedAttrs).forEach((k) => {\r\n            this.attrs[k] = escapeXml(unescapedAttrs[k]);\r\n        });\r\n    }\r\n    visit(visitor) {\r\n        return visitor.visitDeclaration(this);\r\n    }\r\n}\r\nclass Doctype {\r\n    constructor(rootTag, dtd) {\r\n        this.rootTag = rootTag;\r\n        this.dtd = dtd;\r\n    }\r\n    visit(visitor) {\r\n        return visitor.visitDoctype(this);\r\n    }\r\n}\r\nclass Tag {\r\n    constructor(name, unescapedAttrs = {}, children = []) {\r\n        this.name = name;\r\n        this.children = children;\r\n        this.attrs = {};\r\n        Object.keys(unescapedAttrs).forEach((k) => {\r\n            this.attrs[k] = escapeXml(unescapedAttrs[k]);\r\n        });\r\n    }\r\n    visit(visitor) {\r\n        return visitor.visitTag(this);\r\n    }\r\n}\r\nclass Text$2 {\r\n    constructor(unescapedValue) {\r\n        this.value = escapeXml(unescapedValue);\r\n    }\r\n    visit(visitor) {\r\n        return visitor.visitText(this);\r\n    }\r\n}\r\nclass CR extends Text$2 {\r\n    constructor(ws = 0) {\r\n        super(`\\n${new Array(ws + 1).join(' ')}`);\r\n    }\r\n}\r\nconst _ESCAPED_CHARS = [\r\n    [/&/g, '&amp;'],\r\n    [/\"/g, '&quot;'],\r\n    [/'/g, '&apos;'],\r\n    [/</g, '&lt;'],\r\n    [/>/g, '&gt;'],\r\n];\r\n// Escape `_ESCAPED_CHARS` characters in the given text with encoded entities\r\nfunction escapeXml(text) {\r\n    return _ESCAPED_CHARS.reduce((text, entry) => text.replace(entry[0], entry[1]), text);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst _MESSAGES_TAG = 'messagebundle';\r\nconst _MESSAGE_TAG = 'msg';\r\nconst _PLACEHOLDER_TAG = 'ph';\r\nconst _EXAMPLE_TAG = 'ex';\r\nconst _SOURCE_TAG = 'source';\r\nconst _DOCTYPE = `<!ELEMENT messagebundle (msg)*>\r\n<!ATTLIST messagebundle class CDATA #IMPLIED>\r\n\r\n<!ELEMENT msg (#PCDATA|ph|source)*>\r\n<!ATTLIST msg id CDATA #IMPLIED>\r\n<!ATTLIST msg seq CDATA #IMPLIED>\r\n<!ATTLIST msg name CDATA #IMPLIED>\r\n<!ATTLIST msg desc CDATA #IMPLIED>\r\n<!ATTLIST msg meaning CDATA #IMPLIED>\r\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\r\n<!ATTLIST msg xml:space (default|preserve) \"default\">\r\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\r\n\r\n<!ELEMENT source (#PCDATA)>\r\n\r\n<!ELEMENT ph (#PCDATA|ex)*>\r\n<!ATTLIST ph name CDATA #REQUIRED>\r\n\r\n<!ELEMENT ex (#PCDATA)>`;\r\nclass Xmb extends Serializer {\r\n    write(messages, locale) {\r\n        const exampleVisitor = new ExampleVisitor();\r\n        const visitor = new _Visitor$1();\r\n        let rootNode = new Tag(_MESSAGES_TAG);\r\n        messages.forEach(message => {\r\n            const attrs = { id: message.id };\r\n            if (message.description) {\r\n                attrs['desc'] = message.description;\r\n            }\r\n            if (message.meaning) {\r\n                attrs['meaning'] = message.meaning;\r\n            }\r\n            let sourceTags = [];\r\n            message.sources.forEach((source) => {\r\n                sourceTags.push(new Tag(_SOURCE_TAG, {}, [new Text$2(`${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)]));\r\n            });\r\n            rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, [...sourceTags, ...visitor.serialize(message.nodes)]));\r\n        });\r\n        rootNode.children.push(new CR());\r\n        return serialize([\r\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }),\r\n            new CR(),\r\n            new Doctype(_MESSAGES_TAG, _DOCTYPE),\r\n            new CR(),\r\n            exampleVisitor.addDefaultExamples(rootNode),\r\n            new CR(),\r\n        ]);\r\n    }\r\n    load(content, url) {\r\n        throw new Error('Unsupported');\r\n    }\r\n    digest(message) {\r\n        return digest$1(message);\r\n    }\r\n    createNameMapper(message) {\r\n        return new SimplePlaceholderMapper(message, toPublicName);\r\n    }\r\n}\r\nclass _Visitor$1 {\r\n    visitText(text, context) {\r\n        return [new Text$2(text.value)];\r\n    }\r\n    visitContainer(container, context) {\r\n        const nodes = [];\r\n        container.children.forEach((node) => nodes.push(...node.visit(this)));\r\n        return nodes;\r\n    }\r\n    visitIcu(icu, context) {\r\n        const nodes = [new Text$2(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\r\n        Object.keys(icu.cases).forEach((c) => {\r\n            nodes.push(new Text$2(`${c} {`), ...icu.cases[c].visit(this), new Text$2(`} `));\r\n        });\r\n        nodes.push(new Text$2(`}`));\r\n        return nodes;\r\n    }\r\n    visitTagPlaceholder(ph, context) {\r\n        const startTagAsText = new Text$2(`<${ph.tag}>`);\r\n        const startEx = new Tag(_EXAMPLE_TAG, {}, [startTagAsText]);\r\n        // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\r\n        const startTagPh = new Tag(_PLACEHOLDER_TAG, { name: ph.startName }, [startEx, startTagAsText]);\r\n        if (ph.isVoid) {\r\n            // void tags have no children nor closing tags\r\n            return [startTagPh];\r\n        }\r\n        const closeTagAsText = new Text$2(`</${ph.tag}>`);\r\n        const closeEx = new Tag(_EXAMPLE_TAG, {}, [closeTagAsText]);\r\n        // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\r\n        const closeTagPh = new Tag(_PLACEHOLDER_TAG, { name: ph.closeName }, [closeEx, closeTagAsText]);\r\n        return [startTagPh, ...this.serialize(ph.children), closeTagPh];\r\n    }\r\n    visitPlaceholder(ph, context) {\r\n        const interpolationAsText = new Text$2(`{{${ph.value}}}`);\r\n        // Example tag needs to be not-empty for TC.\r\n        const exTag = new Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);\r\n        return [\r\n            // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\r\n            new Tag(_PLACEHOLDER_TAG, { name: ph.name }, [exTag, interpolationAsText])\r\n        ];\r\n    }\r\n    visitIcuPlaceholder(ph, context) {\r\n        const icuExpression = ph.value.expression;\r\n        const icuType = ph.value.type;\r\n        const icuCases = Object.keys(ph.value.cases).map((value) => value + ' {...}').join(' ');\r\n        const icuAsText = new Text$2(`{${icuExpression}, ${icuType}, ${icuCases}}`);\r\n        const exTag = new Tag(_EXAMPLE_TAG, {}, [icuAsText]);\r\n        return [\r\n            // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\r\n            new Tag(_PLACEHOLDER_TAG, { name: ph.name }, [exTag, icuAsText])\r\n        ];\r\n    }\r\n    serialize(nodes) {\r\n        return [].concat(...nodes.map(node => node.visit(this)));\r\n    }\r\n}\r\nfunction digest$1(message) {\r\n    return decimalDigest(message);\r\n}\r\n// TC requires at least one non-empty example on placeholders\r\nclass ExampleVisitor {\r\n    addDefaultExamples(node) {\r\n        node.visit(this);\r\n        return node;\r\n    }\r\n    visitTag(tag) {\r\n        if (tag.name === _PLACEHOLDER_TAG) {\r\n            if (!tag.children || tag.children.length == 0) {\r\n                const exText = new Text$2(tag.attrs['name'] || '...');\r\n                tag.children = [new Tag(_EXAMPLE_TAG, {}, [exText])];\r\n            }\r\n        }\r\n        else if (tag.children) {\r\n            tag.children.forEach(node => node.visit(this));\r\n        }\r\n    }\r\n    visitText(text) { }\r\n    visitDeclaration(decl) { }\r\n    visitDoctype(doctype) { }\r\n}\r\n// XMB/XTB placeholders can only contain A-Z, 0-9 and _\r\nfunction toPublicName(internalName) {\r\n    return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */\r\nconst CLOSURE_TRANSLATION_VAR_PREFIX = 'MSG_';\r\n/**\r\n * Prefix for non-`goog.getMsg` i18n-related vars.\r\n * Note: the prefix uses lowercase characters intentionally due to a Closure behavior that\r\n * considers variables like `I18N_0` as constants and throws an error when their value changes.\r\n */\r\nconst TRANSLATION_VAR_PREFIX = 'i18n_';\r\n/** Name of the i18n attributes **/\r\nconst I18N_ATTR = 'i18n';\r\nconst I18N_ATTR_PREFIX = 'i18n-';\r\n/** Prefix of var expressions used in ICUs */\r\nconst I18N_ICU_VAR_PREFIX = 'VAR_';\r\n/** Prefix of ICU expressions for post processing */\r\nconst I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\r\n/** Placeholder wrapper for i18n expressions **/\r\nconst I18N_PLACEHOLDER_SYMBOL = '�';\r\nfunction isI18nAttribute(name) {\r\n    return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\r\n}\r\nfunction isI18nRootNode(meta) {\r\n    return meta instanceof Message;\r\n}\r\nfunction isSingleI18nIcu(meta) {\r\n    return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu$1;\r\n}\r\nfunction hasI18nMeta(node) {\r\n    return !!node.i18n;\r\n}\r\nfunction hasI18nAttrs(element) {\r\n    return element.attrs.some((attr) => isI18nAttribute(attr.name));\r\n}\r\nfunction icuFromI18nMessage(message) {\r\n    return message.nodes[0];\r\n}\r\nfunction wrapI18nPlaceholder(content, contextId = 0) {\r\n    const blockId = contextId > 0 ? `:${contextId}` : '';\r\n    return `${I18N_PLACEHOLDER_SYMBOL}${content}${blockId}${I18N_PLACEHOLDER_SYMBOL}`;\r\n}\r\nfunction assembleI18nBoundString(strings, bindingStartIndex = 0, contextId = 0) {\r\n    if (!strings.length)\r\n        return '';\r\n    let acc = '';\r\n    const lastIdx = strings.length - 1;\r\n    for (let i = 0; i < lastIdx; i++) {\r\n        acc += `${strings[i]}${wrapI18nPlaceholder(bindingStartIndex + i, contextId)}`;\r\n    }\r\n    acc += strings[lastIdx];\r\n    return acc;\r\n}\r\nfunction getSeqNumberGenerator(startsAt = 0) {\r\n    let current = startsAt;\r\n    return () => current++;\r\n}\r\nfunction placeholdersToParams(placeholders) {\r\n    const params = {};\r\n    placeholders.forEach((values, key) => {\r\n        params[key] = literal(values.length > 1 ? `[${values.join('|')}]` : values[0]);\r\n    });\r\n    return params;\r\n}\r\nfunction updatePlaceholderMap(map, name, ...values) {\r\n    const current = map.get(name) || [];\r\n    current.push(...values);\r\n    map.set(name, current);\r\n}\r\nfunction assembleBoundTextPlaceholders(meta, bindingStartIndex = 0, contextId = 0) {\r\n    const startIdx = bindingStartIndex;\r\n    const placeholders = new Map();\r\n    const node = meta instanceof Message ? meta.nodes.find(node => node instanceof Container) : meta;\r\n    if (node) {\r\n        node\r\n            .children\r\n            .filter((child) => child instanceof Placeholder)\r\n            .forEach((child, idx) => {\r\n            const content = wrapI18nPlaceholder(startIdx + idx, contextId);\r\n            updatePlaceholderMap(placeholders, child.name, content);\r\n        });\r\n    }\r\n    return placeholders;\r\n}\r\n/**\r\n * Format the placeholder names in a map of placeholders to expressions.\r\n *\r\n * The placeholder names are converted from \"internal\" format (e.g. `START_TAG_DIV_1`) to \"external\"\r\n * format (e.g. `startTagDiv_1`).\r\n *\r\n * @param params A map of placeholder names to expressions.\r\n * @param useCamelCase whether to camelCase the placeholder name when formatting.\r\n * @returns A new map of formatted placeholder names to expressions.\r\n */\r\nfunction i18nFormatPlaceholderNames(params = {}, useCamelCase) {\r\n    const _params = {};\r\n    if (params && Object.keys(params).length) {\r\n        Object.keys(params).forEach(key => _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key]);\r\n    }\r\n    return _params;\r\n}\r\n/**\r\n * Converts internal placeholder names to public-facing format\r\n * (for example to use in goog.getMsg call).\r\n * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.\r\n *\r\n * @param name The placeholder name that should be formatted\r\n * @returns Formatted placeholder name\r\n */\r\nfunction formatI18nPlaceholderName(name, useCamelCase = true) {\r\n    const publicName = toPublicName(name);\r\n    if (!useCamelCase) {\r\n        return publicName;\r\n    }\r\n    const chunks = publicName.split('_');\r\n    if (chunks.length === 1) {\r\n        // if no \"_\" found - just lowercase the value\r\n        return name.toLowerCase();\r\n    }\r\n    let postfix;\r\n    // eject last element if it's a number\r\n    if (/^\\d+$/.test(chunks[chunks.length - 1])) {\r\n        postfix = chunks.pop();\r\n    }\r\n    let raw = chunks.shift().toLowerCase();\r\n    if (chunks.length) {\r\n        raw += chunks.map(c => c.charAt(0).toUpperCase() + c.slice(1).toLowerCase()).join('');\r\n    }\r\n    return postfix ? `${raw}_${postfix}` : raw;\r\n}\r\n/**\r\n * Generates a prefix for translation const name.\r\n *\r\n * @param extra Additional local prefix that should be injected into translation var name\r\n * @returns Complete translation const prefix\r\n */\r\nfunction getTranslationConstPrefix(extra) {\r\n    return `${CLOSURE_TRANSLATION_VAR_PREFIX}${extra}`.toUpperCase();\r\n}\r\n/**\r\n * Generate AST to declare a variable. E.g. `var I18N_1;`.\r\n * @param variable the name of the variable to declare.\r\n */\r\nfunction declareI18nVariable(variable) {\r\n    return new DeclareVarStmt(variable.name, undefined, INFERRED_TYPE, undefined, variable.sourceSpan);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in\r\n * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may\r\n * bot work in some cases when object keys are mangled by minifier.\r\n *\r\n * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with\r\n * inputs that contain potentially unsafe chars.\r\n */\r\nconst UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\r\n/** Name of the temporary to use during data binding */\r\nconst TEMPORARY_NAME = '_t';\r\n/** Name of the context parameter passed into a template function */\r\nconst CONTEXT_NAME = 'ctx';\r\n/** Name of the RenderFlag passed into a template function */\r\nconst RENDER_FLAGS = 'rf';\r\n/** The prefix reference variables */\r\nconst REFERENCE_PREFIX = '_r';\r\n/** The name of the implicit context reference */\r\nconst IMPLICIT_REFERENCE = '$implicit';\r\n/** Non bindable attribute name **/\r\nconst NON_BINDABLE_ATTR = 'ngNonBindable';\r\n/** Name for the variable keeping track of the context returned by `ɵɵrestoreView`. */\r\nconst RESTORED_VIEW_CONTEXT_NAME = 'restoredCtx';\r\n/**\r\n * Creates an allocator for a temporary variable.\r\n *\r\n * A variable declaration is added to the statements the first time the allocator is invoked.\r\n */\r\nfunction temporaryAllocator(statements, name) {\r\n    let temp = null;\r\n    return () => {\r\n        if (!temp) {\r\n            statements.push(new DeclareVarStmt(TEMPORARY_NAME, undefined, DYNAMIC_TYPE));\r\n            temp = variable(name);\r\n        }\r\n        return temp;\r\n    };\r\n}\r\nfunction unsupported(feature) {\r\n    if (this) {\r\n        throw new Error(`Builder ${this.constructor.name} doesn't support ${feature} yet`);\r\n    }\r\n    throw new Error(`Feature ${feature} is not supported yet`);\r\n}\r\nfunction invalid$1(arg) {\r\n    throw new Error(`Invalid state: Visitor ${this.constructor.name} doesn't handle ${arg.constructor.name}`);\r\n}\r\nfunction asLiteral(value) {\r\n    if (Array.isArray(value)) {\r\n        return literalArr(value.map(asLiteral));\r\n    }\r\n    return literal(value, INFERRED_TYPE);\r\n}\r\nfunction conditionallyCreateMapObjectLiteral(keys, keepDeclared) {\r\n    if (Object.getOwnPropertyNames(keys).length > 0) {\r\n        return mapToExpression(keys, keepDeclared);\r\n    }\r\n    return null;\r\n}\r\nfunction mapToExpression(map, keepDeclared) {\r\n    return literalMap(Object.getOwnPropertyNames(map).map(key => {\r\n        // canonical syntax: `dirProp: publicProp`\r\n        // if there is no `:`, use dirProp = elProp\r\n        const value = map[key];\r\n        let declaredName;\r\n        let publicName;\r\n        let minifiedName;\r\n        let needsDeclaredName;\r\n        if (Array.isArray(value)) {\r\n            [publicName, declaredName] = value;\r\n            minifiedName = key;\r\n            needsDeclaredName = publicName !== declaredName;\r\n        }\r\n        else {\r\n            [declaredName, publicName] = splitAtColon(key, [key, value]);\r\n            minifiedName = declaredName;\r\n            // Only include the declared name if extracted from the key, i.e. the key contains a colon.\r\n            // Otherwise the declared name should be omitted even if it is different from the public name,\r\n            // as it may have already been minified.\r\n            needsDeclaredName = publicName !== declaredName && key.includes(':');\r\n        }\r\n        return {\r\n            key: minifiedName,\r\n            // put quotes around keys that contain potentially unsafe characters\r\n            quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\r\n            value: (keepDeclared && needsDeclaredName) ?\r\n                literalArr([asLiteral(publicName), asLiteral(declaredName)]) :\r\n                asLiteral(publicName)\r\n        };\r\n    }));\r\n}\r\n/**\r\n *  Remove trailing null nodes as they are implied.\r\n */\r\nfunction trimTrailingNulls(parameters) {\r\n    while (isNull(parameters[parameters.length - 1])) {\r\n        parameters.pop();\r\n    }\r\n    return parameters;\r\n}\r\nfunction getQueryPredicate(query, constantPool) {\r\n    if (Array.isArray(query.predicate)) {\r\n        let predicate = [];\r\n        query.predicate.forEach((selector) => {\r\n            // Each item in predicates array may contain strings with comma-separated refs\r\n            // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them\r\n            // as separate array entities\r\n            const selectors = selector.split(',').map(token => literal(token.trim()));\r\n            predicate.push(...selectors);\r\n        });\r\n        return constantPool.getConstLiteral(literalArr(predicate), true);\r\n    }\r\n    else {\r\n        return query.predicate;\r\n    }\r\n}\r\n/**\r\n * A representation for an object literal used during codegen of definition objects. The generic\r\n * type `T` allows to reference a documented type of the generated structure, such that the\r\n * property names that are set can be resolved to their documented declaration.\r\n */\r\nclass DefinitionMap {\r\n    constructor() {\r\n        this.values = [];\r\n    }\r\n    set(key, value) {\r\n        if (value) {\r\n            this.values.push({ key: key, value, quoted: false });\r\n        }\r\n    }\r\n    toLiteralMap() {\r\n        return literalMap(this.values);\r\n    }\r\n}\r\n/**\r\n * Extract a map of properties to values for a given element or template node, which can be used\r\n * by the directive matching machinery.\r\n *\r\n * @param elOrTpl the element or template in question\r\n * @return an object set up for directive matching. For attributes on the element/template, this\r\n * object maps a property name to its (static) value. For any bindings, this map simply maps the\r\n * property name to an empty string.\r\n */\r\nfunction getAttrsForDirectiveMatching(elOrTpl) {\r\n    const attributesMap = {};\r\n    if (elOrTpl instanceof Template && elOrTpl.tagName !== 'ng-template') {\r\n        elOrTpl.templateAttrs.forEach(a => attributesMap[a.name] = '');\r\n    }\r\n    else {\r\n        elOrTpl.attributes.forEach(a => {\r\n            if (!isI18nAttribute(a.name)) {\r\n                attributesMap[a.name] = a.value;\r\n            }\r\n        });\r\n        elOrTpl.inputs.forEach(i => {\r\n            attributesMap[i.name] = '';\r\n        });\r\n        elOrTpl.outputs.forEach(o => {\r\n            attributesMap[o.name] = '';\r\n        });\r\n    }\r\n    return attributesMap;\r\n}\r\n/** Returns a call expression to a chained instruction, e.g. `property(params[0])(params[1])`. */\r\nfunction chainedInstruction(reference, calls, span) {\r\n    let expression = importExpr(reference, null, span);\r\n    if (calls.length > 0) {\r\n        for (let i = 0; i < calls.length; i++) {\r\n            expression = expression.callFn(calls[i], span);\r\n        }\r\n    }\r\n    else {\r\n        // Add a blank invocation, in case the `calls` array is empty.\r\n        expression = expression.callFn([], span);\r\n    }\r\n    return expression;\r\n}\r\n/**\r\n * Gets the number of arguments expected to be passed to a generated instruction in the case of\r\n * interpolation instructions.\r\n * @param interpolation An interpolation ast\r\n */\r\nfunction getInterpolationArgsLength(interpolation) {\r\n    const { expressions, strings } = interpolation;\r\n    if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {\r\n        // If the interpolation has one interpolated value, but the prefix and suffix are both empty\r\n        // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or\r\n        // `textInterpolate`.\r\n        return 1;\r\n    }\r\n    else {\r\n        return expressions.length + strings.length;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Creates an array literal expression from the given array, mapping all values to an expression\r\n * using the provided mapping function. If the array is empty or null, then null is returned.\r\n *\r\n * @param values The array to transfer into literal array expression.\r\n * @param mapper The logic to use for creating an expression for the array's values.\r\n * @returns An array literal expression representing `values`, or null if `values` is empty or\r\n * is itself null.\r\n */\r\nfunction toOptionalLiteralArray(values, mapper) {\r\n    if (values === null || values.length === 0) {\r\n        return null;\r\n    }\r\n    return literalArr(values.map(value => mapper(value)));\r\n}\r\n/**\r\n * Creates an object literal expression from the given object, mapping all values to an expression\r\n * using the provided mapping function. If the object has no keys, then null is returned.\r\n *\r\n * @param object The object to transfer into an object literal expression.\r\n * @param mapper The logic to use for creating an expression for the object's values.\r\n * @returns An object literal expression representing `object`, or null if `object` does not have\r\n * any keys.\r\n */\r\nfunction toOptionalLiteralMap(object, mapper) {\r\n    const entries = Object.keys(object).map(key => {\r\n        const value = object[key];\r\n        return { key, value: mapper(value), quoted: true };\r\n    });\r\n    if (entries.length > 0) {\r\n        return literalMap(entries);\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\nfunction compileDependencies(deps) {\r\n    if (deps === 'invalid') {\r\n        // The `deps` can be set to the string \"invalid\"  by the `unwrapConstructorDependencies()`\r\n        // function, which tries to convert `ConstructorDeps` into `R3DependencyMetadata[]`.\r\n        return literal('invalid');\r\n    }\r\n    else if (deps === null) {\r\n        return literal(null);\r\n    }\r\n    else {\r\n        return literalArr(deps.map(compileDependency));\r\n    }\r\n}\r\nfunction compileDependency(dep) {\r\n    const depMeta = new DefinitionMap();\r\n    depMeta.set('token', dep.token);\r\n    if (dep.attributeNameType !== null) {\r\n        depMeta.set('attribute', literal(true));\r\n    }\r\n    if (dep.host) {\r\n        depMeta.set('host', literal(true));\r\n    }\r\n    if (dep.optional) {\r\n        depMeta.set('optional', literal(true));\r\n    }\r\n    if (dep.self) {\r\n        depMeta.set('self', literal(true));\r\n    }\r\n    if (dep.skipSelf) {\r\n        depMeta.set('skipSelf', literal(true));\r\n    }\r\n    return depMeta.toLiteralMap();\r\n}\r\n/**\r\n * Generate an expression that has the given `expr` wrapped in the following form:\r\n *\r\n * ```\r\n * forwardRef(() => expr)\r\n * ```\r\n */\r\nfunction generateForwardRef(expr) {\r\n    return importExpr(Identifiers.forwardRef).callFn([fn([], [new ReturnStatement(expr)])]);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\r\nconst VERSION = 3;\r\nconst JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\r\nclass SourceMapGenerator {\r\n    constructor(file = null) {\r\n        this.file = file;\r\n        this.sourcesContent = new Map();\r\n        this.lines = [];\r\n        this.lastCol0 = 0;\r\n        this.hasMappings = false;\r\n    }\r\n    // The content is `null` when the content is expected to be loaded using the URL\r\n    addSource(url, content = null) {\r\n        if (!this.sourcesContent.has(url)) {\r\n            this.sourcesContent.set(url, content);\r\n        }\r\n        return this;\r\n    }\r\n    addLine() {\r\n        this.lines.push([]);\r\n        this.lastCol0 = 0;\r\n        return this;\r\n    }\r\n    addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {\r\n        if (!this.currentLine) {\r\n            throw new Error(`A line must be added before mappings can be added`);\r\n        }\r\n        if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\r\n            throw new Error(`Unknown source file \"${sourceUrl}\"`);\r\n        }\r\n        if (col0 == null) {\r\n            throw new Error(`The column in the generated code must be provided`);\r\n        }\r\n        if (col0 < this.lastCol0) {\r\n            throw new Error(`Mapping should be added in output order`);\r\n        }\r\n        if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\r\n            throw new Error(`The source location must be provided when a source url is provided`);\r\n        }\r\n        this.hasMappings = true;\r\n        this.lastCol0 = col0;\r\n        this.currentLine.push({ col0, sourceUrl, sourceLine0, sourceCol0 });\r\n        return this;\r\n    }\r\n    /**\r\n     * @internal strip this from published d.ts files due to\r\n     * https://github.com/microsoft/TypeScript/issues/36216\r\n     */\r\n    get currentLine() {\r\n        return this.lines.slice(-1)[0];\r\n    }\r\n    toJSON() {\r\n        if (!this.hasMappings) {\r\n            return null;\r\n        }\r\n        const sourcesIndex = new Map();\r\n        const sources = [];\r\n        const sourcesContent = [];\r\n        Array.from(this.sourcesContent.keys()).forEach((url, i) => {\r\n            sourcesIndex.set(url, i);\r\n            sources.push(url);\r\n            sourcesContent.push(this.sourcesContent.get(url) || null);\r\n        });\r\n        let mappings = '';\r\n        let lastCol0 = 0;\r\n        let lastSourceIndex = 0;\r\n        let lastSourceLine0 = 0;\r\n        let lastSourceCol0 = 0;\r\n        this.lines.forEach(segments => {\r\n            lastCol0 = 0;\r\n            mappings += segments\r\n                .map(segment => {\r\n                // zero-based starting column of the line in the generated code\r\n                let segAsStr = toBase64VLQ(segment.col0 - lastCol0);\r\n                lastCol0 = segment.col0;\r\n                if (segment.sourceUrl != null) {\r\n                    // zero-based index into the “sources” list\r\n                    segAsStr +=\r\n                        toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);\r\n                    lastSourceIndex = sourcesIndex.get(segment.sourceUrl);\r\n                    // the zero-based starting line in the original source\r\n                    segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);\r\n                    lastSourceLine0 = segment.sourceLine0;\r\n                    // the zero-based starting column in the original source\r\n                    segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);\r\n                    lastSourceCol0 = segment.sourceCol0;\r\n                }\r\n                return segAsStr;\r\n            })\r\n                .join(',');\r\n            mappings += ';';\r\n        });\r\n        mappings = mappings.slice(0, -1);\r\n        return {\r\n            'file': this.file || '',\r\n            'version': VERSION,\r\n            'sourceRoot': '',\r\n            'sources': sources,\r\n            'sourcesContent': sourcesContent,\r\n            'mappings': mappings,\r\n        };\r\n    }\r\n    toJsComment() {\r\n        return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) :\r\n            '';\r\n    }\r\n}\r\nfunction toBase64String(value) {\r\n    let b64 = '';\r\n    const encoded = utf8Encode(value);\r\n    for (let i = 0; i < encoded.length;) {\r\n        const i1 = encoded[i++];\r\n        const i2 = i < encoded.length ? encoded[i++] : null;\r\n        const i3 = i < encoded.length ? encoded[i++] : null;\r\n        b64 += toBase64Digit(i1 >> 2);\r\n        b64 += toBase64Digit(((i1 & 3) << 4) | (i2 === null ? 0 : i2 >> 4));\r\n        b64 += i2 === null ? '=' : toBase64Digit(((i2 & 15) << 2) | (i3 === null ? 0 : i3 >> 6));\r\n        b64 += i2 === null || i3 === null ? '=' : toBase64Digit(i3 & 63);\r\n    }\r\n    return b64;\r\n}\r\nfunction toBase64VLQ(value) {\r\n    value = value < 0 ? ((-value) << 1) + 1 : value << 1;\r\n    let out = '';\r\n    do {\r\n        let digit = value & 31;\r\n        value = value >> 5;\r\n        if (value > 0) {\r\n            digit = digit | 32;\r\n        }\r\n        out += toBase64Digit(digit);\r\n    } while (value > 0);\r\n    return out;\r\n}\r\nconst B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\r\nfunction toBase64Digit(value) {\r\n    if (value < 0 || value >= 64) {\r\n        throw new Error(`Can only encode value in the range [0, 63]`);\r\n    }\r\n    return B64_DIGITS[value];\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\r\nconst _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\r\nconst _INDENT_WITH = '  ';\r\nconst CATCH_ERROR_VAR$1 = variable('error', null, null);\r\nconst CATCH_STACK_VAR$1 = variable('stack', null, null);\r\nclass _EmittedLine {\r\n    constructor(indent) {\r\n        this.indent = indent;\r\n        this.partsLength = 0;\r\n        this.parts = [];\r\n        this.srcSpans = [];\r\n    }\r\n}\r\nclass EmitterVisitorContext {\r\n    constructor(_indent) {\r\n        this._indent = _indent;\r\n        this._classes = [];\r\n        this._preambleLineCount = 0;\r\n        this._lines = [new _EmittedLine(_indent)];\r\n    }\r\n    static createRoot() {\r\n        return new EmitterVisitorContext(0);\r\n    }\r\n    /**\r\n     * @internal strip this from published d.ts files due to\r\n     * https://github.com/microsoft/TypeScript/issues/36216\r\n     */\r\n    get _currentLine() {\r\n        return this._lines[this._lines.length - 1];\r\n    }\r\n    println(from, lastPart = '') {\r\n        this.print(from || null, lastPart, true);\r\n    }\r\n    lineIsEmpty() {\r\n        return this._currentLine.parts.length === 0;\r\n    }\r\n    lineLength() {\r\n        return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\r\n    }\r\n    print(from, part, newLine = false) {\r\n        if (part.length > 0) {\r\n            this._currentLine.parts.push(part);\r\n            this._currentLine.partsLength += part.length;\r\n            this._currentLine.srcSpans.push(from && from.sourceSpan || null);\r\n        }\r\n        if (newLine) {\r\n            this._lines.push(new _EmittedLine(this._indent));\r\n        }\r\n    }\r\n    removeEmptyLastLine() {\r\n        if (this.lineIsEmpty()) {\r\n            this._lines.pop();\r\n        }\r\n    }\r\n    incIndent() {\r\n        this._indent++;\r\n        if (this.lineIsEmpty()) {\r\n            this._currentLine.indent = this._indent;\r\n        }\r\n    }\r\n    decIndent() {\r\n        this._indent--;\r\n        if (this.lineIsEmpty()) {\r\n            this._currentLine.indent = this._indent;\r\n        }\r\n    }\r\n    pushClass(clazz) {\r\n        this._classes.push(clazz);\r\n    }\r\n    popClass() {\r\n        return this._classes.pop();\r\n    }\r\n    get currentClass() {\r\n        return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;\r\n    }\r\n    toSource() {\r\n        return this.sourceLines\r\n            .map(l => l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '')\r\n            .join('\\n');\r\n    }\r\n    toSourceMapGenerator(genFilePath, startsAtLine = 0) {\r\n        const map = new SourceMapGenerator(genFilePath);\r\n        let firstOffsetMapped = false;\r\n        const mapFirstOffsetIfNeeded = () => {\r\n            if (!firstOffsetMapped) {\r\n                // Add a single space so that tools won't try to load the file from disk.\r\n                // Note: We are using virtual urls like `ng:///`, so we have to\r\n                // provide a content here.\r\n                map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\r\n                firstOffsetMapped = true;\r\n            }\r\n        };\r\n        for (let i = 0; i < startsAtLine; i++) {\r\n            map.addLine();\r\n            mapFirstOffsetIfNeeded();\r\n        }\r\n        this.sourceLines.forEach((line, lineIdx) => {\r\n            map.addLine();\r\n            const spans = line.srcSpans;\r\n            const parts = line.parts;\r\n            let col0 = line.indent * _INDENT_WITH.length;\r\n            let spanIdx = 0;\r\n            // skip leading parts without source spans\r\n            while (spanIdx < spans.length && !spans[spanIdx]) {\r\n                col0 += parts[spanIdx].length;\r\n                spanIdx++;\r\n            }\r\n            if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\r\n                firstOffsetMapped = true;\r\n            }\r\n            else {\r\n                mapFirstOffsetIfNeeded();\r\n            }\r\n            while (spanIdx < spans.length) {\r\n                const span = spans[spanIdx];\r\n                const source = span.start.file;\r\n                const sourceLine = span.start.line;\r\n                const sourceCol = span.start.col;\r\n                map.addSource(source.url, source.content)\r\n                    .addMapping(col0, source.url, sourceLine, sourceCol);\r\n                col0 += parts[spanIdx].length;\r\n                spanIdx++;\r\n                // assign parts without span or the same span to the previous segment\r\n                while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\r\n                    col0 += parts[spanIdx].length;\r\n                    spanIdx++;\r\n                }\r\n            }\r\n        });\r\n        return map;\r\n    }\r\n    setPreambleLineCount(count) {\r\n        return this._preambleLineCount = count;\r\n    }\r\n    spanOf(line, column) {\r\n        const emittedLine = this._lines[line - this._preambleLineCount];\r\n        if (emittedLine) {\r\n            let columnsLeft = column - _createIndent(emittedLine.indent).length;\r\n            for (let partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\r\n                const part = emittedLine.parts[partIndex];\r\n                if (part.length > columnsLeft) {\r\n                    return emittedLine.srcSpans[partIndex];\r\n                }\r\n                columnsLeft -= part.length;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * @internal strip this from published d.ts files due to\r\n     * https://github.com/microsoft/TypeScript/issues/36216\r\n     */\r\n    get sourceLines() {\r\n        if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\r\n            return this._lines.slice(0, -1);\r\n        }\r\n        return this._lines;\r\n    }\r\n}\r\nclass AbstractEmitterVisitor {\r\n    constructor(_escapeDollarInStrings) {\r\n        this._escapeDollarInStrings = _escapeDollarInStrings;\r\n    }\r\n    printLeadingComments(stmt, ctx) {\r\n        if (stmt.leadingComments === undefined) {\r\n            return;\r\n        }\r\n        for (const comment of stmt.leadingComments) {\r\n            if (comment instanceof JSDocComment) {\r\n                ctx.print(stmt, `/*${comment.toString()}*/`, comment.trailingNewline);\r\n            }\r\n            else {\r\n                if (comment.multiline) {\r\n                    ctx.print(stmt, `/* ${comment.text} */`, comment.trailingNewline);\r\n                }\r\n                else {\r\n                    comment.text.split('\\n').forEach((line) => {\r\n                        ctx.println(stmt, `// ${line}`);\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    visitExpressionStmt(stmt, ctx) {\r\n        this.printLeadingComments(stmt, ctx);\r\n        stmt.expr.visitExpression(this, ctx);\r\n        ctx.println(stmt, ';');\r\n        return null;\r\n    }\r\n    visitReturnStmt(stmt, ctx) {\r\n        this.printLeadingComments(stmt, ctx);\r\n        ctx.print(stmt, `return `);\r\n        stmt.value.visitExpression(this, ctx);\r\n        ctx.println(stmt, ';');\r\n        return null;\r\n    }\r\n    visitIfStmt(stmt, ctx) {\r\n        this.printLeadingComments(stmt, ctx);\r\n        ctx.print(stmt, `if (`);\r\n        stmt.condition.visitExpression(this, ctx);\r\n        ctx.print(stmt, `) {`);\r\n        const hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\r\n        if (stmt.trueCase.length <= 1 && !hasElseCase) {\r\n            ctx.print(stmt, ` `);\r\n            this.visitAllStatements(stmt.trueCase, ctx);\r\n            ctx.removeEmptyLastLine();\r\n            ctx.print(stmt, ` `);\r\n        }\r\n        else {\r\n            ctx.println();\r\n            ctx.incIndent();\r\n            this.visitAllStatements(stmt.trueCase, ctx);\r\n            ctx.decIndent();\r\n            if (hasElseCase) {\r\n                ctx.println(stmt, `} else {`);\r\n                ctx.incIndent();\r\n                this.visitAllStatements(stmt.falseCase, ctx);\r\n                ctx.decIndent();\r\n            }\r\n        }\r\n        ctx.println(stmt, `}`);\r\n        return null;\r\n    }\r\n    visitThrowStmt(stmt, ctx) {\r\n        this.printLeadingComments(stmt, ctx);\r\n        ctx.print(stmt, `throw `);\r\n        stmt.error.visitExpression(this, ctx);\r\n        ctx.println(stmt, `;`);\r\n        return null;\r\n    }\r\n    visitWriteVarExpr(expr, ctx) {\r\n        const lineWasEmpty = ctx.lineIsEmpty();\r\n        if (!lineWasEmpty) {\r\n            ctx.print(expr, '(');\r\n        }\r\n        ctx.print(expr, `${expr.name} = `);\r\n        expr.value.visitExpression(this, ctx);\r\n        if (!lineWasEmpty) {\r\n            ctx.print(expr, ')');\r\n        }\r\n        return null;\r\n    }\r\n    visitWriteKeyExpr(expr, ctx) {\r\n        const lineWasEmpty = ctx.lineIsEmpty();\r\n        if (!lineWasEmpty) {\r\n            ctx.print(expr, '(');\r\n        }\r\n        expr.receiver.visitExpression(this, ctx);\r\n        ctx.print(expr, `[`);\r\n        expr.index.visitExpression(this, ctx);\r\n        ctx.print(expr, `] = `);\r\n        expr.value.visitExpression(this, ctx);\r\n        if (!lineWasEmpty) {\r\n            ctx.print(expr, ')');\r\n        }\r\n        return null;\r\n    }\r\n    visitWritePropExpr(expr, ctx) {\r\n        const lineWasEmpty = ctx.lineIsEmpty();\r\n        if (!lineWasEmpty) {\r\n            ctx.print(expr, '(');\r\n        }\r\n        expr.receiver.visitExpression(this, ctx);\r\n        ctx.print(expr, `.${expr.name} = `);\r\n        expr.value.visitExpression(this, ctx);\r\n        if (!lineWasEmpty) {\r\n            ctx.print(expr, ')');\r\n        }\r\n        return null;\r\n    }\r\n    visitInvokeMethodExpr(expr, ctx) {\r\n        expr.receiver.visitExpression(this, ctx);\r\n        let name = expr.name;\r\n        if (expr.builtin != null) {\r\n            name = this.getBuiltinMethodName(expr.builtin);\r\n            if (name == null) {\r\n                // some builtins just mean to skip the call.\r\n                return null;\r\n            }\r\n        }\r\n        ctx.print(expr, `.${name}(`);\r\n        this.visitAllExpressions(expr.args, ctx, `,`);\r\n        ctx.print(expr, `)`);\r\n        return null;\r\n    }\r\n    visitInvokeFunctionExpr(expr, ctx) {\r\n        expr.fn.visitExpression(this, ctx);\r\n        ctx.print(expr, `(`);\r\n        this.visitAllExpressions(expr.args, ctx, ',');\r\n        ctx.print(expr, `)`);\r\n        return null;\r\n    }\r\n    visitTaggedTemplateExpr(expr, ctx) {\r\n        expr.tag.visitExpression(this, ctx);\r\n        ctx.print(expr, '`' + expr.template.elements[0].rawText);\r\n        for (let i = 1; i < expr.template.elements.length; i++) {\r\n            ctx.print(expr, '${');\r\n            expr.template.expressions[i - 1].visitExpression(this, ctx);\r\n            ctx.print(expr, `}${expr.template.elements[i].rawText}`);\r\n        }\r\n        ctx.print(expr, '`');\r\n        return null;\r\n    }\r\n    visitWrappedNodeExpr(ast, ctx) {\r\n        throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\r\n    }\r\n    visitTypeofExpr(expr, ctx) {\r\n        ctx.print(expr, 'typeof ');\r\n        expr.expr.visitExpression(this, ctx);\r\n    }\r\n    visitReadVarExpr(ast, ctx) {\r\n        let varName = ast.name;\r\n        if (ast.builtin != null) {\r\n            switch (ast.builtin) {\r\n                case BuiltinVar.Super:\r\n                    varName = 'super';\r\n                    break;\r\n                case BuiltinVar.This:\r\n                    varName = 'this';\r\n                    break;\r\n                case BuiltinVar.CatchError:\r\n                    varName = CATCH_ERROR_VAR$1.name;\r\n                    break;\r\n                case BuiltinVar.CatchStack:\r\n                    varName = CATCH_STACK_VAR$1.name;\r\n                    break;\r\n                default:\r\n                    throw new Error(`Unknown builtin variable ${ast.builtin}`);\r\n            }\r\n        }\r\n        ctx.print(ast, varName);\r\n        return null;\r\n    }\r\n    visitInstantiateExpr(ast, ctx) {\r\n        ctx.print(ast, `new `);\r\n        ast.classExpr.visitExpression(this, ctx);\r\n        ctx.print(ast, `(`);\r\n        this.visitAllExpressions(ast.args, ctx, ',');\r\n        ctx.print(ast, `)`);\r\n        return null;\r\n    }\r\n    visitLiteralExpr(ast, ctx) {\r\n        const value = ast.value;\r\n        if (typeof value === 'string') {\r\n            ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\r\n        }\r\n        else {\r\n            ctx.print(ast, `${value}`);\r\n        }\r\n        return null;\r\n    }\r\n    visitLocalizedString(ast, ctx) {\r\n        const head = ast.serializeI18nHead();\r\n        ctx.print(ast, '$localize `' + head.raw);\r\n        for (let i = 1; i < ast.messageParts.length; i++) {\r\n            ctx.print(ast, '${');\r\n            ast.expressions[i - 1].visitExpression(this, ctx);\r\n            ctx.print(ast, `}${ast.serializeI18nTemplatePart(i).raw}`);\r\n        }\r\n        ctx.print(ast, '`');\r\n        return null;\r\n    }\r\n    visitConditionalExpr(ast, ctx) {\r\n        ctx.print(ast, `(`);\r\n        ast.condition.visitExpression(this, ctx);\r\n        ctx.print(ast, '? ');\r\n        ast.trueCase.visitExpression(this, ctx);\r\n        ctx.print(ast, ': ');\r\n        ast.falseCase.visitExpression(this, ctx);\r\n        ctx.print(ast, `)`);\r\n        return null;\r\n    }\r\n    visitNotExpr(ast, ctx) {\r\n        ctx.print(ast, '!');\r\n        ast.condition.visitExpression(this, ctx);\r\n        return null;\r\n    }\r\n    visitAssertNotNullExpr(ast, ctx) {\r\n        ast.condition.visitExpression(this, ctx);\r\n        return null;\r\n    }\r\n    visitUnaryOperatorExpr(ast, ctx) {\r\n        let opStr;\r\n        switch (ast.operator) {\r\n            case UnaryOperator.Plus:\r\n                opStr = '+';\r\n                break;\r\n            case UnaryOperator.Minus:\r\n                opStr = '-';\r\n                break;\r\n            default:\r\n                throw new Error(`Unknown operator ${ast.operator}`);\r\n        }\r\n        if (ast.parens)\r\n            ctx.print(ast, `(`);\r\n        ctx.print(ast, opStr);\r\n        ast.expr.visitExpression(this, ctx);\r\n        if (ast.parens)\r\n            ctx.print(ast, `)`);\r\n        return null;\r\n    }\r\n    visitBinaryOperatorExpr(ast, ctx) {\r\n        let opStr;\r\n        switch (ast.operator) {\r\n            case BinaryOperator.Equals:\r\n                opStr = '==';\r\n                break;\r\n            case BinaryOperator.Identical:\r\n                opStr = '===';\r\n                break;\r\n            case BinaryOperator.NotEquals:\r\n                opStr = '!=';\r\n                break;\r\n            case BinaryOperator.NotIdentical:\r\n                opStr = '!==';\r\n                break;\r\n            case BinaryOperator.And:\r\n                opStr = '&&';\r\n                break;\r\n            case BinaryOperator.BitwiseAnd:\r\n                opStr = '&';\r\n                break;\r\n            case BinaryOperator.Or:\r\n                opStr = '||';\r\n                break;\r\n            case BinaryOperator.Plus:\r\n                opStr = '+';\r\n                break;\r\n            case BinaryOperator.Minus:\r\n                opStr = '-';\r\n                break;\r\n            case BinaryOperator.Divide:\r\n                opStr = '/';\r\n                break;\r\n            case BinaryOperator.Multiply:\r\n                opStr = '*';\r\n                break;\r\n            case BinaryOperator.Modulo:\r\n                opStr = '%';\r\n                break;\r\n            case BinaryOperator.Lower:\r\n                opStr = '<';\r\n                break;\r\n            case BinaryOperator.LowerEquals:\r\n                opStr = '<=';\r\n                break;\r\n            case BinaryOperator.Bigger:\r\n                opStr = '>';\r\n                break;\r\n            case BinaryOperator.BiggerEquals:\r\n                opStr = '>=';\r\n                break;\r\n            case BinaryOperator.NullishCoalesce:\r\n                opStr = '??';\r\n                break;\r\n            default:\r\n                throw new Error(`Unknown operator ${ast.operator}`);\r\n        }\r\n        if (ast.parens)\r\n            ctx.print(ast, `(`);\r\n        ast.lhs.visitExpression(this, ctx);\r\n        ctx.print(ast, ` ${opStr} `);\r\n        ast.rhs.visitExpression(this, ctx);\r\n        if (ast.parens)\r\n            ctx.print(ast, `)`);\r\n        return null;\r\n    }\r\n    visitReadPropExpr(ast, ctx) {\r\n        ast.receiver.visitExpression(this, ctx);\r\n        ctx.print(ast, `.`);\r\n        ctx.print(ast, ast.name);\r\n        return null;\r\n    }\r\n    visitReadKeyExpr(ast, ctx) {\r\n        ast.receiver.visitExpression(this, ctx);\r\n        ctx.print(ast, `[`);\r\n        ast.index.visitExpression(this, ctx);\r\n        ctx.print(ast, `]`);\r\n        return null;\r\n    }\r\n    visitLiteralArrayExpr(ast, ctx) {\r\n        ctx.print(ast, `[`);\r\n        this.visitAllExpressions(ast.entries, ctx, ',');\r\n        ctx.print(ast, `]`);\r\n        return null;\r\n    }\r\n    visitLiteralMapExpr(ast, ctx) {\r\n        ctx.print(ast, `{`);\r\n        this.visitAllObjects(entry => {\r\n            ctx.print(ast, `${escapeIdentifier(entry.key, this._escapeDollarInStrings, entry.quoted)}:`);\r\n            entry.value.visitExpression(this, ctx);\r\n        }, ast.entries, ctx, ',');\r\n        ctx.print(ast, `}`);\r\n        return null;\r\n    }\r\n    visitCommaExpr(ast, ctx) {\r\n        ctx.print(ast, '(');\r\n        this.visitAllExpressions(ast.parts, ctx, ',');\r\n        ctx.print(ast, ')');\r\n        return null;\r\n    }\r\n    visitAllExpressions(expressions, ctx, separator) {\r\n        this.visitAllObjects(expr => expr.visitExpression(this, ctx), expressions, ctx, separator);\r\n    }\r\n    visitAllObjects(handler, expressions, ctx, separator) {\r\n        let incrementedIndent = false;\r\n        for (let i = 0; i < expressions.length; i++) {\r\n            if (i > 0) {\r\n                if (ctx.lineLength() > 80) {\r\n                    ctx.print(null, separator, true);\r\n                    if (!incrementedIndent) {\r\n                        // continuation are marked with double indent.\r\n                        ctx.incIndent();\r\n                        ctx.incIndent();\r\n                        incrementedIndent = true;\r\n                    }\r\n                }\r\n                else {\r\n                    ctx.print(null, separator, false);\r\n                }\r\n            }\r\n            handler(expressions[i]);\r\n        }\r\n        if (incrementedIndent) {\r\n            // continuation are marked with double indent.\r\n            ctx.decIndent();\r\n            ctx.decIndent();\r\n        }\r\n    }\r\n    visitAllStatements(statements, ctx) {\r\n        statements.forEach((stmt) => stmt.visitStatement(this, ctx));\r\n    }\r\n}\r\nfunction escapeIdentifier(input, escapeDollar, alwaysQuote = true) {\r\n    if (input == null) {\r\n        return null;\r\n    }\r\n    const body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, (...match) => {\r\n        if (match[0] == '$') {\r\n            return escapeDollar ? '\\\\$' : '$';\r\n        }\r\n        else if (match[0] == '\\n') {\r\n            return '\\\\n';\r\n        }\r\n        else if (match[0] == '\\r') {\r\n            return '\\\\r';\r\n        }\r\n        else {\r\n            return `\\\\${match[0]}`;\r\n        }\r\n    });\r\n    const requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\r\n    return requiresQuotes ? `'${body}'` : body;\r\n}\r\nfunction _createIndent(count) {\r\n    let res = '';\r\n    for (let i = 0; i < count; i++) {\r\n        res += _INDENT_WITH;\r\n    }\r\n    return res;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nfunction typeWithParameters(type, numParams) {\r\n    if (numParams === 0) {\r\n        return expressionType(type);\r\n    }\r\n    const params = [];\r\n    for (let i = 0; i < numParams; i++) {\r\n        params.push(DYNAMIC_TYPE);\r\n    }\r\n    return expressionType(type, undefined, params);\r\n}\r\nconst ANIMATE_SYMBOL_PREFIX = '@';\r\nfunction prepareSyntheticPropertyName(name) {\r\n    return `${ANIMATE_SYMBOL_PREFIX}${name}`;\r\n}\r\nfunction prepareSyntheticListenerName(name, phase) {\r\n    return `${ANIMATE_SYMBOL_PREFIX}${name}.${phase}`;\r\n}\r\nfunction getSafePropertyAccessString(accessor, name) {\r\n    const escapedName = escapeIdentifier(name, false, false);\r\n    return escapedName !== name ? `${accessor}[${escapedName}]` : `${accessor}.${name}`;\r\n}\r\nfunction prepareSyntheticListenerFunctionName(name, phase) {\r\n    return `animation_${name}_${phase}`;\r\n}\r\nfunction jitOnlyGuardedExpression(expr) {\r\n    return guardedExpression('ngJitMode', expr);\r\n}\r\nfunction devOnlyGuardedExpression(expr) {\r\n    return guardedExpression('ngDevMode', expr);\r\n}\r\nfunction guardedExpression(guard, expr) {\r\n    const guardExpr = new ExternalExpr({ name: guard, moduleName: null });\r\n    const guardNotDefined = new BinaryOperatorExpr(BinaryOperator.Identical, new TypeofExpr(guardExpr), literal('undefined'));\r\n    const guardUndefinedOrTrue = new BinaryOperatorExpr(BinaryOperator.Or, guardNotDefined, guardExpr, /* type */ undefined, \r\n    /* sourceSpan */ undefined, true);\r\n    return new BinaryOperatorExpr(BinaryOperator.And, guardUndefinedOrTrue, expr);\r\n}\r\nfunction wrapReference(value) {\r\n    const wrapped = new WrappedNodeExpr(value);\r\n    return { value: wrapped, type: wrapped };\r\n}\r\nfunction refsToArray(refs, shouldForwardDeclare) {\r\n    const values = literalArr(refs.map(ref => ref.value));\r\n    return shouldForwardDeclare ? fn([], [new ReturnStatement(values)]) : values;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nvar R3FactoryDelegateType;\r\n(function (R3FactoryDelegateType) {\r\n    R3FactoryDelegateType[R3FactoryDelegateType[\"Class\"] = 0] = \"Class\";\r\n    R3FactoryDelegateType[R3FactoryDelegateType[\"Function\"] = 1] = \"Function\";\r\n})(R3FactoryDelegateType || (R3FactoryDelegateType = {}));\r\nvar FactoryTarget;\r\n(function (FactoryTarget) {\r\n    FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\r\n    FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\r\n    FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\r\n    FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\r\n    FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\r\n})(FactoryTarget || (FactoryTarget = {}));\r\n/**\r\n * Construct a factory function expression for the given `R3FactoryMetadata`.\r\n */\r\nfunction compileFactoryFunction(meta) {\r\n    const t = variable('t');\r\n    let baseFactoryVar = null;\r\n    // The type to instantiate via constructor invocation. If there is no delegated factory, meaning\r\n    // this type is always created by constructor invocation, then this is the type-to-create\r\n    // parameter provided by the user (t) if specified, or the current type if not. If there is a\r\n    // delegated factory (which is used to create the current type) then this is only the type-to-\r\n    // create parameter (t).\r\n    const typeForCtor = !isDelegatedFactoryMetadata(meta) ?\r\n        new BinaryOperatorExpr(BinaryOperator.Or, t, meta.internalType) :\r\n        t;\r\n    let ctorExpr = null;\r\n    if (meta.deps !== null) {\r\n        // There is a constructor (either explicitly or implicitly defined).\r\n        if (meta.deps !== 'invalid') {\r\n            ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.target));\r\n        }\r\n    }\r\n    else {\r\n        // There is no constructor, use the base class' factory to construct typeForCtor.\r\n        baseFactoryVar = variable(`ɵ${meta.name}_BaseFactory`);\r\n        ctorExpr = baseFactoryVar.callFn([typeForCtor]);\r\n    }\r\n    const body = [];\r\n    let retExpr = null;\r\n    function makeConditionalFactory(nonCtorExpr) {\r\n        const r = variable('r');\r\n        body.push(r.set(NULL_EXPR).toDeclStmt());\r\n        const ctorStmt = ctorExpr !== null ? r.set(ctorExpr).toStmt() :\r\n            importExpr(Identifiers.invalidFactory).callFn([]).toStmt();\r\n        body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\r\n        return r;\r\n    }\r\n    if (isDelegatedFactoryMetadata(meta)) {\r\n        // This type is created with a delegated factory. If a type parameter is not specified, call\r\n        // the factory instead.\r\n        const delegateArgs = injectDependencies(meta.delegateDeps, meta.target);\r\n        // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.\r\n        const factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ?\r\n            InstantiateExpr :\r\n            InvokeFunctionExpr)(meta.delegate, delegateArgs);\r\n        retExpr = makeConditionalFactory(factoryExpr);\r\n    }\r\n    else if (isExpressionFactoryMetadata(meta)) {\r\n        // TODO(alxhub): decide whether to lower the value here or in the caller\r\n        retExpr = makeConditionalFactory(meta.expression);\r\n    }\r\n    else {\r\n        retExpr = ctorExpr;\r\n    }\r\n    if (retExpr === null) {\r\n        // The expression cannot be formed so render an `ɵɵinvalidFactory()` call.\r\n        body.push(importExpr(Identifiers.invalidFactory).callFn([]).toStmt());\r\n    }\r\n    else if (baseFactoryVar !== null) {\r\n        // This factory uses a base factory, so call `ɵɵgetInheritedFactory()` to compute it.\r\n        const getInheritedFactoryCall = importExpr(Identifiers.getInheritedFactory).callFn([meta.internalType]);\r\n        // Memoize the base factoryFn: `baseFactory || (baseFactory = ɵɵgetInheritedFactory(...))`\r\n        const baseFactory = new BinaryOperatorExpr(BinaryOperator.Or, baseFactoryVar, baseFactoryVar.set(getInheritedFactoryCall));\r\n        body.push(new ReturnStatement(baseFactory.callFn([typeForCtor])));\r\n    }\r\n    else {\r\n        // This is straightforward factory, just return it.\r\n        body.push(new ReturnStatement(retExpr));\r\n    }\r\n    let factoryFn = fn([new FnParam('t', DYNAMIC_TYPE)], body, INFERRED_TYPE, undefined, `${meta.name}_Factory`);\r\n    if (baseFactoryVar !== null) {\r\n        // There is a base factory variable so wrap its declaration along with the factory function into\r\n        // an IIFE.\r\n        factoryFn = fn([], [\r\n            new DeclareVarStmt(baseFactoryVar.name), new ReturnStatement(factoryFn)\r\n        ]).callFn([], /* sourceSpan */ undefined, /* pure */ true);\r\n    }\r\n    return {\r\n        expression: factoryFn,\r\n        statements: [],\r\n        type: createFactoryType(meta),\r\n    };\r\n}\r\nfunction createFactoryType(meta) {\r\n    const ctorDepsType = meta.deps !== null && meta.deps !== 'invalid' ? createCtorDepsType(meta.deps) : NONE_TYPE;\r\n    return expressionType(importExpr(Identifiers.FactoryDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]));\r\n}\r\nfunction injectDependencies(deps, target) {\r\n    return deps.map((dep, index) => compileInjectDependency(dep, target, index));\r\n}\r\nfunction compileInjectDependency(dep, target, index) {\r\n    // Interpret the dependency according to its resolved type.\r\n    if (dep.token === null) {\r\n        return importExpr(Identifiers.invalidFactoryDep).callFn([literal(index)]);\r\n    }\r\n    else if (dep.attributeNameType === null) {\r\n        // Build up the injection flags according to the metadata.\r\n        const flags = 0 /* Default */ | (dep.self ? 2 /* Self */ : 0) |\r\n            (dep.skipSelf ? 4 /* SkipSelf */ : 0) | (dep.host ? 1 /* Host */ : 0) |\r\n            (dep.optional ? 8 /* Optional */ : 0) |\r\n            (target === FactoryTarget.Pipe ? 16 /* ForPipe */ : 0);\r\n        // If this dependency is optional or otherwise has non-default flags, then additional\r\n        // parameters describing how to inject the dependency must be passed to the inject function\r\n        // that's being used.\r\n        let flagsParam = (flags !== 0 /* Default */ || dep.optional) ? literal(flags) : null;\r\n        // Build up the arguments to the injectFn call.\r\n        const injectArgs = [dep.token];\r\n        if (flagsParam) {\r\n            injectArgs.push(flagsParam);\r\n        }\r\n        const injectFn = getInjectFn(target);\r\n        return importExpr(injectFn).callFn(injectArgs);\r\n    }\r\n    else {\r\n        // The `dep.attributeTypeName` value is defined, which indicates that this is an `@Attribute()`\r\n        // type dependency. For the generated JS we still want to use the `dep.token` value in case the\r\n        // name given for the attribute is not a string literal. For example given `@Attribute(foo())`,\r\n        // we want to generate `ɵɵinjectAttribute(foo())`.\r\n        //\r\n        // The `dep.attributeTypeName` is only actually used (in `createCtorDepType()`) to generate\r\n        // typings.\r\n        return importExpr(Identifiers.injectAttribute).callFn([dep.token]);\r\n    }\r\n}\r\nfunction createCtorDepsType(deps) {\r\n    let hasTypes = false;\r\n    const attributeTypes = deps.map(dep => {\r\n        const type = createCtorDepType(dep);\r\n        if (type !== null) {\r\n            hasTypes = true;\r\n            return type;\r\n        }\r\n        else {\r\n            return literal(null);\r\n        }\r\n    });\r\n    if (hasTypes) {\r\n        return expressionType(literalArr(attributeTypes));\r\n    }\r\n    else {\r\n        return NONE_TYPE;\r\n    }\r\n}\r\nfunction createCtorDepType(dep) {\r\n    const entries = [];\r\n    if (dep.attributeNameType !== null) {\r\n        entries.push({ key: 'attribute', value: dep.attributeNameType, quoted: false });\r\n    }\r\n    if (dep.optional) {\r\n        entries.push({ key: 'optional', value: literal(true), quoted: false });\r\n    }\r\n    if (dep.host) {\r\n        entries.push({ key: 'host', value: literal(true), quoted: false });\r\n    }\r\n    if (dep.self) {\r\n        entries.push({ key: 'self', value: literal(true), quoted: false });\r\n    }\r\n    if (dep.skipSelf) {\r\n        entries.push({ key: 'skipSelf', value: literal(true), quoted: false });\r\n    }\r\n    return entries.length > 0 ? literalMap(entries) : null;\r\n}\r\nfunction isDelegatedFactoryMetadata(meta) {\r\n    return meta.delegateType !== undefined;\r\n}\r\nfunction isExpressionFactoryMetadata(meta) {\r\n    return meta.expression !== undefined;\r\n}\r\nfunction getInjectFn(target) {\r\n    switch (target) {\r\n        case FactoryTarget.Component:\r\n        case FactoryTarget.Directive:\r\n        case FactoryTarget.Pipe:\r\n            return Identifiers.directiveInject;\r\n        case FactoryTarget.NgModule:\r\n        case FactoryTarget.Injectable:\r\n        default:\r\n            return Identifiers.inject;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nfunction createR3ProviderExpression(expression, isForwardRef) {\r\n    return { expression, isForwardRef };\r\n}\r\nfunction compileInjectable(meta, resolveForwardRefs) {\r\n    let result = null;\r\n    const factoryMeta = {\r\n        name: meta.name,\r\n        type: meta.type,\r\n        internalType: meta.internalType,\r\n        typeArgumentCount: meta.typeArgumentCount,\r\n        deps: [],\r\n        target: FactoryTarget.Injectable,\r\n    };\r\n    if (meta.useClass !== undefined) {\r\n        // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is\r\n        // used to instantiate the class with dependencies injected, or deps are not specified and\r\n        // the factory of the class is used to instantiate it.\r\n        //\r\n        // A special case exists for useClass: Type where Type is the injectable type itself and no\r\n        // deps are specified, in which case 'useClass' is effectively ignored.\r\n        const useClassOnSelf = meta.useClass.expression.isEquivalent(meta.internalType);\r\n        let deps = undefined;\r\n        if (meta.deps !== undefined) {\r\n            deps = meta.deps;\r\n        }\r\n        if (deps !== undefined) {\r\n            // factory: () => new meta.useClass(...deps)\r\n            result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { delegate: meta.useClass.expression, delegateDeps: deps, delegateType: R3FactoryDelegateType.Class }));\r\n        }\r\n        else if (useClassOnSelf) {\r\n            result = compileFactoryFunction(factoryMeta);\r\n        }\r\n        else {\r\n            result = {\r\n                statements: [],\r\n                expression: delegateToFactory(meta.type.value, meta.useClass.expression, resolveForwardRefs)\r\n            };\r\n        }\r\n    }\r\n    else if (meta.useFactory !== undefined) {\r\n        if (meta.deps !== undefined) {\r\n            result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { delegate: meta.useFactory, delegateDeps: meta.deps || [], delegateType: R3FactoryDelegateType.Function }));\r\n        }\r\n        else {\r\n            result = {\r\n                statements: [],\r\n                expression: fn([], [new ReturnStatement(meta.useFactory.callFn([]))])\r\n            };\r\n        }\r\n    }\r\n    else if (meta.useValue !== undefined) {\r\n        // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\r\n        // client code because meta.useValue is an Expression which will be defined even if the actual\r\n        // value is undefined.\r\n        result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { expression: meta.useValue.expression }));\r\n    }\r\n    else if (meta.useExisting !== undefined) {\r\n        // useExisting is an `inject` call on the existing token.\r\n        result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), { expression: importExpr(Identifiers.inject).callFn([meta.useExisting.expression]) }));\r\n    }\r\n    else {\r\n        result = {\r\n            statements: [],\r\n            expression: delegateToFactory(meta.type.value, meta.internalType, resolveForwardRefs)\r\n        };\r\n    }\r\n    const token = meta.internalType;\r\n    const injectableProps = new DefinitionMap();\r\n    injectableProps.set('token', token);\r\n    injectableProps.set('factory', result.expression);\r\n    // Only generate providedIn property if it has a non-null value\r\n    if (meta.providedIn.expression.value !== null) {\r\n        injectableProps.set('providedIn', meta.providedIn.isForwardRef ? generateForwardRef(meta.providedIn.expression) :\r\n            meta.providedIn.expression);\r\n    }\r\n    const expression = importExpr(Identifiers.ɵɵdefineInjectable)\r\n        .callFn([injectableProps.toLiteralMap()], undefined, true);\r\n    return {\r\n        expression,\r\n        type: createInjectableType(meta),\r\n        statements: result.statements,\r\n    };\r\n}\r\nfunction createInjectableType(meta) {\r\n    return new ExpressionType(importExpr(Identifiers.InjectableDeclaration, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));\r\n}\r\nfunction delegateToFactory(type, internalType, unwrapForwardRefs) {\r\n    if (type.node === internalType.node) {\r\n        // The types are the same, so we can simply delegate directly to the type's factory.\r\n        // ```\r\n        // factory: type.ɵfac\r\n        // ```\r\n        return internalType.prop('ɵfac');\r\n    }\r\n    if (!unwrapForwardRefs) {\r\n        // The type is not wrapped in a `forwardRef()`, so we create a simple factory function that\r\n        // accepts a sub-type as an argument.\r\n        // ```\r\n        // factory: function(t) { return internalType.ɵfac(t); }\r\n        // ```\r\n        return createFactoryFunction(internalType);\r\n    }\r\n    // The internalType is actually wrapped in a `forwardRef()` so we need to resolve that before\r\n    // calling its factory.\r\n    // ```\r\n    // factory: function(t) { return core.resolveForwardRef(type).ɵfac(t); }\r\n    // ```\r\n    const unwrappedType = importExpr(Identifiers.resolveForwardRef).callFn([internalType]);\r\n    return createFactoryFunction(unwrappedType);\r\n}\r\nfunction createFactoryFunction(type) {\r\n    return fn([new FnParam('t', DYNAMIC_TYPE)], [new ReturnStatement(type.callMethod('ɵfac', [variable('t')]))]);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nfunction assertArrayOfStrings(identifier, value) {\r\n    if (value == null) {\r\n        return;\r\n    }\r\n    if (!Array.isArray(value)) {\r\n        throw new Error(`Expected '${identifier}' to be an array of strings.`);\r\n    }\r\n    for (let i = 0; i < value.length; i += 1) {\r\n        if (typeof value[i] !== 'string') {\r\n            throw new Error(`Expected '${identifier}' to be an array of strings.`);\r\n        }\r\n    }\r\n}\r\nconst UNUSABLE_INTERPOLATION_REGEXPS = [\r\n    /^\\s*$/,\r\n    /[<>]/,\r\n    /^[{}]$/,\r\n    /&(#|[a-z])/i,\r\n    /^\\/\\//, // comment\r\n];\r\nfunction assertInterpolationSymbols(identifier, value) {\r\n    if (value != null && !(Array.isArray(value) && value.length == 2)) {\r\n        throw new Error(`Expected '${identifier}' to be an array, [start, end].`);\r\n    }\r\n    else if (value != null) {\r\n        const start = value[0];\r\n        const end = value[1];\r\n        // Check for unusable interpolation symbols\r\n        UNUSABLE_INTERPOLATION_REGEXPS.forEach(regexp => {\r\n            if (regexp.test(start) || regexp.test(end)) {\r\n                throw new Error(`['${start}', '${end}'] contains unusable interpolation symbol.`);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass InterpolationConfig {\r\n    constructor(start, end) {\r\n        this.start = start;\r\n        this.end = end;\r\n    }\r\n    static fromArray(markers) {\r\n        if (!markers) {\r\n            return DEFAULT_INTERPOLATION_CONFIG;\r\n        }\r\n        assertInterpolationSymbols('interpolation', markers);\r\n        return new InterpolationConfig(markers[0], markers[1]);\r\n    }\r\n}\r\nconst DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A token representing the a reference to a static type.\r\n *\r\n * This token is unique for a filePath and name and can be used as a hash table key.\r\n */\r\nclass StaticSymbol {\r\n    constructor(filePath, name, members) {\r\n        this.filePath = filePath;\r\n        this.name = name;\r\n        this.members = members;\r\n    }\r\n    assertNoMembers() {\r\n        if (this.members.length) {\r\n            throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`);\r\n        }\r\n    }\r\n}\r\n/**\r\n * A cache of static symbol used by the StaticReflector to return the same symbol for the\r\n * same symbol values.\r\n */\r\nclass StaticSymbolCache {\r\n    constructor() {\r\n        this.cache = new Map();\r\n    }\r\n    get(declarationFile, name, members) {\r\n        members = members || [];\r\n        const memberSuffix = members.length ? `.${members.join('.')}` : '';\r\n        const key = `\"${declarationFile}\".${name}${memberSuffix}`;\r\n        let result = this.cache.get(key);\r\n        if (!result) {\r\n            result = new StaticSymbol(declarationFile, name, members);\r\n            this.cache.set(key, result);\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n// group 0: \"[prop] or (event) or @trigger\"\r\n// group 1: \"prop\" from \"[prop]\"\r\n// group 2: \"event\" from \"(event)\"\r\n// group 3: \"@trigger\" from \"@trigger\"\r\nconst HOST_REG_EXP = /^(?:(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\)))|(\\@[-\\w]+)$/;\r\nfunction sanitizeIdentifier(name) {\r\n    return name.replace(/\\W/g, '_');\r\n}\r\nlet _anonymousTypeIndex = 0;\r\nfunction identifierName(compileIdentifier) {\r\n    if (!compileIdentifier || !compileIdentifier.reference) {\r\n        return null;\r\n    }\r\n    const ref = compileIdentifier.reference;\r\n    if (ref instanceof StaticSymbol) {\r\n        return ref.name;\r\n    }\r\n    if (ref['__anonymousType']) {\r\n        return ref['__anonymousType'];\r\n    }\r\n    if (ref['__forward_ref__']) {\r\n        // We do not want to try to stringify a `forwardRef()` function because that would cause the\r\n        // inner function to be evaluated too early, defeating the whole point of the `forwardRef`.\r\n        return '__forward_ref__';\r\n    }\r\n    let identifier = stringify(ref);\r\n    if (identifier.indexOf('(') >= 0) {\r\n        // case: anonymous functions!\r\n        identifier = `anonymous_${_anonymousTypeIndex++}`;\r\n        ref['__anonymousType'] = identifier;\r\n    }\r\n    else {\r\n        identifier = sanitizeIdentifier(identifier);\r\n    }\r\n    return identifier;\r\n}\r\nfunction identifierModuleUrl(compileIdentifier) {\r\n    const ref = compileIdentifier.reference;\r\n    if (ref instanceof StaticSymbol) {\r\n        return ref.filePath;\r\n    }\r\n    // Runtime type\r\n    return `./${stringify(ref)}`;\r\n}\r\nfunction viewClassName(compType, embeddedTemplateIndex) {\r\n    return `View_${identifierName({ reference: compType })}_${embeddedTemplateIndex}`;\r\n}\r\nfunction rendererTypeName(compType) {\r\n    return `RenderType_${identifierName({ reference: compType })}`;\r\n}\r\nfunction hostViewClassName(compType) {\r\n    return `HostView_${identifierName({ reference: compType })}`;\r\n}\r\nfunction componentFactoryName(compType) {\r\n    return `${identifierName({ reference: compType })}NgFactory`;\r\n}\r\nvar CompileSummaryKind;\r\n(function (CompileSummaryKind) {\r\n    CompileSummaryKind[CompileSummaryKind[\"Pipe\"] = 0] = \"Pipe\";\r\n    CompileSummaryKind[CompileSummaryKind[\"Directive\"] = 1] = \"Directive\";\r\n    CompileSummaryKind[CompileSummaryKind[\"NgModule\"] = 2] = \"NgModule\";\r\n    CompileSummaryKind[CompileSummaryKind[\"Injectable\"] = 3] = \"Injectable\";\r\n})(CompileSummaryKind || (CompileSummaryKind = {}));\r\nfunction tokenName(token) {\r\n    return token.value != null ? sanitizeIdentifier(token.value) : identifierName(token.identifier);\r\n}\r\nfunction tokenReference(token) {\r\n    if (token.identifier != null) {\r\n        return token.identifier.reference;\r\n    }\r\n    else {\r\n        return token.value;\r\n    }\r\n}\r\n/**\r\n * Metadata about a stylesheet\r\n */\r\nclass CompileStylesheetMetadata {\r\n    constructor({ moduleUrl, styles, styleUrls } = {}) {\r\n        this.moduleUrl = moduleUrl || null;\r\n        this.styles = _normalizeArray(styles);\r\n        this.styleUrls = _normalizeArray(styleUrls);\r\n    }\r\n}\r\n/**\r\n * Metadata regarding compilation of a template.\r\n */\r\nclass CompileTemplateMetadata {\r\n    constructor({ encapsulation, template, templateUrl, htmlAst, styles, styleUrls, externalStylesheets, animations, ngContentSelectors, interpolation, isInline, preserveWhitespaces }) {\r\n        this.encapsulation = encapsulation;\r\n        this.template = template;\r\n        this.templateUrl = templateUrl;\r\n        this.htmlAst = htmlAst;\r\n        this.styles = _normalizeArray(styles);\r\n        this.styleUrls = _normalizeArray(styleUrls);\r\n        this.externalStylesheets = _normalizeArray(externalStylesheets);\r\n        this.animations = animations ? flatten(animations) : [];\r\n        this.ngContentSelectors = ngContentSelectors || [];\r\n        if (interpolation && interpolation.length != 2) {\r\n            throw new Error(`'interpolation' should have a start and an end symbol.`);\r\n        }\r\n        this.interpolation = interpolation;\r\n        this.isInline = isInline;\r\n        this.preserveWhitespaces = preserveWhitespaces;\r\n    }\r\n    toSummary() {\r\n        return {\r\n            ngContentSelectors: this.ngContentSelectors,\r\n            encapsulation: this.encapsulation,\r\n            styles: this.styles,\r\n            animations: this.animations\r\n        };\r\n    }\r\n}\r\n/**\r\n * Metadata regarding compilation of a directive.\r\n */\r\nclass CompileDirectiveMetadata {\r\n    constructor({ isHost, type, isComponent, selector, exportAs, changeDetection, inputs, outputs, hostListeners, hostProperties, hostAttributes, providers, viewProviders, queries, guards, viewQueries, entryComponents, template, componentViewType, rendererType, componentFactory }) {\r\n        this.isHost = !!isHost;\r\n        this.type = type;\r\n        this.isComponent = isComponent;\r\n        this.selector = selector;\r\n        this.exportAs = exportAs;\r\n        this.changeDetection = changeDetection;\r\n        this.inputs = inputs;\r\n        this.outputs = outputs;\r\n        this.hostListeners = hostListeners;\r\n        this.hostProperties = hostProperties;\r\n        this.hostAttributes = hostAttributes;\r\n        this.providers = _normalizeArray(providers);\r\n        this.viewProviders = _normalizeArray(viewProviders);\r\n        this.queries = _normalizeArray(queries);\r\n        this.guards = guards;\r\n        this.viewQueries = _normalizeArray(viewQueries);\r\n        this.entryComponents = _normalizeArray(entryComponents);\r\n        this.template = template;\r\n        this.componentViewType = componentViewType;\r\n        this.rendererType = rendererType;\r\n        this.componentFactory = componentFactory;\r\n    }\r\n    static create({ isHost, type, isComponent, selector, exportAs, changeDetection, inputs, outputs, host, providers, viewProviders, queries, guards, viewQueries, entryComponents, template, componentViewType, rendererType, componentFactory }) {\r\n        const hostListeners = {};\r\n        const hostProperties = {};\r\n        const hostAttributes = {};\r\n        if (host != null) {\r\n            Object.keys(host).forEach(key => {\r\n                const value = host[key];\r\n                const matches = key.match(HOST_REG_EXP);\r\n                if (matches === null) {\r\n                    hostAttributes[key] = value;\r\n                }\r\n                else if (matches[1] != null) {\r\n                    hostProperties[matches[1]] = value;\r\n                }\r\n                else if (matches[2] != null) {\r\n                    hostListeners[matches[2]] = value;\r\n                }\r\n            });\r\n        }\r\n        const inputsMap = {};\r\n        if (inputs != null) {\r\n            inputs.forEach((bindConfig) => {\r\n                // canonical syntax: `dirProp: elProp`\r\n                // if there is no `:`, use dirProp = elProp\r\n                const parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\r\n                inputsMap[parts[0]] = parts[1];\r\n            });\r\n        }\r\n        const outputsMap = {};\r\n        if (outputs != null) {\r\n            outputs.forEach((bindConfig) => {\r\n                // canonical syntax: `dirProp: elProp`\r\n                // if there is no `:`, use dirProp = elProp\r\n                const parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\r\n                outputsMap[parts[0]] = parts[1];\r\n            });\r\n        }\r\n        return new CompileDirectiveMetadata({\r\n            isHost,\r\n            type,\r\n            isComponent: !!isComponent,\r\n            selector,\r\n            exportAs,\r\n            changeDetection,\r\n            inputs: inputsMap,\r\n            outputs: outputsMap,\r\n            hostListeners,\r\n            hostProperties,\r\n            hostAttributes,\r\n            providers,\r\n            viewProviders,\r\n            queries,\r\n            guards,\r\n            viewQueries,\r\n            entryComponents,\r\n            template,\r\n            componentViewType,\r\n            rendererType,\r\n            componentFactory,\r\n        });\r\n    }\r\n    toSummary() {\r\n        return {\r\n            summaryKind: CompileSummaryKind.Directive,\r\n            type: this.type,\r\n            isComponent: this.isComponent,\r\n            selector: this.selector,\r\n            exportAs: this.exportAs,\r\n            inputs: this.inputs,\r\n            outputs: this.outputs,\r\n            hostListeners: this.hostListeners,\r\n            hostProperties: this.hostProperties,\r\n            hostAttributes: this.hostAttributes,\r\n            providers: this.providers,\r\n            viewProviders: this.viewProviders,\r\n            queries: this.queries,\r\n            guards: this.guards,\r\n            viewQueries: this.viewQueries,\r\n            entryComponents: this.entryComponents,\r\n            changeDetection: this.changeDetection,\r\n            template: this.template && this.template.toSummary(),\r\n            componentViewType: this.componentViewType,\r\n            rendererType: this.rendererType,\r\n            componentFactory: this.componentFactory\r\n        };\r\n    }\r\n}\r\nclass CompilePipeMetadata {\r\n    constructor({ type, name, pure }) {\r\n        this.type = type;\r\n        this.name = name;\r\n        this.pure = !!pure;\r\n    }\r\n    toSummary() {\r\n        return {\r\n            summaryKind: CompileSummaryKind.Pipe,\r\n            type: this.type,\r\n            name: this.name,\r\n            pure: this.pure\r\n        };\r\n    }\r\n}\r\nclass CompileShallowModuleMetadata {\r\n}\r\n/**\r\n * Metadata regarding compilation of a module.\r\n */\r\nclass CompileNgModuleMetadata {\r\n    constructor({ type, providers, declaredDirectives, exportedDirectives, declaredPipes, exportedPipes, entryComponents, bootstrapComponents, importedModules, exportedModules, schemas, transitiveModule, id }) {\r\n        this.type = type || null;\r\n        this.declaredDirectives = _normalizeArray(declaredDirectives);\r\n        this.exportedDirectives = _normalizeArray(exportedDirectives);\r\n        this.declaredPipes = _normalizeArray(declaredPipes);\r\n        this.exportedPipes = _normalizeArray(exportedPipes);\r\n        this.providers = _normalizeArray(providers);\r\n        this.entryComponents = _normalizeArray(entryComponents);\r\n        this.bootstrapComponents = _normalizeArray(bootstrapComponents);\r\n        this.importedModules = _normalizeArray(importedModules);\r\n        this.exportedModules = _normalizeArray(exportedModules);\r\n        this.schemas = _normalizeArray(schemas);\r\n        this.id = id || null;\r\n        this.transitiveModule = transitiveModule || null;\r\n    }\r\n    toSummary() {\r\n        const module = this.transitiveModule;\r\n        return {\r\n            summaryKind: CompileSummaryKind.NgModule,\r\n            type: this.type,\r\n            entryComponents: module.entryComponents,\r\n            providers: module.providers,\r\n            modules: module.modules,\r\n            exportedDirectives: module.exportedDirectives,\r\n            exportedPipes: module.exportedPipes\r\n        };\r\n    }\r\n}\r\nclass TransitiveCompileNgModuleMetadata {\r\n    constructor() {\r\n        this.directivesSet = new Set();\r\n        this.directives = [];\r\n        this.exportedDirectivesSet = new Set();\r\n        this.exportedDirectives = [];\r\n        this.pipesSet = new Set();\r\n        this.pipes = [];\r\n        this.exportedPipesSet = new Set();\r\n        this.exportedPipes = [];\r\n        this.modulesSet = new Set();\r\n        this.modules = [];\r\n        this.entryComponentsSet = new Set();\r\n        this.entryComponents = [];\r\n        this.providers = [];\r\n    }\r\n    addProvider(provider, module) {\r\n        this.providers.push({ provider: provider, module: module });\r\n    }\r\n    addDirective(id) {\r\n        if (!this.directivesSet.has(id.reference)) {\r\n            this.directivesSet.add(id.reference);\r\n            this.directives.push(id);\r\n        }\r\n    }\r\n    addExportedDirective(id) {\r\n        if (!this.exportedDirectivesSet.has(id.reference)) {\r\n            this.exportedDirectivesSet.add(id.reference);\r\n            this.exportedDirectives.push(id);\r\n        }\r\n    }\r\n    addPipe(id) {\r\n        if (!this.pipesSet.has(id.reference)) {\r\n            this.pipesSet.add(id.reference);\r\n            this.pipes.push(id);\r\n        }\r\n    }\r\n    addExportedPipe(id) {\r\n        if (!this.exportedPipesSet.has(id.reference)) {\r\n            this.exportedPipesSet.add(id.reference);\r\n            this.exportedPipes.push(id);\r\n        }\r\n    }\r\n    addModule(id) {\r\n        if (!this.modulesSet.has(id.reference)) {\r\n            this.modulesSet.add(id.reference);\r\n            this.modules.push(id);\r\n        }\r\n    }\r\n    addEntryComponent(ec) {\r\n        if (!this.entryComponentsSet.has(ec.componentType)) {\r\n            this.entryComponentsSet.add(ec.componentType);\r\n            this.entryComponents.push(ec);\r\n        }\r\n    }\r\n}\r\nfunction _normalizeArray(obj) {\r\n    return obj || [];\r\n}\r\nclass ProviderMeta {\r\n    constructor(token, { useClass, useValue, useExisting, useFactory, deps, multi }) {\r\n        this.token = token;\r\n        this.useClass = useClass || null;\r\n        this.useValue = useValue;\r\n        this.useExisting = useExisting;\r\n        this.useFactory = useFactory || null;\r\n        this.dependencies = deps || null;\r\n        this.multi = !!multi;\r\n    }\r\n}\r\nfunction flatten(list) {\r\n    return list.reduce((flat, item) => {\r\n        const flatItem = Array.isArray(item) ? flatten(item) : item;\r\n        return flat.concat(flatItem);\r\n    }, []);\r\n}\r\nfunction jitSourceUrl(url) {\r\n    // Note: We need 3 \"/\" so that ng shows up as a separate domain\r\n    // in the chrome dev tools.\r\n    return url.replace(/(\\w+:\\/\\/[\\w:-]+)?(\\/+)?/, 'ng:///');\r\n}\r\nfunction templateSourceUrl(ngModuleType, compMeta, templateMeta) {\r\n    let url;\r\n    if (templateMeta.isInline) {\r\n        if (compMeta.type.reference instanceof StaticSymbol) {\r\n            // Note: a .ts file might contain multiple components with inline templates,\r\n            // so we need to give them unique urls, as these will be used for sourcemaps.\r\n            url = `${compMeta.type.reference.filePath}.${compMeta.type.reference.name}.html`;\r\n        }\r\n        else {\r\n            url = `${identifierName(ngModuleType)}/${identifierName(compMeta.type)}.html`;\r\n        }\r\n    }\r\n    else {\r\n        url = templateMeta.templateUrl;\r\n    }\r\n    return compMeta.type.reference instanceof StaticSymbol ? url : jitSourceUrl(url);\r\n}\r\nfunction sharedStylesheetJitUrl(meta, id) {\r\n    const pathParts = meta.moduleUrl.split(/\\/\\\\/g);\r\n    const baseName = pathParts[pathParts.length - 1];\r\n    return jitSourceUrl(`css/${id}${baseName}.ngstyle.js`);\r\n}\r\nfunction ngModuleJitUrl(moduleMeta) {\r\n    return jitSourceUrl(`${identifierName(moduleMeta.type)}/module.ngfactory.js`);\r\n}\r\nfunction templateJitUrl(ngModuleType, compMeta) {\r\n    return jitSourceUrl(`${identifierName(ngModuleType)}/${identifierName(compMeta.type)}.ngfactory.js`);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * In TypeScript, tagged template functions expect a \"template object\", which is an array of\r\n * \"cooked\" strings plus a `raw` property that contains an array of \"raw\" strings. This is\r\n * typically constructed with a function called `__makeTemplateObject(cooked, raw)`, but it may not\r\n * be available in all environments.\r\n *\r\n * This is a JavaScript polyfill that uses __makeTemplateObject when it's available, but otherwise\r\n * creates an inline helper with the same functionality.\r\n *\r\n * In the inline function, if `Object.defineProperty` is available we use that to attach the `raw`\r\n * array.\r\n */\r\nconst makeTemplateObjectPolyfill = '(this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,\"raw\",{value:t}):e.raw=t,e})';\r\nclass AbstractJsEmitterVisitor extends AbstractEmitterVisitor {\r\n    constructor() {\r\n        super(false);\r\n    }\r\n    visitDeclareClassStmt(stmt, ctx) {\r\n        ctx.pushClass(stmt);\r\n        this._visitClassConstructor(stmt, ctx);\r\n        if (stmt.parent != null) {\r\n            ctx.print(stmt, `${stmt.name}.prototype = Object.create(`);\r\n            stmt.parent.visitExpression(this, ctx);\r\n            ctx.println(stmt, `.prototype);`);\r\n        }\r\n        stmt.getters.forEach((getter) => this._visitClassGetter(stmt, getter, ctx));\r\n        stmt.methods.forEach((method) => this._visitClassMethod(stmt, method, ctx));\r\n        ctx.popClass();\r\n        return null;\r\n    }\r\n    _visitClassConstructor(stmt, ctx) {\r\n        ctx.print(stmt, `function ${stmt.name}(`);\r\n        if (stmt.constructorMethod != null) {\r\n            this._visitParams(stmt.constructorMethod.params, ctx);\r\n        }\r\n        ctx.println(stmt, `) {`);\r\n        ctx.incIndent();\r\n        if (stmt.constructorMethod != null) {\r\n            if (stmt.constructorMethod.body.length > 0) {\r\n                ctx.println(stmt, `var self = this;`);\r\n                this.visitAllStatements(stmt.constructorMethod.body, ctx);\r\n            }\r\n        }\r\n        ctx.decIndent();\r\n        ctx.println(stmt, `}`);\r\n    }\r\n    _visitClassGetter(stmt, getter, ctx) {\r\n        ctx.println(stmt, `Object.defineProperty(${stmt.name}.prototype, '${getter.name}', { get: function() {`);\r\n        ctx.incIndent();\r\n        if (getter.body.length > 0) {\r\n            ctx.println(stmt, `var self = this;`);\r\n            this.visitAllStatements(getter.body, ctx);\r\n        }\r\n        ctx.decIndent();\r\n        ctx.println(stmt, `}});`);\r\n    }\r\n    _visitClassMethod(stmt, method, ctx) {\r\n        ctx.print(stmt, `${stmt.name}.prototype.${method.name} = function(`);\r\n        this._visitParams(method.params, ctx);\r\n        ctx.println(stmt, `) {`);\r\n        ctx.incIndent();\r\n        if (method.body.length > 0) {\r\n            ctx.println(stmt, `var self = this;`);\r\n            this.visitAllStatements(method.body, ctx);\r\n        }\r\n        ctx.decIndent();\r\n        ctx.println(stmt, `};`);\r\n    }\r\n    visitWrappedNodeExpr(ast, ctx) {\r\n        throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');\r\n    }\r\n    visitReadVarExpr(ast, ctx) {\r\n        if (ast.builtin === BuiltinVar.This) {\r\n            ctx.print(ast, 'self');\r\n        }\r\n        else if (ast.builtin === BuiltinVar.Super) {\r\n            throw new Error(`'super' needs to be handled at a parent ast node, not at the variable level!`);\r\n        }\r\n        else {\r\n            super.visitReadVarExpr(ast, ctx);\r\n        }\r\n        return null;\r\n    }\r\n    visitDeclareVarStmt(stmt, ctx) {\r\n        ctx.print(stmt, `var ${stmt.name}`);\r\n        if (stmt.value) {\r\n            ctx.print(stmt, ' = ');\r\n            stmt.value.visitExpression(this, ctx);\r\n        }\r\n        ctx.println(stmt, `;`);\r\n        return null;\r\n    }\r\n    visitCastExpr(ast, ctx) {\r\n        ast.value.visitExpression(this, ctx);\r\n        return null;\r\n    }\r\n    visitInvokeFunctionExpr(expr, ctx) {\r\n        const fnExpr = expr.fn;\r\n        if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\r\n            ctx.currentClass.parent.visitExpression(this, ctx);\r\n            ctx.print(expr, `.call(this`);\r\n            if (expr.args.length > 0) {\r\n                ctx.print(expr, `, `);\r\n                this.visitAllExpressions(expr.args, ctx, ',');\r\n            }\r\n            ctx.print(expr, `)`);\r\n        }\r\n        else {\r\n            super.visitInvokeFunctionExpr(expr, ctx);\r\n        }\r\n        return null;\r\n    }\r\n    visitTaggedTemplateExpr(ast, ctx) {\r\n        // The following convoluted piece of code is effectively the downlevelled equivalent of\r\n        // ```\r\n        // tag`...`\r\n        // ```\r\n        // which is effectively like:\r\n        // ```\r\n        // tag(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\r\n        // ```\r\n        const elements = ast.template.elements;\r\n        ast.tag.visitExpression(this, ctx);\r\n        ctx.print(ast, `(${makeTemplateObjectPolyfill}(`);\r\n        ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.text, false)).join(', ')}], `);\r\n        ctx.print(ast, `[${elements.map(part => escapeIdentifier(part.rawText, false)).join(', ')}])`);\r\n        ast.template.expressions.forEach(expression => {\r\n            ctx.print(ast, ', ');\r\n            expression.visitExpression(this, ctx);\r\n        });\r\n        ctx.print(ast, ')');\r\n        return null;\r\n    }\r\n    visitFunctionExpr(ast, ctx) {\r\n        ctx.print(ast, `function${ast.name ? ' ' + ast.name : ''}(`);\r\n        this._visitParams(ast.params, ctx);\r\n        ctx.println(ast, `) {`);\r\n        ctx.incIndent();\r\n        this.visitAllStatements(ast.statements, ctx);\r\n        ctx.decIndent();\r\n        ctx.print(ast, `}`);\r\n        return null;\r\n    }\r\n    visitDeclareFunctionStmt(stmt, ctx) {\r\n        ctx.print(stmt, `function ${stmt.name}(`);\r\n        this._visitParams(stmt.params, ctx);\r\n        ctx.println(stmt, `) {`);\r\n        ctx.incIndent();\r\n        this.visitAllStatements(stmt.statements, ctx);\r\n        ctx.decIndent();\r\n        ctx.println(stmt, `}`);\r\n        return null;\r\n    }\r\n    visitTryCatchStmt(stmt, ctx) {\r\n        ctx.println(stmt, `try {`);\r\n        ctx.incIndent();\r\n        this.visitAllStatements(stmt.bodyStmts, ctx);\r\n        ctx.decIndent();\r\n        ctx.println(stmt, `} catch (${CATCH_ERROR_VAR$1.name}) {`);\r\n        ctx.incIndent();\r\n        const catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [\r\n                StmtModifier.Final\r\n            ])].concat(stmt.catchStmts);\r\n        this.visitAllStatements(catchStmts, ctx);\r\n        ctx.decIndent();\r\n        ctx.println(stmt, `}`);\r\n        return null;\r\n    }\r\n    visitLocalizedString(ast, ctx) {\r\n        // The following convoluted piece of code is effectively the downlevelled equivalent of\r\n        // ```\r\n        // $localize `...`\r\n        // ```\r\n        // which is effectively like:\r\n        // ```\r\n        // $localize(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\r\n        // ```\r\n        ctx.print(ast, `$localize(${makeTemplateObjectPolyfill}(`);\r\n        const parts = [ast.serializeI18nHead()];\r\n        for (let i = 1; i < ast.messageParts.length; i++) {\r\n            parts.push(ast.serializeI18nTemplatePart(i));\r\n        }\r\n        ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.cooked, false)).join(', ')}], `);\r\n        ctx.print(ast, `[${parts.map(part => escapeIdentifier(part.raw, false)).join(', ')}])`);\r\n        ast.expressions.forEach(expression => {\r\n            ctx.print(ast, ', ');\r\n            expression.visitExpression(this, ctx);\r\n        });\r\n        ctx.print(ast, ')');\r\n        return null;\r\n    }\r\n    _visitParams(params, ctx) {\r\n        this.visitAllObjects(param => ctx.print(null, param.name), params, ctx, ',');\r\n    }\r\n    getBuiltinMethodName(method) {\r\n        let name;\r\n        switch (method) {\r\n            case BuiltinMethod.ConcatArray:\r\n                name = 'concat';\r\n                break;\r\n            case BuiltinMethod.SubscribeObservable:\r\n                name = 'subscribe';\r\n                break;\r\n            case BuiltinMethod.Bind:\r\n                name = 'bind';\r\n                break;\r\n            default:\r\n                throw new Error(`Unknown builtin method: ${method}`);\r\n        }\r\n        return name;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * The Trusted Types policy, or null if Trusted Types are not\r\n * enabled/supported, or undefined if the policy has not been created yet.\r\n */\r\nlet policy;\r\n/**\r\n * Returns the Trusted Types policy, or null if Trusted Types are not\r\n * enabled/supported. The first call to this function will create the policy.\r\n */\r\nfunction getPolicy() {\r\n    if (policy === undefined) {\r\n        policy = null;\r\n        if (_global.trustedTypes) {\r\n            try {\r\n                policy =\r\n                    _global.trustedTypes.createPolicy('angular#unsafe-jit', {\r\n                        createScript: (s) => s,\r\n                    });\r\n            }\r\n            catch (_a) {\r\n                // trustedTypes.createPolicy throws if called with a name that is\r\n                // already registered, even in report-only mode. Until the API changes,\r\n                // catch the error not to break the applications functionally. In such\r\n                // cases, the code will fall back to using strings.\r\n            }\r\n        }\r\n    }\r\n    return policy;\r\n}\r\n/**\r\n * Unsafely promote a string to a TrustedScript, falling back to strings when\r\n * Trusted Types are not available.\r\n * @security In particular, it must be assured that the provided string will\r\n * never cause an XSS vulnerability if used in a context that will be\r\n * interpreted and executed as a script by a browser, e.g. when calling eval.\r\n */\r\nfunction trustedScriptFromString(script) {\r\n    var _a;\r\n    return ((_a = getPolicy()) === null || _a === void 0 ? void 0 : _a.createScript(script)) || script;\r\n}\r\n/**\r\n * Unsafely call the Function constructor with the given string arguments.\r\n * @security This is a security-sensitive function; any use of this function\r\n * must go through security review. In particular, it must be assured that it\r\n * is only called from the JIT compiler, as use in other code can lead to XSS\r\n * vulnerabilities.\r\n */\r\nfunction newTrustedFunctionForJIT(...args) {\r\n    if (!_global.trustedTypes) {\r\n        // In environments that don't support Trusted Types, fall back to the most\r\n        // straightforward implementation:\r\n        return new Function(...args);\r\n    }\r\n    // Chrome currently does not support passing TrustedScript to the Function\r\n    // constructor. The following implements the workaround proposed on the page\r\n    // below, where the Chromium bug is also referenced:\r\n    // https://github.com/w3c/webappsec-trusted-types/wiki/Trusted-Types-for-function-constructor\r\n    const fnArgs = args.slice(0, -1).join(',');\r\n    const fnBody = args[args.length - 1];\r\n    const body = `(function anonymous(${fnArgs}\r\n) { ${fnBody}\r\n})`;\r\n    // Using eval directly confuses the compiler and prevents this module from\r\n    // being stripped out of JS binaries even if not used. The global['eval']\r\n    // indirection fixes that.\r\n    const fn = _global['eval'](trustedScriptFromString(body));\r\n    if (fn.bind === undefined) {\r\n        // Workaround for a browser bug that only exists in Chrome 83, where passing\r\n        // a TrustedScript to eval just returns the TrustedScript back without\r\n        // evaluating it. In that case, fall back to the most straightforward\r\n        // implementation:\r\n        return new Function(...args);\r\n    }\r\n    // To completely mimic the behavior of calling \"new Function\", two more\r\n    // things need to happen:\r\n    // 1. Stringifying the resulting function should return its source code\r\n    fn.toString = () => body;\r\n    // 2. When calling the resulting function, `this` should refer to `global`\r\n    return fn.bind(_global);\r\n    // When Trusted Types support in Function constructors is widely available,\r\n    // the implementation of this function can be simplified to:\r\n    // return new Function(...args.map(a => trustedScriptFromString(a)));\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A helper class to manage the evaluation of JIT generated code.\r\n */\r\nclass JitEvaluator {\r\n    /**\r\n     *\r\n     * @param sourceUrl The URL of the generated code.\r\n     * @param statements An array of Angular statement AST nodes to be evaluated.\r\n     * @param reflector A helper used when converting the statements to executable code.\r\n     * @param createSourceMaps If true then create a source-map for the generated code and include it\r\n     * inline as a source-map comment.\r\n     * @returns A map of all the variables in the generated code.\r\n     */\r\n    evaluateStatements(sourceUrl, statements, reflector, createSourceMaps) {\r\n        const converter = new JitEmitterVisitor(reflector);\r\n        const ctx = EmitterVisitorContext.createRoot();\r\n        // Ensure generated code is in strict mode\r\n        if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\r\n            statements = [\r\n                literal('use strict').toStmt(),\r\n                ...statements,\r\n            ];\r\n        }\r\n        converter.visitAllStatements(statements, ctx);\r\n        converter.createReturnStmt(ctx);\r\n        return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\r\n    }\r\n    /**\r\n     * Evaluate a piece of JIT generated code.\r\n     * @param sourceUrl The URL of this generated code.\r\n     * @param ctx A context object that contains an AST of the code to be evaluated.\r\n     * @param vars A map containing the names and values of variables that the evaluated code might\r\n     * reference.\r\n     * @param createSourceMap If true then create a source-map for the generated code and include it\r\n     * inline as a source-map comment.\r\n     * @returns The result of evaluating the code.\r\n     */\r\n    evaluateCode(sourceUrl, ctx, vars, createSourceMap) {\r\n        let fnBody = `\"use strict\";${ctx.toSource()}\\n//# sourceURL=${sourceUrl}`;\r\n        const fnArgNames = [];\r\n        const fnArgValues = [];\r\n        for (const argName in vars) {\r\n            fnArgValues.push(vars[argName]);\r\n            fnArgNames.push(argName);\r\n        }\r\n        if (createSourceMap) {\r\n            // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\r\n            // E.g. ```\r\n            // function anonymous(a,b,c\r\n            // /**/) { ... }```\r\n            // We don't want to hard code this fact, so we auto detect it via an empty function first.\r\n            const emptyFn = newTrustedFunctionForJIT(...fnArgNames.concat('return null;')).toString();\r\n            const headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\r\n            fnBody += `\\n${ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment()}`;\r\n        }\r\n        const fn = newTrustedFunctionForJIT(...fnArgNames.concat(fnBody));\r\n        return this.executeFunction(fn, fnArgValues);\r\n    }\r\n    /**\r\n     * Execute a JIT generated function by calling it.\r\n     *\r\n     * This method can be overridden in tests to capture the functions that are generated\r\n     * by this `JitEvaluator` class.\r\n     *\r\n     * @param fn A function to execute.\r\n     * @param args The arguments to pass to the function being executed.\r\n     * @returns The return value of the executed function.\r\n     */\r\n    executeFunction(fn, args) {\r\n        return fn(...args);\r\n    }\r\n}\r\n/**\r\n * An Angular AST visitor that converts AST nodes into executable JavaScript code.\r\n */\r\nclass JitEmitterVisitor extends AbstractJsEmitterVisitor {\r\n    constructor(reflector) {\r\n        super();\r\n        this.reflector = reflector;\r\n        this._evalArgNames = [];\r\n        this._evalArgValues = [];\r\n        this._evalExportedVars = [];\r\n    }\r\n    createReturnStmt(ctx) {\r\n        const stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(resultVar => new LiteralMapEntry(resultVar, variable(resultVar), false))));\r\n        stmt.visitStatement(this, ctx);\r\n    }\r\n    getArgs() {\r\n        const result = {};\r\n        for (let i = 0; i < this._evalArgNames.length; i++) {\r\n            result[this._evalArgNames[i]] = this._evalArgValues[i];\r\n        }\r\n        return result;\r\n    }\r\n    visitExternalExpr(ast, ctx) {\r\n        this._emitReferenceToExternal(ast, this.reflector.resolveExternalReference(ast.value), ctx);\r\n        return null;\r\n    }\r\n    visitWrappedNodeExpr(ast, ctx) {\r\n        this._emitReferenceToExternal(ast, ast.node, ctx);\r\n        return null;\r\n    }\r\n    visitDeclareVarStmt(stmt, ctx) {\r\n        if (stmt.hasModifier(StmtModifier.Exported)) {\r\n            this._evalExportedVars.push(stmt.name);\r\n        }\r\n        return super.visitDeclareVarStmt(stmt, ctx);\r\n    }\r\n    visitDeclareFunctionStmt(stmt, ctx) {\r\n        if (stmt.hasModifier(StmtModifier.Exported)) {\r\n            this._evalExportedVars.push(stmt.name);\r\n        }\r\n        return super.visitDeclareFunctionStmt(stmt, ctx);\r\n    }\r\n    visitDeclareClassStmt(stmt, ctx) {\r\n        if (stmt.hasModifier(StmtModifier.Exported)) {\r\n            this._evalExportedVars.push(stmt.name);\r\n        }\r\n        return super.visitDeclareClassStmt(stmt, ctx);\r\n    }\r\n    _emitReferenceToExternal(ast, value, ctx) {\r\n        let id = this._evalArgValues.indexOf(value);\r\n        if (id === -1) {\r\n            id = this._evalArgValues.length;\r\n            this._evalArgValues.push(value);\r\n            const name = identifierName({ reference: value }) || 'val';\r\n            this._evalArgNames.push(`jit_${name}_${id}`);\r\n        }\r\n        ctx.print(ast, this._evalArgNames[id]);\r\n    }\r\n}\r\nfunction isUseStrictStatement(statement) {\r\n    return statement.isEquivalent(literal('use strict').toStmt());\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst $EOF = 0;\r\nconst $BSPACE = 8;\r\nconst $TAB = 9;\r\nconst $LF = 10;\r\nconst $VTAB = 11;\r\nconst $FF = 12;\r\nconst $CR = 13;\r\nconst $SPACE = 32;\r\nconst $BANG = 33;\r\nconst $DQ = 34;\r\nconst $HASH = 35;\r\nconst $$ = 36;\r\nconst $PERCENT = 37;\r\nconst $AMPERSAND = 38;\r\nconst $SQ = 39;\r\nconst $LPAREN = 40;\r\nconst $RPAREN = 41;\r\nconst $STAR = 42;\r\nconst $PLUS = 43;\r\nconst $COMMA = 44;\r\nconst $MINUS = 45;\r\nconst $PERIOD = 46;\r\nconst $SLASH = 47;\r\nconst $COLON = 58;\r\nconst $SEMICOLON = 59;\r\nconst $LT = 60;\r\nconst $EQ = 61;\r\nconst $GT = 62;\r\nconst $QUESTION = 63;\r\nconst $0 = 48;\r\nconst $7 = 55;\r\nconst $9 = 57;\r\nconst $A = 65;\r\nconst $E = 69;\r\nconst $F = 70;\r\nconst $X = 88;\r\nconst $Z = 90;\r\nconst $LBRACKET = 91;\r\nconst $BACKSLASH = 92;\r\nconst $RBRACKET = 93;\r\nconst $CARET = 94;\r\nconst $_ = 95;\r\nconst $a = 97;\r\nconst $b = 98;\r\nconst $e = 101;\r\nconst $f = 102;\r\nconst $n = 110;\r\nconst $r = 114;\r\nconst $t = 116;\r\nconst $u = 117;\r\nconst $v = 118;\r\nconst $x = 120;\r\nconst $z = 122;\r\nconst $LBRACE = 123;\r\nconst $BAR = 124;\r\nconst $RBRACE = 125;\r\nconst $NBSP = 160;\r\nconst $PIPE = 124;\r\nconst $TILDA = 126;\r\nconst $AT = 64;\r\nconst $BT = 96;\r\nfunction isWhitespace(code) {\r\n    return (code >= $TAB && code <= $SPACE) || (code == $NBSP);\r\n}\r\nfunction isDigit(code) {\r\n    return $0 <= code && code <= $9;\r\n}\r\nfunction isAsciiLetter(code) {\r\n    return code >= $a && code <= $z || code >= $A && code <= $Z;\r\n}\r\nfunction isAsciiHexDigit(code) {\r\n    return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\r\n}\r\nfunction isNewLine(code) {\r\n    return code === $LF || code === $CR;\r\n}\r\nfunction isOctalDigit(code) {\r\n    return $0 <= code && code <= $7;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass ParseLocation {\r\n    constructor(file, offset, line, col) {\r\n        this.file = file;\r\n        this.offset = offset;\r\n        this.line = line;\r\n        this.col = col;\r\n    }\r\n    toString() {\r\n        return this.offset != null ? `${this.file.url}@${this.line}:${this.col}` : this.file.url;\r\n    }\r\n    moveBy(delta) {\r\n        const source = this.file.content;\r\n        const len = source.length;\r\n        let offset = this.offset;\r\n        let line = this.line;\r\n        let col = this.col;\r\n        while (offset > 0 && delta < 0) {\r\n            offset--;\r\n            delta++;\r\n            const ch = source.charCodeAt(offset);\r\n            if (ch == $LF) {\r\n                line--;\r\n                const priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));\r\n                col = priorLine > 0 ? offset - priorLine : offset;\r\n            }\r\n            else {\r\n                col--;\r\n            }\r\n        }\r\n        while (offset < len && delta > 0) {\r\n            const ch = source.charCodeAt(offset);\r\n            offset++;\r\n            delta--;\r\n            if (ch == $LF) {\r\n                line++;\r\n                col = 0;\r\n            }\r\n            else {\r\n                col++;\r\n            }\r\n        }\r\n        return new ParseLocation(this.file, offset, line, col);\r\n    }\r\n    // Return the source around the location\r\n    // Up to `maxChars` or `maxLines` on each side of the location\r\n    getContext(maxChars, maxLines) {\r\n        const content = this.file.content;\r\n        let startOffset = this.offset;\r\n        if (startOffset != null) {\r\n            if (startOffset > content.length - 1) {\r\n                startOffset = content.length - 1;\r\n            }\r\n            let endOffset = startOffset;\r\n            let ctxChars = 0;\r\n            let ctxLines = 0;\r\n            while (ctxChars < maxChars && startOffset > 0) {\r\n                startOffset--;\r\n                ctxChars++;\r\n                if (content[startOffset] == '\\n') {\r\n                    if (++ctxLines == maxLines) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            ctxChars = 0;\r\n            ctxLines = 0;\r\n            while (ctxChars < maxChars && endOffset < content.length - 1) {\r\n                endOffset++;\r\n                ctxChars++;\r\n                if (content[endOffset] == '\\n') {\r\n                    if (++ctxLines == maxLines) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            return {\r\n                before: content.substring(startOffset, this.offset),\r\n                after: content.substring(this.offset, endOffset + 1),\r\n            };\r\n        }\r\n        return null;\r\n    }\r\n}\r\nclass ParseSourceFile {\r\n    constructor(content, url) {\r\n        this.content = content;\r\n        this.url = url;\r\n    }\r\n}\r\nclass ParseSourceSpan {\r\n    /**\r\n     * Create an object that holds information about spans of tokens/nodes captured during\r\n     * lexing/parsing of text.\r\n     *\r\n     * @param start\r\n     * The location of the start of the span (having skipped leading trivia).\r\n     * Skipping leading trivia makes source-spans more \"user friendly\", since things like HTML\r\n     * elements will appear to begin at the start of the opening tag, rather than at the start of any\r\n     * leading trivia, which could include newlines.\r\n     *\r\n     * @param end\r\n     * The location of the end of the span.\r\n     *\r\n     * @param fullStart\r\n     * The start of the token without skipping the leading trivia.\r\n     * This is used by tooling that splits tokens further, such as extracting Angular interpolations\r\n     * from text tokens. Such tooling creates new source-spans relative to the original token's\r\n     * source-span. If leading trivia characters have been skipped then the new source-spans may be\r\n     * incorrectly offset.\r\n     *\r\n     * @param details\r\n     * Additional information (such as identifier names) that should be associated with the span.\r\n     */\r\n    constructor(start, end, fullStart = start, details = null) {\r\n        this.start = start;\r\n        this.end = end;\r\n        this.fullStart = fullStart;\r\n        this.details = details;\r\n    }\r\n    toString() {\r\n        return this.start.file.content.substring(this.start.offset, this.end.offset);\r\n    }\r\n}\r\nvar ParseErrorLevel;\r\n(function (ParseErrorLevel) {\r\n    ParseErrorLevel[ParseErrorLevel[\"WARNING\"] = 0] = \"WARNING\";\r\n    ParseErrorLevel[ParseErrorLevel[\"ERROR\"] = 1] = \"ERROR\";\r\n})(ParseErrorLevel || (ParseErrorLevel = {}));\r\nclass ParseError {\r\n    constructor(span, msg, level = ParseErrorLevel.ERROR) {\r\n        this.span = span;\r\n        this.msg = msg;\r\n        this.level = level;\r\n    }\r\n    contextualMessage() {\r\n        const ctx = this.span.start.getContext(100, 3);\r\n        return ctx ? `${this.msg} (\"${ctx.before}[${ParseErrorLevel[this.level]} ->]${ctx.after}\")` :\r\n            this.msg;\r\n    }\r\n    toString() {\r\n        const details = this.span.details ? `, ${this.span.details}` : '';\r\n        return `${this.contextualMessage()}: ${this.span.start}${details}`;\r\n    }\r\n}\r\nfunction typeSourceSpan(kind, type) {\r\n    const moduleUrl = identifierModuleUrl(type);\r\n    const sourceFileName = moduleUrl != null ? `in ${kind} ${identifierName(type)} in ${moduleUrl}` :\r\n        `in ${kind} ${identifierName(type)}`;\r\n    const sourceFile = new ParseSourceFile('', sourceFileName);\r\n    return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\r\n}\r\n/**\r\n * Generates Source Span object for a given R3 Type for JIT mode.\r\n *\r\n * @param kind Component or Directive.\r\n * @param typeName name of the Component or Directive.\r\n * @param sourceUrl reference to Component or Directive source.\r\n * @returns instance of ParseSourceSpan that represent a given Component or Directive.\r\n */\r\nfunction r3JitTypeSourceSpan(kind, typeName, sourceUrl) {\r\n    const sourceFileName = `in ${kind} ${typeName} in ${sourceUrl}`;\r\n    const sourceFile = new ParseSourceFile('', sourceFileName);\r\n    return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nfunction compileInjector(meta) {\r\n    const definitionMap = new DefinitionMap();\r\n    if (meta.providers !== null) {\r\n        definitionMap.set('providers', meta.providers);\r\n    }\r\n    if (meta.imports.length > 0) {\r\n        definitionMap.set('imports', literalArr(meta.imports));\r\n    }\r\n    const expression = importExpr(Identifiers.defineInjector).callFn([definitionMap.toLiteralMap()], undefined, true);\r\n    const type = createInjectorType(meta);\r\n    return { expression, type, statements: [] };\r\n}\r\nfunction createInjectorType(meta) {\r\n    return new ExpressionType(importExpr(Identifiers.InjectorDeclaration, [new ExpressionType(meta.type.type)]));\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Implementation of `CompileReflector` which resolves references to @angular/core\r\n * symbols at runtime, according to a consumer-provided mapping.\r\n *\r\n * Only supports `resolveExternalReference`, all other methods throw.\r\n */\r\nclass R3JitReflector {\r\n    constructor(context) {\r\n        this.context = context;\r\n    }\r\n    resolveExternalReference(ref) {\r\n        // This reflector only handles @angular/core imports.\r\n        if (ref.moduleName !== '@angular/core') {\r\n            throw new Error(`Cannot resolve external reference to ${ref.moduleName}, only references to @angular/core are supported.`);\r\n        }\r\n        if (!this.context.hasOwnProperty(ref.name)) {\r\n            throw new Error(`No value provided for @angular/core symbol '${ref.name}'.`);\r\n        }\r\n        return this.context[ref.name];\r\n    }\r\n    parameters(typeOrFunc) {\r\n        throw new Error('Not implemented.');\r\n    }\r\n    annotations(typeOrFunc) {\r\n        throw new Error('Not implemented.');\r\n    }\r\n    shallowAnnotations(typeOrFunc) {\r\n        throw new Error('Not implemented.');\r\n    }\r\n    tryAnnotations(typeOrFunc) {\r\n        throw new Error('Not implemented.');\r\n    }\r\n    propMetadata(typeOrFunc) {\r\n        throw new Error('Not implemented.');\r\n    }\r\n    hasLifecycleHook(type, lcProperty) {\r\n        throw new Error('Not implemented.');\r\n    }\r\n    guards(typeOrFunc) {\r\n        throw new Error('Not implemented.');\r\n    }\r\n    componentModuleUrl(type, cmpMetadata) {\r\n        throw new Error('Not implemented.');\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\r\n */\r\nfunction compileNgModule(meta) {\r\n    const { internalType, bootstrap, declarations, imports, exports, schemas, containsForwardDecls, emitInline, id } = meta;\r\n    const statements = [];\r\n    const definitionMap = new DefinitionMap();\r\n    definitionMap.set('type', internalType);\r\n    if (bootstrap.length > 0) {\r\n        definitionMap.set('bootstrap', refsToArray(bootstrap, containsForwardDecls));\r\n    }\r\n    // If requested to emit scope information inline, pass the `declarations`, `imports` and `exports`\r\n    // to the `ɵɵdefineNgModule()` call. The JIT compilation uses this.\r\n    if (emitInline) {\r\n        if (declarations.length > 0) {\r\n            definitionMap.set('declarations', refsToArray(declarations, containsForwardDecls));\r\n        }\r\n        if (imports.length > 0) {\r\n            definitionMap.set('imports', refsToArray(imports, containsForwardDecls));\r\n        }\r\n        if (exports.length > 0) {\r\n            definitionMap.set('exports', refsToArray(exports, containsForwardDecls));\r\n        }\r\n    }\r\n    // If not emitting inline, the scope information is not passed into `ɵɵdefineNgModule` as it would\r\n    // prevent tree-shaking of the declarations, imports and exports references.\r\n    else {\r\n        const setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\r\n        if (setNgModuleScopeCall !== null) {\r\n            statements.push(setNgModuleScopeCall);\r\n        }\r\n    }\r\n    if (schemas !== null && schemas.length > 0) {\r\n        definitionMap.set('schemas', literalArr(schemas.map(ref => ref.value)));\r\n    }\r\n    if (id !== null) {\r\n        definitionMap.set('id', id);\r\n    }\r\n    const expression = importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()], undefined, true);\r\n    const type = createNgModuleType(meta);\r\n    return { expression, type, statements };\r\n}\r\n/**\r\n * This function is used in JIT mode to generate the call to `ɵɵdefineNgModule()` from a call to\r\n * `ɵɵngDeclareNgModule()`.\r\n */\r\nfunction compileNgModuleDeclarationExpression(meta) {\r\n    const definitionMap = new DefinitionMap();\r\n    definitionMap.set('type', new WrappedNodeExpr(meta.type));\r\n    if (meta.bootstrap !== undefined) {\r\n        definitionMap.set('bootstrap', new WrappedNodeExpr(meta.bootstrap));\r\n    }\r\n    if (meta.declarations !== undefined) {\r\n        definitionMap.set('declarations', new WrappedNodeExpr(meta.declarations));\r\n    }\r\n    if (meta.imports !== undefined) {\r\n        definitionMap.set('imports', new WrappedNodeExpr(meta.imports));\r\n    }\r\n    if (meta.exports !== undefined) {\r\n        definitionMap.set('exports', new WrappedNodeExpr(meta.exports));\r\n    }\r\n    if (meta.schemas !== undefined) {\r\n        definitionMap.set('schemas', new WrappedNodeExpr(meta.schemas));\r\n    }\r\n    if (meta.id !== undefined) {\r\n        definitionMap.set('id', new WrappedNodeExpr(meta.id));\r\n    }\r\n    return importExpr(Identifiers.defineNgModule).callFn([definitionMap.toLiteralMap()]);\r\n}\r\nfunction createNgModuleType({ type: moduleType, declarations, imports, exports }) {\r\n    return new ExpressionType(importExpr(Identifiers.NgModuleDeclaration, [\r\n        new ExpressionType(moduleType.type), tupleTypeOf(declarations), tupleTypeOf(imports),\r\n        tupleTypeOf(exports)\r\n    ]));\r\n}\r\n/**\r\n * Generates a function call to `ɵɵsetNgModuleScope` with all necessary information so that the\r\n * transitive module scope can be computed during runtime in JIT mode. This call is marked pure\r\n * such that the references to declarations, imports and exports may be elided causing these\r\n * symbols to become tree-shakeable.\r\n */\r\nfunction generateSetNgModuleScopeCall(meta) {\r\n    const { adjacentType: moduleType, declarations, imports, exports, containsForwardDecls } = meta;\r\n    const scopeMap = new DefinitionMap();\r\n    if (declarations.length > 0) {\r\n        scopeMap.set('declarations', refsToArray(declarations, containsForwardDecls));\r\n    }\r\n    if (imports.length > 0) {\r\n        scopeMap.set('imports', refsToArray(imports, containsForwardDecls));\r\n    }\r\n    if (exports.length > 0) {\r\n        scopeMap.set('exports', refsToArray(exports, containsForwardDecls));\r\n    }\r\n    if (Object.keys(scopeMap.values).length === 0) {\r\n        return null;\r\n    }\r\n    // setNgModuleScope(...)\r\n    const fnCall = new InvokeFunctionExpr(\r\n    /* fn */ importExpr(Identifiers.setNgModuleScope), \r\n    /* args */ [moduleType, scopeMap.toLiteralMap()]);\r\n    // (ngJitMode guard) && setNgModuleScope(...)\r\n    const guardedCall = jitOnlyGuardedExpression(fnCall);\r\n    // function() { (ngJitMode guard) && setNgModuleScope(...); }\r\n    const iife = new FunctionExpr(\r\n    /* params */ [], \r\n    /* statements */ [guardedCall.toStmt()]);\r\n    // (function() { (ngJitMode guard) && setNgModuleScope(...); })()\r\n    const iifeCall = new InvokeFunctionExpr(\r\n    /* fn */ iife, \r\n    /* args */ []);\r\n    return iifeCall.toStmt();\r\n}\r\nfunction tupleTypeOf(exp) {\r\n    const types = exp.map(ref => typeofExpr(ref.type));\r\n    return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nfunction compilePipeFromMetadata(metadata) {\r\n    const definitionMapValues = [];\r\n    // e.g. `name: 'myPipe'`\r\n    definitionMapValues.push({ key: 'name', value: literal(metadata.pipeName), quoted: false });\r\n    // e.g. `type: MyPipe`\r\n    definitionMapValues.push({ key: 'type', value: metadata.type.value, quoted: false });\r\n    // e.g. `pure: true`\r\n    definitionMapValues.push({ key: 'pure', value: literal(metadata.pure), quoted: false });\r\n    const expression = importExpr(Identifiers.definePipe).callFn([literalMap(definitionMapValues)], undefined, true);\r\n    const type = createPipeType(metadata);\r\n    return { expression, type, statements: [] };\r\n}\r\nfunction createPipeType(metadata) {\r\n    return new ExpressionType(importExpr(Identifiers.PipeDeclaration, [\r\n        typeWithParameters(metadata.type.type, metadata.typeArgumentCount),\r\n        new ExpressionType(new LiteralExpr(metadata.pipeName)),\r\n    ]));\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass ParserError {\r\n    constructor(message, input, errLocation, ctxLocation) {\r\n        this.input = input;\r\n        this.errLocation = errLocation;\r\n        this.ctxLocation = ctxLocation;\r\n        this.message = `Parser Error: ${message} ${errLocation} [${input}] in ${ctxLocation}`;\r\n    }\r\n}\r\nclass ParseSpan {\r\n    constructor(start, end) {\r\n        this.start = start;\r\n        this.end = end;\r\n    }\r\n    toAbsolute(absoluteOffset) {\r\n        return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\r\n    }\r\n}\r\nclass AST {\r\n    constructor(span, \r\n    /**\r\n     * Absolute location of the expression AST in a source code file.\r\n     */\r\n    sourceSpan) {\r\n        this.span = span;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return null;\r\n    }\r\n    toString() {\r\n        return 'AST';\r\n    }\r\n}\r\nclass ASTWithName extends AST {\r\n    constructor(span, sourceSpan, nameSpan) {\r\n        super(span, sourceSpan);\r\n        this.nameSpan = nameSpan;\r\n    }\r\n}\r\n/**\r\n * Represents a quoted expression of the form:\r\n *\r\n * quote = prefix `:` uninterpretedExpression\r\n * prefix = identifier\r\n * uninterpretedExpression = arbitrary string\r\n *\r\n * A quoted expression is meant to be pre-processed by an AST transformer that\r\n * converts it into another AST that no longer contains quoted expressions.\r\n * It is meant to allow third-party developers to extend Angular template\r\n * expression language. The `uninterpretedExpression` part of the quote is\r\n * therefore not interpreted by the Angular's own expression parser.\r\n */\r\nclass Quote extends AST {\r\n    constructor(span, sourceSpan, prefix, uninterpretedExpression, location) {\r\n        super(span, sourceSpan);\r\n        this.prefix = prefix;\r\n        this.uninterpretedExpression = uninterpretedExpression;\r\n        this.location = location;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitQuote(this, context);\r\n    }\r\n    toString() {\r\n        return 'Quote';\r\n    }\r\n}\r\nclass EmptyExpr extends AST {\r\n    visit(visitor, context = null) {\r\n        // do nothing\r\n    }\r\n}\r\nclass ImplicitReceiver extends AST {\r\n    visit(visitor, context = null) {\r\n        return visitor.visitImplicitReceiver(this, context);\r\n    }\r\n}\r\n/**\r\n * Receiver when something is accessed through `this` (e.g. `this.foo`). Note that this class\r\n * inherits from `ImplicitReceiver`, because accessing something through `this` is treated the\r\n * same as accessing it implicitly inside of an Angular template (e.g. `[attr.title]=\"this.title\"`\r\n * is the same as `[attr.title]=\"title\"`.). Inheriting allows for the `this` accesses to be treated\r\n * the same as implicit ones, except for a couple of exceptions like `$event` and `$any`.\r\n * TODO: we should find a way for this class not to extend from `ImplicitReceiver` in the future.\r\n */\r\nclass ThisReceiver extends ImplicitReceiver {\r\n    visit(visitor, context = null) {\r\n        var _a;\r\n        return (_a = visitor.visitThisReceiver) === null || _a === void 0 ? void 0 : _a.call(visitor, this, context);\r\n    }\r\n}\r\n/**\r\n * Multiple expressions separated by a semicolon.\r\n */\r\nclass Chain extends AST {\r\n    constructor(span, sourceSpan, expressions) {\r\n        super(span, sourceSpan);\r\n        this.expressions = expressions;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitChain(this, context);\r\n    }\r\n}\r\nclass Conditional extends AST {\r\n    constructor(span, sourceSpan, condition, trueExp, falseExp) {\r\n        super(span, sourceSpan);\r\n        this.condition = condition;\r\n        this.trueExp = trueExp;\r\n        this.falseExp = falseExp;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitConditional(this, context);\r\n    }\r\n}\r\nclass PropertyRead extends ASTWithName {\r\n    constructor(span, sourceSpan, nameSpan, receiver, name) {\r\n        super(span, sourceSpan, nameSpan);\r\n        this.receiver = receiver;\r\n        this.name = name;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitPropertyRead(this, context);\r\n    }\r\n}\r\nclass PropertyWrite extends ASTWithName {\r\n    constructor(span, sourceSpan, nameSpan, receiver, name, value) {\r\n        super(span, sourceSpan, nameSpan);\r\n        this.receiver = receiver;\r\n        this.name = name;\r\n        this.value = value;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitPropertyWrite(this, context);\r\n    }\r\n}\r\nclass SafePropertyRead extends ASTWithName {\r\n    constructor(span, sourceSpan, nameSpan, receiver, name) {\r\n        super(span, sourceSpan, nameSpan);\r\n        this.receiver = receiver;\r\n        this.name = name;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitSafePropertyRead(this, context);\r\n    }\r\n}\r\nclass KeyedRead extends AST {\r\n    constructor(span, sourceSpan, receiver, key) {\r\n        super(span, sourceSpan);\r\n        this.receiver = receiver;\r\n        this.key = key;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitKeyedRead(this, context);\r\n    }\r\n}\r\nclass SafeKeyedRead extends AST {\r\n    constructor(span, sourceSpan, receiver, key) {\r\n        super(span, sourceSpan);\r\n        this.receiver = receiver;\r\n        this.key = key;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitSafeKeyedRead(this, context);\r\n    }\r\n}\r\nclass KeyedWrite extends AST {\r\n    constructor(span, sourceSpan, receiver, key, value) {\r\n        super(span, sourceSpan);\r\n        this.receiver = receiver;\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitKeyedWrite(this, context);\r\n    }\r\n}\r\nclass BindingPipe extends ASTWithName {\r\n    constructor(span, sourceSpan, exp, name, args, nameSpan) {\r\n        super(span, sourceSpan, nameSpan);\r\n        this.exp = exp;\r\n        this.name = name;\r\n        this.args = args;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitPipe(this, context);\r\n    }\r\n}\r\nclass LiteralPrimitive extends AST {\r\n    constructor(span, sourceSpan, value) {\r\n        super(span, sourceSpan);\r\n        this.value = value;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitLiteralPrimitive(this, context);\r\n    }\r\n}\r\nclass LiteralArray extends AST {\r\n    constructor(span, sourceSpan, expressions) {\r\n        super(span, sourceSpan);\r\n        this.expressions = expressions;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitLiteralArray(this, context);\r\n    }\r\n}\r\nclass LiteralMap extends AST {\r\n    constructor(span, sourceSpan, keys, values) {\r\n        super(span, sourceSpan);\r\n        this.keys = keys;\r\n        this.values = values;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitLiteralMap(this, context);\r\n    }\r\n}\r\nclass Interpolation extends AST {\r\n    constructor(span, sourceSpan, strings, expressions) {\r\n        super(span, sourceSpan);\r\n        this.strings = strings;\r\n        this.expressions = expressions;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitInterpolation(this, context);\r\n    }\r\n}\r\nclass Binary extends AST {\r\n    constructor(span, sourceSpan, operation, left, right) {\r\n        super(span, sourceSpan);\r\n        this.operation = operation;\r\n        this.left = left;\r\n        this.right = right;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitBinary(this, context);\r\n    }\r\n}\r\n/**\r\n * For backwards compatibility reasons, `Unary` inherits from `Binary` and mimics the binary AST\r\n * node that was originally used. This inheritance relation can be deleted in some future major,\r\n * after consumers have been given a chance to fully support Unary.\r\n */\r\nclass Unary extends Binary {\r\n    /**\r\n     * During the deprecation period this constructor is private, to avoid consumers from creating\r\n     * a `Unary` with the fallback properties for `Binary`.\r\n     */\r\n    constructor(span, sourceSpan, operator, expr, binaryOp, binaryLeft, binaryRight) {\r\n        super(span, sourceSpan, binaryOp, binaryLeft, binaryRight);\r\n        this.operator = operator;\r\n        this.expr = expr;\r\n    }\r\n    /**\r\n     * Creates a unary minus expression \"-x\", represented as `Binary` using \"0 - x\".\r\n     */\r\n    static createMinus(span, sourceSpan, expr) {\r\n        return new Unary(span, sourceSpan, '-', expr, '-', new LiteralPrimitive(span, sourceSpan, 0), expr);\r\n    }\r\n    /**\r\n     * Creates a unary plus expression \"+x\", represented as `Binary` using \"x - 0\".\r\n     */\r\n    static createPlus(span, sourceSpan, expr) {\r\n        return new Unary(span, sourceSpan, '+', expr, '-', expr, new LiteralPrimitive(span, sourceSpan, 0));\r\n    }\r\n    visit(visitor, context = null) {\r\n        if (visitor.visitUnary !== undefined) {\r\n            return visitor.visitUnary(this, context);\r\n        }\r\n        return visitor.visitBinary(this, context);\r\n    }\r\n}\r\nclass PrefixNot extends AST {\r\n    constructor(span, sourceSpan, expression) {\r\n        super(span, sourceSpan);\r\n        this.expression = expression;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitPrefixNot(this, context);\r\n    }\r\n}\r\nclass NonNullAssert extends AST {\r\n    constructor(span, sourceSpan, expression) {\r\n        super(span, sourceSpan);\r\n        this.expression = expression;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitNonNullAssert(this, context);\r\n    }\r\n}\r\nclass MethodCall extends ASTWithName {\r\n    constructor(span, sourceSpan, nameSpan, receiver, name, args, argumentSpan) {\r\n        super(span, sourceSpan, nameSpan);\r\n        this.receiver = receiver;\r\n        this.name = name;\r\n        this.args = args;\r\n        this.argumentSpan = argumentSpan;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitMethodCall(this, context);\r\n    }\r\n}\r\nclass SafeMethodCall extends ASTWithName {\r\n    constructor(span, sourceSpan, nameSpan, receiver, name, args, argumentSpan) {\r\n        super(span, sourceSpan, nameSpan);\r\n        this.receiver = receiver;\r\n        this.name = name;\r\n        this.args = args;\r\n        this.argumentSpan = argumentSpan;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitSafeMethodCall(this, context);\r\n    }\r\n}\r\nclass FunctionCall extends AST {\r\n    constructor(span, sourceSpan, target, args) {\r\n        super(span, sourceSpan);\r\n        this.target = target;\r\n        this.args = args;\r\n    }\r\n    visit(visitor, context = null) {\r\n        return visitor.visitFunctionCall(this, context);\r\n    }\r\n}\r\n/**\r\n * Records the absolute position of a text span in a source file, where `start` and `end` are the\r\n * starting and ending byte offsets, respectively, of the text span in a source file.\r\n */\r\nclass AbsoluteSourceSpan {\r\n    constructor(start, end) {\r\n        this.start = start;\r\n        this.end = end;\r\n    }\r\n}\r\nclass ASTWithSource extends AST {\r\n    constructor(ast, source, location, absoluteOffset, errors) {\r\n        super(new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));\r\n        this.ast = ast;\r\n        this.source = source;\r\n        this.location = location;\r\n        this.errors = errors;\r\n    }\r\n    visit(visitor, context = null) {\r\n        if (visitor.visitASTWithSource) {\r\n            return visitor.visitASTWithSource(this, context);\r\n        }\r\n        return this.ast.visit(visitor, context);\r\n    }\r\n    toString() {\r\n        return `${this.source} in ${this.location}`;\r\n    }\r\n}\r\nclass VariableBinding {\r\n    /**\r\n     * @param sourceSpan entire span of the binding.\r\n     * @param key name of the LHS along with its span.\r\n     * @param value optional value for the RHS along with its span.\r\n     */\r\n    constructor(sourceSpan, key, value) {\r\n        this.sourceSpan = sourceSpan;\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n}\r\nclass ExpressionBinding {\r\n    /**\r\n     * @param sourceSpan entire span of the binding.\r\n     * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its\r\n     * span. Note that the length of the span may not be the same as\r\n     * `key.source.length`. For example,\r\n     * 1. key.source = ngFor, key.span is for \"ngFor\"\r\n     * 2. key.source = ngForOf, key.span is for \"of\"\r\n     * 3. key.source = ngForTrackBy, key.span is for \"trackBy\"\r\n     * @param value optional expression for the RHS.\r\n     */\r\n    constructor(sourceSpan, key, value) {\r\n        this.sourceSpan = sourceSpan;\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n}\r\nclass RecursiveAstVisitor$1 {\r\n    visit(ast, context) {\r\n        // The default implementation just visits every node.\r\n        // Classes that extend RecursiveAstVisitor should override this function\r\n        // to selectively visit the specified node.\r\n        ast.visit(this, context);\r\n    }\r\n    visitUnary(ast, context) {\r\n        this.visit(ast.expr, context);\r\n    }\r\n    visitBinary(ast, context) {\r\n        this.visit(ast.left, context);\r\n        this.visit(ast.right, context);\r\n    }\r\n    visitChain(ast, context) {\r\n        this.visitAll(ast.expressions, context);\r\n    }\r\n    visitConditional(ast, context) {\r\n        this.visit(ast.condition, context);\r\n        this.visit(ast.trueExp, context);\r\n        this.visit(ast.falseExp, context);\r\n    }\r\n    visitPipe(ast, context) {\r\n        this.visit(ast.exp, context);\r\n        this.visitAll(ast.args, context);\r\n    }\r\n    visitFunctionCall(ast, context) {\r\n        if (ast.target) {\r\n            this.visit(ast.target, context);\r\n        }\r\n        this.visitAll(ast.args, context);\r\n    }\r\n    visitImplicitReceiver(ast, context) { }\r\n    visitThisReceiver(ast, context) { }\r\n    visitInterpolation(ast, context) {\r\n        this.visitAll(ast.expressions, context);\r\n    }\r\n    visitKeyedRead(ast, context) {\r\n        this.visit(ast.receiver, context);\r\n        this.visit(ast.key, context);\r\n    }\r\n    visitKeyedWrite(ast, context) {\r\n        this.visit(ast.receiver, context);\r\n        this.visit(ast.key, context);\r\n        this.visit(ast.value, context);\r\n    }\r\n    visitLiteralArray(ast, context) {\r\n        this.visitAll(ast.expressions, context);\r\n    }\r\n    visitLiteralMap(ast, context) {\r\n        this.visitAll(ast.values, context);\r\n    }\r\n    visitLiteralPrimitive(ast, context) { }\r\n    visitMethodCall(ast, context) {\r\n        this.visit(ast.receiver, context);\r\n        this.visitAll(ast.args, context);\r\n    }\r\n    visitPrefixNot(ast, context) {\r\n        this.visit(ast.expression, context);\r\n    }\r\n    visitNonNullAssert(ast, context) {\r\n        this.visit(ast.expression, context);\r\n    }\r\n    visitPropertyRead(ast, context) {\r\n        this.visit(ast.receiver, context);\r\n    }\r\n    visitPropertyWrite(ast, context) {\r\n        this.visit(ast.receiver, context);\r\n        this.visit(ast.value, context);\r\n    }\r\n    visitSafePropertyRead(ast, context) {\r\n        this.visit(ast.receiver, context);\r\n    }\r\n    visitSafeMethodCall(ast, context) {\r\n        this.visit(ast.receiver, context);\r\n        this.visitAll(ast.args, context);\r\n    }\r\n    visitSafeKeyedRead(ast, context) {\r\n        this.visit(ast.receiver, context);\r\n        this.visit(ast.key, context);\r\n    }\r\n    visitQuote(ast, context) { }\r\n    // This is not part of the AstVisitor interface, just a helper method\r\n    visitAll(asts, context) {\r\n        for (const ast of asts) {\r\n            this.visit(ast, context);\r\n        }\r\n    }\r\n}\r\nclass AstTransformer$1 {\r\n    visitImplicitReceiver(ast, context) {\r\n        return ast;\r\n    }\r\n    visitThisReceiver(ast, context) {\r\n        return ast;\r\n    }\r\n    visitInterpolation(ast, context) {\r\n        return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));\r\n    }\r\n    visitLiteralPrimitive(ast, context) {\r\n        return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);\r\n    }\r\n    visitPropertyRead(ast, context) {\r\n        return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\r\n    }\r\n    visitPropertyWrite(ast, context) {\r\n        return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, ast.value.visit(this));\r\n    }\r\n    visitSafePropertyRead(ast, context) {\r\n        return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\r\n    }\r\n    visitMethodCall(ast, context) {\r\n        return new MethodCall(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args), ast.argumentSpan);\r\n    }\r\n    visitSafeMethodCall(ast, context) {\r\n        return new SafeMethodCall(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args), ast.argumentSpan);\r\n    }\r\n    visitFunctionCall(ast, context) {\r\n        return new FunctionCall(ast.span, ast.sourceSpan, ast.target.visit(this), this.visitAll(ast.args));\r\n    }\r\n    visitLiteralArray(ast, context) {\r\n        return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\r\n    }\r\n    visitLiteralMap(ast, context) {\r\n        return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));\r\n    }\r\n    visitUnary(ast, context) {\r\n        switch (ast.operator) {\r\n            case '+':\r\n                return Unary.createPlus(ast.span, ast.sourceSpan, ast.expr.visit(this));\r\n            case '-':\r\n                return Unary.createMinus(ast.span, ast.sourceSpan, ast.expr.visit(this));\r\n            default:\r\n                throw new Error(`Unknown unary operator ${ast.operator}`);\r\n        }\r\n    }\r\n    visitBinary(ast, context) {\r\n        return new Binary(ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));\r\n    }\r\n    visitPrefixNot(ast, context) {\r\n        return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));\r\n    }\r\n    visitNonNullAssert(ast, context) {\r\n        return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));\r\n    }\r\n    visitConditional(ast, context) {\r\n        return new Conditional(ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\r\n    }\r\n    visitPipe(ast, context) {\r\n        return new BindingPipe(ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args), ast.nameSpan);\r\n    }\r\n    visitKeyedRead(ast, context) {\r\n        return new KeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));\r\n    }\r\n    visitKeyedWrite(ast, context) {\r\n        return new KeyedWrite(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this), ast.value.visit(this));\r\n    }\r\n    visitAll(asts) {\r\n        const res = [];\r\n        for (let i = 0; i < asts.length; ++i) {\r\n            res[i] = asts[i].visit(this);\r\n        }\r\n        return res;\r\n    }\r\n    visitChain(ast, context) {\r\n        return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\r\n    }\r\n    visitQuote(ast, context) {\r\n        return new Quote(ast.span, ast.sourceSpan, ast.prefix, ast.uninterpretedExpression, ast.location);\r\n    }\r\n    visitSafeKeyedRead(ast, context) {\r\n        return new SafeKeyedRead(ast.span, ast.sourceSpan, ast.receiver.visit(this), ast.key.visit(this));\r\n    }\r\n}\r\n// A transformer that only creates new nodes if the transformer makes a change or\r\n// a change is made a child node.\r\nclass AstMemoryEfficientTransformer {\r\n    visitImplicitReceiver(ast, context) {\r\n        return ast;\r\n    }\r\n    visitThisReceiver(ast, context) {\r\n        return ast;\r\n    }\r\n    visitInterpolation(ast, context) {\r\n        const expressions = this.visitAll(ast.expressions);\r\n        if (expressions !== ast.expressions)\r\n            return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);\r\n        return ast;\r\n    }\r\n    visitLiteralPrimitive(ast, context) {\r\n        return ast;\r\n    }\r\n    visitPropertyRead(ast, context) {\r\n        const receiver = ast.receiver.visit(this);\r\n        if (receiver !== ast.receiver) {\r\n            return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\r\n        }\r\n        return ast;\r\n    }\r\n    visitPropertyWrite(ast, context) {\r\n        const receiver = ast.receiver.visit(this);\r\n        const value = ast.value.visit(this);\r\n        if (receiver !== ast.receiver || value !== ast.value) {\r\n            return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);\r\n        }\r\n        return ast;\r\n    }\r\n    visitSafePropertyRead(ast, context) {\r\n        const receiver = ast.receiver.visit(this);\r\n        if (receiver !== ast.receiver) {\r\n            return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\r\n        }\r\n        return ast;\r\n    }\r\n    visitMethodCall(ast, context) {\r\n        const receiver = ast.receiver.visit(this);\r\n        const args = this.visitAll(ast.args);\r\n        if (receiver !== ast.receiver || args !== ast.args) {\r\n            return new MethodCall(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args, ast.argumentSpan);\r\n        }\r\n        return ast;\r\n    }\r\n    visitSafeMethodCall(ast, context) {\r\n        const receiver = ast.receiver.visit(this);\r\n        const args = this.visitAll(ast.args);\r\n        if (receiver !== ast.receiver || args !== ast.args) {\r\n            return new SafeMethodCall(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args, ast.argumentSpan);\r\n        }\r\n        return ast;\r\n    }\r\n    visitFunctionCall(ast, context) {\r\n        const target = ast.target && ast.target.visit(this);\r\n        const args = this.visitAll(ast.args);\r\n        if (target !== ast.target || args !== ast.args) {\r\n            return new FunctionCall(ast.span, ast.sourceSpan, target, args);\r\n        }\r\n        return ast;\r\n    }\r\n    visitLiteralArray(ast, context) {\r\n        const expressions = this.visitAll(ast.expressions);\r\n        if (expressions !== ast.expressions) {\r\n            return new LiteralArray(ast.span, ast.sourceSpan, expressions);\r\n        }\r\n        return ast;\r\n    }\r\n    visitLiteralMap(ast, context) {\r\n        const values = this.visitAll(ast.values);\r\n        if (values !== ast.values) {\r\n            return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);\r\n        }\r\n        return ast;\r\n    }\r\n    visitUnary(ast, context) {\r\n        const expr = ast.expr.visit(this);\r\n        if (expr !== ast.expr) {\r\n            switch (ast.operator) {\r\n                case '+':\r\n                    return Unary.createPlus(ast.span, ast.sourceSpan, expr);\r\n                case '-':\r\n                    return Unary.createMinus(ast.span, ast.sourceSpan, expr);\r\n                default:\r\n                    throw new Error(`Unknown unary operator ${ast.operator}`);\r\n            }\r\n        }\r\n        return ast;\r\n    }\r\n    visitBinary(ast, context) {\r\n        const left = ast.left.visit(this);\r\n        const right = ast.right.visit(this);\r\n        if (left !== ast.left || right !== ast.right) {\r\n            return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);\r\n        }\r\n        return ast;\r\n    }\r\n    visitPrefixNot(ast, context) {\r\n        const expression = ast.expression.visit(this);\r\n        if (expression !== ast.expression) {\r\n            return new PrefixNot(ast.span, ast.sourceSpan, expression);\r\n        }\r\n        return ast;\r\n    }\r\n    visitNonNullAssert(ast, context) {\r\n        const expression = ast.expression.visit(this);\r\n        if (expression !== ast.expression) {\r\n            return new NonNullAssert(ast.span, ast.sourceSpan, expression);\r\n        }\r\n        return ast;\r\n    }\r\n    visitConditional(ast, context) {\r\n        const condition = ast.condition.visit(this);\r\n        const trueExp = ast.trueExp.visit(this);\r\n        const falseExp = ast.falseExp.visit(this);\r\n        if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {\r\n            return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);\r\n        }\r\n        return ast;\r\n    }\r\n    visitPipe(ast, context) {\r\n        const exp = ast.exp.visit(this);\r\n        const args = this.visitAll(ast.args);\r\n        if (exp !== ast.exp || args !== ast.args) {\r\n            return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);\r\n        }\r\n        return ast;\r\n    }\r\n    visitKeyedRead(ast, context) {\r\n        const obj = ast.receiver.visit(this);\r\n        const key = ast.key.visit(this);\r\n        if (obj !== ast.receiver || key !== ast.key) {\r\n            return new KeyedRead(ast.span, ast.sourceSpan, obj, key);\r\n        }\r\n        return ast;\r\n    }\r\n    visitKeyedWrite(ast, context) {\r\n        const obj = ast.receiver.visit(this);\r\n        const key = ast.key.visit(this);\r\n        const value = ast.value.visit(this);\r\n        if (obj !== ast.receiver || key !== ast.key || value !== ast.value) {\r\n            return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);\r\n        }\r\n        return ast;\r\n    }\r\n    visitAll(asts) {\r\n        const res = [];\r\n        let modified = false;\r\n        for (let i = 0; i < asts.length; ++i) {\r\n            const original = asts[i];\r\n            const value = original.visit(this);\r\n            res[i] = value;\r\n            modified = modified || value !== original;\r\n        }\r\n        return modified ? res : asts;\r\n    }\r\n    visitChain(ast, context) {\r\n        const expressions = this.visitAll(ast.expressions);\r\n        if (expressions !== ast.expressions) {\r\n            return new Chain(ast.span, ast.sourceSpan, expressions);\r\n        }\r\n        return ast;\r\n    }\r\n    visitQuote(ast, context) {\r\n        return ast;\r\n    }\r\n    visitSafeKeyedRead(ast, context) {\r\n        const obj = ast.receiver.visit(this);\r\n        const key = ast.key.visit(this);\r\n        if (obj !== ast.receiver || key !== ast.key) {\r\n            return new SafeKeyedRead(ast.span, ast.sourceSpan, obj, key);\r\n        }\r\n        return ast;\r\n    }\r\n}\r\n// Bindings\r\nclass ParsedProperty {\r\n    constructor(name, expression, type, \r\n    // TODO(FW-2095): `keySpan` should really be required but allows `undefined` so VE does\r\n    // not need to be updated. Make `keySpan` required when VE is removed.\r\n    sourceSpan, keySpan, valueSpan) {\r\n        this.name = name;\r\n        this.expression = expression;\r\n        this.type = type;\r\n        this.sourceSpan = sourceSpan;\r\n        this.keySpan = keySpan;\r\n        this.valueSpan = valueSpan;\r\n        this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\r\n        this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\r\n    }\r\n}\r\nvar ParsedPropertyType;\r\n(function (ParsedPropertyType) {\r\n    ParsedPropertyType[ParsedPropertyType[\"DEFAULT\"] = 0] = \"DEFAULT\";\r\n    ParsedPropertyType[ParsedPropertyType[\"LITERAL_ATTR\"] = 1] = \"LITERAL_ATTR\";\r\n    ParsedPropertyType[ParsedPropertyType[\"ANIMATION\"] = 2] = \"ANIMATION\";\r\n})(ParsedPropertyType || (ParsedPropertyType = {}));\r\nclass ParsedEvent {\r\n    // Regular events have a target\r\n    // Animation events have a phase\r\n    constructor(name, targetOrPhase, type, handler, sourceSpan, \r\n    // TODO(FW-2095): keySpan should be required but was made optional to avoid changing VE\r\n    handlerSpan, keySpan) {\r\n        this.name = name;\r\n        this.targetOrPhase = targetOrPhase;\r\n        this.type = type;\r\n        this.handler = handler;\r\n        this.sourceSpan = sourceSpan;\r\n        this.handlerSpan = handlerSpan;\r\n        this.keySpan = keySpan;\r\n    }\r\n}\r\n/**\r\n * ParsedVariable represents a variable declaration in a microsyntax expression.\r\n */\r\nclass ParsedVariable {\r\n    constructor(name, value, sourceSpan, keySpan, valueSpan) {\r\n        this.name = name;\r\n        this.value = value;\r\n        this.sourceSpan = sourceSpan;\r\n        this.keySpan = keySpan;\r\n        this.valueSpan = valueSpan;\r\n    }\r\n}\r\nclass BoundElementProperty {\r\n    constructor(name, type, securityContext, value, unit, sourceSpan, keySpan, valueSpan) {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.securityContext = securityContext;\r\n        this.value = value;\r\n        this.unit = unit;\r\n        this.sourceSpan = sourceSpan;\r\n        this.keySpan = keySpan;\r\n        this.valueSpan = valueSpan;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst CORE$1 = '@angular/core';\r\nclass Identifiers$1 {\r\n}\r\nIdentifiers$1.ANALYZE_FOR_ENTRY_COMPONENTS = {\r\n    name: 'ANALYZE_FOR_ENTRY_COMPONENTS',\r\n    moduleName: CORE$1,\r\n};\r\nIdentifiers$1.ElementRef = { name: 'ElementRef', moduleName: CORE$1 };\r\nIdentifiers$1.NgModuleRef = { name: 'NgModuleRef', moduleName: CORE$1 };\r\nIdentifiers$1.ViewContainerRef = { name: 'ViewContainerRef', moduleName: CORE$1 };\r\nIdentifiers$1.ChangeDetectorRef = {\r\n    name: 'ChangeDetectorRef',\r\n    moduleName: CORE$1,\r\n};\r\nIdentifiers$1.QueryList = { name: 'QueryList', moduleName: CORE$1 };\r\nIdentifiers$1.TemplateRef = { name: 'TemplateRef', moduleName: CORE$1 };\r\nIdentifiers$1.Renderer2 = { name: 'Renderer2', moduleName: CORE$1 };\r\nIdentifiers$1.CodegenComponentFactoryResolver = {\r\n    name: 'ɵCodegenComponentFactoryResolver',\r\n    moduleName: CORE$1,\r\n};\r\nIdentifiers$1.ComponentFactoryResolver = {\r\n    name: 'ComponentFactoryResolver',\r\n    moduleName: CORE$1,\r\n};\r\nIdentifiers$1.ComponentFactory = { name: 'ComponentFactory', moduleName: CORE$1 };\r\nIdentifiers$1.ComponentRef = { name: 'ComponentRef', moduleName: CORE$1 };\r\nIdentifiers$1.NgModuleFactory = { name: 'NgModuleFactory', moduleName: CORE$1 };\r\nIdentifiers$1.createModuleFactory = {\r\n    name: 'ɵcmf',\r\n    moduleName: CORE$1,\r\n};\r\nIdentifiers$1.moduleDef = {\r\n    name: 'ɵmod',\r\n    moduleName: CORE$1,\r\n};\r\nIdentifiers$1.moduleProviderDef = {\r\n    name: 'ɵmpd',\r\n    moduleName: CORE$1,\r\n};\r\nIdentifiers$1.RegisterModuleFactoryFn = {\r\n    name: 'ɵregisterModuleFactory',\r\n    moduleName: CORE$1,\r\n};\r\nIdentifiers$1.inject = { name: 'ɵɵinject', moduleName: CORE$1 };\r\nIdentifiers$1.directiveInject = { name: 'ɵɵdirectiveInject', moduleName: CORE$1 };\r\nIdentifiers$1.INJECTOR = { name: 'INJECTOR', moduleName: CORE$1 };\r\nIdentifiers$1.Injector = { name: 'Injector', moduleName: CORE$1 };\r\nIdentifiers$1.ViewEncapsulation = {\r\n    name: 'ViewEncapsulation',\r\n    moduleName: CORE$1,\r\n};\r\nIdentifiers$1.ChangeDetectionStrategy = {\r\n    name: 'ChangeDetectionStrategy',\r\n    moduleName: CORE$1,\r\n};\r\nIdentifiers$1.SecurityContext = {\r\n    name: 'SecurityContext',\r\n    moduleName: CORE$1,\r\n};\r\nIdentifiers$1.LOCALE_ID = { name: 'LOCALE_ID', moduleName: CORE$1 };\r\nIdentifiers$1.TRANSLATIONS_FORMAT = {\r\n    name: 'TRANSLATIONS_FORMAT',\r\n    moduleName: CORE$1,\r\n};\r\nIdentifiers$1.inlineInterpolate = {\r\n    name: 'ɵinlineInterpolate',\r\n    moduleName: CORE$1,\r\n};\r\nIdentifiers$1.interpolate = { name: 'ɵinterpolate', moduleName: CORE$1 };\r\nIdentifiers$1.EMPTY_ARRAY = { name: 'ɵEMPTY_ARRAY', moduleName: CORE$1 };\r\nIdentifiers$1.EMPTY_MAP = { name: 'ɵEMPTY_MAP', moduleName: CORE$1 };\r\nIdentifiers$1.Renderer = { name: 'Renderer', moduleName: CORE$1 };\r\nIdentifiers$1.viewDef = { name: 'ɵvid', moduleName: CORE$1 };\r\nIdentifiers$1.elementDef = { name: 'ɵeld', moduleName: CORE$1 };\r\nIdentifiers$1.anchorDef = { name: 'ɵand', moduleName: CORE$1 };\r\nIdentifiers$1.textDef = { name: 'ɵted', moduleName: CORE$1 };\r\nIdentifiers$1.directiveDef = { name: 'ɵdid', moduleName: CORE$1 };\r\nIdentifiers$1.providerDef = { name: 'ɵprd', moduleName: CORE$1 };\r\nIdentifiers$1.queryDef = { name: 'ɵqud', moduleName: CORE$1 };\r\nIdentifiers$1.pureArrayDef = { name: 'ɵpad', moduleName: CORE$1 };\r\nIdentifiers$1.pureObjectDef = { name: 'ɵpod', moduleName: CORE$1 };\r\nIdentifiers$1.purePipeDef = { name: 'ɵppd', moduleName: CORE$1 };\r\nIdentifiers$1.pipeDef = { name: 'ɵpid', moduleName: CORE$1 };\r\nIdentifiers$1.nodeValue = { name: 'ɵnov', moduleName: CORE$1 };\r\nIdentifiers$1.ngContentDef = { name: 'ɵncd', moduleName: CORE$1 };\r\nIdentifiers$1.unwrapValue = { name: 'ɵunv', moduleName: CORE$1 };\r\nIdentifiers$1.createRendererType2 = { name: 'ɵcrt', moduleName: CORE$1 };\r\n// type only\r\nIdentifiers$1.RendererType2 = {\r\n    name: 'RendererType2',\r\n    moduleName: CORE$1,\r\n};\r\n// type only\r\nIdentifiers$1.ViewDefinition = {\r\n    name: 'ɵViewDefinition',\r\n    moduleName: CORE$1,\r\n};\r\nIdentifiers$1.createComponentFactory = { name: 'ɵccf', moduleName: CORE$1 };\r\nfunction createTokenForReference(reference) {\r\n    return { identifier: { reference: reference } };\r\n}\r\nfunction createTokenForExternalReference(reflector, reference) {\r\n    return createTokenForReference(reflector.resolveExternalReference(reference));\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass EventHandlerVars {\r\n}\r\nEventHandlerVars.event = variable('$event');\r\nclass ConvertActionBindingResult {\r\n    constructor(\r\n    /**\r\n     * Render2 compatible statements,\r\n     */\r\n    stmts, \r\n    /**\r\n     * Variable name used with render2 compatible statements.\r\n     */\r\n    allowDefault) {\r\n        this.stmts = stmts;\r\n        this.allowDefault = allowDefault;\r\n        /**\r\n         * This is bit of a hack. It converts statements which render2 expects to statements which are\r\n         * expected by render3.\r\n         *\r\n         * Example: `<div click=\"doSomething($event)\">` will generate:\r\n         *\r\n         * Render3:\r\n         * ```\r\n         * const pd_b:any = ((<any>ctx.doSomething($event)) !== false);\r\n         * return pd_b;\r\n         * ```\r\n         *\r\n         * but render2 expects:\r\n         * ```\r\n         * return ctx.doSomething($event);\r\n         * ```\r\n         */\r\n        // TODO(misko): remove this hack once we no longer support ViewEngine.\r\n        this.render3Stmts = stmts.map((statement) => {\r\n            if (statement instanceof DeclareVarStmt && statement.name == allowDefault.name &&\r\n                statement.value instanceof BinaryOperatorExpr) {\r\n                const lhs = statement.value.lhs;\r\n                return new ReturnStatement(lhs.value);\r\n            }\r\n            return statement;\r\n        });\r\n    }\r\n}\r\n/**\r\n * Converts the given expression AST into an executable output AST, assuming the expression is\r\n * used in an action binding (e.g. an event handler).\r\n */\r\nfunction convertActionBinding(localResolver, implicitReceiver, action, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses, globals) {\r\n    if (!localResolver) {\r\n        localResolver = new DefaultLocalResolver(globals);\r\n    }\r\n    const actionWithoutBuiltins = convertPropertyBindingBuiltins({\r\n        createLiteralArrayConverter: (argCount) => {\r\n            // Note: no caching for literal arrays in actions.\r\n            return (args) => literalArr(args);\r\n        },\r\n        createLiteralMapConverter: (keys) => {\r\n            // Note: no caching for literal maps in actions.\r\n            return (values) => {\r\n                const entries = keys.map((k, i) => ({\r\n                    key: k.key,\r\n                    value: values[i],\r\n                    quoted: k.quoted,\r\n                }));\r\n                return literalMap(entries);\r\n            };\r\n        },\r\n        createPipeConverter: (name) => {\r\n            throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);\r\n        }\r\n    }, action);\r\n    const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses);\r\n    const actionStmts = [];\r\n    flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\r\n    prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\r\n    if (visitor.usesImplicitReceiver) {\r\n        localResolver.notifyImplicitReceiverUse();\r\n    }\r\n    const lastIndex = actionStmts.length - 1;\r\n    let preventDefaultVar = null;\r\n    if (lastIndex >= 0) {\r\n        const lastStatement = actionStmts[lastIndex];\r\n        const returnExpr = convertStmtIntoExpression(lastStatement);\r\n        if (returnExpr) {\r\n            // Note: We need to cast the result of the method call to dynamic,\r\n            // as it might be a void method!\r\n            preventDefaultVar = createPreventDefaultVar(bindingId);\r\n            actionStmts[lastIndex] =\r\n                preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false)))\r\n                    .toDeclStmt(null, [StmtModifier.Final]);\r\n        }\r\n    }\r\n    return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\r\n}\r\nfunction convertPropertyBindingBuiltins(converterFactory, ast) {\r\n    return convertBuiltins(converterFactory, ast);\r\n}\r\nclass ConvertPropertyBindingResult {\r\n    constructor(stmts, currValExpr) {\r\n        this.stmts = stmts;\r\n        this.currValExpr = currValExpr;\r\n    }\r\n}\r\nvar BindingForm;\r\n(function (BindingForm) {\r\n    // The general form of binding expression, supports all expressions.\r\n    BindingForm[BindingForm[\"General\"] = 0] = \"General\";\r\n    // Try to generate a simple binding (no temporaries or statements)\r\n    // otherwise generate a general binding\r\n    BindingForm[BindingForm[\"TrySimple\"] = 1] = \"TrySimple\";\r\n    // Inlines assignment of temporaries into the generated expression. The result may still\r\n    // have statements attached for declarations of temporary variables.\r\n    // This is the only relevant form for Ivy, the other forms are only used in ViewEngine.\r\n    BindingForm[BindingForm[\"Expression\"] = 2] = \"Expression\";\r\n})(BindingForm || (BindingForm = {}));\r\n/**\r\n * Converts the given expression AST into an executable output AST, assuming the expression\r\n * is used in property binding. The expression has to be preprocessed via\r\n * `convertPropertyBindingBuiltins`.\r\n */\r\nfunction convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId, form, interpolationFunction) {\r\n    if (!localResolver) {\r\n        localResolver = new DefaultLocalResolver();\r\n    }\r\n    const visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);\r\n    const outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\r\n    const stmts = getStatementsFromVisitor(visitor, bindingId);\r\n    if (visitor.usesImplicitReceiver) {\r\n        localResolver.notifyImplicitReceiverUse();\r\n    }\r\n    if (visitor.temporaryCount === 0 && form == BindingForm.TrySimple) {\r\n        return new ConvertPropertyBindingResult([], outputExpr);\r\n    }\r\n    else if (form === BindingForm.Expression) {\r\n        return new ConvertPropertyBindingResult(stmts, outputExpr);\r\n    }\r\n    const currValExpr = createCurrValueExpr(bindingId);\r\n    stmts.push(currValExpr.set(outputExpr).toDeclStmt(DYNAMIC_TYPE, [StmtModifier.Final]));\r\n    return new ConvertPropertyBindingResult(stmts, currValExpr);\r\n}\r\n/**\r\n * Given some expression, such as a binding or interpolation expression, and a context expression to\r\n * look values up on, visit each facet of the given expression resolving values from the context\r\n * expression such that a list of arguments can be derived from the found values that can be used as\r\n * arguments to an external update instruction.\r\n *\r\n * @param localResolver The resolver to use to look up expressions by name appropriately\r\n * @param contextVariableExpression The expression representing the context variable used to create\r\n * the final argument expressions\r\n * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to\r\n * be resolved and what arguments list to build.\r\n * @param bindingId A name prefix used to create temporary variable names if they're needed for the\r\n * arguments generated\r\n * @returns An array of expressions that can be passed as arguments to instruction expressions like\r\n * `o.importExpr(R3.propertyInterpolate).callFn(result)`\r\n */\r\nfunction convertUpdateArguments(localResolver, contextVariableExpression, expressionWithArgumentsToExtract, bindingId) {\r\n    const visitor = new _AstToIrVisitor(localResolver, contextVariableExpression, bindingId, undefined);\r\n    const outputExpr = expressionWithArgumentsToExtract.visit(visitor, _Mode.Expression);\r\n    if (visitor.usesImplicitReceiver) {\r\n        localResolver.notifyImplicitReceiverUse();\r\n    }\r\n    const stmts = getStatementsFromVisitor(visitor, bindingId);\r\n    // Removing the first argument, because it was a length for ViewEngine, not Ivy.\r\n    let args = outputExpr.args.slice(1);\r\n    if (expressionWithArgumentsToExtract instanceof Interpolation) {\r\n        // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the\r\n        // args returned to just the value, because we're going to pass it to a special instruction.\r\n        const strings = expressionWithArgumentsToExtract.strings;\r\n        if (args.length === 3 && strings[0] === '' && strings[1] === '') {\r\n            // Single argument interpolate instructions.\r\n            args = [args[1]];\r\n        }\r\n        else if (args.length >= 19) {\r\n            // 19 or more arguments must be passed to the `interpolateV`-style instructions, which accept\r\n            // an array of arguments\r\n            args = [literalArr(args)];\r\n        }\r\n    }\r\n    return { stmts, args };\r\n}\r\nfunction getStatementsFromVisitor(visitor, bindingId) {\r\n    const stmts = [];\r\n    for (let i = 0; i < visitor.temporaryCount; i++) {\r\n        stmts.push(temporaryDeclaration(bindingId, i));\r\n    }\r\n    return stmts;\r\n}\r\nfunction convertBuiltins(converterFactory, ast) {\r\n    const visitor = new _BuiltinAstConverter(converterFactory);\r\n    return ast.visit(visitor);\r\n}\r\nfunction temporaryName(bindingId, temporaryNumber) {\r\n    return `tmp_${bindingId}_${temporaryNumber}`;\r\n}\r\nfunction temporaryDeclaration(bindingId, temporaryNumber) {\r\n    return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber));\r\n}\r\nfunction prependTemporaryDecls(temporaryCount, bindingId, statements) {\r\n    for (let i = temporaryCount - 1; i >= 0; i--) {\r\n        statements.unshift(temporaryDeclaration(bindingId, i));\r\n    }\r\n}\r\nvar _Mode;\r\n(function (_Mode) {\r\n    _Mode[_Mode[\"Statement\"] = 0] = \"Statement\";\r\n    _Mode[_Mode[\"Expression\"] = 1] = \"Expression\";\r\n})(_Mode || (_Mode = {}));\r\nfunction ensureStatementMode(mode, ast) {\r\n    if (mode !== _Mode.Statement) {\r\n        throw new Error(`Expected a statement, but saw ${ast}`);\r\n    }\r\n}\r\nfunction ensureExpressionMode(mode, ast) {\r\n    if (mode !== _Mode.Expression) {\r\n        throw new Error(`Expected an expression, but saw ${ast}`);\r\n    }\r\n}\r\nfunction convertToStatementIfNeeded(mode, expr) {\r\n    if (mode === _Mode.Statement) {\r\n        return expr.toStmt();\r\n    }\r\n    else {\r\n        return expr;\r\n    }\r\n}\r\nclass _BuiltinAstConverter extends AstTransformer$1 {\r\n    constructor(_converterFactory) {\r\n        super();\r\n        this._converterFactory = _converterFactory;\r\n    }\r\n    visitPipe(ast, context) {\r\n        const args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));\r\n        return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createPipeConverter(ast.name, args.length));\r\n    }\r\n    visitLiteralArray(ast, context) {\r\n        const args = ast.expressions.map(ast => ast.visit(this, context));\r\n        return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\r\n    }\r\n    visitLiteralMap(ast, context) {\r\n        const args = ast.values.map(ast => ast.visit(this, context));\r\n        return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));\r\n    }\r\n}\r\nclass _AstToIrVisitor {\r\n    constructor(_localResolver, _implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses) {\r\n        this._localResolver = _localResolver;\r\n        this._implicitReceiver = _implicitReceiver;\r\n        this.bindingId = bindingId;\r\n        this.interpolationFunction = interpolationFunction;\r\n        this.baseSourceSpan = baseSourceSpan;\r\n        this.implicitReceiverAccesses = implicitReceiverAccesses;\r\n        this._nodeMap = new Map();\r\n        this._resultMap = new Map();\r\n        this._currentTemporary = 0;\r\n        this.temporaryCount = 0;\r\n        this.usesImplicitReceiver = false;\r\n    }\r\n    visitUnary(ast, mode) {\r\n        let op;\r\n        switch (ast.operator) {\r\n            case '+':\r\n                op = UnaryOperator.Plus;\r\n                break;\r\n            case '-':\r\n                op = UnaryOperator.Minus;\r\n                break;\r\n            default:\r\n                throw new Error(`Unsupported operator ${ast.operator}`);\r\n        }\r\n        return convertToStatementIfNeeded(mode, new UnaryOperatorExpr(op, this._visit(ast.expr, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));\r\n    }\r\n    visitBinary(ast, mode) {\r\n        let op;\r\n        switch (ast.operation) {\r\n            case '+':\r\n                op = BinaryOperator.Plus;\r\n                break;\r\n            case '-':\r\n                op = BinaryOperator.Minus;\r\n                break;\r\n            case '*':\r\n                op = BinaryOperator.Multiply;\r\n                break;\r\n            case '/':\r\n                op = BinaryOperator.Divide;\r\n                break;\r\n            case '%':\r\n                op = BinaryOperator.Modulo;\r\n                break;\r\n            case '&&':\r\n                op = BinaryOperator.And;\r\n                break;\r\n            case '||':\r\n                op = BinaryOperator.Or;\r\n                break;\r\n            case '==':\r\n                op = BinaryOperator.Equals;\r\n                break;\r\n            case '!=':\r\n                op = BinaryOperator.NotEquals;\r\n                break;\r\n            case '===':\r\n                op = BinaryOperator.Identical;\r\n                break;\r\n            case '!==':\r\n                op = BinaryOperator.NotIdentical;\r\n                break;\r\n            case '<':\r\n                op = BinaryOperator.Lower;\r\n                break;\r\n            case '>':\r\n                op = BinaryOperator.Bigger;\r\n                break;\r\n            case '<=':\r\n                op = BinaryOperator.LowerEquals;\r\n                break;\r\n            case '>=':\r\n                op = BinaryOperator.BiggerEquals;\r\n                break;\r\n            case '??':\r\n                return this.convertNullishCoalesce(ast, mode);\r\n            default:\r\n                throw new Error(`Unsupported operation ${ast.operation}`);\r\n        }\r\n        return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));\r\n    }\r\n    visitChain(ast, mode) {\r\n        ensureStatementMode(mode, ast);\r\n        return this.visitAll(ast.expressions, mode);\r\n    }\r\n    visitConditional(ast, mode) {\r\n        const value = this._visit(ast.condition, _Mode.Expression);\r\n        return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression), this.convertSourceSpan(ast.span)));\r\n    }\r\n    visitPipe(ast, mode) {\r\n        throw new Error(`Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);\r\n    }\r\n    visitFunctionCall(ast, mode) {\r\n        const convertedArgs = this.visitAll(ast.args, _Mode.Expression);\r\n        let fnResult;\r\n        if (ast instanceof BuiltinFunctionCall) {\r\n            fnResult = ast.converter(convertedArgs);\r\n        }\r\n        else {\r\n            fnResult = this._visit(ast.target, _Mode.Expression)\r\n                .callFn(convertedArgs, this.convertSourceSpan(ast.span));\r\n        }\r\n        return convertToStatementIfNeeded(mode, fnResult);\r\n    }\r\n    visitImplicitReceiver(ast, mode) {\r\n        ensureExpressionMode(mode, ast);\r\n        this.usesImplicitReceiver = true;\r\n        return this._implicitReceiver;\r\n    }\r\n    visitThisReceiver(ast, mode) {\r\n        return this.visitImplicitReceiver(ast, mode);\r\n    }\r\n    visitInterpolation(ast, mode) {\r\n        ensureExpressionMode(mode, ast);\r\n        const args = [literal(ast.expressions.length)];\r\n        for (let i = 0; i < ast.strings.length - 1; i++) {\r\n            args.push(literal(ast.strings[i]));\r\n            args.push(this._visit(ast.expressions[i], _Mode.Expression));\r\n        }\r\n        args.push(literal(ast.strings[ast.strings.length - 1]));\r\n        if (this.interpolationFunction) {\r\n            return this.interpolationFunction(args);\r\n        }\r\n        return ast.expressions.length <= 9 ?\r\n            importExpr(Identifiers$1.inlineInterpolate).callFn(args) :\r\n            importExpr(Identifiers$1.interpolate).callFn([\r\n                args[0], literalArr(args.slice(1), undefined, this.convertSourceSpan(ast.span))\r\n            ]);\r\n    }\r\n    visitKeyedRead(ast, mode) {\r\n        const leftMostSafe = this.leftMostSafeNode(ast);\r\n        if (leftMostSafe) {\r\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\r\n        }\r\n        else {\r\n            return convertToStatementIfNeeded(mode, this._visit(ast.receiver, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\r\n        }\r\n    }\r\n    visitKeyedWrite(ast, mode) {\r\n        const obj = this._visit(ast.receiver, _Mode.Expression);\r\n        const key = this._visit(ast.key, _Mode.Expression);\r\n        const value = this._visit(ast.value, _Mode.Expression);\r\n        if (obj === this._implicitReceiver) {\r\n            this._localResolver.maybeRestoreView(0, false);\r\n        }\r\n        return convertToStatementIfNeeded(mode, obj.key(key).set(value));\r\n    }\r\n    visitLiteralArray(ast, mode) {\r\n        throw new Error(`Illegal State: literal arrays should have been converted into functions`);\r\n    }\r\n    visitLiteralMap(ast, mode) {\r\n        throw new Error(`Illegal State: literal maps should have been converted into functions`);\r\n    }\r\n    visitLiteralPrimitive(ast, mode) {\r\n        // For literal values of null, undefined, true, or false allow type interference\r\n        // to infer the type.\r\n        const type = ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ?\r\n            INFERRED_TYPE :\r\n            undefined;\r\n        return convertToStatementIfNeeded(mode, literal(ast.value, type, this.convertSourceSpan(ast.span)));\r\n    }\r\n    _getLocal(name, receiver) {\r\n        var _a;\r\n        if (((_a = this._localResolver.globals) === null || _a === void 0 ? void 0 : _a.has(name)) && receiver instanceof ThisReceiver) {\r\n            return null;\r\n        }\r\n        return this._localResolver.getLocal(name);\r\n    }\r\n    visitMethodCall(ast, mode) {\r\n        if (ast.receiver instanceof ImplicitReceiver &&\r\n            !(ast.receiver instanceof ThisReceiver) && ast.name === '$any') {\r\n            const args = this.visitAll(ast.args, _Mode.Expression);\r\n            if (args.length != 1) {\r\n                throw new Error(`Invalid call to $any, expected 1 argument but received ${args.length || 'none'}`);\r\n            }\r\n            return args[0].cast(DYNAMIC_TYPE, this.convertSourceSpan(ast.span));\r\n        }\r\n        const leftMostSafe = this.leftMostSafeNode(ast);\r\n        if (leftMostSafe) {\r\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\r\n        }\r\n        else {\r\n            const args = this.visitAll(ast.args, _Mode.Expression);\r\n            const prevUsesImplicitReceiver = this.usesImplicitReceiver;\r\n            let result = null;\r\n            const receiver = this._visit(ast.receiver, _Mode.Expression);\r\n            if (receiver === this._implicitReceiver) {\r\n                const varExpr = this._getLocal(ast.name, ast.receiver);\r\n                if (varExpr) {\r\n                    // Restore the previous \"usesImplicitReceiver\" state since the implicit\r\n                    // receiver has been replaced with a resolved local expression.\r\n                    this.usesImplicitReceiver = prevUsesImplicitReceiver;\r\n                    result = varExpr.callFn(args);\r\n                    this.addImplicitReceiverAccess(ast.name);\r\n                }\r\n            }\r\n            if (result == null) {\r\n                result = receiver.callMethod(ast.name, args, this.convertSourceSpan(ast.span));\r\n            }\r\n            return convertToStatementIfNeeded(mode, result);\r\n        }\r\n    }\r\n    visitPrefixNot(ast, mode) {\r\n        return convertToStatementIfNeeded(mode, not(this._visit(ast.expression, _Mode.Expression)));\r\n    }\r\n    visitNonNullAssert(ast, mode) {\r\n        return convertToStatementIfNeeded(mode, assertNotNull(this._visit(ast.expression, _Mode.Expression)));\r\n    }\r\n    visitPropertyRead(ast, mode) {\r\n        const leftMostSafe = this.leftMostSafeNode(ast);\r\n        if (leftMostSafe) {\r\n            return this.convertSafeAccess(ast, leftMostSafe, mode);\r\n        }\r\n        else {\r\n            let result = null;\r\n            const prevUsesImplicitReceiver = this.usesImplicitReceiver;\r\n            const receiver = this._visit(ast.receiver, _Mode.Expression);\r\n            if (receiver === this._implicitReceiver) {\r\n                result = this._getLocal(ast.name, ast.receiver);\r\n                if (result) {\r\n                    // Restore the previous \"usesImplicitReceiver\" state since the implicit\r\n                    // receiver has been replaced with a resolved local expression.\r\n                    this.usesImplicitReceiver = prevUsesImplicitReceiver;\r\n                    this.addImplicitReceiverAccess(ast.name);\r\n                }\r\n            }\r\n            if (result == null) {\r\n                result = receiver.prop(ast.name);\r\n            }\r\n            return convertToStatementIfNeeded(mode, result);\r\n        }\r\n    }\r\n    visitPropertyWrite(ast, mode) {\r\n        const receiver = this._visit(ast.receiver, _Mode.Expression);\r\n        const prevUsesImplicitReceiver = this.usesImplicitReceiver;\r\n        let varExpr = null;\r\n        if (receiver === this._implicitReceiver) {\r\n            const localExpr = this._getLocal(ast.name, ast.receiver);\r\n            if (localExpr) {\r\n                if (localExpr instanceof ReadPropExpr) {\r\n                    // If the local variable is a property read expression, it's a reference\r\n                    // to a 'context.property' value and will be used as the target of the\r\n                    // write expression.\r\n                    varExpr = localExpr;\r\n                    // Restore the previous \"usesImplicitReceiver\" state since the implicit\r\n                    // receiver has been replaced with a resolved local expression.\r\n                    this.usesImplicitReceiver = prevUsesImplicitReceiver;\r\n                    this.addImplicitReceiverAccess(ast.name);\r\n                }\r\n                else {\r\n                    // Otherwise it's an error.\r\n                    const receiver = ast.name;\r\n                    const value = (ast.value instanceof PropertyRead) ? ast.value.name : undefined;\r\n                    throw new Error(`Cannot assign value \"${value}\" to template variable \"${receiver}\". Template variables are read-only.`);\r\n                }\r\n            }\r\n        }\r\n        // If no local expression could be produced, use the original receiver's\r\n        // property as the target.\r\n        if (varExpr === null) {\r\n            varExpr = receiver.prop(ast.name);\r\n        }\r\n        return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));\r\n    }\r\n    visitSafePropertyRead(ast, mode) {\r\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\r\n    }\r\n    visitSafeMethodCall(ast, mode) {\r\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\r\n    }\r\n    visitSafeKeyedRead(ast, mode) {\r\n        return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\r\n    }\r\n    visitAll(asts, mode) {\r\n        return asts.map(ast => this._visit(ast, mode));\r\n    }\r\n    visitQuote(ast, mode) {\r\n        throw new Error(`Quotes are not supported for evaluation!\r\n        Statement: ${ast.uninterpretedExpression} located at ${ast.location}`);\r\n    }\r\n    _visit(ast, mode) {\r\n        const result = this._resultMap.get(ast);\r\n        if (result)\r\n            return result;\r\n        return (this._nodeMap.get(ast) || ast).visit(this, mode);\r\n    }\r\n    convertSafeAccess(ast, leftMostSafe, mode) {\r\n        // If the expression contains a safe access node on the left it needs to be converted to\r\n        // an expression that guards the access to the member by checking the receiver for blank. As\r\n        // execution proceeds from left to right, the left most part of the expression must be guarded\r\n        // first but, because member access is left associative, the right side of the expression is at\r\n        // the top of the AST. The desired result requires lifting a copy of the left part of the\r\n        // expression up to test it for blank before generating the unguarded version.\r\n        // Consider, for example the following expression: a?.b.c?.d.e\r\n        // This results in the ast:\r\n        //         .\r\n        //        / \\\r\n        //       ?.   e\r\n        //      /  \\\r\n        //     .    d\r\n        //    / \\\r\n        //   ?.  c\r\n        //  /  \\\r\n        // a    b\r\n        // The following tree should be generated:\r\n        //\r\n        //        /---- ? ----\\\r\n        //       /      |      \\\r\n        //     a   /--- ? ---\\  null\r\n        //        /     |     \\\r\n        //       .      .     null\r\n        //      / \\    / \\\r\n        //     .  c   .   e\r\n        //    / \\    / \\\r\n        //   a   b  .   d\r\n        //         / \\\r\n        //        .   c\r\n        //       / \\\r\n        //      a   b\r\n        //\r\n        // Notice that the first guard condition is the left hand of the left most safe access node\r\n        // which comes in as leftMostSafe to this routine.\r\n        let guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\r\n        let temporary = undefined;\r\n        if (this.needsTemporaryInSafeAccess(leftMostSafe.receiver)) {\r\n            // If the expression has method calls or pipes then we need to save the result into a\r\n            // temporary variable to avoid calling stateful or impure code more than once.\r\n            temporary = this.allocateTemporary();\r\n            // Preserve the result in the temporary variable\r\n            guardedExpression = temporary.set(guardedExpression);\r\n            // Ensure all further references to the guarded expression refer to the temporary instead.\r\n            this._resultMap.set(leftMostSafe.receiver, temporary);\r\n        }\r\n        const condition = guardedExpression.isBlank();\r\n        // Convert the ast to an unguarded access to the receiver's member. The map will substitute\r\n        // leftMostNode with its unguarded version in the call to `this.visit()`.\r\n        if (leftMostSafe instanceof SafeMethodCall) {\r\n            this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args, leftMostSafe.argumentSpan));\r\n        }\r\n        else if (leftMostSafe instanceof SafeKeyedRead) {\r\n            this._nodeMap.set(leftMostSafe, new KeyedRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.receiver, leftMostSafe.key));\r\n        }\r\n        else {\r\n            this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name));\r\n        }\r\n        // Recursively convert the node now without the guarded member access.\r\n        const access = this._visit(ast, _Mode.Expression);\r\n        // Remove the mapping. This is not strictly required as the converter only traverses each node\r\n        // once but is safer if the conversion is changed to traverse the nodes more than once.\r\n        this._nodeMap.delete(leftMostSafe);\r\n        // If we allocated a temporary, release it.\r\n        if (temporary) {\r\n            this.releaseTemporary(temporary);\r\n        }\r\n        // Produce the conditional\r\n        return convertToStatementIfNeeded(mode, condition.conditional(NULL_EXPR, access));\r\n    }\r\n    convertNullishCoalesce(ast, mode) {\r\n        const left = this._visit(ast.left, _Mode.Expression);\r\n        const right = this._visit(ast.right, _Mode.Expression);\r\n        const temporary = this.allocateTemporary();\r\n        this.releaseTemporary(temporary);\r\n        // Generate the following expression. It is identical to how TS\r\n        // transpiles binary expressions with a nullish coalescing operator.\r\n        // let temp;\r\n        // (temp = a) !== null && temp !== undefined ? temp : b;\r\n        return convertToStatementIfNeeded(mode, temporary.set(left)\r\n            .notIdentical(NULL_EXPR)\r\n            .and(temporary.notIdentical(literal(undefined)))\r\n            .conditional(temporary, right));\r\n    }\r\n    // Given an expression of the form a?.b.c?.d.e then the left most safe node is\r\n    // the (a?.b). The . and ?. are left associative thus can be rewritten as:\r\n    // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\r\n    // safe method call as this needs to be transformed initially to:\r\n    //   a == null ? null : a.c.b.c?.d.e\r\n    // then to:\r\n    //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\r\n    leftMostSafeNode(ast) {\r\n        const visit = (visitor, ast) => {\r\n            return (this._nodeMap.get(ast) || ast).visit(visitor);\r\n        };\r\n        return ast.visit({\r\n            visitUnary(ast) {\r\n                return null;\r\n            },\r\n            visitBinary(ast) {\r\n                return null;\r\n            },\r\n            visitChain(ast) {\r\n                return null;\r\n            },\r\n            visitConditional(ast) {\r\n                return null;\r\n            },\r\n            visitFunctionCall(ast) {\r\n                return null;\r\n            },\r\n            visitImplicitReceiver(ast) {\r\n                return null;\r\n            },\r\n            visitThisReceiver(ast) {\r\n                return null;\r\n            },\r\n            visitInterpolation(ast) {\r\n                return null;\r\n            },\r\n            visitKeyedRead(ast) {\r\n                return visit(this, ast.receiver);\r\n            },\r\n            visitKeyedWrite(ast) {\r\n                return null;\r\n            },\r\n            visitLiteralArray(ast) {\r\n                return null;\r\n            },\r\n            visitLiteralMap(ast) {\r\n                return null;\r\n            },\r\n            visitLiteralPrimitive(ast) {\r\n                return null;\r\n            },\r\n            visitMethodCall(ast) {\r\n                return visit(this, ast.receiver);\r\n            },\r\n            visitPipe(ast) {\r\n                return null;\r\n            },\r\n            visitPrefixNot(ast) {\r\n                return null;\r\n            },\r\n            visitNonNullAssert(ast) {\r\n                return null;\r\n            },\r\n            visitPropertyRead(ast) {\r\n                return visit(this, ast.receiver);\r\n            },\r\n            visitPropertyWrite(ast) {\r\n                return null;\r\n            },\r\n            visitQuote(ast) {\r\n                return null;\r\n            },\r\n            visitSafeMethodCall(ast) {\r\n                return visit(this, ast.receiver) || ast;\r\n            },\r\n            visitSafePropertyRead(ast) {\r\n                return visit(this, ast.receiver) || ast;\r\n            },\r\n            visitSafeKeyedRead(ast) {\r\n                return visit(this, ast.receiver) || ast;\r\n            }\r\n        });\r\n    }\r\n    // Returns true of the AST includes a method or a pipe indicating that, if the\r\n    // expression is used as the target of a safe property or method access then\r\n    // the expression should be stored into a temporary variable.\r\n    needsTemporaryInSafeAccess(ast) {\r\n        const visit = (visitor, ast) => {\r\n            return ast && (this._nodeMap.get(ast) || ast).visit(visitor);\r\n        };\r\n        const visitSome = (visitor, ast) => {\r\n            return ast.some(ast => visit(visitor, ast));\r\n        };\r\n        return ast.visit({\r\n            visitUnary(ast) {\r\n                return visit(this, ast.expr);\r\n            },\r\n            visitBinary(ast) {\r\n                return visit(this, ast.left) || visit(this, ast.right);\r\n            },\r\n            visitChain(ast) {\r\n                return false;\r\n            },\r\n            visitConditional(ast) {\r\n                return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);\r\n            },\r\n            visitFunctionCall(ast) {\r\n                return true;\r\n            },\r\n            visitImplicitReceiver(ast) {\r\n                return false;\r\n            },\r\n            visitThisReceiver(ast) {\r\n                return false;\r\n            },\r\n            visitInterpolation(ast) {\r\n                return visitSome(this, ast.expressions);\r\n            },\r\n            visitKeyedRead(ast) {\r\n                return false;\r\n            },\r\n            visitKeyedWrite(ast) {\r\n                return false;\r\n            },\r\n            visitLiteralArray(ast) {\r\n                return true;\r\n            },\r\n            visitLiteralMap(ast) {\r\n                return true;\r\n            },\r\n            visitLiteralPrimitive(ast) {\r\n                return false;\r\n            },\r\n            visitMethodCall(ast) {\r\n                return true;\r\n            },\r\n            visitPipe(ast) {\r\n                return true;\r\n            },\r\n            visitPrefixNot(ast) {\r\n                return visit(this, ast.expression);\r\n            },\r\n            visitNonNullAssert(ast) {\r\n                return visit(this, ast.expression);\r\n            },\r\n            visitPropertyRead(ast) {\r\n                return false;\r\n            },\r\n            visitPropertyWrite(ast) {\r\n                return false;\r\n            },\r\n            visitQuote(ast) {\r\n                return false;\r\n            },\r\n            visitSafeMethodCall(ast) {\r\n                return true;\r\n            },\r\n            visitSafePropertyRead(ast) {\r\n                return false;\r\n            },\r\n            visitSafeKeyedRead(ast) {\r\n                return false;\r\n            }\r\n        });\r\n    }\r\n    allocateTemporary() {\r\n        const tempNumber = this._currentTemporary++;\r\n        this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\r\n        return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));\r\n    }\r\n    releaseTemporary(temporary) {\r\n        this._currentTemporary--;\r\n        if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\r\n            throw new Error(`Temporary ${temporary.name} released out of order`);\r\n        }\r\n    }\r\n    /**\r\n     * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.\r\n     *\r\n     * `ParseSpan` objects are relative to the start of the expression.\r\n     * This method converts these to full `ParseSourceSpan` objects that\r\n     * show where the span is within the overall source file.\r\n     *\r\n     * @param span the relative span to convert.\r\n     * @returns a `ParseSourceSpan` for the given span or null if no\r\n     * `baseSourceSpan` was provided to this class.\r\n     */\r\n    convertSourceSpan(span) {\r\n        if (this.baseSourceSpan) {\r\n            const start = this.baseSourceSpan.start.moveBy(span.start);\r\n            const end = this.baseSourceSpan.start.moveBy(span.end);\r\n            const fullStart = this.baseSourceSpan.fullStart.moveBy(span.start);\r\n            return new ParseSourceSpan(start, end, fullStart);\r\n        }\r\n        else {\r\n            return null;\r\n        }\r\n    }\r\n    /** Adds the name of an AST to the list of implicit receiver accesses. */\r\n    addImplicitReceiverAccess(name) {\r\n        if (this.implicitReceiverAccesses) {\r\n            this.implicitReceiverAccesses.add(name);\r\n        }\r\n    }\r\n}\r\nfunction flattenStatements(arg, output) {\r\n    if (Array.isArray(arg)) {\r\n        arg.forEach((entry) => flattenStatements(entry, output));\r\n    }\r\n    else {\r\n        output.push(arg);\r\n    }\r\n}\r\nclass DefaultLocalResolver {\r\n    constructor(globals) {\r\n        this.globals = globals;\r\n    }\r\n    notifyImplicitReceiverUse() { }\r\n    maybeRestoreView() { }\r\n    getLocal(name) {\r\n        if (name === EventHandlerVars.event.name) {\r\n            return EventHandlerVars.event;\r\n        }\r\n        return null;\r\n    }\r\n}\r\nfunction createCurrValueExpr(bindingId) {\r\n    return variable(`currVal_${bindingId}`); // fix syntax highlighting: `\r\n}\r\nfunction createPreventDefaultVar(bindingId) {\r\n    return variable(`pd_${bindingId}`);\r\n}\r\nfunction convertStmtIntoExpression(stmt) {\r\n    if (stmt instanceof ExpressionStatement) {\r\n        return stmt.expr;\r\n    }\r\n    else if (stmt instanceof ReturnStatement) {\r\n        return stmt.value;\r\n    }\r\n    return null;\r\n}\r\nclass BuiltinFunctionCall extends FunctionCall {\r\n    constructor(span, sourceSpan, args, converter) {\r\n        super(span, sourceSpan, null, args);\r\n        this.args = args;\r\n        this.converter = converter;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * This file is a port of shadowCSS from webcomponents.js to TypeScript.\r\n *\r\n * Please make sure to keep to edits in sync with the source file.\r\n *\r\n * Source:\r\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\r\n *\r\n * The original file level comment is reproduced below\r\n */\r\n/*\r\n  This is a limited shim for ShadowDOM css styling.\r\n  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles\r\n\r\n  The intention here is to support only the styling features which can be\r\n  relatively simply implemented. The goal is to allow users to avoid the\r\n  most obvious pitfalls and do so without compromising performance significantly.\r\n  For ShadowDOM styling that's not covered here, a set of best practices\r\n  can be provided that should allow users to accomplish more complex styling.\r\n\r\n  The following is a list of specific ShadowDOM styling features and a brief\r\n  discussion of the approach used to shim.\r\n\r\n  Shimmed features:\r\n\r\n  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host\r\n  element using the :host rule. To shim this feature, the :host styles are\r\n  reformatted and prefixed with a given scope name and promoted to a\r\n  document level stylesheet.\r\n  For example, given a scope name of .foo, a rule like this:\r\n\r\n    :host {\r\n        background: red;\r\n      }\r\n    }\r\n\r\n  becomes:\r\n\r\n    .foo {\r\n      background: red;\r\n    }\r\n\r\n  * encapsulation: Styles defined within ShadowDOM, apply only to\r\n  dom inside the ShadowDOM. Polymer uses one of two techniques to implement\r\n  this feature.\r\n\r\n  By default, rules are prefixed with the host element tag name\r\n  as a descendant selector. This ensures styling does not leak out of the 'top'\r\n  of the element's ShadowDOM. For example,\r\n\r\n  div {\r\n      font-weight: bold;\r\n    }\r\n\r\n  becomes:\r\n\r\n  x-foo div {\r\n      font-weight: bold;\r\n    }\r\n\r\n  becomes:\r\n\r\n\r\n  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then\r\n  selectors are scoped by adding an attribute selector suffix to each\r\n  simple selector that contains the host element tag name. Each element\r\n  in the element's ShadowDOM template is also given the scope attribute.\r\n  Thus, these rules match only elements that have the scope attribute.\r\n  For example, given a scope name of x-foo, a rule like this:\r\n\r\n    div {\r\n      font-weight: bold;\r\n    }\r\n\r\n  becomes:\r\n\r\n    div[x-foo] {\r\n      font-weight: bold;\r\n    }\r\n\r\n  Note that elements that are dynamically added to a scope must have the scope\r\n  selector added to them manually.\r\n\r\n  * upper/lower bound encapsulation: Styles which are defined outside a\r\n  shadowRoot should not cross the ShadowDOM boundary and should not apply\r\n  inside a shadowRoot.\r\n\r\n  This styling behavior is not emulated. Some possible ways to do this that\r\n  were rejected due to complexity and/or performance concerns include: (1) reset\r\n  every possible property for every possible selector for a given scope name;\r\n  (2) re-implement css in javascript.\r\n\r\n  As an alternative, users should make sure to use selectors\r\n  specific to the scope in which they are working.\r\n\r\n  * ::distributed: This behavior is not emulated. It's often not necessary\r\n  to style the contents of a specific insertion point and instead, descendants\r\n  of the host element can be styled selectively. Users can also create an\r\n  extra node around an insertion point and style that node's contents\r\n  via descendent selectors. For example, with a shadowRoot like this:\r\n\r\n    <style>\r\n      ::content(div) {\r\n        background: red;\r\n      }\r\n    </style>\r\n    <content></content>\r\n\r\n  could become:\r\n\r\n    <style>\r\n      / *@polyfill .content-container div * /\r\n      ::content(div) {\r\n        background: red;\r\n      }\r\n    </style>\r\n    <div class=\"content-container\">\r\n      <content></content>\r\n    </div>\r\n\r\n  Note the use of @polyfill in the comment above a ShadowDOM specific style\r\n  declaration. This is a directive to the styling shim to use the selector\r\n  in comments in lieu of the next selector when running under polyfill.\r\n*/\r\nclass ShadowCss {\r\n    constructor() {\r\n        this.strictStyling = true;\r\n    }\r\n    /*\r\n     * Shim some cssText with the given selector. Returns cssText that can\r\n     * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).\r\n     *\r\n     * When strictStyling is true:\r\n     * - selector is the attribute added to all elements inside the host,\r\n     * - hostSelector is the attribute added to the host itself.\r\n     */\r\n    shimCssText(cssText, selector, hostSelector = '') {\r\n        const commentsWithHash = extractCommentsWithHash(cssText);\r\n        cssText = stripComments(cssText);\r\n        cssText = this._insertDirectives(cssText);\r\n        const scopedCssText = this._scopeCssText(cssText, selector, hostSelector);\r\n        return [scopedCssText, ...commentsWithHash].join('\\n');\r\n    }\r\n    _insertDirectives(cssText) {\r\n        cssText = this._insertPolyfillDirectivesInCssText(cssText);\r\n        return this._insertPolyfillRulesInCssText(cssText);\r\n    }\r\n    /*\r\n     * Process styles to convert native ShadowDOM rules that will trip\r\n     * up the css parser; we rely on decorating the stylesheet with inert rules.\r\n     *\r\n     * For example, we convert this rule:\r\n     *\r\n     * polyfill-next-selector { content: ':host menu-item'; }\r\n     * ::content menu-item {\r\n     *\r\n     * to this:\r\n     *\r\n     * scopeName menu-item {\r\n     *\r\n     **/\r\n    _insertPolyfillDirectivesInCssText(cssText) {\r\n        // Difference with webcomponents.js: does not handle comments\r\n        return cssText.replace(_cssContentNextSelectorRe, function (...m) {\r\n            return m[2] + '{';\r\n        });\r\n    }\r\n    /*\r\n     * Process styles to add rules which will only apply under the polyfill\r\n     *\r\n     * For example, we convert this rule:\r\n     *\r\n     * polyfill-rule {\r\n     *   content: ':host menu-item';\r\n     * ...\r\n     * }\r\n     *\r\n     * to this:\r\n     *\r\n     * scopeName menu-item {...}\r\n     *\r\n     **/\r\n    _insertPolyfillRulesInCssText(cssText) {\r\n        // Difference with webcomponents.js: does not handle comments\r\n        return cssText.replace(_cssContentRuleRe, (...m) => {\r\n            const rule = m[0].replace(m[1], '').replace(m[2], '');\r\n            return m[4] + rule;\r\n        });\r\n    }\r\n    /* Ensure styles are scoped. Pseudo-scoping takes a rule like:\r\n     *\r\n     *  .foo {... }\r\n     *\r\n     *  and converts this to\r\n     *\r\n     *  scopeName .foo { ... }\r\n     */\r\n    _scopeCssText(cssText, scopeSelector, hostSelector) {\r\n        const unscopedRules = this._extractUnscopedRulesFromCssText(cssText);\r\n        // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\r\n        cssText = this._insertPolyfillHostInCssText(cssText);\r\n        cssText = this._convertColonHost(cssText);\r\n        cssText = this._convertColonHostContext(cssText);\r\n        cssText = this._convertShadowDOMSelectors(cssText);\r\n        if (scopeSelector) {\r\n            cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\r\n        }\r\n        cssText = cssText + '\\n' + unscopedRules;\r\n        return cssText.trim();\r\n    }\r\n    /*\r\n     * Process styles to add rules which will only apply under the polyfill\r\n     * and do not process via CSSOM. (CSSOM is destructive to rules on rare\r\n     * occasions, e.g. -webkit-calc on Safari.)\r\n     * For example, we convert this rule:\r\n     *\r\n     * @polyfill-unscoped-rule {\r\n     *   content: 'menu-item';\r\n     * ... }\r\n     *\r\n     * to this:\r\n     *\r\n     * menu-item {...}\r\n     *\r\n     **/\r\n    _extractUnscopedRulesFromCssText(cssText) {\r\n        // Difference with webcomponents.js: does not handle comments\r\n        let r = '';\r\n        let m;\r\n        _cssContentUnscopedRuleRe.lastIndex = 0;\r\n        while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\r\n            const rule = m[0].replace(m[2], '').replace(m[1], m[4]);\r\n            r += rule + '\\n\\n';\r\n        }\r\n        return r;\r\n    }\r\n    /*\r\n     * convert a rule like :host(.foo) > .bar { }\r\n     *\r\n     * to\r\n     *\r\n     * .foo<scopeName> > .bar\r\n     */\r\n    _convertColonHost(cssText) {\r\n        return cssText.replace(_cssColonHostRe, (_, hostSelectors, otherSelectors) => {\r\n            if (hostSelectors) {\r\n                const convertedSelectors = [];\r\n                const hostSelectorArray = hostSelectors.split(',').map(p => p.trim());\r\n                for (const hostSelector of hostSelectorArray) {\r\n                    if (!hostSelector)\r\n                        break;\r\n                    const convertedSelector = _polyfillHostNoCombinator + hostSelector.replace(_polyfillHost, '') + otherSelectors;\r\n                    convertedSelectors.push(convertedSelector);\r\n                }\r\n                return convertedSelectors.join(',');\r\n            }\r\n            else {\r\n                return _polyfillHostNoCombinator + otherSelectors;\r\n            }\r\n        });\r\n    }\r\n    /*\r\n     * convert a rule like :host-context(.foo) > .bar { }\r\n     *\r\n     * to\r\n     *\r\n     * .foo<scopeName> > .bar, .foo <scopeName> > .bar { }\r\n     *\r\n     * and\r\n     *\r\n     * :host-context(.foo:host) .bar { ... }\r\n     *\r\n     * to\r\n     *\r\n     * .foo<scopeName> .bar { ... }\r\n     */\r\n    _convertColonHostContext(cssText) {\r\n        return cssText.replace(_cssColonHostContextReGlobal, selectorText => {\r\n            // We have captured a selector that contains a `:host-context` rule.\r\n            var _a;\r\n            // For backward compatibility `:host-context` may contain a comma separated list of selectors.\r\n            // Each context selector group will contain a list of host-context selectors that must match\r\n            // an ancestor of the host.\r\n            // (Normally `contextSelectorGroups` will only contain a single array of context selectors.)\r\n            const contextSelectorGroups = [[]];\r\n            // There may be more than `:host-context` in this selector so `selectorText` could look like:\r\n            // `:host-context(.one):host-context(.two)`.\r\n            // Execute `_cssColonHostContextRe` over and over until we have extracted all the\r\n            // `:host-context` selectors from this selector.\r\n            let match;\r\n            while (match = _cssColonHostContextRe.exec(selectorText)) {\r\n                // `match` = [':host-context(<selectors>)<rest>', <selectors>, <rest>]\r\n                // The `<selectors>` could actually be a comma separated list: `:host-context(.one, .two)`.\r\n                const newContextSelectors = ((_a = match[1]) !== null && _a !== void 0 ? _a : '').trim().split(',').map(m => m.trim()).filter(m => m !== '');\r\n                // We must duplicate the current selector group for each of these new selectors.\r\n                // For example if the current groups are:\r\n                // ```\r\n                // [\r\n                //   ['a', 'b', 'c'],\r\n                //   ['x', 'y', 'z'],\r\n                // ]\r\n                // ```\r\n                // And we have a new set of comma separated selectors: `:host-context(m,n)` then the new\r\n                // groups are:\r\n                // ```\r\n                // [\r\n                //   ['a', 'b', 'c', 'm'],\r\n                //   ['x', 'y', 'z', 'm'],\r\n                //   ['a', 'b', 'c', 'n'],\r\n                //   ['x', 'y', 'z', 'n'],\r\n                // ]\r\n                // ```\r\n                const contextSelectorGroupsLength = contextSelectorGroups.length;\r\n                repeatGroups(contextSelectorGroups, newContextSelectors.length);\r\n                for (let i = 0; i < newContextSelectors.length; i++) {\r\n                    for (let j = 0; j < contextSelectorGroupsLength; j++) {\r\n                        contextSelectorGroups[j + (i * contextSelectorGroupsLength)].push(newContextSelectors[i]);\r\n                    }\r\n                }\r\n                // Update the `selectorText` and see repeat to see if there are more `:host-context`s.\r\n                selectorText = match[2];\r\n            }\r\n            // The context selectors now must be combined with each other to capture all the possible\r\n            // selectors that `:host-context` can match. See `combineHostContextSelectors()` for more\r\n            // info about how this is done.\r\n            return contextSelectorGroups\r\n                .map(contextSelectors => combineHostContextSelectors(contextSelectors, selectorText))\r\n                .join(', ');\r\n        });\r\n    }\r\n    /*\r\n     * Convert combinators like ::shadow and pseudo-elements like ::content\r\n     * by replacing with space.\r\n     */\r\n    _convertShadowDOMSelectors(cssText) {\r\n        return _shadowDOMSelectorsRe.reduce((result, pattern) => result.replace(pattern, ' '), cssText);\r\n    }\r\n    // change a selector like 'div' to 'name div'\r\n    _scopeSelectors(cssText, scopeSelector, hostSelector) {\r\n        return processRules(cssText, (rule) => {\r\n            let selector = rule.selector;\r\n            let content = rule.content;\r\n            if (rule.selector[0] !== '@') {\r\n                selector =\r\n                    this._scopeSelector(rule.selector, scopeSelector, hostSelector, this.strictStyling);\r\n            }\r\n            else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') ||\r\n                rule.selector.startsWith('@document')) {\r\n                content = this._scopeSelectors(rule.content, scopeSelector, hostSelector);\r\n            }\r\n            else if (rule.selector.startsWith('@font-face') || rule.selector.startsWith('@page')) {\r\n                content = this._stripScopingSelectors(rule.content);\r\n            }\r\n            return new CssRule(selector, content);\r\n        });\r\n    }\r\n    /**\r\n     * Handle a css text that is within a rule that should not contain scope selectors by simply\r\n     * removing them! An example of such a rule is `@font-face`.\r\n     *\r\n     * `@font-face` rules cannot contain nested selectors. Nor can they be nested under a selector.\r\n     * Normally this would be a syntax error by the author of the styles. But in some rare cases, such\r\n     * as importing styles from a library, and applying `:host ::ng-deep` to the imported styles, we\r\n     * can end up with broken css if the imported styles happen to contain @font-face rules.\r\n     *\r\n     * For example:\r\n     *\r\n     * ```\r\n     * :host ::ng-deep {\r\n     *   import 'some/lib/containing/font-face';\r\n     * }\r\n     *\r\n     * Similar logic applies to `@page` rules which can contain a particular set of properties,\r\n     * as well as some specific at-rules. Since they can't be encapsulated, we have to strip\r\n     * any scoping selectors from them. For more information: https://www.w3.org/TR/css-page-3\r\n     * ```\r\n     */\r\n    _stripScopingSelectors(cssText) {\r\n        return processRules(cssText, rule => {\r\n            const selector = rule.selector.replace(_shadowDeepSelectors, ' ')\r\n                .replace(_polyfillHostNoCombinatorRe, ' ');\r\n            return new CssRule(selector, rule.content);\r\n        });\r\n    }\r\n    _scopeSelector(selector, scopeSelector, hostSelector, strict) {\r\n        return selector.split(',')\r\n            .map(part => part.trim().split(_shadowDeepSelectors))\r\n            .map((deepParts) => {\r\n            const [shallowPart, ...otherParts] = deepParts;\r\n            const applyScope = (shallowPart) => {\r\n                if (this._selectorNeedsScoping(shallowPart, scopeSelector)) {\r\n                    return strict ?\r\n                        this._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) :\r\n                        this._applySelectorScope(shallowPart, scopeSelector, hostSelector);\r\n                }\r\n                else {\r\n                    return shallowPart;\r\n                }\r\n            };\r\n            return [applyScope(shallowPart), ...otherParts].join(' ');\r\n        })\r\n            .join(', ');\r\n    }\r\n    _selectorNeedsScoping(selector, scopeSelector) {\r\n        const re = this._makeScopeMatcher(scopeSelector);\r\n        return !re.test(selector);\r\n    }\r\n    _makeScopeMatcher(scopeSelector) {\r\n        const lre = /\\[/g;\r\n        const rre = /\\]/g;\r\n        scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\r\n        return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\r\n    }\r\n    _applySelectorScope(selector, scopeSelector, hostSelector) {\r\n        // Difference from webcomponents.js: scopeSelector could not be an array\r\n        return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\r\n    }\r\n    // scope via name and [is=name]\r\n    _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {\r\n        // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\r\n        _polyfillHostRe.lastIndex = 0;\r\n        if (_polyfillHostRe.test(selector)) {\r\n            const replaceBy = this.strictStyling ? `[${hostSelector}]` : scopeSelector;\r\n            return selector\r\n                .replace(_polyfillHostNoCombinatorRe, (hnc, selector) => {\r\n                return selector.replace(/([^:]*)(:*)(.*)/, (_, before, colon, after) => {\r\n                    return before + replaceBy + colon + after;\r\n                });\r\n            })\r\n                .replace(_polyfillHostRe, replaceBy + ' ');\r\n        }\r\n        return scopeSelector + ' ' + selector;\r\n    }\r\n    // return a selector with [name] suffix on each simple selector\r\n    // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */\r\n    _applyStrictSelectorScope(selector, scopeSelector, hostSelector) {\r\n        const isRe = /\\[is=([^\\]]*)\\]/g;\r\n        scopeSelector = scopeSelector.replace(isRe, (_, ...parts) => parts[0]);\r\n        const attrName = '[' + scopeSelector + ']';\r\n        const _scopeSelectorPart = (p) => {\r\n            let scopedP = p.trim();\r\n            if (!scopedP) {\r\n                return '';\r\n            }\r\n            if (p.indexOf(_polyfillHostNoCombinator) > -1) {\r\n                scopedP = this._applySimpleSelectorScope(p, scopeSelector, hostSelector);\r\n            }\r\n            else {\r\n                // remove :host since it should be unnecessary\r\n                const t = p.replace(_polyfillHostRe, '');\r\n                if (t.length > 0) {\r\n                    const matches = t.match(/([^:]*)(:*)(.*)/);\r\n                    if (matches) {\r\n                        scopedP = matches[1] + attrName + matches[2] + matches[3];\r\n                    }\r\n                }\r\n            }\r\n            return scopedP;\r\n        };\r\n        const safeContent = new SafeSelector(selector);\r\n        selector = safeContent.content();\r\n        let scopedSelector = '';\r\n        let startIndex = 0;\r\n        let res;\r\n        const sep = /( |>|\\+|~(?!=))\\s*/g;\r\n        // If a selector appears before :host it should not be shimmed as it\r\n        // matches on ancestor elements and not on elements in the host's shadow\r\n        // `:host-context(div)` is transformed to\r\n        // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\r\n        // the `div` is not part of the component in the 2nd selectors and should not be scoped.\r\n        // Historically `component-tag:host` was matching the component so we also want to preserve\r\n        // this behavior to avoid breaking legacy apps (it should not match).\r\n        // The behavior should be:\r\n        // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\r\n        // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\r\n        //   `:host-context(tag)`)\r\n        const hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1;\r\n        // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present\r\n        let shouldScope = !hasHost;\r\n        while ((res = sep.exec(selector)) !== null) {\r\n            const separator = res[1];\r\n            const part = selector.slice(startIndex, res.index).trim();\r\n            shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\r\n            const scopedPart = shouldScope ? _scopeSelectorPart(part) : part;\r\n            scopedSelector += `${scopedPart} ${separator} `;\r\n            startIndex = sep.lastIndex;\r\n        }\r\n        const part = selector.substring(startIndex);\r\n        shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\r\n        scopedSelector += shouldScope ? _scopeSelectorPart(part) : part;\r\n        // replace the placeholders with their original values\r\n        return safeContent.restore(scopedSelector);\r\n    }\r\n    _insertPolyfillHostInCssText(selector) {\r\n        return selector.replace(_colonHostContextRe, _polyfillHostContext)\r\n            .replace(_colonHostRe, _polyfillHost);\r\n    }\r\n}\r\nclass SafeSelector {\r\n    constructor(selector) {\r\n        this.placeholders = [];\r\n        this.index = 0;\r\n        // Replaces attribute selectors with placeholders.\r\n        // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\r\n        selector = this._escapeRegexMatches(selector, /(\\[[^\\]]*\\])/g);\r\n        // CSS allows for certain special characters to be used in selectors if they're escaped.\r\n        // E.g. `.foo:blue` won't match a class called `foo:blue`, because the colon denotes a\r\n        // pseudo-class, but writing `.foo\\:blue` will match, because the colon was escaped.\r\n        // Replace all escape sequences (`\\` followed by a character) with a placeholder so\r\n        // that our handling of pseudo-selectors doesn't mess with them.\r\n        selector = this._escapeRegexMatches(selector, /(\\\\.)/g);\r\n        // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\r\n        // WS and \"+\" would otherwise be interpreted as selector separators.\r\n        this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, (_, pseudo, exp) => {\r\n            const replaceBy = `__ph-${this.index}__`;\r\n            this.placeholders.push(exp);\r\n            this.index++;\r\n            return pseudo + replaceBy;\r\n        });\r\n    }\r\n    restore(content) {\r\n        return content.replace(/__ph-(\\d+)__/g, (_ph, index) => this.placeholders[+index]);\r\n    }\r\n    content() {\r\n        return this._content;\r\n    }\r\n    /**\r\n     * Replaces all of the substrings that match a regex within a\r\n     * special string (e.g. `__ph-0__`, `__ph-1__`, etc).\r\n     */\r\n    _escapeRegexMatches(content, pattern) {\r\n        return content.replace(pattern, (_, keep) => {\r\n            const replaceBy = `__ph-${this.index}__`;\r\n            this.placeholders.push(keep);\r\n            this.index++;\r\n            return replaceBy;\r\n        });\r\n    }\r\n}\r\nconst _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\r\nconst _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\r\nconst _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\r\nconst _polyfillHost = '-shadowcsshost';\r\n// note: :host-context pre-processed to -shadowcsshostcontext.\r\nconst _polyfillHostContext = '-shadowcsscontext';\r\nconst _parenSuffix = '(?:\\\\((' +\r\n    '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' +\r\n    ')\\\\))?([^,{]*)';\r\nconst _cssColonHostRe = new RegExp(_polyfillHost + _parenSuffix, 'gim');\r\nconst _cssColonHostContextReGlobal = new RegExp(_polyfillHostContext + _parenSuffix, 'gim');\r\nconst _cssColonHostContextRe = new RegExp(_polyfillHostContext + _parenSuffix, 'im');\r\nconst _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\r\nconst _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\r\nconst _shadowDOMSelectorsRe = [\r\n    /::shadow/g,\r\n    /::content/g,\r\n    // Deprecated selectors\r\n    /\\/shadow-deep\\//g,\r\n    /\\/shadow\\//g,\r\n];\r\n// The deep combinator is deprecated in the CSS spec\r\n// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.\r\n// see https://github.com/angular/angular/pull/17677\r\nconst _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\r\nconst _selectorReSuffix = '([>\\\\s~+\\[.,{:][\\\\s\\\\S]*)?$';\r\nconst _polyfillHostRe = /-shadowcsshost/gim;\r\nconst _colonHostRe = /:host/gim;\r\nconst _colonHostContextRe = /:host-context/gim;\r\nconst _commentRe = /\\/\\*\\s*[\\s\\S]*?\\*\\//g;\r\nfunction stripComments(input) {\r\n    return input.replace(_commentRe, '');\r\n}\r\nconst _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=[\\s\\S]+?\\*\\//g;\r\nfunction extractCommentsWithHash(input) {\r\n    return input.match(_commentWithHashRe) || [];\r\n}\r\nconst BLOCK_PLACEHOLDER = '%BLOCK%';\r\nconst QUOTE_PLACEHOLDER = '%QUOTED%';\r\nconst _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\r\nconst _quotedRe = /%QUOTED%/g;\r\nconst CONTENT_PAIRS = new Map([['{', '}']]);\r\nconst QUOTE_PAIRS = new Map([[`\"`, `\"`], [`'`, `'`]]);\r\nclass CssRule {\r\n    constructor(selector, content) {\r\n        this.selector = selector;\r\n        this.content = content;\r\n    }\r\n}\r\nfunction processRules(input, ruleCallback) {\r\n    const inputWithEscapedQuotes = escapeBlocks(input, QUOTE_PAIRS, QUOTE_PLACEHOLDER);\r\n    const inputWithEscapedBlocks = escapeBlocks(inputWithEscapedQuotes.escapedString, CONTENT_PAIRS, BLOCK_PLACEHOLDER);\r\n    let nextBlockIndex = 0;\r\n    let nextQuoteIndex = 0;\r\n    return inputWithEscapedBlocks.escapedString\r\n        .replace(_ruleRe, (...m) => {\r\n        const selector = m[2];\r\n        let content = '';\r\n        let suffix = m[4];\r\n        let contentPrefix = '';\r\n        if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\r\n            content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\r\n            suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\r\n            contentPrefix = '{';\r\n        }\r\n        const rule = ruleCallback(new CssRule(selector, content));\r\n        return `${m[1]}${rule.selector}${m[3]}${contentPrefix}${rule.content}${suffix}`;\r\n    })\r\n        .replace(_quotedRe, () => inputWithEscapedQuotes.blocks[nextQuoteIndex++]);\r\n}\r\nclass StringWithEscapedBlocks {\r\n    constructor(escapedString, blocks) {\r\n        this.escapedString = escapedString;\r\n        this.blocks = blocks;\r\n    }\r\n}\r\nfunction escapeBlocks(input, charPairs, placeholder) {\r\n    const resultParts = [];\r\n    const escapedBlocks = [];\r\n    let openCharCount = 0;\r\n    let nonBlockStartIndex = 0;\r\n    let blockStartIndex = -1;\r\n    let openChar;\r\n    let closeChar;\r\n    for (let i = 0; i < input.length; i++) {\r\n        const char = input[i];\r\n        if (char === '\\\\') {\r\n            i++;\r\n        }\r\n        else if (char === closeChar) {\r\n            openCharCount--;\r\n            if (openCharCount === 0) {\r\n                escapedBlocks.push(input.substring(blockStartIndex, i));\r\n                resultParts.push(placeholder);\r\n                nonBlockStartIndex = i;\r\n                blockStartIndex = -1;\r\n                openChar = closeChar = undefined;\r\n            }\r\n        }\r\n        else if (char === openChar) {\r\n            openCharCount++;\r\n        }\r\n        else if (openCharCount === 0 && charPairs.has(char)) {\r\n            openChar = char;\r\n            closeChar = charPairs.get(char);\r\n            openCharCount = 1;\r\n            blockStartIndex = i + 1;\r\n            resultParts.push(input.substring(nonBlockStartIndex, blockStartIndex));\r\n        }\r\n    }\r\n    if (blockStartIndex !== -1) {\r\n        escapedBlocks.push(input.substring(blockStartIndex));\r\n        resultParts.push(placeholder);\r\n    }\r\n    else {\r\n        resultParts.push(input.substring(nonBlockStartIndex));\r\n    }\r\n    return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\r\n}\r\n/**\r\n * Combine the `contextSelectors` with the `hostMarker` and the `otherSelectors`\r\n * to create a selector that matches the same as `:host-context()`.\r\n *\r\n * Given a single context selector `A` we need to output selectors that match on the host and as an\r\n * ancestor of the host:\r\n *\r\n * ```\r\n * A <hostMarker>, A<hostMarker> {}\r\n * ```\r\n *\r\n * When there is more than one context selector we also have to create combinations of those\r\n * selectors with each other. For example if there are `A` and `B` selectors the output is:\r\n *\r\n * ```\r\n * AB<hostMarker>, AB <hostMarker>, A B<hostMarker>,\r\n * B A<hostMarker>, A B <hostMarker>, B A <hostMarker> {}\r\n * ```\r\n *\r\n * And so on...\r\n *\r\n * @param hostMarker the string that selects the host element.\r\n * @param contextSelectors an array of context selectors that will be combined.\r\n * @param otherSelectors the rest of the selectors that are not context selectors.\r\n */\r\nfunction combineHostContextSelectors(contextSelectors, otherSelectors) {\r\n    const hostMarker = _polyfillHostNoCombinator;\r\n    _polyfillHostRe.lastIndex = 0; // reset the regex to ensure we get an accurate test\r\n    const otherSelectorsHasHost = _polyfillHostRe.test(otherSelectors);\r\n    // If there are no context selectors then just output a host marker\r\n    if (contextSelectors.length === 0) {\r\n        return hostMarker + otherSelectors;\r\n    }\r\n    const combined = [contextSelectors.pop() || ''];\r\n    while (contextSelectors.length > 0) {\r\n        const length = combined.length;\r\n        const contextSelector = contextSelectors.pop();\r\n        for (let i = 0; i < length; i++) {\r\n            const previousSelectors = combined[i];\r\n            // Add the new selector as a descendant of the previous selectors\r\n            combined[length * 2 + i] = previousSelectors + ' ' + contextSelector;\r\n            // Add the new selector as an ancestor of the previous selectors\r\n            combined[length + i] = contextSelector + ' ' + previousSelectors;\r\n            // Add the new selector to act on the same element as the previous selectors\r\n            combined[i] = contextSelector + previousSelectors;\r\n        }\r\n    }\r\n    // Finally connect the selector to the `hostMarker`s: either acting directly on the host\r\n    // (A<hostMarker>) or as an ancestor (A <hostMarker>).\r\n    return combined\r\n        .map(s => otherSelectorsHasHost ?\r\n        `${s}${otherSelectors}` :\r\n        `${s}${hostMarker}${otherSelectors}, ${s} ${hostMarker}${otherSelectors}`)\r\n        .join(',');\r\n}\r\n/**\r\n * Mutate the given `groups` array so that there are `multiples` clones of the original array\r\n * stored.\r\n *\r\n * For example `repeatGroups([a, b], 3)` will result in `[a, b, a, b, a, b]` - but importantly the\r\n * newly added groups will be clones of the original.\r\n *\r\n * @param groups An array of groups of strings that will be repeated. This array is mutated\r\n *     in-place.\r\n * @param multiples The number of times the current groups should appear.\r\n */\r\nfunction repeatGroups(groups, multiples) {\r\n    const length = groups.length;\r\n    for (let i = 1; i < multiples; i++) {\r\n        for (let j = 0; j < length; j++) {\r\n            groups[j + (i * length)] = groups[j].slice(0);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst COMPONENT_VARIABLE = '%COMP%';\r\nconst HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\r\nconst CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\r\nclass StylesCompileDependency {\r\n    constructor(name, moduleUrl, setValue) {\r\n        this.name = name;\r\n        this.moduleUrl = moduleUrl;\r\n        this.setValue = setValue;\r\n    }\r\n}\r\nclass CompiledStylesheet {\r\n    constructor(outputCtx, stylesVar, dependencies, isShimmed, meta) {\r\n        this.outputCtx = outputCtx;\r\n        this.stylesVar = stylesVar;\r\n        this.dependencies = dependencies;\r\n        this.isShimmed = isShimmed;\r\n        this.meta = meta;\r\n    }\r\n}\r\nclass StyleCompiler {\r\n    constructor(_urlResolver) {\r\n        this._urlResolver = _urlResolver;\r\n        this._shadowCss = new ShadowCss();\r\n    }\r\n    compileComponent(outputCtx, comp) {\r\n        const template = comp.template;\r\n        return this._compileStyles(outputCtx, comp, new CompileStylesheetMetadata({\r\n            styles: template.styles,\r\n            styleUrls: template.styleUrls,\r\n            moduleUrl: identifierModuleUrl(comp.type)\r\n        }), this.needsStyleShim(comp), true);\r\n    }\r\n    compileStyles(outputCtx, comp, stylesheet, shim = this.needsStyleShim(comp)) {\r\n        return this._compileStyles(outputCtx, comp, stylesheet, shim, false);\r\n    }\r\n    needsStyleShim(comp) {\r\n        return comp.template.encapsulation === ViewEncapsulation.Emulated;\r\n    }\r\n    _compileStyles(outputCtx, comp, stylesheet, shim, isComponentStylesheet) {\r\n        const styleExpressions = stylesheet.styles.map(plainStyle => literal(this._shimIfNeeded(plainStyle, shim)));\r\n        const dependencies = [];\r\n        stylesheet.styleUrls.forEach((styleUrl) => {\r\n            const exprIndex = styleExpressions.length;\r\n            // Note: This placeholder will be filled later.\r\n            styleExpressions.push(null);\r\n            dependencies.push(new StylesCompileDependency(getStylesVarName(null), styleUrl, (value) => styleExpressions[exprIndex] = outputCtx.importExpr(value)));\r\n        });\r\n        // styles variable contains plain strings and arrays of other styles arrays (recursive),\r\n        // so we set its type to dynamic.\r\n        const stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);\r\n        const stmt = variable(stylesVar)\r\n            .set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const])))\r\n            .toDeclStmt(null, isComponentStylesheet ? [StmtModifier.Final] : [\r\n            StmtModifier.Final, StmtModifier.Exported\r\n        ]);\r\n        outputCtx.statements.push(stmt);\r\n        return new CompiledStylesheet(outputCtx, stylesVar, dependencies, shim, stylesheet);\r\n    }\r\n    _shimIfNeeded(style, shim) {\r\n        return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;\r\n    }\r\n}\r\nfunction getStylesVarName(component) {\r\n    let result = `styles`;\r\n    if (component) {\r\n        result += `_${identifierName(component.type)}`;\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A path is an ordered set of elements. Typically a path is to  a\r\n * particular offset in a source file. The head of the list is the top\r\n * most node. The tail is the node that contains the offset directly.\r\n *\r\n * For example, the expression `a + b + c` might have an ast that looks\r\n * like:\r\n *     +\r\n *    / \\\r\n *   a   +\r\n *      / \\\r\n *     b   c\r\n *\r\n * The path to the node at offset 9 would be `['+' at 1-10, '+' at 7-10,\r\n * 'c' at 9-10]` and the path the node at offset 1 would be\r\n * `['+' at 1-10, 'a' at 1-2]`.\r\n */\r\nclass AstPath {\r\n    constructor(path, position = -1) {\r\n        this.path = path;\r\n        this.position = position;\r\n    }\r\n    get empty() {\r\n        return !this.path || !this.path.length;\r\n    }\r\n    get head() {\r\n        return this.path[0];\r\n    }\r\n    get tail() {\r\n        return this.path[this.path.length - 1];\r\n    }\r\n    parentOf(node) {\r\n        return node && this.path[this.path.indexOf(node) - 1];\r\n    }\r\n    childOf(node) {\r\n        return this.path[this.path.indexOf(node) + 1];\r\n    }\r\n    first(ctor) {\r\n        for (let i = this.path.length - 1; i >= 0; i--) {\r\n            let item = this.path[i];\r\n            if (item instanceof ctor)\r\n                return item;\r\n        }\r\n    }\r\n    push(node) {\r\n        this.path.push(node);\r\n    }\r\n    pop() {\r\n        return this.path.pop();\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass NodeWithI18n {\r\n    constructor(sourceSpan, i18n) {\r\n        this.sourceSpan = sourceSpan;\r\n        this.i18n = i18n;\r\n    }\r\n}\r\nclass Text$3 extends NodeWithI18n {\r\n    constructor(value, sourceSpan, i18n) {\r\n        super(sourceSpan, i18n);\r\n        this.value = value;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitText(this, context);\r\n    }\r\n}\r\nclass Expansion extends NodeWithI18n {\r\n    constructor(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {\r\n        super(sourceSpan, i18n);\r\n        this.switchValue = switchValue;\r\n        this.type = type;\r\n        this.cases = cases;\r\n        this.switchValueSourceSpan = switchValueSourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitExpansion(this, context);\r\n    }\r\n}\r\nclass ExpansionCase {\r\n    constructor(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {\r\n        this.value = value;\r\n        this.expression = expression;\r\n        this.sourceSpan = sourceSpan;\r\n        this.valueSourceSpan = valueSourceSpan;\r\n        this.expSourceSpan = expSourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitExpansionCase(this, context);\r\n    }\r\n}\r\nclass Attribute extends NodeWithI18n {\r\n    constructor(name, value, sourceSpan, keySpan, valueSpan, i18n) {\r\n        super(sourceSpan, i18n);\r\n        this.name = name;\r\n        this.value = value;\r\n        this.keySpan = keySpan;\r\n        this.valueSpan = valueSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitAttribute(this, context);\r\n    }\r\n}\r\nclass Element$1 extends NodeWithI18n {\r\n    constructor(name, attrs, children, sourceSpan, startSourceSpan, endSourceSpan = null, i18n) {\r\n        super(sourceSpan, i18n);\r\n        this.name = name;\r\n        this.attrs = attrs;\r\n        this.children = children;\r\n        this.startSourceSpan = startSourceSpan;\r\n        this.endSourceSpan = endSourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitElement(this, context);\r\n    }\r\n}\r\nclass Comment$1 {\r\n    constructor(value, sourceSpan) {\r\n        this.value = value;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitComment(this, context);\r\n    }\r\n}\r\nfunction visitAll$1(visitor, nodes, context = null) {\r\n    const result = [];\r\n    const visit = visitor.visit ?\r\n        (ast) => visitor.visit(ast, context) || ast.visit(visitor, context) :\r\n        (ast) => ast.visit(visitor, context);\r\n    nodes.forEach(ast => {\r\n        const astResult = visit(ast);\r\n        if (astResult) {\r\n            result.push(astResult);\r\n        }\r\n    });\r\n    return result;\r\n}\r\nclass RecursiveVisitor$1 {\r\n    constructor() { }\r\n    visitElement(ast, context) {\r\n        this.visitChildren(context, visit => {\r\n            visit(ast.attrs);\r\n            visit(ast.children);\r\n        });\r\n    }\r\n    visitAttribute(ast, context) { }\r\n    visitText(ast, context) { }\r\n    visitComment(ast, context) { }\r\n    visitExpansion(ast, context) {\r\n        return this.visitChildren(context, visit => {\r\n            visit(ast.cases);\r\n        });\r\n    }\r\n    visitExpansionCase(ast, context) { }\r\n    visitChildren(context, cb) {\r\n        let results = [];\r\n        let t = this;\r\n        function visit(children) {\r\n            if (children)\r\n                results.push(visitAll$1(t, children, context));\r\n        }\r\n        cb(visit);\r\n        return Array.prototype.concat.apply([], results);\r\n    }\r\n}\r\nfunction spanOf(ast) {\r\n    const start = ast.sourceSpan.start.offset;\r\n    let end = ast.sourceSpan.end.offset;\r\n    if (ast instanceof Element$1) {\r\n        if (ast.endSourceSpan) {\r\n            end = ast.endSourceSpan.end.offset;\r\n        }\r\n        else if (ast.children && ast.children.length) {\r\n            end = spanOf(ast.children[ast.children.length - 1]).end;\r\n        }\r\n    }\r\n    return { start, end };\r\n}\r\nfunction findNode(nodes, position) {\r\n    const path = [];\r\n    const visitor = new class extends RecursiveVisitor$1 {\r\n        visit(ast, context) {\r\n            const span = spanOf(ast);\r\n            if (span.start <= position && position < span.end) {\r\n                path.push(ast);\r\n            }\r\n            else {\r\n                // Returning a value here will result in the children being skipped.\r\n                return true;\r\n            }\r\n        }\r\n    };\r\n    visitAll$1(visitor, nodes);\r\n    return new AstPath(path, position);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nvar TokenType;\r\n(function (TokenType) {\r\n    TokenType[TokenType[\"TAG_OPEN_START\"] = 0] = \"TAG_OPEN_START\";\r\n    TokenType[TokenType[\"TAG_OPEN_END\"] = 1] = \"TAG_OPEN_END\";\r\n    TokenType[TokenType[\"TAG_OPEN_END_VOID\"] = 2] = \"TAG_OPEN_END_VOID\";\r\n    TokenType[TokenType[\"TAG_CLOSE\"] = 3] = \"TAG_CLOSE\";\r\n    TokenType[TokenType[\"INCOMPLETE_TAG_OPEN\"] = 4] = \"INCOMPLETE_TAG_OPEN\";\r\n    TokenType[TokenType[\"TEXT\"] = 5] = \"TEXT\";\r\n    TokenType[TokenType[\"ESCAPABLE_RAW_TEXT\"] = 6] = \"ESCAPABLE_RAW_TEXT\";\r\n    TokenType[TokenType[\"RAW_TEXT\"] = 7] = \"RAW_TEXT\";\r\n    TokenType[TokenType[\"COMMENT_START\"] = 8] = \"COMMENT_START\";\r\n    TokenType[TokenType[\"COMMENT_END\"] = 9] = \"COMMENT_END\";\r\n    TokenType[TokenType[\"CDATA_START\"] = 10] = \"CDATA_START\";\r\n    TokenType[TokenType[\"CDATA_END\"] = 11] = \"CDATA_END\";\r\n    TokenType[TokenType[\"ATTR_NAME\"] = 12] = \"ATTR_NAME\";\r\n    TokenType[TokenType[\"ATTR_QUOTE\"] = 13] = \"ATTR_QUOTE\";\r\n    TokenType[TokenType[\"ATTR_VALUE\"] = 14] = \"ATTR_VALUE\";\r\n    TokenType[TokenType[\"DOC_TYPE\"] = 15] = \"DOC_TYPE\";\r\n    TokenType[TokenType[\"EXPANSION_FORM_START\"] = 16] = \"EXPANSION_FORM_START\";\r\n    TokenType[TokenType[\"EXPANSION_CASE_VALUE\"] = 17] = \"EXPANSION_CASE_VALUE\";\r\n    TokenType[TokenType[\"EXPANSION_CASE_EXP_START\"] = 18] = \"EXPANSION_CASE_EXP_START\";\r\n    TokenType[TokenType[\"EXPANSION_CASE_EXP_END\"] = 19] = \"EXPANSION_CASE_EXP_END\";\r\n    TokenType[TokenType[\"EXPANSION_FORM_END\"] = 20] = \"EXPANSION_FORM_END\";\r\n    TokenType[TokenType[\"EOF\"] = 21] = \"EOF\";\r\n})(TokenType || (TokenType = {}));\r\nclass Token {\r\n    constructor(type, parts, sourceSpan) {\r\n        this.type = type;\r\n        this.parts = parts;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n}\r\nclass TokenError extends ParseError {\r\n    constructor(errorMsg, tokenType, span) {\r\n        super(span, errorMsg);\r\n        this.tokenType = tokenType;\r\n    }\r\n}\r\nclass TokenizeResult {\r\n    constructor(tokens, errors, nonNormalizedIcuExpressions) {\r\n        this.tokens = tokens;\r\n        this.errors = errors;\r\n        this.nonNormalizedIcuExpressions = nonNormalizedIcuExpressions;\r\n    }\r\n}\r\nfunction tokenize(source, url, getTagDefinition, options = {}) {\r\n    const tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);\r\n    tokenizer.tokenize();\r\n    return new TokenizeResult(mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);\r\n}\r\nconst _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\r\nfunction _unexpectedCharacterErrorMsg(charCode) {\r\n    const char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);\r\n    return `Unexpected character \"${char}\"`;\r\n}\r\nfunction _unknownEntityErrorMsg(entitySrc) {\r\n    return `Unknown entity \"${entitySrc}\" - use the \"&#<decimal>;\" or  \"&#x<hex>;\" syntax`;\r\n}\r\nfunction _unparsableEntityErrorMsg(type, entityStr) {\r\n    return `Unable to parse entity \"${entityStr}\" - ${type} character reference entities must end with \";\"`;\r\n}\r\nvar CharacterReferenceType;\r\n(function (CharacterReferenceType) {\r\n    CharacterReferenceType[\"HEX\"] = \"hexadecimal\";\r\n    CharacterReferenceType[\"DEC\"] = \"decimal\";\r\n})(CharacterReferenceType || (CharacterReferenceType = {}));\r\nclass _ControlFlowError {\r\n    constructor(error) {\r\n        this.error = error;\r\n    }\r\n}\r\n// See https://www.w3.org/TR/html51/syntax.html#writing-html-documents\r\nclass _Tokenizer {\r\n    /**\r\n     * @param _file The html source file being tokenized.\r\n     * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.\r\n     * @param options Configuration of the tokenization.\r\n     */\r\n    constructor(_file, _getTagDefinition, options) {\r\n        this._getTagDefinition = _getTagDefinition;\r\n        this._currentTokenStart = null;\r\n        this._currentTokenType = null;\r\n        this._expansionCaseStack = [];\r\n        this._inInterpolation = false;\r\n        this.tokens = [];\r\n        this.errors = [];\r\n        this.nonNormalizedIcuExpressions = [];\r\n        this._tokenizeIcu = options.tokenizeExpansionForms || false;\r\n        this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\r\n        this._leadingTriviaCodePoints =\r\n            options.leadingTriviaChars && options.leadingTriviaChars.map(c => c.codePointAt(0) || 0);\r\n        const range = options.range || { endPos: _file.content.length, startPos: 0, startLine: 0, startCol: 0 };\r\n        this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) :\r\n            new PlainCharacterCursor(_file, range);\r\n        this._preserveLineEndings = options.preserveLineEndings || false;\r\n        this._escapedString = options.escapedString || false;\r\n        this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;\r\n        try {\r\n            this._cursor.init();\r\n        }\r\n        catch (e) {\r\n            this.handleError(e);\r\n        }\r\n    }\r\n    _processCarriageReturns(content) {\r\n        if (this._preserveLineEndings) {\r\n            return content;\r\n        }\r\n        // https://www.w3.org/TR/html51/syntax.html#preprocessing-the-input-stream\r\n        // In order to keep the original position in the source, we can not\r\n        // pre-process it.\r\n        // Instead CRs are processed right before instantiating the tokens.\r\n        return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\r\n    }\r\n    tokenize() {\r\n        while (this._cursor.peek() !== $EOF) {\r\n            const start = this._cursor.clone();\r\n            try {\r\n                if (this._attemptCharCode($LT)) {\r\n                    if (this._attemptCharCode($BANG)) {\r\n                        if (this._attemptCharCode($LBRACKET)) {\r\n                            this._consumeCdata(start);\r\n                        }\r\n                        else if (this._attemptCharCode($MINUS)) {\r\n                            this._consumeComment(start);\r\n                        }\r\n                        else {\r\n                            this._consumeDocType(start);\r\n                        }\r\n                    }\r\n                    else if (this._attemptCharCode($SLASH)) {\r\n                        this._consumeTagClose(start);\r\n                    }\r\n                    else {\r\n                        this._consumeTagOpen(start);\r\n                    }\r\n                }\r\n                else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\r\n                    this._consumeText();\r\n                }\r\n            }\r\n            catch (e) {\r\n                this.handleError(e);\r\n            }\r\n        }\r\n        this._beginToken(TokenType.EOF);\r\n        this._endToken([]);\r\n    }\r\n    /**\r\n     * @returns whether an ICU token has been created\r\n     * @internal\r\n     */\r\n    _tokenizeExpansionForm() {\r\n        if (this.isExpansionFormStart()) {\r\n            this._consumeExpansionFormStart();\r\n            return true;\r\n        }\r\n        if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {\r\n            this._consumeExpansionCaseStart();\r\n            return true;\r\n        }\r\n        if (this._cursor.peek() === $RBRACE) {\r\n            if (this._isInExpansionCase()) {\r\n                this._consumeExpansionCaseEnd();\r\n                return true;\r\n            }\r\n            if (this._isInExpansionForm()) {\r\n                this._consumeExpansionFormEnd();\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    _beginToken(type, start = this._cursor.clone()) {\r\n        this._currentTokenStart = start;\r\n        this._currentTokenType = type;\r\n    }\r\n    _endToken(parts, end) {\r\n        if (this._currentTokenStart === null) {\r\n            throw new TokenError('Programming error - attempted to end a token when there was no start to the token', this._currentTokenType, this._cursor.getSpan(end));\r\n        }\r\n        if (this._currentTokenType === null) {\r\n            throw new TokenError('Programming error - attempted to end a token which has no token type', null, this._cursor.getSpan(this._currentTokenStart));\r\n        }\r\n        const token = new Token(this._currentTokenType, parts, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));\r\n        this.tokens.push(token);\r\n        this._currentTokenStart = null;\r\n        this._currentTokenType = null;\r\n        return token;\r\n    }\r\n    _createError(msg, span) {\r\n        if (this._isInExpansionForm()) {\r\n            msg += ` (Do you have an unescaped \"{\" in your template? Use \"{{ '{' }}\") to escape it.)`;\r\n        }\r\n        const error = new TokenError(msg, this._currentTokenType, span);\r\n        this._currentTokenStart = null;\r\n        this._currentTokenType = null;\r\n        return new _ControlFlowError(error);\r\n    }\r\n    handleError(e) {\r\n        if (e instanceof CursorError) {\r\n            e = this._createError(e.msg, this._cursor.getSpan(e.cursor));\r\n        }\r\n        if (e instanceof _ControlFlowError) {\r\n            this.errors.push(e.error);\r\n        }\r\n        else {\r\n            throw e;\r\n        }\r\n    }\r\n    _attemptCharCode(charCode) {\r\n        if (this._cursor.peek() === charCode) {\r\n            this._cursor.advance();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    _attemptCharCodeCaseInsensitive(charCode) {\r\n        if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {\r\n            this._cursor.advance();\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    _requireCharCode(charCode) {\r\n        const location = this._cursor.clone();\r\n        if (!this._attemptCharCode(charCode)) {\r\n            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\r\n        }\r\n    }\r\n    _attemptStr(chars) {\r\n        const len = chars.length;\r\n        if (this._cursor.charsLeft() < len) {\r\n            return false;\r\n        }\r\n        const initialPosition = this._cursor.clone();\r\n        for (let i = 0; i < len; i++) {\r\n            if (!this._attemptCharCode(chars.charCodeAt(i))) {\r\n                // If attempting to parse the string fails, we want to reset the parser\r\n                // to where it was before the attempt\r\n                this._cursor = initialPosition;\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    _attemptStrCaseInsensitive(chars) {\r\n        for (let i = 0; i < chars.length; i++) {\r\n            if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    _requireStr(chars) {\r\n        const location = this._cursor.clone();\r\n        if (!this._attemptStr(chars)) {\r\n            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\r\n        }\r\n    }\r\n    _attemptCharCodeUntilFn(predicate) {\r\n        while (!predicate(this._cursor.peek())) {\r\n            this._cursor.advance();\r\n        }\r\n    }\r\n    _requireCharCodeUntilFn(predicate, len) {\r\n        const start = this._cursor.clone();\r\n        this._attemptCharCodeUntilFn(predicate);\r\n        if (this._cursor.diff(start) < len) {\r\n            throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\r\n        }\r\n    }\r\n    _attemptUntilChar(char) {\r\n        while (this._cursor.peek() !== char) {\r\n            this._cursor.advance();\r\n        }\r\n    }\r\n    _readChar(decodeEntities) {\r\n        if (decodeEntities && this._cursor.peek() === $AMPERSAND) {\r\n            return this._decodeEntity();\r\n        }\r\n        else {\r\n            // Don't rely upon reading directly from `_input` as the actual char value\r\n            // may have been generated from an escape sequence.\r\n            const char = String.fromCodePoint(this._cursor.peek());\r\n            this._cursor.advance();\r\n            return char;\r\n        }\r\n    }\r\n    _decodeEntity() {\r\n        const start = this._cursor.clone();\r\n        this._cursor.advance();\r\n        if (this._attemptCharCode($HASH)) {\r\n            const isHex = this._attemptCharCode($x) || this._attemptCharCode($X);\r\n            const codeStart = this._cursor.clone();\r\n            this._attemptCharCodeUntilFn(isDigitEntityEnd);\r\n            if (this._cursor.peek() != $SEMICOLON) {\r\n                // Advance cursor to include the peeked character in the string provided to the error\r\n                // message.\r\n                this._cursor.advance();\r\n                const entityType = isHex ? CharacterReferenceType.HEX : CharacterReferenceType.DEC;\r\n                throw this._createError(_unparsableEntityErrorMsg(entityType, this._cursor.getChars(start)), this._cursor.getSpan());\r\n            }\r\n            const strNum = this._cursor.getChars(codeStart);\r\n            this._cursor.advance();\r\n            try {\r\n                const charCode = parseInt(strNum, isHex ? 16 : 10);\r\n                return String.fromCharCode(charCode);\r\n            }\r\n            catch (_a) {\r\n                throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());\r\n            }\r\n        }\r\n        else {\r\n            const nameStart = this._cursor.clone();\r\n            this._attemptCharCodeUntilFn(isNamedEntityEnd);\r\n            if (this._cursor.peek() != $SEMICOLON) {\r\n                this._cursor = nameStart;\r\n                return '&';\r\n            }\r\n            const name = this._cursor.getChars(nameStart);\r\n            this._cursor.advance();\r\n            const char = NAMED_ENTITIES[name];\r\n            if (!char) {\r\n                throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));\r\n            }\r\n            return char;\r\n        }\r\n    }\r\n    _consumeRawText(decodeEntities, endMarkerPredicate) {\r\n        this._beginToken(decodeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT);\r\n        const parts = [];\r\n        while (true) {\r\n            const tagCloseStart = this._cursor.clone();\r\n            const foundEndMarker = endMarkerPredicate();\r\n            this._cursor = tagCloseStart;\r\n            if (foundEndMarker) {\r\n                break;\r\n            }\r\n            parts.push(this._readChar(decodeEntities));\r\n        }\r\n        return this._endToken([this._processCarriageReturns(parts.join(''))]);\r\n    }\r\n    _consumeComment(start) {\r\n        this._beginToken(TokenType.COMMENT_START, start);\r\n        this._requireCharCode($MINUS);\r\n        this._endToken([]);\r\n        this._consumeRawText(false, () => this._attemptStr('-->'));\r\n        this._beginToken(TokenType.COMMENT_END);\r\n        this._requireStr('-->');\r\n        this._endToken([]);\r\n    }\r\n    _consumeCdata(start) {\r\n        this._beginToken(TokenType.CDATA_START, start);\r\n        this._requireStr('CDATA[');\r\n        this._endToken([]);\r\n        this._consumeRawText(false, () => this._attemptStr(']]>'));\r\n        this._beginToken(TokenType.CDATA_END);\r\n        this._requireStr(']]>');\r\n        this._endToken([]);\r\n    }\r\n    _consumeDocType(start) {\r\n        this._beginToken(TokenType.DOC_TYPE, start);\r\n        const contentStart = this._cursor.clone();\r\n        this._attemptUntilChar($GT);\r\n        const content = this._cursor.getChars(contentStart);\r\n        this._cursor.advance();\r\n        this._endToken([content]);\r\n    }\r\n    _consumePrefixAndName() {\r\n        const nameOrPrefixStart = this._cursor.clone();\r\n        let prefix = '';\r\n        while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {\r\n            this._cursor.advance();\r\n        }\r\n        let nameStart;\r\n        if (this._cursor.peek() === $COLON) {\r\n            prefix = this._cursor.getChars(nameOrPrefixStart);\r\n            this._cursor.advance();\r\n            nameStart = this._cursor.clone();\r\n        }\r\n        else {\r\n            nameStart = nameOrPrefixStart;\r\n        }\r\n        this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);\r\n        const name = this._cursor.getChars(nameStart);\r\n        return [prefix, name];\r\n    }\r\n    _consumeTagOpen(start) {\r\n        let tagName;\r\n        let prefix;\r\n        let openTagToken;\r\n        try {\r\n            if (!isAsciiLetter(this._cursor.peek())) {\r\n                throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\r\n            }\r\n            openTagToken = this._consumeTagOpenStart(start);\r\n            prefix = openTagToken.parts[0];\r\n            tagName = openTagToken.parts[1];\r\n            this._attemptCharCodeUntilFn(isNotWhitespace);\r\n            while (this._cursor.peek() !== $SLASH && this._cursor.peek() !== $GT &&\r\n                this._cursor.peek() !== $LT && this._cursor.peek() !== $EOF) {\r\n                this._consumeAttributeName();\r\n                this._attemptCharCodeUntilFn(isNotWhitespace);\r\n                if (this._attemptCharCode($EQ)) {\r\n                    this._attemptCharCodeUntilFn(isNotWhitespace);\r\n                    this._consumeAttributeValue();\r\n                }\r\n                this._attemptCharCodeUntilFn(isNotWhitespace);\r\n            }\r\n            this._consumeTagOpenEnd();\r\n        }\r\n        catch (e) {\r\n            if (e instanceof _ControlFlowError) {\r\n                if (openTagToken) {\r\n                    // We errored before we could close the opening tag, so it is incomplete.\r\n                    openTagToken.type = TokenType.INCOMPLETE_TAG_OPEN;\r\n                }\r\n                else {\r\n                    // When the start tag is invalid, assume we want a \"<\" as text.\r\n                    // Back to back text tokens are merged at the end.\r\n                    this._beginToken(TokenType.TEXT, start);\r\n                    this._endToken(['<']);\r\n                }\r\n                return;\r\n            }\r\n            throw e;\r\n        }\r\n        const contentTokenType = this._getTagDefinition(tagName).getContentType(prefix);\r\n        if (contentTokenType === TagContentType.RAW_TEXT) {\r\n            this._consumeRawTextWithTagClose(prefix, tagName, false);\r\n        }\r\n        else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\r\n            this._consumeRawTextWithTagClose(prefix, tagName, true);\r\n        }\r\n    }\r\n    _consumeRawTextWithTagClose(prefix, tagName, decodeEntities) {\r\n        this._consumeRawText(decodeEntities, () => {\r\n            if (!this._attemptCharCode($LT))\r\n                return false;\r\n            if (!this._attemptCharCode($SLASH))\r\n                return false;\r\n            this._attemptCharCodeUntilFn(isNotWhitespace);\r\n            if (!this._attemptStrCaseInsensitive(tagName))\r\n                return false;\r\n            this._attemptCharCodeUntilFn(isNotWhitespace);\r\n            return this._attemptCharCode($GT);\r\n        });\r\n        this._beginToken(TokenType.TAG_CLOSE);\r\n        this._requireCharCodeUntilFn(code => code === $GT, 3);\r\n        this._cursor.advance(); // Consume the `>`\r\n        this._endToken([prefix, tagName]);\r\n    }\r\n    _consumeTagOpenStart(start) {\r\n        this._beginToken(TokenType.TAG_OPEN_START, start);\r\n        const parts = this._consumePrefixAndName();\r\n        return this._endToken(parts);\r\n    }\r\n    _consumeAttributeName() {\r\n        const attrNameStart = this._cursor.peek();\r\n        if (attrNameStart === $SQ || attrNameStart === $DQ) {\r\n            throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());\r\n        }\r\n        this._beginToken(TokenType.ATTR_NAME);\r\n        const prefixAndName = this._consumePrefixAndName();\r\n        this._endToken(prefixAndName);\r\n    }\r\n    _consumeAttributeValue() {\r\n        let value;\r\n        if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {\r\n            this._beginToken(TokenType.ATTR_QUOTE);\r\n            const quoteChar = this._cursor.peek();\r\n            this._cursor.advance();\r\n            this._endToken([String.fromCodePoint(quoteChar)]);\r\n            this._beginToken(TokenType.ATTR_VALUE);\r\n            const parts = [];\r\n            while (this._cursor.peek() !== quoteChar) {\r\n                parts.push(this._readChar(true));\r\n            }\r\n            value = parts.join('');\r\n            this._endToken([this._processCarriageReturns(value)]);\r\n            this._beginToken(TokenType.ATTR_QUOTE);\r\n            this._cursor.advance();\r\n            this._endToken([String.fromCodePoint(quoteChar)]);\r\n        }\r\n        else {\r\n            this._beginToken(TokenType.ATTR_VALUE);\r\n            const valueStart = this._cursor.clone();\r\n            this._requireCharCodeUntilFn(isNameEnd, 1);\r\n            value = this._cursor.getChars(valueStart);\r\n            this._endToken([this._processCarriageReturns(value)]);\r\n        }\r\n    }\r\n    _consumeTagOpenEnd() {\r\n        const tokenType = this._attemptCharCode($SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;\r\n        this._beginToken(tokenType);\r\n        this._requireCharCode($GT);\r\n        this._endToken([]);\r\n    }\r\n    _consumeTagClose(start) {\r\n        this._beginToken(TokenType.TAG_CLOSE, start);\r\n        this._attemptCharCodeUntilFn(isNotWhitespace);\r\n        const prefixAndName = this._consumePrefixAndName();\r\n        this._attemptCharCodeUntilFn(isNotWhitespace);\r\n        this._requireCharCode($GT);\r\n        this._endToken(prefixAndName);\r\n    }\r\n    _consumeExpansionFormStart() {\r\n        this._beginToken(TokenType.EXPANSION_FORM_START);\r\n        this._requireCharCode($LBRACE);\r\n        this._endToken([]);\r\n        this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);\r\n        this._beginToken(TokenType.RAW_TEXT);\r\n        const condition = this._readUntil($COMMA);\r\n        const normalizedCondition = this._processCarriageReturns(condition);\r\n        if (this._i18nNormalizeLineEndingsInICUs) {\r\n            // We explicitly want to normalize line endings for this text.\r\n            this._endToken([normalizedCondition]);\r\n        }\r\n        else {\r\n            // We are not normalizing line endings.\r\n            const conditionToken = this._endToken([condition]);\r\n            if (normalizedCondition !== condition) {\r\n                this.nonNormalizedIcuExpressions.push(conditionToken);\r\n            }\r\n        }\r\n        this._requireCharCode($COMMA);\r\n        this._attemptCharCodeUntilFn(isNotWhitespace);\r\n        this._beginToken(TokenType.RAW_TEXT);\r\n        const type = this._readUntil($COMMA);\r\n        this._endToken([type]);\r\n        this._requireCharCode($COMMA);\r\n        this._attemptCharCodeUntilFn(isNotWhitespace);\r\n    }\r\n    _consumeExpansionCaseStart() {\r\n        this._beginToken(TokenType.EXPANSION_CASE_VALUE);\r\n        const value = this._readUntil($LBRACE).trim();\r\n        this._endToken([value]);\r\n        this._attemptCharCodeUntilFn(isNotWhitespace);\r\n        this._beginToken(TokenType.EXPANSION_CASE_EXP_START);\r\n        this._requireCharCode($LBRACE);\r\n        this._endToken([]);\r\n        this._attemptCharCodeUntilFn(isNotWhitespace);\r\n        this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);\r\n    }\r\n    _consumeExpansionCaseEnd() {\r\n        this._beginToken(TokenType.EXPANSION_CASE_EXP_END);\r\n        this._requireCharCode($RBRACE);\r\n        this._endToken([]);\r\n        this._attemptCharCodeUntilFn(isNotWhitespace);\r\n        this._expansionCaseStack.pop();\r\n    }\r\n    _consumeExpansionFormEnd() {\r\n        this._beginToken(TokenType.EXPANSION_FORM_END);\r\n        this._requireCharCode($RBRACE);\r\n        this._endToken([]);\r\n        this._expansionCaseStack.pop();\r\n    }\r\n    _consumeText() {\r\n        const start = this._cursor.clone();\r\n        this._beginToken(TokenType.TEXT, start);\r\n        const parts = [];\r\n        do {\r\n            if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\r\n                parts.push(this._interpolationConfig.start);\r\n                this._inInterpolation = true;\r\n            }\r\n            else if (this._interpolationConfig && this._inInterpolation &&\r\n                this._attemptStr(this._interpolationConfig.end)) {\r\n                parts.push(this._interpolationConfig.end);\r\n                this._inInterpolation = false;\r\n            }\r\n            else {\r\n                parts.push(this._readChar(true));\r\n            }\r\n        } while (!this._isTextEnd());\r\n        // It is possible that an interpolation was started but not ended inside this text token.\r\n        // Make sure that we reset the state of the lexer correctly.\r\n        this._inInterpolation = false;\r\n        this._endToken([this._processCarriageReturns(parts.join(''))]);\r\n    }\r\n    _isTextEnd() {\r\n        if (this._isTagStart() || this._cursor.peek() === $EOF) {\r\n            return true;\r\n        }\r\n        if (this._tokenizeIcu && !this._inInterpolation) {\r\n            if (this.isExpansionFormStart()) {\r\n                // start of an expansion form\r\n                return true;\r\n            }\r\n            if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {\r\n                // end of and expansion case\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    /**\r\n     * Returns true if the current cursor is pointing to the start of a tag\r\n     * (opening/closing/comments/cdata/etc).\r\n     */\r\n    _isTagStart() {\r\n        if (this._cursor.peek() === $LT) {\r\n            // We assume that `<` followed by whitespace is not the start of an HTML element.\r\n            const tmp = this._cursor.clone();\r\n            tmp.advance();\r\n            // If the next character is alphabetic, ! nor / then it is a tag start\r\n            const code = tmp.peek();\r\n            if (($a <= code && code <= $z) || ($A <= code && code <= $Z) ||\r\n                code === $SLASH || code === $BANG) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    _readUntil(char) {\r\n        const start = this._cursor.clone();\r\n        this._attemptUntilChar(char);\r\n        return this._cursor.getChars(start);\r\n    }\r\n    _isInExpansionCase() {\r\n        return this._expansionCaseStack.length > 0 &&\r\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\r\n                TokenType.EXPANSION_CASE_EXP_START;\r\n    }\r\n    _isInExpansionForm() {\r\n        return this._expansionCaseStack.length > 0 &&\r\n            this._expansionCaseStack[this._expansionCaseStack.length - 1] ===\r\n                TokenType.EXPANSION_FORM_START;\r\n    }\r\n    isExpansionFormStart() {\r\n        if (this._cursor.peek() !== $LBRACE) {\r\n            return false;\r\n        }\r\n        if (this._interpolationConfig) {\r\n            const start = this._cursor.clone();\r\n            const isInterpolation = this._attemptStr(this._interpolationConfig.start);\r\n            this._cursor = start;\r\n            return !isInterpolation;\r\n        }\r\n        return true;\r\n    }\r\n}\r\nfunction isNotWhitespace(code) {\r\n    return !isWhitespace(code) || code === $EOF;\r\n}\r\nfunction isNameEnd(code) {\r\n    return isWhitespace(code) || code === $GT || code === $LT ||\r\n        code === $SLASH || code === $SQ || code === $DQ || code === $EQ ||\r\n        code === $EOF;\r\n}\r\nfunction isPrefixEnd(code) {\r\n    return (code < $a || $z < code) && (code < $A || $Z < code) &&\r\n        (code < $0 || code > $9);\r\n}\r\nfunction isDigitEntityEnd(code) {\r\n    return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);\r\n}\r\nfunction isNamedEntityEnd(code) {\r\n    return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);\r\n}\r\nfunction isExpansionCaseStart(peek) {\r\n    return peek !== $RBRACE;\r\n}\r\nfunction compareCharCodeCaseInsensitive(code1, code2) {\r\n    return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);\r\n}\r\nfunction toUpperCaseCharCode(code) {\r\n    return code >= $a && code <= $z ? code - $a + $A : code;\r\n}\r\nfunction mergeTextTokens(srcTokens) {\r\n    const dstTokens = [];\r\n    let lastDstToken = undefined;\r\n    for (let i = 0; i < srcTokens.length; i++) {\r\n        const token = srcTokens[i];\r\n        if (lastDstToken && lastDstToken.type == TokenType.TEXT && token.type == TokenType.TEXT) {\r\n            lastDstToken.parts[0] += token.parts[0];\r\n            lastDstToken.sourceSpan.end = token.sourceSpan.end;\r\n        }\r\n        else {\r\n            lastDstToken = token;\r\n            dstTokens.push(lastDstToken);\r\n        }\r\n    }\r\n    return dstTokens;\r\n}\r\nclass PlainCharacterCursor {\r\n    constructor(fileOrCursor, range) {\r\n        if (fileOrCursor instanceof PlainCharacterCursor) {\r\n            this.file = fileOrCursor.file;\r\n            this.input = fileOrCursor.input;\r\n            this.end = fileOrCursor.end;\r\n            const state = fileOrCursor.state;\r\n            // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.\r\n            // In ES5 bundles the object spread operator is translated into the `__assign` helper, which\r\n            // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is\r\n            // called in tight loops, this difference matters.\r\n            this.state = {\r\n                peek: state.peek,\r\n                offset: state.offset,\r\n                line: state.line,\r\n                column: state.column,\r\n            };\r\n        }\r\n        else {\r\n            if (!range) {\r\n                throw new Error('Programming error: the range argument must be provided with a file argument.');\r\n            }\r\n            this.file = fileOrCursor;\r\n            this.input = fileOrCursor.content;\r\n            this.end = range.endPos;\r\n            this.state = {\r\n                peek: -1,\r\n                offset: range.startPos,\r\n                line: range.startLine,\r\n                column: range.startCol,\r\n            };\r\n        }\r\n    }\r\n    clone() {\r\n        return new PlainCharacterCursor(this);\r\n    }\r\n    peek() {\r\n        return this.state.peek;\r\n    }\r\n    charsLeft() {\r\n        return this.end - this.state.offset;\r\n    }\r\n    diff(other) {\r\n        return this.state.offset - other.state.offset;\r\n    }\r\n    advance() {\r\n        this.advanceState(this.state);\r\n    }\r\n    init() {\r\n        this.updatePeek(this.state);\r\n    }\r\n    getSpan(start, leadingTriviaCodePoints) {\r\n        start = start || this;\r\n        let fullStart = start;\r\n        if (leadingTriviaCodePoints) {\r\n            while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {\r\n                if (fullStart === start) {\r\n                    start = start.clone();\r\n                }\r\n                start.advance();\r\n            }\r\n        }\r\n        const startLocation = this.locationFromCursor(start);\r\n        const endLocation = this.locationFromCursor(this);\r\n        const fullStartLocation = fullStart !== start ? this.locationFromCursor(fullStart) : startLocation;\r\n        return new ParseSourceSpan(startLocation, endLocation, fullStartLocation);\r\n    }\r\n    getChars(start) {\r\n        return this.input.substring(start.state.offset, this.state.offset);\r\n    }\r\n    charAt(pos) {\r\n        return this.input.charCodeAt(pos);\r\n    }\r\n    advanceState(state) {\r\n        if (state.offset >= this.end) {\r\n            this.state = state;\r\n            throw new CursorError('Unexpected character \"EOF\"', this);\r\n        }\r\n        const currentChar = this.charAt(state.offset);\r\n        if (currentChar === $LF) {\r\n            state.line++;\r\n            state.column = 0;\r\n        }\r\n        else if (!isNewLine(currentChar)) {\r\n            state.column++;\r\n        }\r\n        state.offset++;\r\n        this.updatePeek(state);\r\n    }\r\n    updatePeek(state) {\r\n        state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);\r\n    }\r\n    locationFromCursor(cursor) {\r\n        return new ParseLocation(cursor.file, cursor.state.offset, cursor.state.line, cursor.state.column);\r\n    }\r\n}\r\nclass EscapedCharacterCursor extends PlainCharacterCursor {\r\n    constructor(fileOrCursor, range) {\r\n        if (fileOrCursor instanceof EscapedCharacterCursor) {\r\n            super(fileOrCursor);\r\n            this.internalState = Object.assign({}, fileOrCursor.internalState);\r\n        }\r\n        else {\r\n            super(fileOrCursor, range);\r\n            this.internalState = this.state;\r\n        }\r\n    }\r\n    advance() {\r\n        this.state = this.internalState;\r\n        super.advance();\r\n        this.processEscapeSequence();\r\n    }\r\n    init() {\r\n        super.init();\r\n        this.processEscapeSequence();\r\n    }\r\n    clone() {\r\n        return new EscapedCharacterCursor(this);\r\n    }\r\n    getChars(start) {\r\n        const cursor = start.clone();\r\n        let chars = '';\r\n        while (cursor.internalState.offset < this.internalState.offset) {\r\n            chars += String.fromCodePoint(cursor.peek());\r\n            cursor.advance();\r\n        }\r\n        return chars;\r\n    }\r\n    /**\r\n     * Process the escape sequence that starts at the current position in the text.\r\n     *\r\n     * This method is called to ensure that `peek` has the unescaped value of escape sequences.\r\n     */\r\n    processEscapeSequence() {\r\n        const peek = () => this.internalState.peek;\r\n        if (peek() === $BACKSLASH) {\r\n            // We have hit an escape sequence so we need the internal state to become independent\r\n            // of the external state.\r\n            this.internalState = Object.assign({}, this.state);\r\n            // Move past the backslash\r\n            this.advanceState(this.internalState);\r\n            // First check for standard control char sequences\r\n            if (peek() === $n) {\r\n                this.state.peek = $LF;\r\n            }\r\n            else if (peek() === $r) {\r\n                this.state.peek = $CR;\r\n            }\r\n            else if (peek() === $v) {\r\n                this.state.peek = $VTAB;\r\n            }\r\n            else if (peek() === $t) {\r\n                this.state.peek = $TAB;\r\n            }\r\n            else if (peek() === $b) {\r\n                this.state.peek = $BSPACE;\r\n            }\r\n            else if (peek() === $f) {\r\n                this.state.peek = $FF;\r\n            }\r\n            // Now consider more complex sequences\r\n            else if (peek() === $u) {\r\n                // Unicode code-point sequence\r\n                this.advanceState(this.internalState); // advance past the `u` char\r\n                if (peek() === $LBRACE) {\r\n                    // Variable length Unicode, e.g. `\\x{123}`\r\n                    this.advanceState(this.internalState); // advance past the `{` char\r\n                    // Advance past the variable number of hex digits until we hit a `}` char\r\n                    const digitStart = this.clone();\r\n                    let length = 0;\r\n                    while (peek() !== $RBRACE) {\r\n                        this.advanceState(this.internalState);\r\n                        length++;\r\n                    }\r\n                    this.state.peek = this.decodeHexDigits(digitStart, length);\r\n                }\r\n                else {\r\n                    // Fixed length Unicode, e.g. `\\u1234`\r\n                    const digitStart = this.clone();\r\n                    this.advanceState(this.internalState);\r\n                    this.advanceState(this.internalState);\r\n                    this.advanceState(this.internalState);\r\n                    this.state.peek = this.decodeHexDigits(digitStart, 4);\r\n                }\r\n            }\r\n            else if (peek() === $x) {\r\n                // Hex char code, e.g. `\\x2F`\r\n                this.advanceState(this.internalState); // advance past the `x` char\r\n                const digitStart = this.clone();\r\n                this.advanceState(this.internalState);\r\n                this.state.peek = this.decodeHexDigits(digitStart, 2);\r\n            }\r\n            else if (isOctalDigit(peek())) {\r\n                // Octal char code, e.g. `\\012`,\r\n                let octal = '';\r\n                let length = 0;\r\n                let previous = this.clone();\r\n                while (isOctalDigit(peek()) && length < 3) {\r\n                    previous = this.clone();\r\n                    octal += String.fromCodePoint(peek());\r\n                    this.advanceState(this.internalState);\r\n                    length++;\r\n                }\r\n                this.state.peek = parseInt(octal, 8);\r\n                // Backup one char\r\n                this.internalState = previous.internalState;\r\n            }\r\n            else if (isNewLine(this.internalState.peek)) {\r\n                // Line continuation `\\` followed by a new line\r\n                this.advanceState(this.internalState); // advance over the newline\r\n                this.state = this.internalState;\r\n            }\r\n            else {\r\n                // If none of the `if` blocks were executed then we just have an escaped normal character.\r\n                // In that case we just, effectively, skip the backslash from the character.\r\n                this.state.peek = this.internalState.peek;\r\n            }\r\n        }\r\n    }\r\n    decodeHexDigits(start, length) {\r\n        const hex = this.input.substr(start.internalState.offset, length);\r\n        const charCode = parseInt(hex, 16);\r\n        if (!isNaN(charCode)) {\r\n            return charCode;\r\n        }\r\n        else {\r\n            start.state = start.internalState;\r\n            throw new CursorError('Invalid hexadecimal escape sequence', start);\r\n        }\r\n    }\r\n}\r\nclass CursorError {\r\n    constructor(msg, cursor) {\r\n        this.msg = msg;\r\n        this.cursor = cursor;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass TreeError extends ParseError {\r\n    constructor(elementName, span, msg) {\r\n        super(span, msg);\r\n        this.elementName = elementName;\r\n    }\r\n    static create(elementName, span, msg) {\r\n        return new TreeError(elementName, span, msg);\r\n    }\r\n}\r\nclass ParseTreeResult {\r\n    constructor(rootNodes, errors) {\r\n        this.rootNodes = rootNodes;\r\n        this.errors = errors;\r\n    }\r\n}\r\nclass Parser {\r\n    constructor(getTagDefinition) {\r\n        this.getTagDefinition = getTagDefinition;\r\n    }\r\n    parse(source, url, options) {\r\n        const tokenizeResult = tokenize(source, url, this.getTagDefinition, options);\r\n        const parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);\r\n        parser.build();\r\n        return new ParseTreeResult(parser.rootNodes, tokenizeResult.errors.concat(parser.errors));\r\n    }\r\n}\r\nclass _TreeBuilder {\r\n    constructor(tokens, getTagDefinition) {\r\n        this.tokens = tokens;\r\n        this.getTagDefinition = getTagDefinition;\r\n        this._index = -1;\r\n        this._elementStack = [];\r\n        this.rootNodes = [];\r\n        this.errors = [];\r\n        this._advance();\r\n    }\r\n    build() {\r\n        while (this._peek.type !== TokenType.EOF) {\r\n            if (this._peek.type === TokenType.TAG_OPEN_START ||\r\n                this._peek.type === TokenType.INCOMPLETE_TAG_OPEN) {\r\n                this._consumeStartTag(this._advance());\r\n            }\r\n            else if (this._peek.type === TokenType.TAG_CLOSE) {\r\n                this._consumeEndTag(this._advance());\r\n            }\r\n            else if (this._peek.type === TokenType.CDATA_START) {\r\n                this._closeVoidElement();\r\n                this._consumeCdata(this._advance());\r\n            }\r\n            else if (this._peek.type === TokenType.COMMENT_START) {\r\n                this._closeVoidElement();\r\n                this._consumeComment(this._advance());\r\n            }\r\n            else if (this._peek.type === TokenType.TEXT || this._peek.type === TokenType.RAW_TEXT ||\r\n                this._peek.type === TokenType.ESCAPABLE_RAW_TEXT) {\r\n                this._closeVoidElement();\r\n                this._consumeText(this._advance());\r\n            }\r\n            else if (this._peek.type === TokenType.EXPANSION_FORM_START) {\r\n                this._consumeExpansion(this._advance());\r\n            }\r\n            else {\r\n                // Skip all other tokens...\r\n                this._advance();\r\n            }\r\n        }\r\n    }\r\n    _advance() {\r\n        const prev = this._peek;\r\n        if (this._index < this.tokens.length - 1) {\r\n            // Note: there is always an EOF token at the end\r\n            this._index++;\r\n        }\r\n        this._peek = this.tokens[this._index];\r\n        return prev;\r\n    }\r\n    _advanceIf(type) {\r\n        if (this._peek.type === type) {\r\n            return this._advance();\r\n        }\r\n        return null;\r\n    }\r\n    _consumeCdata(_startToken) {\r\n        this._consumeText(this._advance());\r\n        this._advanceIf(TokenType.CDATA_END);\r\n    }\r\n    _consumeComment(token) {\r\n        const text = this._advanceIf(TokenType.RAW_TEXT);\r\n        this._advanceIf(TokenType.COMMENT_END);\r\n        const value = text != null ? text.parts[0].trim() : null;\r\n        this._addToParent(new Comment$1(value, token.sourceSpan));\r\n    }\r\n    _consumeExpansion(token) {\r\n        const switchValue = this._advance();\r\n        const type = this._advance();\r\n        const cases = [];\r\n        // read =\r\n        while (this._peek.type === TokenType.EXPANSION_CASE_VALUE) {\r\n            const expCase = this._parseExpansionCase();\r\n            if (!expCase)\r\n                return; // error\r\n            cases.push(expCase);\r\n        }\r\n        // read the final }\r\n        if (this._peek.type !== TokenType.EXPANSION_FORM_END) {\r\n            this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '}'.`));\r\n            return;\r\n        }\r\n        const sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end, token.sourceSpan.fullStart);\r\n        this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\r\n        this._advance();\r\n    }\r\n    _parseExpansionCase() {\r\n        const value = this._advance();\r\n        // read {\r\n        if (this._peek.type !== TokenType.EXPANSION_CASE_EXP_START) {\r\n            this.errors.push(TreeError.create(null, this._peek.sourceSpan, `Invalid ICU message. Missing '{'.`));\r\n            return null;\r\n        }\r\n        // read until }\r\n        const start = this._advance();\r\n        const exp = this._collectExpansionExpTokens(start);\r\n        if (!exp)\r\n            return null;\r\n        const end = this._advance();\r\n        exp.push(new Token(TokenType.EOF, [], end.sourceSpan));\r\n        // parse everything in between { and }\r\n        const expansionCaseParser = new _TreeBuilder(exp, this.getTagDefinition);\r\n        expansionCaseParser.build();\r\n        if (expansionCaseParser.errors.length > 0) {\r\n            this.errors = this.errors.concat(expansionCaseParser.errors);\r\n            return null;\r\n        }\r\n        const sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end, value.sourceSpan.fullStart);\r\n        const expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end, start.sourceSpan.fullStart);\r\n        return new ExpansionCase(value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\r\n    }\r\n    _collectExpansionExpTokens(start) {\r\n        const exp = [];\r\n        const expansionFormStack = [TokenType.EXPANSION_CASE_EXP_START];\r\n        while (true) {\r\n            if (this._peek.type === TokenType.EXPANSION_FORM_START ||\r\n                this._peek.type === TokenType.EXPANSION_CASE_EXP_START) {\r\n                expansionFormStack.push(this._peek.type);\r\n            }\r\n            if (this._peek.type === TokenType.EXPANSION_CASE_EXP_END) {\r\n                if (lastOnStack(expansionFormStack, TokenType.EXPANSION_CASE_EXP_START)) {\r\n                    expansionFormStack.pop();\r\n                    if (expansionFormStack.length == 0)\r\n                        return exp;\r\n                }\r\n                else {\r\n                    this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\r\n                    return null;\r\n                }\r\n            }\r\n            if (this._peek.type === TokenType.EXPANSION_FORM_END) {\r\n                if (lastOnStack(expansionFormStack, TokenType.EXPANSION_FORM_START)) {\r\n                    expansionFormStack.pop();\r\n                }\r\n                else {\r\n                    this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\r\n                    return null;\r\n                }\r\n            }\r\n            if (this._peek.type === TokenType.EOF) {\r\n                this.errors.push(TreeError.create(null, start.sourceSpan, `Invalid ICU message. Missing '}'.`));\r\n                return null;\r\n            }\r\n            exp.push(this._advance());\r\n        }\r\n    }\r\n    _consumeText(token) {\r\n        let text = token.parts[0];\r\n        if (text.length > 0 && text[0] == '\\n') {\r\n            const parent = this._getParentElement();\r\n            if (parent != null && parent.children.length == 0 &&\r\n                this.getTagDefinition(parent.name).ignoreFirstLf) {\r\n                text = text.substring(1);\r\n            }\r\n        }\r\n        if (text.length > 0) {\r\n            this._addToParent(new Text$3(text, token.sourceSpan));\r\n        }\r\n    }\r\n    _closeVoidElement() {\r\n        const el = this._getParentElement();\r\n        if (el && this.getTagDefinition(el.name).isVoid) {\r\n            this._elementStack.pop();\r\n        }\r\n    }\r\n    _consumeStartTag(startTagToken) {\r\n        const [prefix, name] = startTagToken.parts;\r\n        const attrs = [];\r\n        while (this._peek.type === TokenType.ATTR_NAME) {\r\n            attrs.push(this._consumeAttr(this._advance()));\r\n        }\r\n        const fullName = this._getElementFullName(prefix, name, this._getParentElement());\r\n        let selfClosing = false;\r\n        // Note: There could have been a tokenizer error\r\n        // so that we don't get a token for the end tag...\r\n        if (this._peek.type === TokenType.TAG_OPEN_END_VOID) {\r\n            this._advance();\r\n            selfClosing = true;\r\n            const tagDef = this.getTagDefinition(fullName);\r\n            if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\r\n                this.errors.push(TreeError.create(fullName, startTagToken.sourceSpan, `Only void and foreign elements can be self closed \"${startTagToken.parts[1]}\"`));\r\n            }\r\n        }\r\n        else if (this._peek.type === TokenType.TAG_OPEN_END) {\r\n            this._advance();\r\n            selfClosing = false;\r\n        }\r\n        const end = this._peek.sourceSpan.fullStart;\r\n        const span = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\r\n        // Create a separate `startSpan` because `span` will be modified when there is an `end` span.\r\n        const startSpan = new ParseSourceSpan(startTagToken.sourceSpan.start, end, startTagToken.sourceSpan.fullStart);\r\n        const el = new Element$1(fullName, attrs, [], span, startSpan, undefined);\r\n        this._pushElement(el);\r\n        if (selfClosing) {\r\n            // Elements that are self-closed have their `endSourceSpan` set to the full span, as the\r\n            // element start tag also represents the end tag.\r\n            this._popElement(fullName, span);\r\n        }\r\n        else if (startTagToken.type === TokenType.INCOMPLETE_TAG_OPEN) {\r\n            // We already know the opening tag is not complete, so it is unlikely it has a corresponding\r\n            // close tag. Let's optimistically parse it as a full element and emit an error.\r\n            this._popElement(fullName, null);\r\n            this.errors.push(TreeError.create(fullName, span, `Opening tag \"${fullName}\" not terminated.`));\r\n        }\r\n    }\r\n    _pushElement(el) {\r\n        const parentEl = this._getParentElement();\r\n        if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\r\n            this._elementStack.pop();\r\n        }\r\n        this._addToParent(el);\r\n        this._elementStack.push(el);\r\n    }\r\n    _consumeEndTag(endTagToken) {\r\n        const fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\r\n        if (this.getTagDefinition(fullName).isVoid) {\r\n            this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, `Void elements do not have end tags \"${endTagToken.parts[1]}\"`));\r\n        }\r\n        else if (!this._popElement(fullName, endTagToken.sourceSpan)) {\r\n            const errMsg = `Unexpected closing tag \"${fullName}\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags`;\r\n            this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\r\n        }\r\n    }\r\n    /**\r\n     * Closes the nearest element with the tag name `fullName` in the parse tree.\r\n     * `endSourceSpan` is the span of the closing tag, or null if the element does\r\n     * not have a closing tag (for example, this happens when an incomplete\r\n     * opening tag is recovered).\r\n     */\r\n    _popElement(fullName, endSourceSpan) {\r\n        let unexpectedCloseTagDetected = false;\r\n        for (let stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\r\n            const el = this._elementStack[stackIndex];\r\n            if (el.name == fullName) {\r\n                // Record the parse span with the element that is being closed. Any elements that are\r\n                // removed from the element stack at this point are closed implicitly, so they won't get\r\n                // an end source span (as there is no explicit closing element).\r\n                el.endSourceSpan = endSourceSpan;\r\n                el.sourceSpan.end = endSourceSpan !== null ? endSourceSpan.end : el.sourceSpan.end;\r\n                this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\r\n                return !unexpectedCloseTagDetected;\r\n            }\r\n            if (!this.getTagDefinition(el.name).closedByParent) {\r\n                // Note that we encountered an unexpected close tag but continue processing the element\r\n                // stack so we can assign an `endSourceSpan` if there is a corresponding start tag for this\r\n                // end tag in the stack.\r\n                unexpectedCloseTagDetected = true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    _consumeAttr(attrName) {\r\n        const fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\r\n        let end = attrName.sourceSpan.end;\r\n        let value = '';\r\n        let valueSpan = undefined;\r\n        if (this._peek.type === TokenType.ATTR_QUOTE) {\r\n            this._advance();\r\n        }\r\n        if (this._peek.type === TokenType.ATTR_VALUE) {\r\n            const valueToken = this._advance();\r\n            value = valueToken.parts[0];\r\n            end = valueToken.sourceSpan.end;\r\n            valueSpan = valueToken.sourceSpan;\r\n        }\r\n        if (this._peek.type === TokenType.ATTR_QUOTE) {\r\n            const quoteToken = this._advance();\r\n            end = quoteToken.sourceSpan.end;\r\n        }\r\n        const keySpan = new ParseSourceSpan(attrName.sourceSpan.start, attrName.sourceSpan.end);\r\n        return new Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end, attrName.sourceSpan.fullStart), keySpan, valueSpan);\r\n    }\r\n    _getParentElement() {\r\n        return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\r\n    }\r\n    _addToParent(node) {\r\n        const parent = this._getParentElement();\r\n        if (parent != null) {\r\n            parent.children.push(node);\r\n        }\r\n        else {\r\n            this.rootNodes.push(node);\r\n        }\r\n    }\r\n    _getElementFullName(prefix, localName, parentElement) {\r\n        if (prefix === '') {\r\n            prefix = this.getTagDefinition(localName).implicitNamespacePrefix || '';\r\n            if (prefix === '' && parentElement != null) {\r\n                const parentTagName = splitNsName(parentElement.name)[1];\r\n                const parentTagDefinition = this.getTagDefinition(parentTagName);\r\n                if (!parentTagDefinition.preventNamespaceInheritance) {\r\n                    prefix = getNsPrefix(parentElement.name);\r\n                }\r\n            }\r\n        }\r\n        return mergeNsAndName(prefix, localName);\r\n    }\r\n}\r\nfunction lastOnStack(stack, element) {\r\n    return stack.length > 0 && stack[stack.length - 1] === element;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass HtmlParser extends Parser {\r\n    constructor() {\r\n        super(getHtmlTagDefinition);\r\n    }\r\n    parse(source, url, options) {\r\n        return super.parse(source, url, options);\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';\r\nconst SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']);\r\n// Equivalent to \\s with \\u00a0 (non-breaking space) excluded.\r\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\r\nconst WS_CHARS = ' \\f\\n\\r\\t\\v\\u1680\\u180e\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff';\r\nconst NO_WS_REGEXP = new RegExp(`[^${WS_CHARS}]`);\r\nconst WS_REPLACE_REGEXP = new RegExp(`[${WS_CHARS}]{2,}`, 'g');\r\nfunction hasPreserveWhitespacesAttr(attrs) {\r\n    return attrs.some((attr) => attr.name === PRESERVE_WS_ATTR_NAME);\r\n}\r\n/**\r\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\r\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\r\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\r\n * and later on replaced by a space. We are re-implementing the same idea here.\r\n */\r\nfunction replaceNgsp(value) {\r\n    // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE\r\n    return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');\r\n}\r\n/**\r\n * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:\r\n * - consider spaces, tabs and new lines as whitespace characters;\r\n * - drop text nodes consisting of whitespace characters only;\r\n * - for all other text nodes replace consecutive whitespace characters with one space;\r\n * - convert &ngsp; pseudo-entity to a single space;\r\n *\r\n * Removal and trimming of whitespaces have positive performance impact (less code to generate\r\n * while compiling templates, faster view creation). At the same time it can be \"destructive\"\r\n * in some cases (whitespaces can influence layout). Because of the potential of breaking layout\r\n * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for\r\n * whitespace removal. The default option for whitespace removal will be revisited in Angular 6\r\n * and might be changed to \"on\" by default.\r\n */\r\nclass WhitespaceVisitor {\r\n    visitElement(element, context) {\r\n        if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {\r\n            // don't descent into elements where we need to preserve whitespaces\r\n            // but still visit all attributes to eliminate one used as a market to preserve WS\r\n            return new Element$1(element.name, visitAll$1(this, element.attrs), element.children, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\r\n        }\r\n        return new Element$1(element.name, element.attrs, visitAllWithSiblings(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\r\n    }\r\n    visitAttribute(attribute, context) {\r\n        return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;\r\n    }\r\n    visitText(text, context) {\r\n        const isNotBlank = text.value.match(NO_WS_REGEXP);\r\n        const hasExpansionSibling = context &&\r\n            (context.prev instanceof Expansion || context.next instanceof Expansion);\r\n        if (isNotBlank || hasExpansionSibling) {\r\n            return new Text$3(replaceNgsp(text.value).replace(WS_REPLACE_REGEXP, ' '), text.sourceSpan, text.i18n);\r\n        }\r\n        return null;\r\n    }\r\n    visitComment(comment, context) {\r\n        return comment;\r\n    }\r\n    visitExpansion(expansion, context) {\r\n        return expansion;\r\n    }\r\n    visitExpansionCase(expansionCase, context) {\r\n        return expansionCase;\r\n    }\r\n}\r\nfunction removeWhitespaces(htmlAstWithErrors) {\r\n    return new ParseTreeResult(visitAll$1(new WhitespaceVisitor(), htmlAstWithErrors.rootNodes), htmlAstWithErrors.errors);\r\n}\r\nfunction visitAllWithSiblings(visitor, nodes) {\r\n    const result = [];\r\n    nodes.forEach((ast, i) => {\r\n        const context = { prev: nodes[i - 1], next: nodes[i + 1] };\r\n        const astResult = ast.visit(visitor, context);\r\n        if (astResult) {\r\n            result.push(astResult);\r\n        }\r\n    });\r\n    return result;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n// http://cldr.unicode.org/index/cldr-spec/plural-rules\r\nconst PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];\r\n/**\r\n * Expands special forms into elements.\r\n *\r\n * For example,\r\n *\r\n * ```\r\n * { messages.length, plural,\r\n *   =0 {zero}\r\n *   =1 {one}\r\n *   other {more than one}\r\n * }\r\n * ```\r\n *\r\n * will be expanded into\r\n *\r\n * ```\r\n * <ng-container [ngPlural]=\"messages.length\">\r\n *   <ng-template ngPluralCase=\"=0\">zero</ng-template>\r\n *   <ng-template ngPluralCase=\"=1\">one</ng-template>\r\n *   <ng-template ngPluralCase=\"other\">more than one</ng-template>\r\n * </ng-container>\r\n * ```\r\n */\r\nfunction expandNodes(nodes) {\r\n    const expander = new _Expander();\r\n    return new ExpansionResult(visitAll$1(expander, nodes), expander.isExpanded, expander.errors);\r\n}\r\nclass ExpansionResult {\r\n    constructor(nodes, expanded, errors) {\r\n        this.nodes = nodes;\r\n        this.expanded = expanded;\r\n        this.errors = errors;\r\n    }\r\n}\r\nclass ExpansionError extends ParseError {\r\n    constructor(span, errorMsg) {\r\n        super(span, errorMsg);\r\n    }\r\n}\r\n/**\r\n * Expand expansion forms (plural, select) to directives\r\n *\r\n * @internal\r\n */\r\nclass _Expander {\r\n    constructor() {\r\n        this.isExpanded = false;\r\n        this.errors = [];\r\n    }\r\n    visitElement(element, context) {\r\n        return new Element$1(element.name, element.attrs, visitAll$1(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\r\n    }\r\n    visitAttribute(attribute, context) {\r\n        return attribute;\r\n    }\r\n    visitText(text, context) {\r\n        return text;\r\n    }\r\n    visitComment(comment, context) {\r\n        return comment;\r\n    }\r\n    visitExpansion(icu, context) {\r\n        this.isExpanded = true;\r\n        return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) :\r\n            _expandDefaultForm(icu, this.errors);\r\n    }\r\n    visitExpansionCase(icuCase, context) {\r\n        throw new Error('Should not be reached');\r\n    }\r\n}\r\n// Plural forms are expanded to `NgPlural` and `NgPluralCase`s\r\nfunction _expandPluralForm(ast, errors) {\r\n    const children = ast.cases.map(c => {\r\n        if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\\d+$/)) {\r\n            errors.push(new ExpansionError(c.valueSourceSpan, `Plural cases should be \"=<number>\" or one of ${PLURAL_CASES.join(', ')}`));\r\n        }\r\n        const expansionResult = expandNodes(c.expression);\r\n        errors.push(...expansionResult.errors);\r\n        return new Element$1(`ng-template`, [new Attribute('ngPluralCase', `${c.value}`, c.valueSourceSpan, undefined /* keySpan */, undefined /* valueSpan */, undefined /* i18n */)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\r\n    });\r\n    const switchAttr = new Attribute('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan, undefined /* keySpan */, undefined /* valueSpan */, undefined /* i18n */);\r\n    return new Element$1('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\r\n}\r\n// ICU messages (excluding plural form) are expanded to `NgSwitch`  and `NgSwitchCase`s\r\nfunction _expandDefaultForm(ast, errors) {\r\n    const children = ast.cases.map(c => {\r\n        const expansionResult = expandNodes(c.expression);\r\n        errors.push(...expansionResult.errors);\r\n        if (c.value === 'other') {\r\n            // other is the default case when no values match\r\n            return new Element$1(`ng-template`, [new Attribute('ngSwitchDefault', '', c.valueSourceSpan, undefined /* keySpan */, undefined /* valueSpan */, undefined /* i18n */)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\r\n        }\r\n        return new Element$1(`ng-template`, [new Attribute('ngSwitchCase', `${c.value}`, c.valueSourceSpan, undefined /* keySpan */, undefined /* valueSpan */, undefined /* i18n */)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\r\n    });\r\n    const switchAttr = new Attribute('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan, undefined /* keySpan */, undefined /* valueSpan */, undefined /* i18n */);\r\n    return new Element$1('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A segment of text within the template.\r\n */\r\nclass TextAst {\r\n    constructor(value, ngContentIndex, sourceSpan) {\r\n        this.value = value;\r\n        this.ngContentIndex = ngContentIndex;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitText(this, context);\r\n    }\r\n}\r\n/**\r\n * A bound expression within the text of a template.\r\n */\r\nclass BoundTextAst {\r\n    constructor(value, ngContentIndex, sourceSpan) {\r\n        this.value = value;\r\n        this.ngContentIndex = ngContentIndex;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitBoundText(this, context);\r\n    }\r\n}\r\n/**\r\n * A plain attribute on an element.\r\n */\r\nclass AttrAst {\r\n    constructor(name, value, sourceSpan) {\r\n        this.name = name;\r\n        this.value = value;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitAttr(this, context);\r\n    }\r\n}\r\nconst BoundPropertyMapping = {\r\n    [4 /* Animation */]: 4 /* Animation */,\r\n    [1 /* Attribute */]: 1 /* Attribute */,\r\n    [2 /* Class */]: 2 /* Class */,\r\n    [0 /* Property */]: 0 /* Property */,\r\n    [3 /* Style */]: 3 /* Style */,\r\n};\r\n/**\r\n * A binding for an element property (e.g. `[property]=\"expression\"`) or an animation trigger (e.g.\r\n * `[@trigger]=\"stateExp\"`)\r\n */\r\nclass BoundElementPropertyAst {\r\n    constructor(name, type, securityContext, value, unit, sourceSpan) {\r\n        this.name = name;\r\n        this.type = type;\r\n        this.securityContext = securityContext;\r\n        this.value = value;\r\n        this.unit = unit;\r\n        this.sourceSpan = sourceSpan;\r\n        this.isAnimation = this.type === 4 /* Animation */;\r\n    }\r\n    static fromBoundProperty(prop) {\r\n        const type = BoundPropertyMapping[prop.type];\r\n        return new BoundElementPropertyAst(prop.name, type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan);\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitElementProperty(this, context);\r\n    }\r\n}\r\n/**\r\n * A binding for an element event (e.g. `(event)=\"handler()\"`) or an animation trigger event (e.g.\r\n * `(@trigger.phase)=\"callback($event)\"`).\r\n */\r\nclass BoundEventAst {\r\n    constructor(name, target, phase, handler, sourceSpan, handlerSpan) {\r\n        this.name = name;\r\n        this.target = target;\r\n        this.phase = phase;\r\n        this.handler = handler;\r\n        this.sourceSpan = sourceSpan;\r\n        this.handlerSpan = handlerSpan;\r\n        this.fullName = BoundEventAst.calcFullName(this.name, this.target, this.phase);\r\n        this.isAnimation = !!this.phase;\r\n    }\r\n    static calcFullName(name, target, phase) {\r\n        if (target) {\r\n            return `${target}:${name}`;\r\n        }\r\n        if (phase) {\r\n            return `@${name}.${phase}`;\r\n        }\r\n        return name;\r\n    }\r\n    static fromParsedEvent(event) {\r\n        const target = event.type === 0 /* Regular */ ? event.targetOrPhase : null;\r\n        const phase = event.type === 1 /* Animation */ ? event.targetOrPhase : null;\r\n        return new BoundEventAst(event.name, target, phase, event.handler, event.sourceSpan, event.handlerSpan);\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitEvent(this, context);\r\n    }\r\n}\r\n/**\r\n * A reference declaration on an element (e.g. `let someName=\"expression\"`).\r\n */\r\nclass ReferenceAst {\r\n    constructor(name, value, originalValue, sourceSpan) {\r\n        this.name = name;\r\n        this.value = value;\r\n        this.originalValue = originalValue;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitReference(this, context);\r\n    }\r\n}\r\n/**\r\n * A variable declaration on a <ng-template> (e.g. `var-someName=\"someLocalName\"`).\r\n */\r\nclass VariableAst {\r\n    constructor(name, value, sourceSpan, valueSpan) {\r\n        this.name = name;\r\n        this.value = value;\r\n        this.sourceSpan = sourceSpan;\r\n        this.valueSpan = valueSpan;\r\n    }\r\n    static fromParsedVariable(v) {\r\n        return new VariableAst(v.name, v.value, v.sourceSpan, v.valueSpan);\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitVariable(this, context);\r\n    }\r\n}\r\n/**\r\n * An element declaration in a template.\r\n */\r\nclass ElementAst {\r\n    constructor(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan, endSourceSpan) {\r\n        this.name = name;\r\n        this.attrs = attrs;\r\n        this.inputs = inputs;\r\n        this.outputs = outputs;\r\n        this.references = references;\r\n        this.directives = directives;\r\n        this.providers = providers;\r\n        this.hasViewContainer = hasViewContainer;\r\n        this.queryMatches = queryMatches;\r\n        this.children = children;\r\n        this.ngContentIndex = ngContentIndex;\r\n        this.sourceSpan = sourceSpan;\r\n        this.endSourceSpan = endSourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitElement(this, context);\r\n    }\r\n}\r\n/**\r\n * A `<ng-template>` element included in an Angular template.\r\n */\r\nclass EmbeddedTemplateAst {\r\n    constructor(attrs, outputs, references, variables, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan) {\r\n        this.attrs = attrs;\r\n        this.outputs = outputs;\r\n        this.references = references;\r\n        this.variables = variables;\r\n        this.directives = directives;\r\n        this.providers = providers;\r\n        this.hasViewContainer = hasViewContainer;\r\n        this.queryMatches = queryMatches;\r\n        this.children = children;\r\n        this.ngContentIndex = ngContentIndex;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitEmbeddedTemplate(this, context);\r\n    }\r\n}\r\n/**\r\n * A directive property with a bound value (e.g. `*ngIf=\"condition\").\r\n */\r\nclass BoundDirectivePropertyAst {\r\n    constructor(directiveName, templateName, value, sourceSpan) {\r\n        this.directiveName = directiveName;\r\n        this.templateName = templateName;\r\n        this.value = value;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitDirectiveProperty(this, context);\r\n    }\r\n}\r\n/**\r\n * A directive declared on an element.\r\n */\r\nclass DirectiveAst {\r\n    constructor(directive, inputs, hostProperties, hostEvents, contentQueryStartId, sourceSpan) {\r\n        this.directive = directive;\r\n        this.inputs = inputs;\r\n        this.hostProperties = hostProperties;\r\n        this.hostEvents = hostEvents;\r\n        this.contentQueryStartId = contentQueryStartId;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitDirective(this, context);\r\n    }\r\n}\r\n/**\r\n * A provider declared on an element\r\n */\r\nclass ProviderAst {\r\n    constructor(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan, isModule) {\r\n        this.token = token;\r\n        this.multiProvider = multiProvider;\r\n        this.eager = eager;\r\n        this.providers = providers;\r\n        this.providerType = providerType;\r\n        this.lifecycleHooks = lifecycleHooks;\r\n        this.sourceSpan = sourceSpan;\r\n        this.isModule = isModule;\r\n    }\r\n    visit(visitor, context) {\r\n        // No visit method in the visitor for now...\r\n        return null;\r\n    }\r\n}\r\nvar ProviderAstType;\r\n(function (ProviderAstType) {\r\n    ProviderAstType[ProviderAstType[\"PublicService\"] = 0] = \"PublicService\";\r\n    ProviderAstType[ProviderAstType[\"PrivateService\"] = 1] = \"PrivateService\";\r\n    ProviderAstType[ProviderAstType[\"Component\"] = 2] = \"Component\";\r\n    ProviderAstType[ProviderAstType[\"Directive\"] = 3] = \"Directive\";\r\n    ProviderAstType[ProviderAstType[\"Builtin\"] = 4] = \"Builtin\";\r\n})(ProviderAstType || (ProviderAstType = {}));\r\n/**\r\n * Position where content is to be projected (instance of `<ng-content>` in a template).\r\n */\r\nclass NgContentAst {\r\n    constructor(index, ngContentIndex, sourceSpan) {\r\n        this.index = index;\r\n        this.ngContentIndex = ngContentIndex;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    visit(visitor, context) {\r\n        return visitor.visitNgContent(this, context);\r\n    }\r\n}\r\n/**\r\n * A visitor that accepts each node but doesn't do anything. It is intended to be used\r\n * as the base class for a visitor that is only interested in a subset of the node types.\r\n */\r\nclass NullTemplateVisitor {\r\n    visitNgContent(ast, context) { }\r\n    visitEmbeddedTemplate(ast, context) { }\r\n    visitElement(ast, context) { }\r\n    visitReference(ast, context) { }\r\n    visitVariable(ast, context) { }\r\n    visitEvent(ast, context) { }\r\n    visitElementProperty(ast, context) { }\r\n    visitAttr(ast, context) { }\r\n    visitBoundText(ast, context) { }\r\n    visitText(ast, context) { }\r\n    visitDirective(ast, context) { }\r\n    visitDirectiveProperty(ast, context) { }\r\n}\r\n/**\r\n * Base class that can be used to build a visitor that visits each node\r\n * in an template ast recursively.\r\n */\r\nclass RecursiveTemplateAstVisitor extends NullTemplateVisitor {\r\n    constructor() {\r\n        super();\r\n    }\r\n    // Nodes with children\r\n    visitEmbeddedTemplate(ast, context) {\r\n        return this.visitChildren(context, visit => {\r\n            visit(ast.attrs);\r\n            visit(ast.references);\r\n            visit(ast.variables);\r\n            visit(ast.directives);\r\n            visit(ast.providers);\r\n            visit(ast.children);\r\n        });\r\n    }\r\n    visitElement(ast, context) {\r\n        return this.visitChildren(context, visit => {\r\n            visit(ast.attrs);\r\n            visit(ast.inputs);\r\n            visit(ast.outputs);\r\n            visit(ast.references);\r\n            visit(ast.directives);\r\n            visit(ast.providers);\r\n            visit(ast.children);\r\n        });\r\n    }\r\n    visitDirective(ast, context) {\r\n        return this.visitChildren(context, visit => {\r\n            visit(ast.inputs);\r\n            visit(ast.hostProperties);\r\n            visit(ast.hostEvents);\r\n        });\r\n    }\r\n    visitChildren(context, cb) {\r\n        let results = [];\r\n        let t = this;\r\n        function visit(children) {\r\n            if (children && children.length)\r\n                results.push(templateVisitAll(t, children, context));\r\n        }\r\n        cb(visit);\r\n        return Array.prototype.concat.apply([], results);\r\n    }\r\n}\r\n/**\r\n * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.\r\n */\r\nfunction templateVisitAll(visitor, asts, context = null) {\r\n    const result = [];\r\n    const visit = visitor.visit ?\r\n        (ast) => visitor.visit(ast, context) || ast.visit(visitor, context) :\r\n        (ast) => ast.visit(visitor, context);\r\n    asts.forEach(ast => {\r\n        const astResult = visit(ast);\r\n        if (astResult) {\r\n            result.push(astResult);\r\n        }\r\n    });\r\n    return result;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass ProviderError extends ParseError {\r\n    constructor(message, span) {\r\n        super(span, message);\r\n    }\r\n}\r\nclass ProviderViewContext {\r\n    constructor(reflector, component) {\r\n        this.reflector = reflector;\r\n        this.component = component;\r\n        this.errors = [];\r\n        this.viewQueries = _getViewQueries(component);\r\n        this.viewProviders = new Map();\r\n        component.viewProviders.forEach((provider) => {\r\n            if (this.viewProviders.get(tokenReference(provider.token)) == null) {\r\n                this.viewProviders.set(tokenReference(provider.token), true);\r\n            }\r\n        });\r\n    }\r\n}\r\nclass ProviderElementContext {\r\n    constructor(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, isTemplate, contentQueryStartId, _sourceSpan) {\r\n        this.viewContext = viewContext;\r\n        this._parent = _parent;\r\n        this._isViewRoot = _isViewRoot;\r\n        this._directiveAsts = _directiveAsts;\r\n        this._sourceSpan = _sourceSpan;\r\n        this._transformedProviders = new Map();\r\n        this._seenProviders = new Map();\r\n        this._queriedTokens = new Map();\r\n        this.transformedHasViewContainer = false;\r\n        this._attrs = {};\r\n        attrs.forEach((attrAst) => this._attrs[attrAst.name] = attrAst.value);\r\n        const directivesMeta = _directiveAsts.map(directiveAst => directiveAst.directive);\r\n        this._allProviders =\r\n            _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);\r\n        this._contentQueries = _getContentQueries(contentQueryStartId, directivesMeta);\r\n        Array.from(this._allProviders.values()).forEach((provider) => {\r\n            this._addQueryReadsTo(provider.token, provider.token, this._queriedTokens);\r\n        });\r\n        if (isTemplate) {\r\n            const templateRefId = createTokenForExternalReference(this.viewContext.reflector, Identifiers$1.TemplateRef);\r\n            this._addQueryReadsTo(templateRefId, templateRefId, this._queriedTokens);\r\n        }\r\n        refs.forEach((refAst) => {\r\n            let defaultQueryValue = refAst.value ||\r\n                createTokenForExternalReference(this.viewContext.reflector, Identifiers$1.ElementRef);\r\n            this._addQueryReadsTo({ value: refAst.name }, defaultQueryValue, this._queriedTokens);\r\n        });\r\n        if (this._queriedTokens.get(this.viewContext.reflector.resolveExternalReference(Identifiers$1.ViewContainerRef))) {\r\n            this.transformedHasViewContainer = true;\r\n        }\r\n        // create the providers that we know are eager first\r\n        Array.from(this._allProviders.values()).forEach((provider) => {\r\n            const eager = provider.eager || this._queriedTokens.get(tokenReference(provider.token));\r\n            if (eager) {\r\n                this._getOrCreateLocalProvider(provider.providerType, provider.token, true);\r\n            }\r\n        });\r\n    }\r\n    afterElement() {\r\n        // collect lazy providers\r\n        Array.from(this._allProviders.values()).forEach((provider) => {\r\n            this._getOrCreateLocalProvider(provider.providerType, provider.token, false);\r\n        });\r\n    }\r\n    get transformProviders() {\r\n        // Note: Maps keep their insertion order.\r\n        const lazyProviders = [];\r\n        const eagerProviders = [];\r\n        this._transformedProviders.forEach(provider => {\r\n            if (provider.eager) {\r\n                eagerProviders.push(provider);\r\n            }\r\n            else {\r\n                lazyProviders.push(provider);\r\n            }\r\n        });\r\n        return lazyProviders.concat(eagerProviders);\r\n    }\r\n    get transformedDirectiveAsts() {\r\n        const sortedProviderTypes = this.transformProviders.map(provider => provider.token.identifier);\r\n        const sortedDirectives = this._directiveAsts.slice();\r\n        sortedDirectives.sort((dir1, dir2) => sortedProviderTypes.indexOf(dir1.directive.type) -\r\n            sortedProviderTypes.indexOf(dir2.directive.type));\r\n        return sortedDirectives;\r\n    }\r\n    get queryMatches() {\r\n        const allMatches = [];\r\n        this._queriedTokens.forEach((matches) => {\r\n            allMatches.push(...matches);\r\n        });\r\n        return allMatches;\r\n    }\r\n    _addQueryReadsTo(token, defaultValue, queryReadTokens) {\r\n        this._getQueriesFor(token).forEach((query) => {\r\n            const queryValue = query.meta.read || defaultValue;\r\n            const tokenRef = tokenReference(queryValue);\r\n            let queryMatches = queryReadTokens.get(tokenRef);\r\n            if (!queryMatches) {\r\n                queryMatches = [];\r\n                queryReadTokens.set(tokenRef, queryMatches);\r\n            }\r\n            queryMatches.push({ queryId: query.queryId, value: queryValue });\r\n        });\r\n    }\r\n    _getQueriesFor(token) {\r\n        const result = [];\r\n        let currentEl = this;\r\n        let distance = 0;\r\n        let queries;\r\n        while (currentEl !== null) {\r\n            queries = currentEl._contentQueries.get(tokenReference(token));\r\n            if (queries) {\r\n                result.push(...queries.filter((query) => query.meta.descendants || distance <= 1));\r\n            }\r\n            if (currentEl._directiveAsts.length > 0) {\r\n                distance++;\r\n            }\r\n            currentEl = currentEl._parent;\r\n        }\r\n        queries = this.viewContext.viewQueries.get(tokenReference(token));\r\n        if (queries) {\r\n            result.push(...queries);\r\n        }\r\n        return result;\r\n    }\r\n    _getOrCreateLocalProvider(requestingProviderType, token, eager) {\r\n        const resolvedProvider = this._allProviders.get(tokenReference(token));\r\n        if (!resolvedProvider ||\r\n            ((requestingProviderType === ProviderAstType.Directive ||\r\n                requestingProviderType === ProviderAstType.PublicService) &&\r\n                resolvedProvider.providerType === ProviderAstType.PrivateService) ||\r\n            ((requestingProviderType === ProviderAstType.PrivateService ||\r\n                requestingProviderType === ProviderAstType.PublicService) &&\r\n                resolvedProvider.providerType === ProviderAstType.Builtin)) {\r\n            return null;\r\n        }\r\n        let transformedProviderAst = this._transformedProviders.get(tokenReference(token));\r\n        if (transformedProviderAst) {\r\n            return transformedProviderAst;\r\n        }\r\n        if (this._seenProviders.get(tokenReference(token)) != null) {\r\n            this.viewContext.errors.push(new ProviderError(`Cannot instantiate cyclic dependency! ${tokenName(token)}`, this._sourceSpan));\r\n            return null;\r\n        }\r\n        this._seenProviders.set(tokenReference(token), true);\r\n        const transformedProviders = resolvedProvider.providers.map((provider) => {\r\n            let transformedUseValue = provider.useValue;\r\n            let transformedUseExisting = provider.useExisting;\r\n            let transformedDeps = undefined;\r\n            if (provider.useExisting != null) {\r\n                const existingDiDep = this._getDependency(resolvedProvider.providerType, { token: provider.useExisting }, eager);\r\n                if (existingDiDep.token != null) {\r\n                    transformedUseExisting = existingDiDep.token;\r\n                }\r\n                else {\r\n                    transformedUseExisting = null;\r\n                    transformedUseValue = existingDiDep.value;\r\n                }\r\n            }\r\n            else if (provider.useFactory) {\r\n                const deps = provider.deps || provider.useFactory.diDeps;\r\n                transformedDeps =\r\n                    deps.map((dep) => this._getDependency(resolvedProvider.providerType, dep, eager));\r\n            }\r\n            else if (provider.useClass) {\r\n                const deps = provider.deps || provider.useClass.diDeps;\r\n                transformedDeps =\r\n                    deps.map((dep) => this._getDependency(resolvedProvider.providerType, dep, eager));\r\n            }\r\n            return _transformProvider(provider, {\r\n                useExisting: transformedUseExisting,\r\n                useValue: transformedUseValue,\r\n                deps: transformedDeps\r\n            });\r\n        });\r\n        transformedProviderAst =\r\n            _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });\r\n        this._transformedProviders.set(tokenReference(token), transformedProviderAst);\r\n        return transformedProviderAst;\r\n    }\r\n    _getLocalDependency(requestingProviderType, dep, eager = false) {\r\n        if (dep.isAttribute) {\r\n            const attrValue = this._attrs[dep.token.value];\r\n            return { isValue: true, value: attrValue == null ? null : attrValue };\r\n        }\r\n        if (dep.token != null) {\r\n            // access builtints\r\n            if ((requestingProviderType === ProviderAstType.Directive ||\r\n                requestingProviderType === ProviderAstType.Component)) {\r\n                if (tokenReference(dep.token) ===\r\n                    this.viewContext.reflector.resolveExternalReference(Identifiers$1.Renderer) ||\r\n                    tokenReference(dep.token) ===\r\n                        this.viewContext.reflector.resolveExternalReference(Identifiers$1.ElementRef) ||\r\n                    tokenReference(dep.token) ===\r\n                        this.viewContext.reflector.resolveExternalReference(Identifiers$1.ChangeDetectorRef) ||\r\n                    tokenReference(dep.token) ===\r\n                        this.viewContext.reflector.resolveExternalReference(Identifiers$1.TemplateRef)) {\r\n                    return dep;\r\n                }\r\n                if (tokenReference(dep.token) ===\r\n                    this.viewContext.reflector.resolveExternalReference(Identifiers$1.ViewContainerRef)) {\r\n                    this.transformedHasViewContainer = true;\r\n                }\r\n            }\r\n            // access the injector\r\n            if (tokenReference(dep.token) ===\r\n                this.viewContext.reflector.resolveExternalReference(Identifiers$1.Injector)) {\r\n                return dep;\r\n            }\r\n            // access providers\r\n            if (this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager) != null) {\r\n                return dep;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    _getDependency(requestingProviderType, dep, eager = false) {\r\n        let currElement = this;\r\n        let currEager = eager;\r\n        let result = null;\r\n        if (!dep.isSkipSelf) {\r\n            result = this._getLocalDependency(requestingProviderType, dep, eager);\r\n        }\r\n        if (dep.isSelf) {\r\n            if (!result && dep.isOptional) {\r\n                result = { isValue: true, value: null };\r\n            }\r\n        }\r\n        else {\r\n            // check parent elements\r\n            while (!result && currElement._parent) {\r\n                const prevElement = currElement;\r\n                currElement = currElement._parent;\r\n                if (prevElement._isViewRoot) {\r\n                    currEager = false;\r\n                }\r\n                result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);\r\n            }\r\n            // check @Host restriction\r\n            if (!result) {\r\n                if (!dep.isHost || this.viewContext.component.isHost ||\r\n                    this.viewContext.component.type.reference === tokenReference(dep.token) ||\r\n                    this.viewContext.viewProviders.get(tokenReference(dep.token)) != null) {\r\n                    result = dep;\r\n                }\r\n                else {\r\n                    result = dep.isOptional ? { isValue: true, value: null } : null;\r\n                }\r\n            }\r\n        }\r\n        if (!result) {\r\n            this.viewContext.errors.push(new ProviderError(`No provider for ${tokenName(dep.token)}`, this._sourceSpan));\r\n        }\r\n        return result;\r\n    }\r\n}\r\nclass NgModuleProviderAnalyzer {\r\n    constructor(reflector, ngModule, extraProviders, sourceSpan) {\r\n        this.reflector = reflector;\r\n        this._transformedProviders = new Map();\r\n        this._seenProviders = new Map();\r\n        this._errors = [];\r\n        this._allProviders = new Map();\r\n        ngModule.transitiveModule.modules.forEach((ngModuleType) => {\r\n            const ngModuleProvider = { token: { identifier: ngModuleType }, useClass: ngModuleType };\r\n            _resolveProviders([ngModuleProvider], ProviderAstType.PublicService, true, sourceSpan, this._errors, this._allProviders, /* isModule */ true);\r\n        });\r\n        _resolveProviders(ngModule.transitiveModule.providers.map(entry => entry.provider).concat(extraProviders), ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders, \r\n        /* isModule */ false);\r\n    }\r\n    parse() {\r\n        Array.from(this._allProviders.values()).forEach((provider) => {\r\n            this._getOrCreateLocalProvider(provider.token, provider.eager);\r\n        });\r\n        if (this._errors.length > 0) {\r\n            const errorString = this._errors.join('\\n');\r\n            throw new Error(`Provider parse errors:\\n${errorString}`);\r\n        }\r\n        // Note: Maps keep their insertion order.\r\n        const lazyProviders = [];\r\n        const eagerProviders = [];\r\n        this._transformedProviders.forEach(provider => {\r\n            if (provider.eager) {\r\n                eagerProviders.push(provider);\r\n            }\r\n            else {\r\n                lazyProviders.push(provider);\r\n            }\r\n        });\r\n        return lazyProviders.concat(eagerProviders);\r\n    }\r\n    _getOrCreateLocalProvider(token, eager) {\r\n        const resolvedProvider = this._allProviders.get(tokenReference(token));\r\n        if (!resolvedProvider) {\r\n            return null;\r\n        }\r\n        let transformedProviderAst = this._transformedProviders.get(tokenReference(token));\r\n        if (transformedProviderAst) {\r\n            return transformedProviderAst;\r\n        }\r\n        if (this._seenProviders.get(tokenReference(token)) != null) {\r\n            this._errors.push(new ProviderError(`Cannot instantiate cyclic dependency! ${tokenName(token)}`, resolvedProvider.sourceSpan));\r\n            return null;\r\n        }\r\n        this._seenProviders.set(tokenReference(token), true);\r\n        const transformedProviders = resolvedProvider.providers.map((provider) => {\r\n            let transformedUseValue = provider.useValue;\r\n            let transformedUseExisting = provider.useExisting;\r\n            let transformedDeps = undefined;\r\n            if (provider.useExisting != null) {\r\n                const existingDiDep = this._getDependency({ token: provider.useExisting }, eager, resolvedProvider.sourceSpan);\r\n                if (existingDiDep.token != null) {\r\n                    transformedUseExisting = existingDiDep.token;\r\n                }\r\n                else {\r\n                    transformedUseExisting = null;\r\n                    transformedUseValue = existingDiDep.value;\r\n                }\r\n            }\r\n            else if (provider.useFactory) {\r\n                const deps = provider.deps || provider.useFactory.diDeps;\r\n                transformedDeps =\r\n                    deps.map((dep) => this._getDependency(dep, eager, resolvedProvider.sourceSpan));\r\n            }\r\n            else if (provider.useClass) {\r\n                const deps = provider.deps || provider.useClass.diDeps;\r\n                transformedDeps =\r\n                    deps.map((dep) => this._getDependency(dep, eager, resolvedProvider.sourceSpan));\r\n            }\r\n            return _transformProvider(provider, {\r\n                useExisting: transformedUseExisting,\r\n                useValue: transformedUseValue,\r\n                deps: transformedDeps\r\n            });\r\n        });\r\n        transformedProviderAst =\r\n            _transformProviderAst(resolvedProvider, { eager: eager, providers: transformedProviders });\r\n        this._transformedProviders.set(tokenReference(token), transformedProviderAst);\r\n        return transformedProviderAst;\r\n    }\r\n    _getDependency(dep, eager = false, requestorSourceSpan) {\r\n        let foundLocal = false;\r\n        if (!dep.isSkipSelf && dep.token != null) {\r\n            // access the injector\r\n            if (tokenReference(dep.token) ===\r\n                this.reflector.resolveExternalReference(Identifiers$1.Injector) ||\r\n                tokenReference(dep.token) ===\r\n                    this.reflector.resolveExternalReference(Identifiers$1.ComponentFactoryResolver)) {\r\n                foundLocal = true;\r\n                // access providers\r\n            }\r\n            else if (this._getOrCreateLocalProvider(dep.token, eager) != null) {\r\n                foundLocal = true;\r\n            }\r\n        }\r\n        return dep;\r\n    }\r\n}\r\nfunction _transformProvider(provider, { useExisting, useValue, deps }) {\r\n    return {\r\n        token: provider.token,\r\n        useClass: provider.useClass,\r\n        useExisting: useExisting,\r\n        useFactory: provider.useFactory,\r\n        useValue: useValue,\r\n        deps: deps,\r\n        multi: provider.multi\r\n    };\r\n}\r\nfunction _transformProviderAst(provider, { eager, providers }) {\r\n    return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan, provider.isModule);\r\n}\r\nfunction _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {\r\n    const providersByToken = new Map();\r\n    directives.forEach((directive) => {\r\n        const dirProvider = { token: { identifier: directive.type }, useClass: directive.type };\r\n        _resolveProviders([dirProvider], directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken, /* isModule */ false);\r\n    });\r\n    // Note: directives need to be able to overwrite providers of a component!\r\n    const directivesWithComponentFirst = directives.filter(dir => dir.isComponent).concat(directives.filter(dir => !dir.isComponent));\r\n    directivesWithComponentFirst.forEach((directive) => {\r\n        _resolveProviders(directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken, /* isModule */ false);\r\n        _resolveProviders(directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken, /* isModule */ false);\r\n    });\r\n    return providersByToken;\r\n}\r\nfunction _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken, isModule) {\r\n    providers.forEach((provider) => {\r\n        let resolvedProvider = targetProvidersByToken.get(tokenReference(provider.token));\r\n        if (resolvedProvider != null && !!resolvedProvider.multiProvider !== !!provider.multi) {\r\n            targetErrors.push(new ProviderError(`Mixing multi and non multi provider is not possible for token ${tokenName(resolvedProvider.token)}`, sourceSpan));\r\n        }\r\n        if (!resolvedProvider) {\r\n            const lifecycleHooks = provider.token.identifier &&\r\n                provider.token.identifier.lifecycleHooks ?\r\n                provider.token.identifier.lifecycleHooks :\r\n                [];\r\n            const isUseValue = !(provider.useClass || provider.useExisting || provider.useFactory);\r\n            resolvedProvider = new ProviderAst(provider.token, !!provider.multi, eager || isUseValue, [provider], providerType, lifecycleHooks, sourceSpan, isModule);\r\n            targetProvidersByToken.set(tokenReference(provider.token), resolvedProvider);\r\n        }\r\n        else {\r\n            if (!provider.multi) {\r\n                resolvedProvider.providers.length = 0;\r\n            }\r\n            resolvedProvider.providers.push(provider);\r\n        }\r\n    });\r\n}\r\nfunction _getViewQueries(component) {\r\n    // Note: queries start with id 1 so we can use the number in a Bloom filter!\r\n    let viewQueryId = 1;\r\n    const viewQueries = new Map();\r\n    if (component.viewQueries) {\r\n        component.viewQueries.forEach((query) => _addQueryToTokenMap(viewQueries, { meta: query, queryId: viewQueryId++ }));\r\n    }\r\n    return viewQueries;\r\n}\r\nfunction _getContentQueries(contentQueryStartId, directives) {\r\n    let contentQueryId = contentQueryStartId;\r\n    const contentQueries = new Map();\r\n    directives.forEach((directive, directiveIndex) => {\r\n        if (directive.queries) {\r\n            directive.queries.forEach((query) => _addQueryToTokenMap(contentQueries, { meta: query, queryId: contentQueryId++ }));\r\n        }\r\n    });\r\n    return contentQueries;\r\n}\r\nfunction _addQueryToTokenMap(map, query) {\r\n    query.meta.selectors.forEach((token) => {\r\n        let entry = map.get(tokenReference(token));\r\n        if (!entry) {\r\n            entry = [];\r\n            map.set(tokenReference(token), entry);\r\n        }\r\n        entry.push(query);\r\n    });\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass StyleWithImports {\r\n    constructor(style, styleUrls) {\r\n        this.style = style;\r\n        this.styleUrls = styleUrls;\r\n    }\r\n}\r\nfunction isStyleUrlResolvable(url) {\r\n    if (url == null || url.length === 0 || url[0] == '/')\r\n        return false;\r\n    const schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\r\n    return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\r\n}\r\n/**\r\n * Rewrites stylesheets by resolving and removing the @import urls that\r\n * are either relative or don't have a `package:` scheme\r\n */\r\nfunction extractStyleUrls(resolver, baseUrl, cssText) {\r\n    const foundUrls = [];\r\n    const modifiedCssText = cssText.replace(CSS_STRIPPABLE_COMMENT_REGEXP, '')\r\n        .replace(CSS_IMPORT_REGEXP, (...m) => {\r\n        const url = m[1] || m[2];\r\n        if (!isStyleUrlResolvable(url)) {\r\n            // Do not attempt to resolve non-package absolute URLs with URI\r\n            // scheme\r\n            return m[0];\r\n        }\r\n        foundUrls.push(resolver.resolve(baseUrl, url));\r\n        return '';\r\n    });\r\n    return new StyleWithImports(modifiedCssText, foundUrls);\r\n}\r\nconst CSS_IMPORT_REGEXP = /@import\\s+(?:url\\()?\\s*(?:(?:['\"]([^'\"]*))|([^;\\)\\s]*))[^;]*;?/g;\r\nconst CSS_STRIPPABLE_COMMENT_REGEXP = /\\/\\*(?!#\\s*(?:sourceURL|sourceMappingURL)=)[\\s\\S]+?\\*\\//g;\r\nconst URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst PROPERTY_PARTS_SEPARATOR = '.';\r\nconst ATTRIBUTE_PREFIX = 'attr';\r\nconst CLASS_PREFIX = 'class';\r\nconst STYLE_PREFIX = 'style';\r\nconst TEMPLATE_ATTR_PREFIX = '*';\r\nconst ANIMATE_PROP_PREFIX = 'animate-';\r\n/**\r\n * Parses bindings in templates and in the directive host area.\r\n */\r\nclass BindingParser {\r\n    constructor(_exprParser, _interpolationConfig, _schemaRegistry, pipes, errors) {\r\n        this._exprParser = _exprParser;\r\n        this._interpolationConfig = _interpolationConfig;\r\n        this._schemaRegistry = _schemaRegistry;\r\n        this.errors = errors;\r\n        this.pipesByName = null;\r\n        this._usedPipes = new Map();\r\n        // When the `pipes` parameter is `null`, do not check for used pipes\r\n        // This is used in IVY when we might not know the available pipes at compile time\r\n        if (pipes) {\r\n            const pipesByName = new Map();\r\n            pipes.forEach(pipe => pipesByName.set(pipe.name, pipe));\r\n            this.pipesByName = pipesByName;\r\n        }\r\n    }\r\n    get interpolationConfig() {\r\n        return this._interpolationConfig;\r\n    }\r\n    getUsedPipes() {\r\n        return Array.from(this._usedPipes.values());\r\n    }\r\n    createBoundHostProperties(dirMeta, sourceSpan) {\r\n        if (dirMeta.hostProperties) {\r\n            const boundProps = [];\r\n            Object.keys(dirMeta.hostProperties).forEach(propName => {\r\n                const expression = dirMeta.hostProperties[propName];\r\n                if (typeof expression === 'string') {\r\n                    this.parsePropertyBinding(propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [], \r\n                    // Use the `sourceSpan` for  `keySpan`. This isn't really accurate, but neither is the\r\n                    // sourceSpan, as it represents the sourceSpan of the host itself rather than the\r\n                    // source of the host binding (which doesn't exist in the template). Regardless,\r\n                    // neither of these values are used in Ivy but are only here to satisfy the function\r\n                    // signature. This should likely be refactored in the future so that `sourceSpan`\r\n                    // isn't being used inaccurately.\r\n                    boundProps, sourceSpan);\r\n                }\r\n                else {\r\n                    this._reportError(`Value of the host property binding \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`, sourceSpan);\r\n                }\r\n            });\r\n            return boundProps;\r\n        }\r\n        return null;\r\n    }\r\n    createDirectiveHostPropertyAsts(dirMeta, elementSelector, sourceSpan) {\r\n        const boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);\r\n        return boundProps &&\r\n            boundProps.map((prop) => this.createBoundElementProperty(elementSelector, prop));\r\n    }\r\n    createDirectiveHostEventAsts(dirMeta, sourceSpan) {\r\n        if (dirMeta.hostListeners) {\r\n            const targetEvents = [];\r\n            Object.keys(dirMeta.hostListeners).forEach(propName => {\r\n                const expression = dirMeta.hostListeners[propName];\r\n                if (typeof expression === 'string') {\r\n                    // Use the `sourceSpan` for  `keySpan` and `handlerSpan`. This isn't really accurate, but\r\n                    // neither is the `sourceSpan`, as it represents the `sourceSpan` of the host itself\r\n                    // rather than the source of the host binding (which doesn't exist in the template).\r\n                    // Regardless, neither of these values are used in Ivy but are only here to satisfy the\r\n                    // function signature. This should likely be refactored in the future so that `sourceSpan`\r\n                    // isn't being used inaccurately.\r\n                    this.parseEvent(propName, expression, sourceSpan, sourceSpan, [], targetEvents, sourceSpan);\r\n                }\r\n                else {\r\n                    this._reportError(`Value of the host listener \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`, sourceSpan);\r\n                }\r\n            });\r\n            return targetEvents;\r\n        }\r\n        return null;\r\n    }\r\n    parseInterpolation(value, sourceSpan) {\r\n        const sourceInfo = sourceSpan.start.toString();\r\n        const absoluteOffset = sourceSpan.fullStart.offset;\r\n        try {\r\n            const ast = this._exprParser.parseInterpolation(value, sourceInfo, absoluteOffset, this._interpolationConfig);\r\n            if (ast)\r\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\r\n            this._checkPipes(ast, sourceSpan);\r\n            return ast;\r\n        }\r\n        catch (e) {\r\n            this._reportError(`${e}`, sourceSpan);\r\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\r\n        }\r\n    }\r\n    /**\r\n     * Similar to `parseInterpolation`, but treats the provided string as a single expression\r\n     * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\r\n     * This is used for parsing the switch expression in ICUs.\r\n     */\r\n    parseInterpolationExpression(expression, sourceSpan) {\r\n        const sourceInfo = sourceSpan.start.toString();\r\n        const absoluteOffset = sourceSpan.start.offset;\r\n        try {\r\n            const ast = this._exprParser.parseInterpolationExpression(expression, sourceInfo, absoluteOffset);\r\n            if (ast)\r\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\r\n            this._checkPipes(ast, sourceSpan);\r\n            return ast;\r\n        }\r\n        catch (e) {\r\n            this._reportError(`${e}`, sourceSpan);\r\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\r\n        }\r\n    }\r\n    /**\r\n     * Parses the bindings in a microsyntax expression, and converts them to\r\n     * `ParsedProperty` or `ParsedVariable`.\r\n     *\r\n     * @param tplKey template binding name\r\n     * @param tplValue template binding value\r\n     * @param sourceSpan span of template binding relative to entire the template\r\n     * @param absoluteValueOffset start of the tplValue relative to the entire template\r\n     * @param targetMatchableAttrs potential attributes to match in the template\r\n     * @param targetProps target property bindings in the template\r\n     * @param targetVars target variables in the template\r\n     */\r\n    parseInlineTemplateBinding(tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars, isIvyAst) {\r\n        const absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX.length;\r\n        const bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);\r\n        for (const binding of bindings) {\r\n            // sourceSpan is for the entire HTML attribute. bindingSpan is for a particular\r\n            // binding within the microsyntax expression so it's more narrow than sourceSpan.\r\n            const bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);\r\n            const key = binding.key.source;\r\n            const keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);\r\n            if (binding instanceof VariableBinding) {\r\n                const value = binding.value ? binding.value.source : '$implicit';\r\n                const valueSpan = binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : undefined;\r\n                targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));\r\n            }\r\n            else if (binding.value) {\r\n                const srcSpan = isIvyAst ? bindingSpan : sourceSpan;\r\n                const valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);\r\n                this._parsePropertyAst(key, binding.value, srcSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\r\n            }\r\n            else {\r\n                targetMatchableAttrs.push([key, '' /* value */]);\r\n                // Since this is a literal attribute with no RHS, source span should be\r\n                // just the key span.\r\n                this.parseLiteralAttr(key, null /* value */, keySpan, absoluteValueOffset, undefined /* valueSpan */, targetMatchableAttrs, targetProps, keySpan);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Parses the bindings in a microsyntax expression, e.g.\r\n     * ```\r\n     *    <tag *tplKey=\"let value1 = prop; let value2 = localVar\">\r\n     * ```\r\n     *\r\n     * @param tplKey template binding name\r\n     * @param tplValue template binding value\r\n     * @param sourceSpan span of template binding relative to entire the template\r\n     * @param absoluteKeyOffset start of the `tplKey`\r\n     * @param absoluteValueOffset start of the `tplValue`\r\n     */\r\n    _parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset) {\r\n        const sourceInfo = sourceSpan.start.toString();\r\n        try {\r\n            const bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);\r\n            this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\r\n            bindingsResult.templateBindings.forEach((binding) => {\r\n                if (binding.value instanceof ASTWithSource) {\r\n                    this._checkPipes(binding.value, sourceSpan);\r\n                }\r\n            });\r\n            bindingsResult.warnings.forEach((warning) => {\r\n                this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);\r\n            });\r\n            return bindingsResult.templateBindings;\r\n        }\r\n        catch (e) {\r\n            this._reportError(`${e}`, sourceSpan);\r\n            return [];\r\n        }\r\n    }\r\n    parseLiteralAttr(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, \r\n    // TODO(atscott): keySpan is only optional here so VE template parser implementation does not\r\n    // have to change This should be required when VE is removed.\r\n    targetProps, keySpan) {\r\n        if (isAnimationLabel(name)) {\r\n            name = name.substring(1);\r\n            if (keySpan !== undefined) {\r\n                keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\r\n            }\r\n            if (value) {\r\n                this._reportError(`Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` +\r\n                    ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`, sourceSpan, ParseErrorLevel.ERROR);\r\n            }\r\n            this._parseAnimation(name, value, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);\r\n        }\r\n        else {\r\n            targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset), ParsedPropertyType.LITERAL_ATTR, sourceSpan, keySpan, valueSpan));\r\n        }\r\n    }\r\n    parsePropertyBinding(name, expression, isHost, sourceSpan, absoluteOffset, valueSpan, \r\n    // TODO(atscott): keySpan is only optional here so VE template parser implementation does not\r\n    // have to change This should be required when VE is removed.\r\n    targetMatchableAttrs, targetProps, keySpan) {\r\n        if (name.length === 0) {\r\n            this._reportError(`Property name is missing in binding`, sourceSpan);\r\n        }\r\n        let isAnimationProp = false;\r\n        if (name.startsWith(ANIMATE_PROP_PREFIX)) {\r\n            isAnimationProp = true;\r\n            name = name.substring(ANIMATE_PROP_PREFIX.length);\r\n            if (keySpan !== undefined) {\r\n                keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + ANIMATE_PROP_PREFIX.length, keySpan.end.offset));\r\n            }\r\n        }\r\n        else if (isAnimationLabel(name)) {\r\n            isAnimationProp = true;\r\n            name = name.substring(1);\r\n            if (keySpan !== undefined) {\r\n                keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\r\n            }\r\n        }\r\n        if (isAnimationProp) {\r\n            this._parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps);\r\n        }\r\n        else {\r\n            this._parsePropertyAst(name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\r\n        }\r\n    }\r\n    parsePropertyInterpolation(name, value, sourceSpan, valueSpan, targetMatchableAttrs, \r\n    // TODO(atscott): keySpan is only optional here so VE template parser implementation does not\r\n    // have to change This should be required when VE is removed.\r\n    targetProps, keySpan) {\r\n        const expr = this.parseInterpolation(value, valueSpan || sourceSpan);\r\n        if (expr) {\r\n            this._parsePropertyAst(name, expr, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    _parsePropertyAst(name, ast, sourceSpan, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\r\n        targetMatchableAttrs.push([name, ast.source]);\r\n        targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, keySpan, valueSpan));\r\n    }\r\n    _parseAnimation(name, expression, sourceSpan, absoluteOffset, keySpan, valueSpan, targetMatchableAttrs, targetProps) {\r\n        if (name.length === 0) {\r\n            this._reportError('Animation trigger is missing', sourceSpan);\r\n        }\r\n        // This will occur when a @trigger is not paired with an expression.\r\n        // For animations it is valid to not have an expression since */void\r\n        // states will be applied by angular when the element is attached/detached\r\n        const ast = this._parseBinding(expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);\r\n        targetMatchableAttrs.push([name, ast.source]);\r\n        targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, keySpan, valueSpan));\r\n    }\r\n    _parseBinding(value, isHostBinding, sourceSpan, absoluteOffset) {\r\n        const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();\r\n        try {\r\n            const ast = isHostBinding ?\r\n                this._exprParser.parseSimpleBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig) :\r\n                this._exprParser.parseBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig);\r\n            if (ast)\r\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\r\n            this._checkPipes(ast, sourceSpan);\r\n            return ast;\r\n        }\r\n        catch (e) {\r\n            this._reportError(`${e}`, sourceSpan);\r\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\r\n        }\r\n    }\r\n    createBoundElementProperty(elementSelector, boundProp, skipValidation = false, mapPropertyName = true) {\r\n        if (boundProp.isAnimation) {\r\n            return new BoundElementProperty(boundProp.name, 4 /* Animation */, SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\r\n        }\r\n        let unit = null;\r\n        let bindingType = undefined;\r\n        let boundPropertyName = null;\r\n        const parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\r\n        let securityContexts = undefined;\r\n        // Check for special cases (prefix style, attr, class)\r\n        if (parts.length > 1) {\r\n            if (parts[0] == ATTRIBUTE_PREFIX) {\r\n                boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);\r\n                if (!skipValidation) {\r\n                    this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\r\n                }\r\n                securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);\r\n                const nsSeparatorIdx = boundPropertyName.indexOf(':');\r\n                if (nsSeparatorIdx > -1) {\r\n                    const ns = boundPropertyName.substring(0, nsSeparatorIdx);\r\n                    const name = boundPropertyName.substring(nsSeparatorIdx + 1);\r\n                    boundPropertyName = mergeNsAndName(ns, name);\r\n                }\r\n                bindingType = 1 /* Attribute */;\r\n            }\r\n            else if (parts[0] == CLASS_PREFIX) {\r\n                boundPropertyName = parts[1];\r\n                bindingType = 2 /* Class */;\r\n                securityContexts = [SecurityContext.NONE];\r\n            }\r\n            else if (parts[0] == STYLE_PREFIX) {\r\n                unit = parts.length > 2 ? parts[2] : null;\r\n                boundPropertyName = parts[1];\r\n                bindingType = 3 /* Style */;\r\n                securityContexts = [SecurityContext.STYLE];\r\n            }\r\n        }\r\n        // If not a special case, use the full property name\r\n        if (boundPropertyName === null) {\r\n            const mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);\r\n            boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;\r\n            securityContexts = calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);\r\n            bindingType = 0 /* Property */;\r\n            if (!skipValidation) {\r\n                this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);\r\n            }\r\n        }\r\n        return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.keySpan, boundProp.valueSpan);\r\n    }\r\n    // TODO: keySpan should be required but was made optional to avoid changing VE parser.\r\n    parseEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {\r\n        if (name.length === 0) {\r\n            this._reportError(`Event name is missing in binding`, sourceSpan);\r\n        }\r\n        if (isAnimationLabel(name)) {\r\n            name = name.substr(1);\r\n            if (keySpan !== undefined) {\r\n                keySpan = moveParseSourceSpan(keySpan, new AbsoluteSourceSpan(keySpan.start.offset + 1, keySpan.end.offset));\r\n            }\r\n            this._parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan);\r\n        }\r\n        else {\r\n            this._parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan);\r\n        }\r\n    }\r\n    calcPossibleSecurityContexts(selector, propName, isAttribute) {\r\n        const prop = this._schemaRegistry.getMappedPropName(propName);\r\n        return calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);\r\n    }\r\n    _parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents, keySpan) {\r\n        const matches = splitAtPeriod(name, [name, '']);\r\n        const eventName = matches[0];\r\n        const phase = matches[1].toLowerCase();\r\n        const ast = this._parseAction(expression, handlerSpan);\r\n        targetEvents.push(new ParsedEvent(eventName, phase, 1 /* Animation */, ast, sourceSpan, handlerSpan, keySpan));\r\n        if (eventName.length === 0) {\r\n            this._reportError(`Animation event name is missing in binding`, sourceSpan);\r\n        }\r\n        if (phase) {\r\n            if (phase !== 'start' && phase !== 'done') {\r\n                this._reportError(`The provided animation output phase value \"${phase}\" for \"@${eventName}\" is not supported (use start or done)`, sourceSpan);\r\n            }\r\n        }\r\n        else {\r\n            this._reportError(`The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`, sourceSpan);\r\n        }\r\n    }\r\n    _parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents, keySpan) {\r\n        // long format: 'target: eventName'\r\n        const [target, eventName] = splitAtColon(name, [null, name]);\r\n        const ast = this._parseAction(expression, handlerSpan);\r\n        targetMatchableAttrs.push([name, ast.source]);\r\n        targetEvents.push(new ParsedEvent(eventName, target, 0 /* Regular */, ast, sourceSpan, handlerSpan, keySpan));\r\n        // Don't detect directives for event names for now,\r\n        // so don't add the event name to the matchableAttrs\r\n    }\r\n    _parseAction(value, sourceSpan) {\r\n        const sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();\r\n        const absoluteOffset = (sourceSpan && sourceSpan.start) ? sourceSpan.start.offset : 0;\r\n        try {\r\n            const ast = this._exprParser.parseAction(value, sourceInfo, absoluteOffset, this._interpolationConfig);\r\n            if (ast) {\r\n                this._reportExpressionParserErrors(ast.errors, sourceSpan);\r\n            }\r\n            if (!ast || ast.ast instanceof EmptyExpr) {\r\n                this._reportError(`Empty expressions are not allowed`, sourceSpan);\r\n                return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\r\n            }\r\n            this._checkPipes(ast, sourceSpan);\r\n            return ast;\r\n        }\r\n        catch (e) {\r\n            this._reportError(`${e}`, sourceSpan);\r\n            return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\r\n        }\r\n    }\r\n    _reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {\r\n        this.errors.push(new ParseError(sourceSpan, message, level));\r\n    }\r\n    _reportExpressionParserErrors(errors, sourceSpan) {\r\n        for (const error of errors) {\r\n            this._reportError(error.message, sourceSpan);\r\n        }\r\n    }\r\n    // Make sure all the used pipes are known in `this.pipesByName`\r\n    _checkPipes(ast, sourceSpan) {\r\n        if (ast && this.pipesByName) {\r\n            const collector = new PipeCollector();\r\n            ast.visit(collector);\r\n            collector.pipes.forEach((ast, pipeName) => {\r\n                const pipeMeta = this.pipesByName.get(pipeName);\r\n                if (!pipeMeta) {\r\n                    this._reportError(`The pipe '${pipeName}' could not be found`, new ParseSourceSpan(sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\r\n                }\r\n                else {\r\n                    this._usedPipes.set(pipeName, pipeMeta);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * @param propName the name of the property / attribute\r\n     * @param sourceSpan\r\n     * @param isAttr true when binding to an attribute\r\n     */\r\n    _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {\r\n        const report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\r\n            this._schemaRegistry.validateProperty(propName);\r\n        if (report.error) {\r\n            this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);\r\n        }\r\n    }\r\n}\r\nclass PipeCollector extends RecursiveAstVisitor$1 {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.pipes = new Map();\r\n    }\r\n    visitPipe(ast, context) {\r\n        this.pipes.set(ast.name, ast);\r\n        ast.exp.visit(this);\r\n        this.visitAll(ast.args, context);\r\n        return null;\r\n    }\r\n}\r\nfunction isAnimationLabel(name) {\r\n    return name[0] == '@';\r\n}\r\nfunction calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {\r\n    const ctxs = [];\r\n    CssSelector.parse(selector).forEach((selector) => {\r\n        const elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\r\n        const notElementNames = new Set(selector.notSelectors.filter(selector => selector.isElementSelector())\r\n            .map((selector) => selector.element));\r\n        const possibleElementNames = elementNames.filter(elementName => !notElementNames.has(elementName));\r\n        ctxs.push(...possibleElementNames.map(elementName => registry.securityContext(elementName, propName, isAttribute)));\r\n    });\r\n    return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\r\n}\r\n/**\r\n * Compute a new ParseSourceSpan based off an original `sourceSpan` by using\r\n * absolute offsets from the specified `absoluteSpan`.\r\n *\r\n * @param sourceSpan original source span\r\n * @param absoluteSpan absolute source span to move to\r\n */\r\nfunction moveParseSourceSpan(sourceSpan, absoluteSpan) {\r\n    // The difference of two absolute offsets provide the relative offset\r\n    const startDiff = absoluteSpan.start - sourceSpan.start.offset;\r\n    const endDiff = absoluteSpan.end - sourceSpan.end.offset;\r\n    return new ParseSourceSpan(sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff), sourceSpan.fullStart.moveBy(startDiff), sourceSpan.details);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst NG_CONTENT_SELECT_ATTR = 'select';\r\nconst LINK_ELEMENT = 'link';\r\nconst LINK_STYLE_REL_ATTR = 'rel';\r\nconst LINK_STYLE_HREF_ATTR = 'href';\r\nconst LINK_STYLE_REL_VALUE = 'stylesheet';\r\nconst STYLE_ELEMENT = 'style';\r\nconst SCRIPT_ELEMENT = 'script';\r\nconst NG_NON_BINDABLE_ATTR = 'ngNonBindable';\r\nconst NG_PROJECT_AS = 'ngProjectAs';\r\nfunction preparseElement(ast) {\r\n    let selectAttr = null;\r\n    let hrefAttr = null;\r\n    let relAttr = null;\r\n    let nonBindable = false;\r\n    let projectAs = '';\r\n    ast.attrs.forEach(attr => {\r\n        const lcAttrName = attr.name.toLowerCase();\r\n        if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\r\n            selectAttr = attr.value;\r\n        }\r\n        else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\r\n            hrefAttr = attr.value;\r\n        }\r\n        else if (lcAttrName == LINK_STYLE_REL_ATTR) {\r\n            relAttr = attr.value;\r\n        }\r\n        else if (attr.name == NG_NON_BINDABLE_ATTR) {\r\n            nonBindable = true;\r\n        }\r\n        else if (attr.name == NG_PROJECT_AS) {\r\n            if (attr.value.length > 0) {\r\n                projectAs = attr.value;\r\n            }\r\n        }\r\n    });\r\n    selectAttr = normalizeNgContentSelect(selectAttr);\r\n    const nodeName = ast.name.toLowerCase();\r\n    let type = PreparsedElementType.OTHER;\r\n    if (isNgContent(nodeName)) {\r\n        type = PreparsedElementType.NG_CONTENT;\r\n    }\r\n    else if (nodeName == STYLE_ELEMENT) {\r\n        type = PreparsedElementType.STYLE;\r\n    }\r\n    else if (nodeName == SCRIPT_ELEMENT) {\r\n        type = PreparsedElementType.SCRIPT;\r\n    }\r\n    else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\r\n        type = PreparsedElementType.STYLESHEET;\r\n    }\r\n    return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\r\n}\r\nvar PreparsedElementType;\r\n(function (PreparsedElementType) {\r\n    PreparsedElementType[PreparsedElementType[\"NG_CONTENT\"] = 0] = \"NG_CONTENT\";\r\n    PreparsedElementType[PreparsedElementType[\"STYLE\"] = 1] = \"STYLE\";\r\n    PreparsedElementType[PreparsedElementType[\"STYLESHEET\"] = 2] = \"STYLESHEET\";\r\n    PreparsedElementType[PreparsedElementType[\"SCRIPT\"] = 3] = \"SCRIPT\";\r\n    PreparsedElementType[PreparsedElementType[\"OTHER\"] = 4] = \"OTHER\";\r\n})(PreparsedElementType || (PreparsedElementType = {}));\r\nclass PreparsedElement {\r\n    constructor(type, selectAttr, hrefAttr, nonBindable, projectAs) {\r\n        this.type = type;\r\n        this.selectAttr = selectAttr;\r\n        this.hrefAttr = hrefAttr;\r\n        this.nonBindable = nonBindable;\r\n        this.projectAs = projectAs;\r\n    }\r\n}\r\nfunction normalizeNgContentSelect(selectAttr) {\r\n    if (selectAttr === null || selectAttr.length === 0) {\r\n        return '*';\r\n    }\r\n    return selectAttr;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/;\r\n// Group 1 = \"bind-\"\r\nconst KW_BIND_IDX = 1;\r\n// Group 2 = \"let-\"\r\nconst KW_LET_IDX = 2;\r\n// Group 3 = \"ref-/#\"\r\nconst KW_REF_IDX = 3;\r\n// Group 4 = \"on-\"\r\nconst KW_ON_IDX = 4;\r\n// Group 5 = \"bindon-\"\r\nconst KW_BINDON_IDX = 5;\r\n// Group 6 = \"@\"\r\nconst KW_AT_IDX = 6;\r\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\r\nconst IDENT_KW_IDX = 7;\r\n// Group 8 = identifier inside [()]\r\nconst IDENT_BANANA_BOX_IDX = 8;\r\n// Group 9 = identifier inside []\r\nconst IDENT_PROPERTY_IDX = 9;\r\n// Group 10 = identifier inside ()\r\nconst IDENT_EVENT_IDX = 10;\r\nconst TEMPLATE_ATTR_PREFIX$1 = '*';\r\nconst CLASS_ATTR = 'class';\r\nlet _TEXT_CSS_SELECTOR;\r\nfunction TEXT_CSS_SELECTOR() {\r\n    if (!_TEXT_CSS_SELECTOR) {\r\n        _TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];\r\n    }\r\n    return _TEXT_CSS_SELECTOR;\r\n}\r\nclass TemplateParseError extends ParseError {\r\n    constructor(message, span, level) {\r\n        super(span, message, level);\r\n    }\r\n}\r\nclass TemplateParseResult {\r\n    constructor(templateAst, usedPipes, errors) {\r\n        this.templateAst = templateAst;\r\n        this.usedPipes = usedPipes;\r\n        this.errors = errors;\r\n    }\r\n}\r\nclass TemplateParser {\r\n    constructor(_config, _reflector, _exprParser, _schemaRegistry, _htmlParser, _console, transforms) {\r\n        this._config = _config;\r\n        this._reflector = _reflector;\r\n        this._exprParser = _exprParser;\r\n        this._schemaRegistry = _schemaRegistry;\r\n        this._htmlParser = _htmlParser;\r\n        this._console = _console;\r\n        this.transforms = transforms;\r\n    }\r\n    get expressionParser() {\r\n        return this._exprParser;\r\n    }\r\n    parse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {\r\n        var _a;\r\n        const result = this.tryParse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces);\r\n        const warnings = result.errors.filter(error => error.level === ParseErrorLevel.WARNING);\r\n        const errors = result.errors.filter(error => error.level === ParseErrorLevel.ERROR);\r\n        if (warnings.length > 0) {\r\n            (_a = this._console) === null || _a === void 0 ? void 0 : _a.warn(`Template parse warnings:\\n${warnings.join('\\n')}`);\r\n        }\r\n        if (errors.length > 0) {\r\n            const errorString = errors.join('\\n');\r\n            throw syntaxError(`Template parse errors:\\n${errorString}`, errors);\r\n        }\r\n        return { template: result.templateAst, pipes: result.usedPipes };\r\n    }\r\n    tryParse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {\r\n        let htmlParseResult = typeof template === 'string' ?\r\n            this._htmlParser.parse(template, templateUrl, {\r\n                tokenizeExpansionForms: true,\r\n                interpolationConfig: this.getInterpolationConfig(component)\r\n            }) :\r\n            template;\r\n        if (!preserveWhitespaces) {\r\n            htmlParseResult = removeWhitespaces(htmlParseResult);\r\n        }\r\n        return this.tryParseHtml(this.expandHtml(htmlParseResult), component, directives, pipes, schemas);\r\n    }\r\n    tryParseHtml(htmlAstWithErrors, component, directives, pipes, schemas) {\r\n        let result;\r\n        const errors = htmlAstWithErrors.errors;\r\n        const usedPipes = [];\r\n        if (htmlAstWithErrors.rootNodes.length > 0) {\r\n            const uniqDirectives = removeSummaryDuplicates(directives);\r\n            const uniqPipes = removeSummaryDuplicates(pipes);\r\n            const providerViewContext = new ProviderViewContext(this._reflector, component);\r\n            let interpolationConfig = undefined;\r\n            if (component.template && component.template.interpolation) {\r\n                interpolationConfig = {\r\n                    start: component.template.interpolation[0],\r\n                    end: component.template.interpolation[1]\r\n                };\r\n            }\r\n            const bindingParser = new BindingParser(this._exprParser, interpolationConfig, this._schemaRegistry, uniqPipes, errors);\r\n            const parseVisitor = new TemplateParseVisitor(this._reflector, this._config, providerViewContext, uniqDirectives, bindingParser, this._schemaRegistry, schemas, errors);\r\n            result = visitAll$1(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);\r\n            errors.push(...providerViewContext.errors);\r\n            usedPipes.push(...bindingParser.getUsedPipes());\r\n        }\r\n        else {\r\n            result = [];\r\n        }\r\n        this._assertNoReferenceDuplicationOnTemplate(result, errors);\r\n        if (errors.length > 0) {\r\n            return new TemplateParseResult(result, usedPipes, errors);\r\n        }\r\n        if (this.transforms) {\r\n            this.transforms.forEach((transform) => {\r\n                result = templateVisitAll(transform, result);\r\n            });\r\n        }\r\n        return new TemplateParseResult(result, usedPipes, errors);\r\n    }\r\n    expandHtml(htmlAstWithErrors, forced = false) {\r\n        const errors = htmlAstWithErrors.errors;\r\n        if (errors.length == 0 || forced) {\r\n            // Transform ICU messages to angular directives\r\n            const expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);\r\n            errors.push(...expandedHtmlAst.errors);\r\n            htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);\r\n        }\r\n        return htmlAstWithErrors;\r\n    }\r\n    getInterpolationConfig(component) {\r\n        if (component.template) {\r\n            return InterpolationConfig.fromArray(component.template.interpolation);\r\n        }\r\n        return undefined;\r\n    }\r\n    /** @internal */\r\n    _assertNoReferenceDuplicationOnTemplate(result, errors) {\r\n        const existingReferences = [];\r\n        result.filter(element => !!element.references)\r\n            .forEach(element => element.references.forEach((reference) => {\r\n            const name = reference.name;\r\n            if (existingReferences.indexOf(name) < 0) {\r\n                existingReferences.push(name);\r\n            }\r\n            else {\r\n                const error = new TemplateParseError(`Reference \"#${name}\" is defined several times`, reference.sourceSpan, ParseErrorLevel.ERROR);\r\n                errors.push(error);\r\n            }\r\n        }));\r\n    }\r\n}\r\nclass TemplateParseVisitor {\r\n    constructor(reflector, config, providerViewContext, directives, _bindingParser, _schemaRegistry, _schemas, _targetErrors) {\r\n        this.reflector = reflector;\r\n        this.config = config;\r\n        this.providerViewContext = providerViewContext;\r\n        this._bindingParser = _bindingParser;\r\n        this._schemaRegistry = _schemaRegistry;\r\n        this._schemas = _schemas;\r\n        this._targetErrors = _targetErrors;\r\n        this.selectorMatcher = new SelectorMatcher();\r\n        this.directivesIndex = new Map();\r\n        this.ngContentCount = 0;\r\n        // Note: queries start with id 1 so we can use the number in a Bloom filter!\r\n        this.contentQueryStartId = providerViewContext.component.viewQueries.length + 1;\r\n        directives.forEach((directive, index) => {\r\n            const selector = CssSelector.parse(directive.selector);\r\n            this.selectorMatcher.addSelectables(selector, directive);\r\n            this.directivesIndex.set(directive, index);\r\n        });\r\n    }\r\n    visitExpansion(expansion, context) {\r\n        return null;\r\n    }\r\n    visitExpansionCase(expansionCase, context) {\r\n        return null;\r\n    }\r\n    visitText(text, parent) {\r\n        const ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());\r\n        const valueNoNgsp = replaceNgsp(text.value);\r\n        const expr = this._bindingParser.parseInterpolation(valueNoNgsp, text.sourceSpan);\r\n        return expr ? new BoundTextAst(expr, ngContentIndex, text.sourceSpan) :\r\n            new TextAst(valueNoNgsp, ngContentIndex, text.sourceSpan);\r\n    }\r\n    visitAttribute(attribute, context) {\r\n        return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\r\n    }\r\n    visitComment(comment, context) {\r\n        return null;\r\n    }\r\n    visitElement(element, parent) {\r\n        const queryStartIndex = this.contentQueryStartId;\r\n        const elName = element.name;\r\n        const preparsedElement = preparseElement(element);\r\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\r\n            preparsedElement.type === PreparsedElementType.STYLE) {\r\n            // Skipping <script> for security reasons\r\n            // Skipping <style> as we already processed them\r\n            // in the StyleCompiler\r\n            return null;\r\n        }\r\n        if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\r\n            isStyleUrlResolvable(preparsedElement.hrefAttr)) {\r\n            // Skipping stylesheets with either relative urls or package scheme as we already processed\r\n            // them in the StyleCompiler\r\n            return null;\r\n        }\r\n        const matchableAttrs = [];\r\n        const elementOrDirectiveProps = [];\r\n        const elementOrDirectiveRefs = [];\r\n        const elementVars = [];\r\n        const events = [];\r\n        const templateElementOrDirectiveProps = [];\r\n        const templateMatchableAttrs = [];\r\n        const templateElementVars = [];\r\n        let hasInlineTemplates = false;\r\n        const attrs = [];\r\n        const isTemplateElement = isNgTemplate(element.name);\r\n        element.attrs.forEach(attr => {\r\n            const parsedVariables = [];\r\n            const hasBinding = this._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);\r\n            elementVars.push(...parsedVariables.map(v => VariableAst.fromParsedVariable(v)));\r\n            let templateValue;\r\n            let templateKey;\r\n            const normalizedName = this._normalizeAttributeName(attr.name);\r\n            if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX$1)) {\r\n                templateValue = attr.value;\r\n                templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX$1.length);\r\n            }\r\n            const hasTemplateBinding = templateValue != null;\r\n            if (hasTemplateBinding) {\r\n                if (hasInlineTemplates) {\r\n                    this._reportError(`Can't have multiple template bindings on one element. Use only one attribute prefixed with *`, attr.sourceSpan);\r\n                }\r\n                hasInlineTemplates = true;\r\n                const parsedVariables = [];\r\n                const absoluteOffset = (attr.valueSpan || attr.sourceSpan).start.offset;\r\n                this._bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attr.sourceSpan, absoluteOffset, templateMatchableAttrs, templateElementOrDirectiveProps, parsedVariables, false /* isIvyAst */);\r\n                templateElementVars.push(...parsedVariables.map(v => VariableAst.fromParsedVariable(v)));\r\n            }\r\n            if (!hasBinding && !hasTemplateBinding) {\r\n                // don't include the bindings as attributes as well in the AST\r\n                attrs.push(this.visitAttribute(attr, null));\r\n                matchableAttrs.push([attr.name, attr.value]);\r\n            }\r\n        });\r\n        const elementCssSelector = createElementCssSelector(elName, matchableAttrs);\r\n        const { directives: directiveMetas, matchElement } = this._parseDirectives(this.selectorMatcher, elementCssSelector);\r\n        const references = [];\r\n        const boundDirectivePropNames = new Set();\r\n        const directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references, boundDirectivePropNames);\r\n        const elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, boundDirectivePropNames);\r\n        const isViewRoot = parent.isTemplateElement || hasInlineTemplates;\r\n        const providerContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, isTemplateElement, queryStartIndex, element.sourceSpan);\r\n        const children = visitAll$1(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));\r\n        providerContext.afterElement();\r\n        // Override the actual selector when the `ngProjectAs` attribute is provided\r\n        const projectionSelector = preparsedElement.projectAs != '' ?\r\n            CssSelector.parse(preparsedElement.projectAs)[0] :\r\n            elementCssSelector;\r\n        const ngContentIndex = parent.findNgContentIndex(projectionSelector);\r\n        let parsedElement;\r\n        if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\r\n            // `<ng-content>` element\r\n            if (element.children && !element.children.every(_isEmptyTextNode)) {\r\n                this._reportError(`<ng-content> element cannot have content.`, element.sourceSpan);\r\n            }\r\n            parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);\r\n        }\r\n        else if (isTemplateElement) {\r\n            // `<ng-template>` element\r\n            this._assertAllEventsPublishedByDirectives(directiveAsts, events);\r\n            this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);\r\n            parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);\r\n        }\r\n        else {\r\n            // element other than `<ng-content>` and `<ng-template>`\r\n            this._assertElementExists(matchElement, element);\r\n            this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);\r\n            const ngContentIndex = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);\r\n            parsedElement = new ElementAst(elName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan, element.endSourceSpan || null);\r\n        }\r\n        if (hasInlineTemplates) {\r\n            // The element as a *-attribute\r\n            const templateQueryStartIndex = this.contentQueryStartId;\r\n            const templateSelector = createElementCssSelector('ng-template', templateMatchableAttrs);\r\n            const { directives } = this._parseDirectives(this.selectorMatcher, templateSelector);\r\n            const templateBoundDirectivePropNames = new Set();\r\n            const templateDirectiveAsts = this._createDirectiveAsts(true, elName, directives, templateElementOrDirectiveProps, [], element.sourceSpan, [], templateBoundDirectivePropNames);\r\n            const templateElementProps = this._createElementPropertyAsts(elName, templateElementOrDirectiveProps, templateBoundDirectivePropNames);\r\n            this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);\r\n            const templateProviderContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], true, templateQueryStartIndex, element.sourceSpan);\r\n            templateProviderContext.afterElement();\r\n            parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, templateProviderContext.queryMatches, [parsedElement], ngContentIndex, element.sourceSpan);\r\n        }\r\n        return parsedElement;\r\n    }\r\n    _parseAttr(isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {\r\n        const name = this._normalizeAttributeName(attr.name);\r\n        const value = attr.value;\r\n        const srcSpan = attr.sourceSpan;\r\n        const absoluteOffset = attr.valueSpan ? attr.valueSpan.start.offset : srcSpan.start.offset;\r\n        const boundEvents = [];\r\n        const bindParts = name.match(BIND_NAME_REGEXP);\r\n        let hasBinding = false;\r\n        if (bindParts !== null) {\r\n            hasBinding = true;\r\n            if (bindParts[KW_BIND_IDX] != null) {\r\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\r\n            }\r\n            else if (bindParts[KW_LET_IDX]) {\r\n                if (isTemplateElement) {\r\n                    const identifier = bindParts[IDENT_KW_IDX];\r\n                    this._parseVariable(identifier, value, srcSpan, targetVars);\r\n                }\r\n                else {\r\n                    this._reportError(`\"let-\" is only supported on ng-template elements.`, srcSpan);\r\n                }\r\n            }\r\n            else if (bindParts[KW_REF_IDX]) {\r\n                const identifier = bindParts[IDENT_KW_IDX];\r\n                this._parseReference(identifier, value, srcSpan, targetRefs);\r\n            }\r\n            else if (bindParts[KW_ON_IDX]) {\r\n                this._bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\r\n            }\r\n            else if (bindParts[KW_BINDON_IDX]) {\r\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\r\n                this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\r\n            }\r\n            else if (bindParts[KW_AT_IDX]) {\r\n                this._bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\r\n            }\r\n            else if (bindParts[IDENT_BANANA_BOX_IDX]) {\r\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\r\n                this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\r\n            }\r\n            else if (bindParts[IDENT_PROPERTY_IDX]) {\r\n                this._bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\r\n            }\r\n            else if (bindParts[IDENT_EVENT_IDX]) {\r\n                this._bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\r\n            }\r\n        }\r\n        else {\r\n            hasBinding = this._bindingParser.parsePropertyInterpolation(name, value, srcSpan, attr.valueSpan, targetMatchableAttrs, targetProps);\r\n        }\r\n        if (!hasBinding) {\r\n            this._bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\r\n        }\r\n        targetEvents.push(...boundEvents.map(e => BoundEventAst.fromParsedEvent(e)));\r\n        return hasBinding;\r\n    }\r\n    _normalizeAttributeName(attrName) {\r\n        return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\r\n    }\r\n    _parseVariable(identifier, value, sourceSpan, targetVars) {\r\n        if (identifier.indexOf('-') > -1) {\r\n            this._reportError(`\"-\" is not allowed in variable names`, sourceSpan);\r\n        }\r\n        else if (identifier.length === 0) {\r\n            this._reportError(`Variable does not have a name`, sourceSpan);\r\n        }\r\n        targetVars.push(new VariableAst(identifier, value, sourceSpan));\r\n    }\r\n    _parseReference(identifier, value, sourceSpan, targetRefs) {\r\n        if (identifier.indexOf('-') > -1) {\r\n            this._reportError(`\"-\" is not allowed in reference names`, sourceSpan);\r\n        }\r\n        else if (identifier.length === 0) {\r\n            this._reportError(`Reference does not have a name`, sourceSpan);\r\n        }\r\n        targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));\r\n    }\r\n    _parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, targetEvents) {\r\n        this._bindingParser.parseEvent(`${name}Change`, `${expression}=$event`, sourceSpan, valueSpan, targetMatchableAttrs, targetEvents);\r\n    }\r\n    _parseDirectives(selectorMatcher, elementCssSelector) {\r\n        // Need to sort the directives so that we get consistent results throughout,\r\n        // as selectorMatcher uses Maps inside.\r\n        // Also deduplicate directives as they might match more than one time!\r\n        const directives = newArray(this.directivesIndex.size);\r\n        // Whether any directive selector matches on the element name\r\n        let matchElement = false;\r\n        selectorMatcher.match(elementCssSelector, (selector, directive) => {\r\n            directives[this.directivesIndex.get(directive)] = directive;\r\n            matchElement = matchElement || selector.hasElementSelector();\r\n        });\r\n        return {\r\n            directives: directives.filter(dir => !!dir),\r\n            matchElement,\r\n        };\r\n    }\r\n    _createDirectiveAsts(isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences, targetBoundDirectivePropNames) {\r\n        const matchedReferences = new Set();\r\n        let component = null;\r\n        const directiveAsts = directives.map((directive) => {\r\n            const sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, elementSourceSpan.fullStart, `Directive ${identifierName(directive.type)}`);\r\n            if (directive.isComponent) {\r\n                component = directive;\r\n            }\r\n            const directiveProperties = [];\r\n            const boundProperties = this._bindingParser.createDirectiveHostPropertyAsts(directive, elementName, sourceSpan);\r\n            let hostProperties = boundProperties.map(prop => BoundElementPropertyAst.fromBoundProperty(prop));\r\n            // Note: We need to check the host properties here as well,\r\n            // as we don't know the element name in the DirectiveWrapperCompiler yet.\r\n            hostProperties = this._checkPropertiesInSchema(elementName, hostProperties);\r\n            const parsedEvents = this._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan);\r\n            this._createDirectivePropertyAsts(directive.inputs, props, directiveProperties, targetBoundDirectivePropNames);\r\n            elementOrDirectiveRefs.forEach((elOrDirRef) => {\r\n                if ((elOrDirRef.value.length === 0 && directive.isComponent) ||\r\n                    (elOrDirRef.isReferenceToDirective(directive))) {\r\n                    targetReferences.push(new ReferenceAst(elOrDirRef.name, createTokenForReference(directive.type.reference), elOrDirRef.value, elOrDirRef.sourceSpan));\r\n                    matchedReferences.add(elOrDirRef.name);\r\n                }\r\n            });\r\n            const hostEvents = parsedEvents.map(e => BoundEventAst.fromParsedEvent(e));\r\n            const contentQueryStartId = this.contentQueryStartId;\r\n            this.contentQueryStartId += directive.queries.length;\r\n            return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, contentQueryStartId, sourceSpan);\r\n        });\r\n        elementOrDirectiveRefs.forEach((elOrDirRef) => {\r\n            if (elOrDirRef.value.length > 0) {\r\n                if (!matchedReferences.has(elOrDirRef.name)) {\r\n                    this._reportError(`There is no directive with \"exportAs\" set to \"${elOrDirRef.value}\"`, elOrDirRef.sourceSpan);\r\n                }\r\n            }\r\n            else if (!component) {\r\n                let refToken = null;\r\n                if (isTemplateElement) {\r\n                    refToken = createTokenForExternalReference(this.reflector, Identifiers$1.TemplateRef);\r\n                }\r\n                targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.value, elOrDirRef.sourceSpan));\r\n            }\r\n        });\r\n        return directiveAsts;\r\n    }\r\n    _createDirectivePropertyAsts(directiveProperties, boundProps, targetBoundDirectiveProps, targetBoundDirectivePropNames) {\r\n        if (directiveProperties) {\r\n            const boundPropsByName = new Map();\r\n            boundProps.forEach(boundProp => {\r\n                const prevValue = boundPropsByName.get(boundProp.name);\r\n                if (!prevValue || prevValue.isLiteral) {\r\n                    // give [a]=\"b\" a higher precedence than a=\"b\" on the same element\r\n                    boundPropsByName.set(boundProp.name, boundProp);\r\n                }\r\n            });\r\n            Object.keys(directiveProperties).forEach(dirProp => {\r\n                const elProp = directiveProperties[dirProp];\r\n                const boundProp = boundPropsByName.get(elProp);\r\n                // Bindings are optional, so this binding only needs to be set up if an expression is given.\r\n                if (boundProp) {\r\n                    targetBoundDirectivePropNames.add(boundProp.name);\r\n                    if (!isEmptyExpression(boundProp.expression)) {\r\n                        targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n    _createElementPropertyAsts(elementName, props, boundDirectivePropNames) {\r\n        const boundElementProps = [];\r\n        props.forEach((prop) => {\r\n            if (!prop.isLiteral && !boundDirectivePropNames.has(prop.name)) {\r\n                const boundProp = this._bindingParser.createBoundElementProperty(elementName, prop);\r\n                boundElementProps.push(BoundElementPropertyAst.fromBoundProperty(boundProp));\r\n            }\r\n        });\r\n        return this._checkPropertiesInSchema(elementName, boundElementProps);\r\n    }\r\n    _findComponentDirectives(directives) {\r\n        return directives.filter(directive => directive.directive.isComponent);\r\n    }\r\n    _findComponentDirectiveNames(directives) {\r\n        return this._findComponentDirectives(directives)\r\n            .map(directive => identifierName(directive.directive.type));\r\n    }\r\n    _assertOnlyOneComponent(directives, sourceSpan) {\r\n        const componentTypeNames = this._findComponentDirectiveNames(directives);\r\n        if (componentTypeNames.length > 1) {\r\n            this._reportError(`More than one component matched on this element.\\n` +\r\n                `Make sure that only one component's selector can match a given element.\\n` +\r\n                `Conflicting components: ${componentTypeNames.join(',')}`, sourceSpan);\r\n        }\r\n    }\r\n    /**\r\n     * Make sure that non-angular tags conform to the schemas.\r\n     *\r\n     * Note: An element is considered an angular tag when at least one directive selector matches the\r\n     * tag name.\r\n     *\r\n     * @param matchElement Whether any directive has matched on the tag name\r\n     * @param element the html element\r\n     */\r\n    _assertElementExists(matchElement, element) {\r\n        const elName = element.name.replace(/^:xhtml:/, '');\r\n        if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {\r\n            let errorMsg = `'${elName}' is not a known element:\\n`;\r\n            errorMsg += `1. If '${elName}' is an Angular component, then verify that it is part of this module.\\n`;\r\n            if (elName.indexOf('-') > -1) {\r\n                errorMsg += `2. If '${elName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.`;\r\n            }\r\n            else {\r\n                errorMsg +=\r\n                    `2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\r\n            }\r\n            this._reportError(errorMsg, element.sourceSpan);\r\n        }\r\n    }\r\n    _assertNoComponentsNorElementBindingsOnTemplate(directives, elementProps, sourceSpan) {\r\n        const componentTypeNames = this._findComponentDirectiveNames(directives);\r\n        if (componentTypeNames.length > 0) {\r\n            this._reportError(`Components on an embedded template: ${componentTypeNames.join(',')}`, sourceSpan);\r\n        }\r\n        elementProps.forEach(prop => {\r\n            this._reportError(`Property binding ${prop.name} not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \"@NgModule.declarations\".`, sourceSpan);\r\n        });\r\n    }\r\n    _assertAllEventsPublishedByDirectives(directives, events) {\r\n        const allDirectiveEvents = new Set();\r\n        directives.forEach(directive => {\r\n            Object.keys(directive.directive.outputs).forEach(k => {\r\n                const eventName = directive.directive.outputs[k];\r\n                allDirectiveEvents.add(eventName);\r\n            });\r\n        });\r\n        events.forEach(event => {\r\n            if (event.target != null || !allDirectiveEvents.has(event.name)) {\r\n                this._reportError(`Event binding ${event\r\n                    .fullName} not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \"@NgModule.declarations\".`, event.sourceSpan);\r\n            }\r\n        });\r\n    }\r\n    _checkPropertiesInSchema(elementName, boundProps) {\r\n        // Note: We can't filter out empty expressions before this method,\r\n        // as we still want to validate them!\r\n        return boundProps.filter((boundProp) => {\r\n            if (boundProp.type === 0 /* Property */ &&\r\n                !this._schemaRegistry.hasProperty(elementName, boundProp.name, this._schemas)) {\r\n                let errorMsg = `Can't bind to '${boundProp.name}' since it isn't a known property of '${elementName}'.`;\r\n                if (elementName.startsWith('ng-')) {\r\n                    errorMsg +=\r\n                        `\\n1. If '${boundProp\r\n                            .name}' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.` +\r\n                            `\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\r\n                }\r\n                else if (elementName.indexOf('-') > -1) {\r\n                    errorMsg +=\r\n                        `\\n1. If '${elementName}' is an Angular component and it has '${boundProp.name}' input, then verify that it is part of this module.` +\r\n                            `\\n2. If '${elementName}' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.` +\r\n                            `\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.`;\r\n                }\r\n                this._reportError(errorMsg, boundProp.sourceSpan);\r\n            }\r\n            return !isEmptyExpression(boundProp.value);\r\n        });\r\n    }\r\n    _reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {\r\n        this._targetErrors.push(new ParseError(sourceSpan, message, level));\r\n    }\r\n}\r\nclass NonBindableVisitor {\r\n    visitElement(ast, parent) {\r\n        const preparsedElement = preparseElement(ast);\r\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\r\n            preparsedElement.type === PreparsedElementType.STYLE ||\r\n            preparsedElement.type === PreparsedElementType.STYLESHEET) {\r\n            // Skipping <script> for security reasons\r\n            // Skipping <style> and stylesheets as we already processed them\r\n            // in the StyleCompiler\r\n            return null;\r\n        }\r\n        const attrNameAndValues = ast.attrs.map((attr) => [attr.name, attr.value]);\r\n        const selector = createElementCssSelector(ast.name, attrNameAndValues);\r\n        const ngContentIndex = parent.findNgContentIndex(selector);\r\n        const children = visitAll$1(this, ast.children, EMPTY_ELEMENT_CONTEXT);\r\n        return new ElementAst(ast.name, visitAll$1(this, ast.attrs), [], [], [], [], [], false, [], children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);\r\n    }\r\n    visitComment(comment, context) {\r\n        return null;\r\n    }\r\n    visitAttribute(attribute, context) {\r\n        return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\r\n    }\r\n    visitText(text, parent) {\r\n        const ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());\r\n        return new TextAst(text.value, ngContentIndex, text.sourceSpan);\r\n    }\r\n    visitExpansion(expansion, context) {\r\n        return expansion;\r\n    }\r\n    visitExpansionCase(expansionCase, context) {\r\n        return expansionCase;\r\n    }\r\n}\r\n/**\r\n * A reference to an element or directive in a template. E.g., the reference in this template:\r\n *\r\n * <div #myMenu=\"coolMenu\">\r\n *\r\n * would be {name: 'myMenu', value: 'coolMenu', sourceSpan: ...}\r\n */\r\nclass ElementOrDirectiveRef {\r\n    constructor(name, value, sourceSpan) {\r\n        this.name = name;\r\n        this.value = value;\r\n        this.sourceSpan = sourceSpan;\r\n    }\r\n    /** Gets whether this is a reference to the given directive. */\r\n    isReferenceToDirective(directive) {\r\n        return splitExportAs(directive.exportAs).indexOf(this.value) !== -1;\r\n    }\r\n}\r\n/** Splits a raw, potentially comma-delimited `exportAs` value into an array of names. */\r\nfunction splitExportAs(exportAs) {\r\n    return exportAs ? exportAs.split(',').map(e => e.trim()) : [];\r\n}\r\nfunction splitClasses(classAttrValue) {\r\n    return classAttrValue.trim().split(/\\s+/g);\r\n}\r\nclass ElementContext {\r\n    constructor(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {\r\n        this.isTemplateElement = isTemplateElement;\r\n        this._ngContentIndexMatcher = _ngContentIndexMatcher;\r\n        this._wildcardNgContentIndex = _wildcardNgContentIndex;\r\n        this.providerContext = providerContext;\r\n    }\r\n    static create(isTemplateElement, directives, providerContext) {\r\n        const matcher = new SelectorMatcher();\r\n        let wildcardNgContentIndex = null;\r\n        const component = directives.find(directive => directive.directive.isComponent);\r\n        if (component) {\r\n            const ngContentSelectors = component.directive.template.ngContentSelectors;\r\n            for (let i = 0; i < ngContentSelectors.length; i++) {\r\n                const selector = ngContentSelectors[i];\r\n                if (selector === '*') {\r\n                    wildcardNgContentIndex = i;\r\n                }\r\n                else {\r\n                    matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);\r\n                }\r\n            }\r\n        }\r\n        return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);\r\n    }\r\n    findNgContentIndex(selector) {\r\n        const ngContentIndices = [];\r\n        this._ngContentIndexMatcher.match(selector, (selector, ngContentIndex) => {\r\n            ngContentIndices.push(ngContentIndex);\r\n        });\r\n        ngContentIndices.sort();\r\n        if (this._wildcardNgContentIndex != null) {\r\n            ngContentIndices.push(this._wildcardNgContentIndex);\r\n        }\r\n        return ngContentIndices.length > 0 ? ngContentIndices[0] : null;\r\n    }\r\n}\r\nfunction createElementCssSelector(elementName, attributes) {\r\n    const cssSelector = new CssSelector();\r\n    const elNameNoNs = splitNsName(elementName)[1];\r\n    cssSelector.setElement(elNameNoNs);\r\n    for (let i = 0; i < attributes.length; i++) {\r\n        const attrName = attributes[i][0];\r\n        const attrNameNoNs = splitNsName(attrName)[1];\r\n        const attrValue = attributes[i][1];\r\n        cssSelector.addAttribute(attrNameNoNs, attrValue);\r\n        if (attrName.toLowerCase() == CLASS_ATTR) {\r\n            const classes = splitClasses(attrValue);\r\n            classes.forEach(className => cssSelector.addClassName(className));\r\n        }\r\n    }\r\n    return cssSelector;\r\n}\r\nconst EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);\r\nconst NON_BINDABLE_VISITOR = new NonBindableVisitor();\r\nfunction _isEmptyTextNode(node) {\r\n    return node instanceof Text$3 && node.value.trim().length == 0;\r\n}\r\nfunction removeSummaryDuplicates(items) {\r\n    const map = new Map();\r\n    items.forEach((item) => {\r\n        if (!map.get(item.type.reference)) {\r\n            map.set(item.type.reference, item);\r\n        }\r\n    });\r\n    return Array.from(map.values());\r\n}\r\nfunction isEmptyExpression(ast) {\r\n    if (ast instanceof ASTWithSource) {\r\n        ast = ast.ast;\r\n    }\r\n    return ast instanceof EmptyExpr;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Parses string representation of a style and converts it into object literal.\r\n *\r\n * @param value string representation of style as used in the `style` attribute in HTML.\r\n *   Example: `color: red; height: auto`.\r\n * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',\r\n * 'auto']`\r\n */\r\nfunction parse(value) {\r\n    // we use a string array here instead of a string map\r\n    // because a string-map is not guaranteed to retain the\r\n    // order of the entries whereas a string array can be\r\n    // constructed in a [key, value, key, value] format.\r\n    const styles = [];\r\n    let i = 0;\r\n    let parenDepth = 0;\r\n    let quote = 0 /* QuoteNone */;\r\n    let valueStart = 0;\r\n    let propStart = 0;\r\n    let currentProp = null;\r\n    let valueHasQuotes = false;\r\n    while (i < value.length) {\r\n        const token = value.charCodeAt(i++);\r\n        switch (token) {\r\n            case 40 /* OpenParen */:\r\n                parenDepth++;\r\n                break;\r\n            case 41 /* CloseParen */:\r\n                parenDepth--;\r\n                break;\r\n            case 39 /* QuoteSingle */:\r\n                // valueStart needs to be there since prop values don't\r\n                // have quotes in CSS\r\n                valueHasQuotes = valueHasQuotes || valueStart > 0;\r\n                if (quote === 0 /* QuoteNone */) {\r\n                    quote = 39 /* QuoteSingle */;\r\n                }\r\n                else if (quote === 39 /* QuoteSingle */ && value.charCodeAt(i - 1) !== 92 /* BackSlash */) {\r\n                    quote = 0 /* QuoteNone */;\r\n                }\r\n                break;\r\n            case 34 /* QuoteDouble */:\r\n                // same logic as above\r\n                valueHasQuotes = valueHasQuotes || valueStart > 0;\r\n                if (quote === 0 /* QuoteNone */) {\r\n                    quote = 34 /* QuoteDouble */;\r\n                }\r\n                else if (quote === 34 /* QuoteDouble */ && value.charCodeAt(i - 1) !== 92 /* BackSlash */) {\r\n                    quote = 0 /* QuoteNone */;\r\n                }\r\n                break;\r\n            case 58 /* Colon */:\r\n                if (!currentProp && parenDepth === 0 && quote === 0 /* QuoteNone */) {\r\n                    currentProp = hyphenate(value.substring(propStart, i - 1).trim());\r\n                    valueStart = i;\r\n                }\r\n                break;\r\n            case 59 /* Semicolon */:\r\n                if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0 /* QuoteNone */) {\r\n                    const styleVal = value.substring(valueStart, i - 1).trim();\r\n                    styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\r\n                    propStart = i;\r\n                    valueStart = 0;\r\n                    currentProp = null;\r\n                    valueHasQuotes = false;\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    if (currentProp && valueStart) {\r\n        const styleVal = value.substr(valueStart).trim();\r\n        styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\r\n    }\r\n    return styles;\r\n}\r\nfunction stripUnnecessaryQuotes(value) {\r\n    const qS = value.charCodeAt(0);\r\n    const qE = value.charCodeAt(value.length - 1);\r\n    if (qS == qE && (qS == 39 /* QuoteSingle */ || qS == 34 /* QuoteDouble */)) {\r\n        const tempValue = value.substring(1, value.length - 1);\r\n        // special case to avoid using a multi-quoted string that was just chomped\r\n        // (e.g. `font-family: \"Verdana\", \"sans-serif\"`)\r\n        if (tempValue.indexOf('\\'') == -1 && tempValue.indexOf('\"') == -1) {\r\n            value = tempValue;\r\n        }\r\n    }\r\n    return value;\r\n}\r\nfunction hyphenate(value) {\r\n    return value\r\n        .replace(/[a-z][A-Z]/g, v => {\r\n        return v.charAt(0) + '-' + v.charAt(1);\r\n    })\r\n        .toLowerCase();\r\n}\r\n\r\nconst IMPORTANT_FLAG = '!important';\r\n/**\r\n * Minimum amount of binding slots required in the runtime for style/class bindings.\r\n *\r\n * Styling in Angular uses up two slots in the runtime LView/TData data structures to\r\n * record binding data, property information and metadata.\r\n *\r\n * When a binding is registered it will place the following information in the `LView`:\r\n *\r\n * slot 1) binding value\r\n * slot 2) cached value (all other values collected before it in string form)\r\n *\r\n * When a binding is registered it will place the following information in the `TData`:\r\n *\r\n * slot 1) prop name\r\n * slot 2) binding index that points to the previous style/class binding (and some extra config\r\n * values)\r\n *\r\n * Let's imagine we have a binding that looks like so:\r\n *\r\n * ```\r\n * <div [style.width]=\"x\" [style.height]=\"y\">\r\n * ```\r\n *\r\n * Our `LView` and `TData` data-structures look like so:\r\n *\r\n * ```typescript\r\n * LView = [\r\n *   // ...\r\n *   x, // value of x\r\n *   \"width: x\",\r\n *\r\n *   y, // value of y\r\n *   \"width: x; height: y\",\r\n *   // ...\r\n * ];\r\n *\r\n * TData = [\r\n *   // ...\r\n *   \"width\", // binding slot 20\r\n *   0,\r\n *\r\n *   \"height\",\r\n *   20,\r\n *   // ...\r\n * ];\r\n * ```\r\n *\r\n * */\r\nconst MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;\r\n/**\r\n * Produces creation/update instructions for all styling bindings (class and style)\r\n *\r\n * It also produces the creation instruction to register all initial styling values\r\n * (which are all the static class=\"...\" and style=\"...\" attribute values that exist\r\n * on an element within a template).\r\n *\r\n * The builder class below handles producing instructions for the following cases:\r\n *\r\n * - Static style/class attributes (style=\"...\" and class=\"...\")\r\n * - Dynamic style/class map bindings ([style]=\"map\" and [class]=\"map|string\")\r\n * - Dynamic style/class property bindings ([style.prop]=\"exp\" and [class.name]=\"exp\")\r\n *\r\n * Due to the complex relationship of all of these cases, the instructions generated\r\n * for these attributes/properties/bindings must be done so in the correct order. The\r\n * order which these must be generated is as follows:\r\n *\r\n * if (createMode) {\r\n *   styling(...)\r\n * }\r\n * if (updateMode) {\r\n *   styleMap(...)\r\n *   classMap(...)\r\n *   styleProp(...)\r\n *   classProp(...)\r\n * }\r\n *\r\n * The creation/update methods within the builder class produce these instructions.\r\n */\r\nclass StylingBuilder {\r\n    constructor(_directiveExpr) {\r\n        this._directiveExpr = _directiveExpr;\r\n        /** Whether or not there are any static styling values present */\r\n        this._hasInitialValues = false;\r\n        /**\r\n         *  Whether or not there are any styling bindings present\r\n         *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)\r\n         */\r\n        this.hasBindings = false;\r\n        this.hasBindingsWithPipes = false;\r\n        /** the input for [class] (if it exists) */\r\n        this._classMapInput = null;\r\n        /** the input for [style] (if it exists) */\r\n        this._styleMapInput = null;\r\n        /** an array of each [style.prop] input */\r\n        this._singleStyleInputs = null;\r\n        /** an array of each [class.name] input */\r\n        this._singleClassInputs = null;\r\n        this._lastStylingInput = null;\r\n        this._firstStylingInput = null;\r\n        // maps are used instead of hash maps because a Map will\r\n        // retain the ordering of the keys\r\n        /**\r\n         * Represents the location of each style binding in the template\r\n         * (e.g. `<div [style.width]=\"w\" [style.height]=\"h\">` implies\r\n         * that `width=0` and `height=1`)\r\n         */\r\n        this._stylesIndex = new Map();\r\n        /**\r\n         * Represents the location of each class binding in the template\r\n         * (e.g. `<div [class.big]=\"b\" [class.hidden]=\"h\">` implies\r\n         * that `big=0` and `hidden=1`)\r\n         */\r\n        this._classesIndex = new Map();\r\n        this._initialStyleValues = [];\r\n        this._initialClassValues = [];\r\n    }\r\n    /**\r\n     * Registers a given input to the styling builder to be later used when producing AOT code.\r\n     *\r\n     * The code below will only accept the input if it is somehow tied to styling (whether it be\r\n     * style/class bindings or static style/class attributes).\r\n     */\r\n    registerBoundInput(input) {\r\n        // [attr.style] or [attr.class] are skipped in the code below,\r\n        // they should not be treated as styling-based bindings since\r\n        // they are intended to be written directly to the attr and\r\n        // will therefore skip all style/class resolution that is present\r\n        // with style=\"\", [style]=\"\" and [style.prop]=\"\", class=\"\",\r\n        // [class.prop]=\"\". [class]=\"\" assignments\r\n        let binding = null;\r\n        let name = input.name;\r\n        switch (input.type) {\r\n            case 0 /* Property */:\r\n                binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);\r\n                break;\r\n            case 3 /* Style */:\r\n                binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);\r\n                break;\r\n            case 2 /* Class */:\r\n                binding = this.registerClassInput(name, false, input.value, input.sourceSpan);\r\n                break;\r\n        }\r\n        return binding ? true : false;\r\n    }\r\n    registerInputBasedOnName(name, expression, sourceSpan) {\r\n        let binding = null;\r\n        const prefix = name.substring(0, 6);\r\n        const isStyle = name === 'style' || prefix === 'style.' || prefix === 'style!';\r\n        const isClass = !isStyle && (name === 'class' || prefix === 'class.' || prefix === 'class!');\r\n        if (isStyle || isClass) {\r\n            const isMapBased = name.charAt(5) !== '.'; // style.prop or class.prop makes this a no\r\n            const property = name.substr(isMapBased ? 5 : 6); // the dot explains why there's a +1\r\n            if (isStyle) {\r\n                binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);\r\n            }\r\n            else {\r\n                binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);\r\n            }\r\n        }\r\n        return binding;\r\n    }\r\n    registerStyleInput(name, isMapBased, value, sourceSpan, suffix) {\r\n        if (isEmptyExpression(value)) {\r\n            return null;\r\n        }\r\n        // CSS custom properties are case-sensitive so we shouldn't normalize them.\r\n        // See: https://www.w3.org/TR/css-variables-1/#defining-variables\r\n        if (!isCssCustomProperty(name)) {\r\n            name = hyphenate(name);\r\n        }\r\n        const { property, hasOverrideFlag, suffix: bindingSuffix } = parseProperty(name);\r\n        suffix = typeof suffix === 'string' && suffix.length !== 0 ? suffix : bindingSuffix;\r\n        const entry = { name: property, suffix: suffix, value, sourceSpan, hasOverrideFlag };\r\n        if (isMapBased) {\r\n            this._styleMapInput = entry;\r\n        }\r\n        else {\r\n            (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);\r\n            registerIntoMap(this._stylesIndex, property);\r\n        }\r\n        this._lastStylingInput = entry;\r\n        this._firstStylingInput = this._firstStylingInput || entry;\r\n        this._checkForPipes(value);\r\n        this.hasBindings = true;\r\n        return entry;\r\n    }\r\n    registerClassInput(name, isMapBased, value, sourceSpan) {\r\n        if (isEmptyExpression(value)) {\r\n            return null;\r\n        }\r\n        const { property, hasOverrideFlag } = parseProperty(name);\r\n        const entry = { name: property, value, sourceSpan, hasOverrideFlag, suffix: null };\r\n        if (isMapBased) {\r\n            this._classMapInput = entry;\r\n        }\r\n        else {\r\n            (this._singleClassInputs = this._singleClassInputs || []).push(entry);\r\n            registerIntoMap(this._classesIndex, property);\r\n        }\r\n        this._lastStylingInput = entry;\r\n        this._firstStylingInput = this._firstStylingInput || entry;\r\n        this._checkForPipes(value);\r\n        this.hasBindings = true;\r\n        return entry;\r\n    }\r\n    _checkForPipes(value) {\r\n        if ((value instanceof ASTWithSource) && (value.ast instanceof BindingPipe)) {\r\n            this.hasBindingsWithPipes = true;\r\n        }\r\n    }\r\n    /**\r\n     * Registers the element's static style string value to the builder.\r\n     *\r\n     * @param value the style string (e.g. `width:100px; height:200px;`)\r\n     */\r\n    registerStyleAttr(value) {\r\n        this._initialStyleValues = parse(value);\r\n        this._hasInitialValues = true;\r\n    }\r\n    /**\r\n     * Registers the element's static class string value to the builder.\r\n     *\r\n     * @param value the className string (e.g. `disabled gold zoom`)\r\n     */\r\n    registerClassAttr(value) {\r\n        this._initialClassValues = value.trim().split(/\\s+/g);\r\n        this._hasInitialValues = true;\r\n    }\r\n    /**\r\n     * Appends all styling-related expressions to the provided attrs array.\r\n     *\r\n     * @param attrs an existing array where each of the styling expressions\r\n     * will be inserted into.\r\n     */\r\n    populateInitialStylingAttrs(attrs) {\r\n        // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]\r\n        if (this._initialClassValues.length) {\r\n            attrs.push(literal(1 /* Classes */));\r\n            for (let i = 0; i < this._initialClassValues.length; i++) {\r\n                attrs.push(literal(this._initialClassValues[i]));\r\n            }\r\n        }\r\n        // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]\r\n        if (this._initialStyleValues.length) {\r\n            attrs.push(literal(2 /* Styles */));\r\n            for (let i = 0; i < this._initialStyleValues.length; i += 2) {\r\n                attrs.push(literal(this._initialStyleValues[i]), literal(this._initialStyleValues[i + 1]));\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.\r\n     *\r\n     * The instruction generation code below is used for producing the AOT statement code which is\r\n     * responsible for registering initial styles (within a directive hostBindings' creation block),\r\n     * as well as any of the provided attribute values, to the directive host element.\r\n     */\r\n    assignHostAttrs(attrs, definitionMap) {\r\n        if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {\r\n            this.populateInitialStylingAttrs(attrs);\r\n            definitionMap.set('hostAttrs', literalArr(attrs));\r\n        }\r\n    }\r\n    /**\r\n     * Builds an instruction with all the expressions and parameters for `classMap`.\r\n     *\r\n     * The instruction data will contain all expressions for `classMap` to function\r\n     * which includes the `[class]` expression params.\r\n     */\r\n    buildClassMapInstruction(valueConverter) {\r\n        if (this._classMapInput) {\r\n            return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Builds an instruction with all the expressions and parameters for `styleMap`.\r\n     *\r\n     * The instruction data will contain all expressions for `styleMap` to function\r\n     * which includes the `[style]` expression params.\r\n     */\r\n    buildStyleMapInstruction(valueConverter) {\r\n        if (this._styleMapInput) {\r\n            return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);\r\n        }\r\n        return null;\r\n    }\r\n    _buildMapBasedInstruction(valueConverter, isClassBased, stylingInput) {\r\n        // each styling binding value is stored in the LView\r\n        // map-based bindings allocate two slots: one for the\r\n        // previous binding value and another for the previous\r\n        // className or style attribute value.\r\n        let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\r\n        // these values must be outside of the update block so that they can\r\n        // be evaluated (the AST visit call) during creation time so that any\r\n        // pipes can be picked up in time before the template is built\r\n        const mapValue = stylingInput.value.visit(valueConverter);\r\n        let reference;\r\n        if (mapValue instanceof Interpolation) {\r\n            totalBindingSlotsRequired += mapValue.expressions.length;\r\n            reference = isClassBased ? getClassMapInterpolationExpression(mapValue) :\r\n                getStyleMapInterpolationExpression(mapValue);\r\n        }\r\n        else {\r\n            reference = isClassBased ? Identifiers.classMap : Identifiers.styleMap;\r\n        }\r\n        return {\r\n            reference,\r\n            calls: [{\r\n                    supportsInterpolation: true,\r\n                    sourceSpan: stylingInput.sourceSpan,\r\n                    allocateBindingSlots: totalBindingSlotsRequired,\r\n                    params: (convertFn) => {\r\n                        const convertResult = convertFn(mapValue);\r\n                        const params = Array.isArray(convertResult) ? convertResult : [convertResult];\r\n                        return params;\r\n                    }\r\n                }]\r\n        };\r\n    }\r\n    _buildSingleInputs(reference, inputs, valueConverter, getInterpolationExpressionFn, isClassBased) {\r\n        const instructions = [];\r\n        inputs.forEach(input => {\r\n            const previousInstruction = instructions[instructions.length - 1];\r\n            const value = input.value.visit(valueConverter);\r\n            let referenceForCall = reference;\r\n            // each styling binding value is stored in the LView\r\n            // but there are two values stored for each binding:\r\n            //   1) the value itself\r\n            //   2) an intermediate value (concatenation of style up to this point).\r\n            //      We need to store the intermediate value so that we don't allocate\r\n            //      the strings on each CD.\r\n            let totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\r\n            if (value instanceof Interpolation) {\r\n                totalBindingSlotsRequired += value.expressions.length;\r\n                if (getInterpolationExpressionFn) {\r\n                    referenceForCall = getInterpolationExpressionFn(value);\r\n                }\r\n            }\r\n            const call = {\r\n                sourceSpan: input.sourceSpan,\r\n                allocateBindingSlots: totalBindingSlotsRequired,\r\n                supportsInterpolation: !!getInterpolationExpressionFn,\r\n                params: (convertFn) => {\r\n                    // params => stylingProp(propName, value, suffix)\r\n                    const params = [];\r\n                    params.push(literal(input.name));\r\n                    const convertResult = convertFn(value);\r\n                    if (Array.isArray(convertResult)) {\r\n                        params.push(...convertResult);\r\n                    }\r\n                    else {\r\n                        params.push(convertResult);\r\n                    }\r\n                    // [style.prop] bindings may use suffix values (e.g. px, em, etc...), therefore,\r\n                    // if that is detected then we need to pass that in as an optional param.\r\n                    if (!isClassBased && input.suffix !== null) {\r\n                        params.push(literal(input.suffix));\r\n                    }\r\n                    return params;\r\n                }\r\n            };\r\n            // If we ended up generating a call to the same instruction as the previous styling property\r\n            // we can chain the calls together safely to save some bytes, otherwise we have to generate\r\n            // a separate instruction call. This is primarily a concern with interpolation instructions\r\n            // where we may start off with one `reference`, but end up using another based on the\r\n            // number of interpolations.\r\n            if (previousInstruction && previousInstruction.reference === referenceForCall) {\r\n                previousInstruction.calls.push(call);\r\n            }\r\n            else {\r\n                instructions.push({ reference: referenceForCall, calls: [call] });\r\n            }\r\n        });\r\n        return instructions;\r\n    }\r\n    _buildClassInputs(valueConverter) {\r\n        if (this._singleClassInputs) {\r\n            return this._buildSingleInputs(Identifiers.classProp, this._singleClassInputs, valueConverter, null, true);\r\n        }\r\n        return [];\r\n    }\r\n    _buildStyleInputs(valueConverter) {\r\n        if (this._singleStyleInputs) {\r\n            return this._buildSingleInputs(Identifiers.styleProp, this._singleStyleInputs, valueConverter, getStylePropInterpolationExpression, false);\r\n        }\r\n        return [];\r\n    }\r\n    /**\r\n     * Constructs all instructions which contain the expressions that will be placed\r\n     * into the update block of a template function or a directive hostBindings function.\r\n     */\r\n    buildUpdateLevelInstructions(valueConverter) {\r\n        const instructions = [];\r\n        if (this.hasBindings) {\r\n            const styleMapInstruction = this.buildStyleMapInstruction(valueConverter);\r\n            if (styleMapInstruction) {\r\n                instructions.push(styleMapInstruction);\r\n            }\r\n            const classMapInstruction = this.buildClassMapInstruction(valueConverter);\r\n            if (classMapInstruction) {\r\n                instructions.push(classMapInstruction);\r\n            }\r\n            instructions.push(...this._buildStyleInputs(valueConverter));\r\n            instructions.push(...this._buildClassInputs(valueConverter));\r\n        }\r\n        return instructions;\r\n    }\r\n}\r\nfunction registerIntoMap(map, key) {\r\n    if (!map.has(key)) {\r\n        map.set(key, map.size);\r\n    }\r\n}\r\nfunction parseProperty(name) {\r\n    let hasOverrideFlag = false;\r\n    const overrideIndex = name.indexOf(IMPORTANT_FLAG);\r\n    if (overrideIndex !== -1) {\r\n        name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';\r\n        hasOverrideFlag = true;\r\n    }\r\n    let suffix = null;\r\n    let property = name;\r\n    const unitIndex = name.lastIndexOf('.');\r\n    if (unitIndex > 0) {\r\n        suffix = name.substr(unitIndex + 1);\r\n        property = name.substring(0, unitIndex);\r\n    }\r\n    return { property, suffix, hasOverrideFlag };\r\n}\r\n/**\r\n * Gets the instruction to generate for an interpolated class map.\r\n * @param interpolation An Interpolation AST\r\n */\r\nfunction getClassMapInterpolationExpression(interpolation) {\r\n    switch (getInterpolationArgsLength(interpolation)) {\r\n        case 1:\r\n            return Identifiers.classMap;\r\n        case 3:\r\n            return Identifiers.classMapInterpolate1;\r\n        case 5:\r\n            return Identifiers.classMapInterpolate2;\r\n        case 7:\r\n            return Identifiers.classMapInterpolate3;\r\n        case 9:\r\n            return Identifiers.classMapInterpolate4;\r\n        case 11:\r\n            return Identifiers.classMapInterpolate5;\r\n        case 13:\r\n            return Identifiers.classMapInterpolate6;\r\n        case 15:\r\n            return Identifiers.classMapInterpolate7;\r\n        case 17:\r\n            return Identifiers.classMapInterpolate8;\r\n        default:\r\n            return Identifiers.classMapInterpolateV;\r\n    }\r\n}\r\n/**\r\n * Gets the instruction to generate for an interpolated style map.\r\n * @param interpolation An Interpolation AST\r\n */\r\nfunction getStyleMapInterpolationExpression(interpolation) {\r\n    switch (getInterpolationArgsLength(interpolation)) {\r\n        case 1:\r\n            return Identifiers.styleMap;\r\n        case 3:\r\n            return Identifiers.styleMapInterpolate1;\r\n        case 5:\r\n            return Identifiers.styleMapInterpolate2;\r\n        case 7:\r\n            return Identifiers.styleMapInterpolate3;\r\n        case 9:\r\n            return Identifiers.styleMapInterpolate4;\r\n        case 11:\r\n            return Identifiers.styleMapInterpolate5;\r\n        case 13:\r\n            return Identifiers.styleMapInterpolate6;\r\n        case 15:\r\n            return Identifiers.styleMapInterpolate7;\r\n        case 17:\r\n            return Identifiers.styleMapInterpolate8;\r\n        default:\r\n            return Identifiers.styleMapInterpolateV;\r\n    }\r\n}\r\n/**\r\n * Gets the instruction to generate for an interpolated style prop.\r\n * @param interpolation An Interpolation AST\r\n */\r\nfunction getStylePropInterpolationExpression(interpolation) {\r\n    switch (getInterpolationArgsLength(interpolation)) {\r\n        case 1:\r\n            return Identifiers.styleProp;\r\n        case 3:\r\n            return Identifiers.stylePropInterpolate1;\r\n        case 5:\r\n            return Identifiers.stylePropInterpolate2;\r\n        case 7:\r\n            return Identifiers.stylePropInterpolate3;\r\n        case 9:\r\n            return Identifiers.stylePropInterpolate4;\r\n        case 11:\r\n            return Identifiers.stylePropInterpolate5;\r\n        case 13:\r\n            return Identifiers.stylePropInterpolate6;\r\n        case 15:\r\n            return Identifiers.stylePropInterpolate7;\r\n        case 17:\r\n            return Identifiers.stylePropInterpolate8;\r\n        default:\r\n            return Identifiers.stylePropInterpolateV;\r\n    }\r\n}\r\n/**\r\n * Checks whether property name is a custom CSS property.\r\n * See: https://www.w3.org/TR/css-variables-1\r\n */\r\nfunction isCssCustomProperty(name) {\r\n    return name.startsWith('--');\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nvar TokenType$1;\r\n(function (TokenType) {\r\n    TokenType[TokenType[\"Character\"] = 0] = \"Character\";\r\n    TokenType[TokenType[\"Identifier\"] = 1] = \"Identifier\";\r\n    TokenType[TokenType[\"PrivateIdentifier\"] = 2] = \"PrivateIdentifier\";\r\n    TokenType[TokenType[\"Keyword\"] = 3] = \"Keyword\";\r\n    TokenType[TokenType[\"String\"] = 4] = \"String\";\r\n    TokenType[TokenType[\"Operator\"] = 5] = \"Operator\";\r\n    TokenType[TokenType[\"Number\"] = 6] = \"Number\";\r\n    TokenType[TokenType[\"Error\"] = 7] = \"Error\";\r\n})(TokenType$1 || (TokenType$1 = {}));\r\nconst KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\r\nclass Lexer {\r\n    tokenize(text) {\r\n        const scanner = new _Scanner(text);\r\n        const tokens = [];\r\n        let token = scanner.scanToken();\r\n        while (token != null) {\r\n            tokens.push(token);\r\n            token = scanner.scanToken();\r\n        }\r\n        return tokens;\r\n    }\r\n}\r\nclass Token$1 {\r\n    constructor(index, end, type, numValue, strValue) {\r\n        this.index = index;\r\n        this.end = end;\r\n        this.type = type;\r\n        this.numValue = numValue;\r\n        this.strValue = strValue;\r\n    }\r\n    isCharacter(code) {\r\n        return this.type == TokenType$1.Character && this.numValue == code;\r\n    }\r\n    isNumber() {\r\n        return this.type == TokenType$1.Number;\r\n    }\r\n    isString() {\r\n        return this.type == TokenType$1.String;\r\n    }\r\n    isOperator(operator) {\r\n        return this.type == TokenType$1.Operator && this.strValue == operator;\r\n    }\r\n    isIdentifier() {\r\n        return this.type == TokenType$1.Identifier;\r\n    }\r\n    isPrivateIdentifier() {\r\n        return this.type == TokenType$1.PrivateIdentifier;\r\n    }\r\n    isKeyword() {\r\n        return this.type == TokenType$1.Keyword;\r\n    }\r\n    isKeywordLet() {\r\n        return this.type == TokenType$1.Keyword && this.strValue == 'let';\r\n    }\r\n    isKeywordAs() {\r\n        return this.type == TokenType$1.Keyword && this.strValue == 'as';\r\n    }\r\n    isKeywordNull() {\r\n        return this.type == TokenType$1.Keyword && this.strValue == 'null';\r\n    }\r\n    isKeywordUndefined() {\r\n        return this.type == TokenType$1.Keyword && this.strValue == 'undefined';\r\n    }\r\n    isKeywordTrue() {\r\n        return this.type == TokenType$1.Keyword && this.strValue == 'true';\r\n    }\r\n    isKeywordFalse() {\r\n        return this.type == TokenType$1.Keyword && this.strValue == 'false';\r\n    }\r\n    isKeywordThis() {\r\n        return this.type == TokenType$1.Keyword && this.strValue == 'this';\r\n    }\r\n    isError() {\r\n        return this.type == TokenType$1.Error;\r\n    }\r\n    toNumber() {\r\n        return this.type == TokenType$1.Number ? this.numValue : -1;\r\n    }\r\n    toString() {\r\n        switch (this.type) {\r\n            case TokenType$1.Character:\r\n            case TokenType$1.Identifier:\r\n            case TokenType$1.Keyword:\r\n            case TokenType$1.Operator:\r\n            case TokenType$1.PrivateIdentifier:\r\n            case TokenType$1.String:\r\n            case TokenType$1.Error:\r\n                return this.strValue;\r\n            case TokenType$1.Number:\r\n                return this.numValue.toString();\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n}\r\nfunction newCharacterToken(index, end, code) {\r\n    return new Token$1(index, end, TokenType$1.Character, code, String.fromCharCode(code));\r\n}\r\nfunction newIdentifierToken(index, end, text) {\r\n    return new Token$1(index, end, TokenType$1.Identifier, 0, text);\r\n}\r\nfunction newPrivateIdentifierToken(index, end, text) {\r\n    return new Token$1(index, end, TokenType$1.PrivateIdentifier, 0, text);\r\n}\r\nfunction newKeywordToken(index, end, text) {\r\n    return new Token$1(index, end, TokenType$1.Keyword, 0, text);\r\n}\r\nfunction newOperatorToken(index, end, text) {\r\n    return new Token$1(index, end, TokenType$1.Operator, 0, text);\r\n}\r\nfunction newStringToken(index, end, text) {\r\n    return new Token$1(index, end, TokenType$1.String, 0, text);\r\n}\r\nfunction newNumberToken(index, end, n) {\r\n    return new Token$1(index, end, TokenType$1.Number, n, '');\r\n}\r\nfunction newErrorToken(index, end, message) {\r\n    return new Token$1(index, end, TokenType$1.Error, 0, message);\r\n}\r\nconst EOF = new Token$1(-1, -1, TokenType$1.Character, 0, '');\r\nclass _Scanner {\r\n    constructor(input) {\r\n        this.input = input;\r\n        this.peek = 0;\r\n        this.index = -1;\r\n        this.length = input.length;\r\n        this.advance();\r\n    }\r\n    advance() {\r\n        this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);\r\n    }\r\n    scanToken() {\r\n        const input = this.input, length = this.length;\r\n        let peek = this.peek, index = this.index;\r\n        // Skip whitespace.\r\n        while (peek <= $SPACE) {\r\n            if (++index >= length) {\r\n                peek = $EOF;\r\n                break;\r\n            }\r\n            else {\r\n                peek = input.charCodeAt(index);\r\n            }\r\n        }\r\n        this.peek = peek;\r\n        this.index = index;\r\n        if (index >= length) {\r\n            return null;\r\n        }\r\n        // Handle identifiers and numbers.\r\n        if (isIdentifierStart(peek))\r\n            return this.scanIdentifier();\r\n        if (isDigit(peek))\r\n            return this.scanNumber(index);\r\n        const start = index;\r\n        switch (peek) {\r\n            case $PERIOD:\r\n                this.advance();\r\n                return isDigit(this.peek) ? this.scanNumber(start) :\r\n                    newCharacterToken(start, this.index, $PERIOD);\r\n            case $LPAREN:\r\n            case $RPAREN:\r\n            case $LBRACE:\r\n            case $RBRACE:\r\n            case $LBRACKET:\r\n            case $RBRACKET:\r\n            case $COMMA:\r\n            case $COLON:\r\n            case $SEMICOLON:\r\n                return this.scanCharacter(start, peek);\r\n            case $SQ:\r\n            case $DQ:\r\n                return this.scanString();\r\n            case $HASH:\r\n                return this.scanPrivateIdentifier();\r\n            case $PLUS:\r\n            case $MINUS:\r\n            case $STAR:\r\n            case $SLASH:\r\n            case $PERCENT:\r\n            case $CARET:\r\n                return this.scanOperator(start, String.fromCharCode(peek));\r\n            case $QUESTION:\r\n                return this.scanQuestion(start);\r\n            case $LT:\r\n            case $GT:\r\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');\r\n            case $BANG:\r\n            case $EQ:\r\n                return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');\r\n            case $AMPERSAND:\r\n                return this.scanComplexOperator(start, '&', $AMPERSAND, '&');\r\n            case $BAR:\r\n                return this.scanComplexOperator(start, '|', $BAR, '|');\r\n            case $NBSP:\r\n                while (isWhitespace(this.peek))\r\n                    this.advance();\r\n                return this.scanToken();\r\n        }\r\n        this.advance();\r\n        return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\r\n    }\r\n    scanCharacter(start, code) {\r\n        this.advance();\r\n        return newCharacterToken(start, this.index, code);\r\n    }\r\n    scanOperator(start, str) {\r\n        this.advance();\r\n        return newOperatorToken(start, this.index, str);\r\n    }\r\n    /**\r\n     * Tokenize a 2/3 char long operator\r\n     *\r\n     * @param start start index in the expression\r\n     * @param one first symbol (always part of the operator)\r\n     * @param twoCode code point for the second symbol\r\n     * @param two second symbol (part of the operator when the second code point matches)\r\n     * @param threeCode code point for the third symbol\r\n     * @param three third symbol (part of the operator when provided and matches source expression)\r\n     */\r\n    scanComplexOperator(start, one, twoCode, two, threeCode, three) {\r\n        this.advance();\r\n        let str = one;\r\n        if (this.peek == twoCode) {\r\n            this.advance();\r\n            str += two;\r\n        }\r\n        if (threeCode != null && this.peek == threeCode) {\r\n            this.advance();\r\n            str += three;\r\n        }\r\n        return newOperatorToken(start, this.index, str);\r\n    }\r\n    scanIdentifier() {\r\n        const start = this.index;\r\n        this.advance();\r\n        while (isIdentifierPart(this.peek))\r\n            this.advance();\r\n        const str = this.input.substring(start, this.index);\r\n        return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) :\r\n            newIdentifierToken(start, this.index, str);\r\n    }\r\n    /** Scans an ECMAScript private identifier. */\r\n    scanPrivateIdentifier() {\r\n        const start = this.index;\r\n        this.advance();\r\n        if (!isIdentifierStart(this.peek)) {\r\n            return this.error('Invalid character [#]', -1);\r\n        }\r\n        while (isIdentifierPart(this.peek))\r\n            this.advance();\r\n        const identifierName = this.input.substring(start, this.index);\r\n        return newPrivateIdentifierToken(start, this.index, identifierName);\r\n    }\r\n    scanNumber(start) {\r\n        let simple = (this.index === start);\r\n        this.advance(); // Skip initial digit.\r\n        while (true) {\r\n            if (isDigit(this.peek)) {\r\n                // Do nothing.\r\n            }\r\n            else if (this.peek == $PERIOD) {\r\n                simple = false;\r\n            }\r\n            else if (isExponentStart(this.peek)) {\r\n                this.advance();\r\n                if (isExponentSign(this.peek))\r\n                    this.advance();\r\n                if (!isDigit(this.peek))\r\n                    return this.error('Invalid exponent', -1);\r\n                simple = false;\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n            this.advance();\r\n        }\r\n        const str = this.input.substring(start, this.index);\r\n        const value = simple ? parseIntAutoRadix(str) : parseFloat(str);\r\n        return newNumberToken(start, this.index, value);\r\n    }\r\n    scanString() {\r\n        const start = this.index;\r\n        const quote = this.peek;\r\n        this.advance(); // Skip initial quote.\r\n        let buffer = '';\r\n        let marker = this.index;\r\n        const input = this.input;\r\n        while (this.peek != quote) {\r\n            if (this.peek == $BACKSLASH) {\r\n                buffer += input.substring(marker, this.index);\r\n                this.advance();\r\n                let unescapedCode;\r\n                // Workaround for TS2.1-introduced type strictness\r\n                this.peek = this.peek;\r\n                if (this.peek == $u) {\r\n                    // 4 character hex code for unicode character.\r\n                    const hex = input.substring(this.index + 1, this.index + 5);\r\n                    if (/^[0-9a-f]+$/i.test(hex)) {\r\n                        unescapedCode = parseInt(hex, 16);\r\n                    }\r\n                    else {\r\n                        return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\r\n                    }\r\n                    for (let i = 0; i < 5; i++) {\r\n                        this.advance();\r\n                    }\r\n                }\r\n                else {\r\n                    unescapedCode = unescape(this.peek);\r\n                    this.advance();\r\n                }\r\n                buffer += String.fromCharCode(unescapedCode);\r\n                marker = this.index;\r\n            }\r\n            else if (this.peek == $EOF) {\r\n                return this.error('Unterminated quote', 0);\r\n            }\r\n            else {\r\n                this.advance();\r\n            }\r\n        }\r\n        const last = input.substring(marker, this.index);\r\n        this.advance(); // Skip terminating quote.\r\n        return newStringToken(start, this.index, buffer + last);\r\n    }\r\n    scanQuestion(start) {\r\n        this.advance();\r\n        let str = '?';\r\n        // Either `a ?? b` or 'a?.b'.\r\n        if (this.peek === $QUESTION || this.peek === $PERIOD) {\r\n            str += this.peek === $PERIOD ? '.' : '?';\r\n            this.advance();\r\n        }\r\n        return newOperatorToken(start, this.index, str);\r\n    }\r\n    error(message, offset) {\r\n        const position = this.index + offset;\r\n        return newErrorToken(position, this.index, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\r\n    }\r\n}\r\nfunction isIdentifierStart(code) {\r\n    return ($a <= code && code <= $z) || ($A <= code && code <= $Z) ||\r\n        (code == $_) || (code == $$);\r\n}\r\nfunction isIdentifier(input) {\r\n    if (input.length == 0)\r\n        return false;\r\n    const scanner = new _Scanner(input);\r\n    if (!isIdentifierStart(scanner.peek))\r\n        return false;\r\n    scanner.advance();\r\n    while (scanner.peek !== $EOF) {\r\n        if (!isIdentifierPart(scanner.peek))\r\n            return false;\r\n        scanner.advance();\r\n    }\r\n    return true;\r\n}\r\nfunction isIdentifierPart(code) {\r\n    return isAsciiLetter(code) || isDigit(code) || (code == $_) ||\r\n        (code == $$);\r\n}\r\nfunction isExponentStart(code) {\r\n    return code == $e || code == $E;\r\n}\r\nfunction isExponentSign(code) {\r\n    return code == $MINUS || code == $PLUS;\r\n}\r\nfunction isQuote(code) {\r\n    return code === $SQ || code === $DQ || code === $BT;\r\n}\r\nfunction unescape(code) {\r\n    switch (code) {\r\n        case $n:\r\n            return $LF;\r\n        case $f:\r\n            return $FF;\r\n        case $r:\r\n            return $CR;\r\n        case $t:\r\n            return $TAB;\r\n        case $v:\r\n            return $VTAB;\r\n        default:\r\n            return code;\r\n    }\r\n}\r\nfunction parseIntAutoRadix(text) {\r\n    const result = parseInt(text);\r\n    if (isNaN(result)) {\r\n        throw new Error('Invalid integer literal when parsing ' + text);\r\n    }\r\n    return result;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass SplitInterpolation {\r\n    constructor(strings, expressions, offsets) {\r\n        this.strings = strings;\r\n        this.expressions = expressions;\r\n        this.offsets = offsets;\r\n    }\r\n}\r\nclass TemplateBindingParseResult {\r\n    constructor(templateBindings, warnings, errors) {\r\n        this.templateBindings = templateBindings;\r\n        this.warnings = warnings;\r\n        this.errors = errors;\r\n    }\r\n}\r\nclass Parser$1 {\r\n    constructor(_lexer) {\r\n        this._lexer = _lexer;\r\n        this.errors = [];\r\n        this.simpleExpressionChecker = SimpleExpressionChecker;\r\n    }\r\n    parseAction(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\r\n        this._checkNoInterpolation(input, location, interpolationConfig);\r\n        const sourceToLex = this._stripComments(input);\r\n        const tokens = this._lexer.tokenize(this._stripComments(input));\r\n        const ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length)\r\n            .parseChain();\r\n        return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\r\n    }\r\n    parseBinding(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\r\n        const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\r\n        return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\r\n    }\r\n    checkSimpleExpression(ast) {\r\n        const checker = new this.simpleExpressionChecker();\r\n        ast.visit(checker);\r\n        return checker.errors;\r\n    }\r\n    parseSimpleBinding(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\r\n        const ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\r\n        const errors = this.checkSimpleExpression(ast);\r\n        if (errors.length > 0) {\r\n            this._reportError(`Host binding expression cannot contain ${errors.join(' ')}`, input, location);\r\n        }\r\n        return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\r\n    }\r\n    _reportError(message, input, errLocation, ctxLocation) {\r\n        this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\r\n    }\r\n    _parseBindingAst(input, location, absoluteOffset, interpolationConfig) {\r\n        // Quotes expressions use 3rd-party expression language. We don't want to use\r\n        // our lexer or parser for that, so we check for that ahead of time.\r\n        const quote = this._parseQuote(input, location, absoluteOffset);\r\n        if (quote != null) {\r\n            return quote;\r\n        }\r\n        this._checkNoInterpolation(input, location, interpolationConfig);\r\n        const sourceToLex = this._stripComments(input);\r\n        const tokens = this._lexer.tokenize(sourceToLex);\r\n        return new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length)\r\n            .parseChain();\r\n    }\r\n    _parseQuote(input, location, absoluteOffset) {\r\n        if (input == null)\r\n            return null;\r\n        const prefixSeparatorIndex = input.indexOf(':');\r\n        if (prefixSeparatorIndex == -1)\r\n            return null;\r\n        const prefix = input.substring(0, prefixSeparatorIndex).trim();\r\n        if (!isIdentifier(prefix))\r\n            return null;\r\n        const uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\r\n        const span = new ParseSpan(0, input.length);\r\n        return new Quote(span, span.toAbsolute(absoluteOffset), prefix, uninterpretedExpression, location);\r\n    }\r\n    /**\r\n     * Parse microsyntax template expression and return a list of bindings or\r\n     * parsing errors in case the given expression is invalid.\r\n     *\r\n     * For example,\r\n     * ```\r\n     *   <div *ngFor=\"let item of items\">\r\n     *         ^      ^ absoluteValueOffset for `templateValue`\r\n     *         absoluteKeyOffset for `templateKey`\r\n     * ```\r\n     * contains three bindings:\r\n     * 1. ngFor -> null\r\n     * 2. item -> NgForOfContext.$implicit\r\n     * 3. ngForOf -> items\r\n     *\r\n     * This is apparent from the de-sugared template:\r\n     * ```\r\n     *   <ng-template ngFor let-item [ngForOf]=\"items\">\r\n     * ```\r\n     *\r\n     * @param templateKey name of directive, without the * prefix. For example: ngIf, ngFor\r\n     * @param templateValue RHS of the microsyntax attribute\r\n     * @param templateUrl template filename if it's external, component filename if it's inline\r\n     * @param absoluteKeyOffset start of the `templateKey`\r\n     * @param absoluteValueOffset start of the `templateValue`\r\n     */\r\n    parseTemplateBindings(templateKey, templateValue, templateUrl, absoluteKeyOffset, absoluteValueOffset) {\r\n        const tokens = this._lexer.tokenize(templateValue);\r\n        const parser = new _ParseAST(templateValue, templateUrl, absoluteValueOffset, tokens, templateValue.length, false /* parseAction */, this.errors, 0 /* relative offset */);\r\n        return parser.parseTemplateBindings({\r\n            source: templateKey,\r\n            span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length),\r\n        });\r\n    }\r\n    parseInterpolation(input, location, absoluteOffset, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\r\n        const { strings, expressions, offsets } = this.splitInterpolation(input, location, interpolationConfig);\r\n        if (expressions.length === 0)\r\n            return null;\r\n        const expressionNodes = [];\r\n        for (let i = 0; i < expressions.length; ++i) {\r\n            const expressionText = expressions[i].text;\r\n            const sourceToLex = this._stripComments(expressionText);\r\n            const tokens = this._lexer.tokenize(sourceToLex);\r\n            const ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, offsets[i] + (expressionText.length - sourceToLex.length))\r\n                .parseChain();\r\n            expressionNodes.push(ast);\r\n        }\r\n        return this.createInterpolationAst(strings.map(s => s.text), expressionNodes, input, location, absoluteOffset);\r\n    }\r\n    /**\r\n     * Similar to `parseInterpolation`, but treats the provided string as a single expression\r\n     * element that would normally appear within the interpolation prefix and suffix (`{{` and `}}`).\r\n     * This is used for parsing the switch expression in ICUs.\r\n     */\r\n    parseInterpolationExpression(expression, location, absoluteOffset) {\r\n        const sourceToLex = this._stripComments(expression);\r\n        const tokens = this._lexer.tokenize(sourceToLex);\r\n        const ast = new _ParseAST(expression, location, absoluteOffset, tokens, sourceToLex.length, \r\n        /* parseAction */ false, this.errors, 0)\r\n            .parseChain();\r\n        const strings = ['', '']; // The prefix and suffix strings are both empty\r\n        return this.createInterpolationAst(strings, [ast], expression, location, absoluteOffset);\r\n    }\r\n    createInterpolationAst(strings, expressions, input, location, absoluteOffset) {\r\n        const span = new ParseSpan(0, input.length);\r\n        const interpolation = new Interpolation(span, span.toAbsolute(absoluteOffset), strings, expressions);\r\n        return new ASTWithSource(interpolation, input, location, absoluteOffset, this.errors);\r\n    }\r\n    /**\r\n     * Splits a string of text into \"raw\" text segments and expressions present in interpolations in\r\n     * the string.\r\n     * Returns `null` if there are no interpolations, otherwise a\r\n     * `SplitInterpolation` with splits that look like\r\n     *   <raw text> <expression> <raw text> ... <raw text> <expression> <raw text>\r\n     */\r\n    splitInterpolation(input, location, interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\r\n        const strings = [];\r\n        const expressions = [];\r\n        const offsets = [];\r\n        let i = 0;\r\n        let atInterpolation = false;\r\n        let extendLastString = false;\r\n        let { start: interpStart, end: interpEnd } = interpolationConfig;\r\n        while (i < input.length) {\r\n            if (!atInterpolation) {\r\n                // parse until starting {{\r\n                const start = i;\r\n                i = input.indexOf(interpStart, i);\r\n                if (i === -1) {\r\n                    i = input.length;\r\n                }\r\n                const text = input.substring(start, i);\r\n                strings.push({ text, start, end: i });\r\n                atInterpolation = true;\r\n            }\r\n            else {\r\n                // parse from starting {{ to ending }} while ignoring content inside quotes.\r\n                const fullStart = i;\r\n                const exprStart = fullStart + interpStart.length;\r\n                const exprEnd = this._getInterpolationEndIndex(input, interpEnd, exprStart);\r\n                if (exprEnd === -1) {\r\n                    // Could not find the end of the interpolation; do not parse an expression.\r\n                    // Instead we should extend the content on the last raw string.\r\n                    atInterpolation = false;\r\n                    extendLastString = true;\r\n                    break;\r\n                }\r\n                const fullEnd = exprEnd + interpEnd.length;\r\n                const text = input.substring(exprStart, exprEnd);\r\n                if (text.trim().length === 0) {\r\n                    this._reportError('Blank expressions are not allowed in interpolated strings', input, `at column ${i} in`, location);\r\n                }\r\n                expressions.push({ text, start: fullStart, end: fullEnd });\r\n                offsets.push(exprStart);\r\n                i = fullEnd;\r\n                atInterpolation = false;\r\n            }\r\n        }\r\n        if (!atInterpolation) {\r\n            // If we are now at a text section, add the remaining content as a raw string.\r\n            if (extendLastString) {\r\n                const piece = strings[strings.length - 1];\r\n                piece.text += input.substring(i);\r\n                piece.end = input.length;\r\n            }\r\n            else {\r\n                strings.push({ text: input.substring(i), start: i, end: input.length });\r\n            }\r\n        }\r\n        return new SplitInterpolation(strings, expressions, offsets);\r\n    }\r\n    wrapLiteralPrimitive(input, location, absoluteOffset) {\r\n        const span = new ParseSpan(0, input == null ? 0 : input.length);\r\n        return new ASTWithSource(new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location, absoluteOffset, this.errors);\r\n    }\r\n    _stripComments(input) {\r\n        const i = this._commentStart(input);\r\n        return i != null ? input.substring(0, i).trim() : input;\r\n    }\r\n    _commentStart(input) {\r\n        let outerQuote = null;\r\n        for (let i = 0; i < input.length - 1; i++) {\r\n            const char = input.charCodeAt(i);\r\n            const nextChar = input.charCodeAt(i + 1);\r\n            if (char === $SLASH && nextChar == $SLASH && outerQuote == null)\r\n                return i;\r\n            if (outerQuote === char) {\r\n                outerQuote = null;\r\n            }\r\n            else if (outerQuote == null && isQuote(char)) {\r\n                outerQuote = char;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    _checkNoInterpolation(input, location, { start, end }) {\r\n        let startIndex = -1;\r\n        let endIndex = -1;\r\n        for (const charIndex of this._forEachUnquotedChar(input, 0)) {\r\n            if (startIndex === -1) {\r\n                if (input.startsWith(start)) {\r\n                    startIndex = charIndex;\r\n                }\r\n            }\r\n            else {\r\n                endIndex = this._getInterpolationEndIndex(input, end, charIndex);\r\n                if (endIndex > -1) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (startIndex > -1 && endIndex > -1) {\r\n            this._reportError(`Got interpolation (${start}${end}) where expression was expected`, input, `at column ${startIndex} in`, location);\r\n        }\r\n    }\r\n    /**\r\n     * Finds the index of the end of an interpolation expression\r\n     * while ignoring comments and quoted content.\r\n     */\r\n    _getInterpolationEndIndex(input, expressionEnd, start) {\r\n        for (const charIndex of this._forEachUnquotedChar(input, start)) {\r\n            if (input.startsWith(expressionEnd, charIndex)) {\r\n                return charIndex;\r\n            }\r\n            // Nothing else in the expression matters after we've\r\n            // hit a comment so look directly for the end token.\r\n            if (input.startsWith('//', charIndex)) {\r\n                return input.indexOf(expressionEnd, charIndex);\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    /**\r\n     * Generator used to iterate over the character indexes of a string that are outside of quotes.\r\n     * @param input String to loop through.\r\n     * @param start Index within the string at which to start.\r\n     */\r\n    *_forEachUnquotedChar(input, start) {\r\n        let currentQuote = null;\r\n        let escapeCount = 0;\r\n        for (let i = start; i < input.length; i++) {\r\n            const char = input[i];\r\n            // Skip the characters inside quotes. Note that we only care about the outer-most\r\n            // quotes matching up and we need to account for escape characters.\r\n            if (isQuote(input.charCodeAt(i)) && (currentQuote === null || currentQuote === char) &&\r\n                escapeCount % 2 === 0) {\r\n                currentQuote = currentQuote === null ? char : null;\r\n            }\r\n            else if (currentQuote === null) {\r\n                yield i;\r\n            }\r\n            escapeCount = char === '\\\\' ? escapeCount + 1 : 0;\r\n        }\r\n    }\r\n}\r\nclass IvyParser extends Parser$1 {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.simpleExpressionChecker = IvySimpleExpressionChecker;\r\n    }\r\n}\r\n/** Describes a stateful context an expression parser is in. */\r\nvar ParseContextFlags;\r\n(function (ParseContextFlags) {\r\n    ParseContextFlags[ParseContextFlags[\"None\"] = 0] = \"None\";\r\n    /**\r\n     * A Writable context is one in which a value may be written to an lvalue.\r\n     * For example, after we see a property access, we may expect a write to the\r\n     * property via the \"=\" operator.\r\n     *   prop\r\n     *        ^ possible \"=\" after\r\n     */\r\n    ParseContextFlags[ParseContextFlags[\"Writable\"] = 1] = \"Writable\";\r\n})(ParseContextFlags || (ParseContextFlags = {}));\r\nclass _ParseAST {\r\n    constructor(input, location, absoluteOffset, tokens, inputLength, parseAction, errors, offset) {\r\n        this.input = input;\r\n        this.location = location;\r\n        this.absoluteOffset = absoluteOffset;\r\n        this.tokens = tokens;\r\n        this.inputLength = inputLength;\r\n        this.parseAction = parseAction;\r\n        this.errors = errors;\r\n        this.offset = offset;\r\n        this.rparensExpected = 0;\r\n        this.rbracketsExpected = 0;\r\n        this.rbracesExpected = 0;\r\n        this.context = ParseContextFlags.None;\r\n        // Cache of expression start and input indeces to the absolute source span they map to, used to\r\n        // prevent creating superfluous source spans in `sourceSpan`.\r\n        // A serial of the expression start and input index is used for mapping because both are stateful\r\n        // and may change for subsequent expressions visited by the parser.\r\n        this.sourceSpanCache = new Map();\r\n        this.index = 0;\r\n    }\r\n    peek(offset) {\r\n        const i = this.index + offset;\r\n        return i < this.tokens.length ? this.tokens[i] : EOF;\r\n    }\r\n    get next() {\r\n        return this.peek(0);\r\n    }\r\n    /** Whether all the parser input has been processed. */\r\n    get atEOF() {\r\n        return this.index >= this.tokens.length;\r\n    }\r\n    /**\r\n     * Index of the next token to be processed, or the end of the last token if all have been\r\n     * processed.\r\n     */\r\n    get inputIndex() {\r\n        return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;\r\n    }\r\n    /**\r\n     * End index of the last processed token, or the start of the first token if none have been\r\n     * processed.\r\n     */\r\n    get currentEndIndex() {\r\n        if (this.index > 0) {\r\n            const curToken = this.peek(-1);\r\n            return curToken.end + this.offset;\r\n        }\r\n        // No tokens have been processed yet; return the next token's start or the length of the input\r\n        // if there is no token.\r\n        if (this.tokens.length === 0) {\r\n            return this.inputLength + this.offset;\r\n        }\r\n        return this.next.index + this.offset;\r\n    }\r\n    /**\r\n     * Returns the absolute offset of the start of the current token.\r\n     */\r\n    get currentAbsoluteOffset() {\r\n        return this.absoluteOffset + this.inputIndex;\r\n    }\r\n    /**\r\n     * Retrieve a `ParseSpan` from `start` to the current position (or to `artificialEndIndex` if\r\n     * provided).\r\n     *\r\n     * @param start Position from which the `ParseSpan` will start.\r\n     * @param artificialEndIndex Optional ending index to be used if provided (and if greater than the\r\n     *     natural ending index)\r\n     */\r\n    span(start, artificialEndIndex) {\r\n        let endIndex = this.currentEndIndex;\r\n        if (artificialEndIndex !== undefined && artificialEndIndex > this.currentEndIndex) {\r\n            endIndex = artificialEndIndex;\r\n        }\r\n        // In some unusual parsing scenarios (like when certain tokens are missing and an `EmptyExpr` is\r\n        // being created), the current token may already be advanced beyond the `currentEndIndex`. This\r\n        // appears to be a deep-seated parser bug.\r\n        //\r\n        // As a workaround for now, swap the start and end indices to ensure a valid `ParseSpan`.\r\n        // TODO(alxhub): fix the bug upstream in the parser state, and remove this workaround.\r\n        if (start > endIndex) {\r\n            const tmp = endIndex;\r\n            endIndex = start;\r\n            start = tmp;\r\n        }\r\n        return new ParseSpan(start, endIndex);\r\n    }\r\n    sourceSpan(start, artificialEndIndex) {\r\n        const serial = `${start}@${this.inputIndex}:${artificialEndIndex}`;\r\n        if (!this.sourceSpanCache.has(serial)) {\r\n            this.sourceSpanCache.set(serial, this.span(start, artificialEndIndex).toAbsolute(this.absoluteOffset));\r\n        }\r\n        return this.sourceSpanCache.get(serial);\r\n    }\r\n    advance() {\r\n        this.index++;\r\n    }\r\n    /**\r\n     * Executes a callback in the provided context.\r\n     */\r\n    withContext(context, cb) {\r\n        this.context |= context;\r\n        const ret = cb();\r\n        this.context ^= context;\r\n        return ret;\r\n    }\r\n    consumeOptionalCharacter(code) {\r\n        if (this.next.isCharacter(code)) {\r\n            this.advance();\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    peekKeywordLet() {\r\n        return this.next.isKeywordLet();\r\n    }\r\n    peekKeywordAs() {\r\n        return this.next.isKeywordAs();\r\n    }\r\n    /**\r\n     * Consumes an expected character, otherwise emits an error about the missing expected character\r\n     * and skips over the token stream until reaching a recoverable point.\r\n     *\r\n     * See `this.error` and `this.skip` for more details.\r\n     */\r\n    expectCharacter(code) {\r\n        if (this.consumeOptionalCharacter(code))\r\n            return;\r\n        this.error(`Missing expected ${String.fromCharCode(code)}`);\r\n    }\r\n    consumeOptionalOperator(op) {\r\n        if (this.next.isOperator(op)) {\r\n            this.advance();\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    expectOperator(operator) {\r\n        if (this.consumeOptionalOperator(operator))\r\n            return;\r\n        this.error(`Missing expected operator ${operator}`);\r\n    }\r\n    prettyPrintToken(tok) {\r\n        return tok === EOF ? 'end of input' : `token ${tok}`;\r\n    }\r\n    expectIdentifierOrKeyword() {\r\n        const n = this.next;\r\n        if (!n.isIdentifier() && !n.isKeyword()) {\r\n            if (n.isPrivateIdentifier()) {\r\n                this._reportErrorForPrivateIdentifier(n, 'expected identifier or keyword');\r\n            }\r\n            else {\r\n                this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier or keyword`);\r\n            }\r\n            return null;\r\n        }\r\n        this.advance();\r\n        return n.toString();\r\n    }\r\n    expectIdentifierOrKeywordOrString() {\r\n        const n = this.next;\r\n        if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\r\n            if (n.isPrivateIdentifier()) {\r\n                this._reportErrorForPrivateIdentifier(n, 'expected identifier, keyword or string');\r\n            }\r\n            else {\r\n                this.error(`Unexpected ${this.prettyPrintToken(n)}, expected identifier, keyword, or string`);\r\n            }\r\n            return '';\r\n        }\r\n        this.advance();\r\n        return n.toString();\r\n    }\r\n    parseChain() {\r\n        const exprs = [];\r\n        const start = this.inputIndex;\r\n        while (this.index < this.tokens.length) {\r\n            const expr = this.parsePipe();\r\n            exprs.push(expr);\r\n            if (this.consumeOptionalCharacter($SEMICOLON)) {\r\n                if (!this.parseAction) {\r\n                    this.error('Binding expression cannot contain chained expression');\r\n                }\r\n                while (this.consumeOptionalCharacter($SEMICOLON)) {\r\n                } // read all semicolons\r\n            }\r\n            else if (this.index < this.tokens.length) {\r\n                this.error(`Unexpected token '${this.next}'`);\r\n            }\r\n        }\r\n        if (exprs.length == 0) {\r\n            // We have no expressions so create an empty expression that spans the entire input length\r\n            const artificialStart = this.offset;\r\n            const artificialEnd = this.offset + this.inputLength;\r\n            return new EmptyExpr(this.span(artificialStart, artificialEnd), this.sourceSpan(artificialStart, artificialEnd));\r\n        }\r\n        if (exprs.length == 1)\r\n            return exprs[0];\r\n        return new Chain(this.span(start), this.sourceSpan(start), exprs);\r\n    }\r\n    parsePipe() {\r\n        const start = this.inputIndex;\r\n        let result = this.parseExpression();\r\n        if (this.consumeOptionalOperator('|')) {\r\n            if (this.parseAction) {\r\n                this.error('Cannot have a pipe in an action expression');\r\n            }\r\n            do {\r\n                const nameStart = this.inputIndex;\r\n                let nameId = this.expectIdentifierOrKeyword();\r\n                let nameSpan;\r\n                let fullSpanEnd = undefined;\r\n                if (nameId !== null) {\r\n                    nameSpan = this.sourceSpan(nameStart);\r\n                }\r\n                else {\r\n                    // No valid identifier was found, so we'll assume an empty pipe name ('').\r\n                    nameId = '';\r\n                    // However, there may have been whitespace present between the pipe character and the next\r\n                    // token in the sequence (or the end of input). We want to track this whitespace so that\r\n                    // the `BindingPipe` we produce covers not just the pipe character, but any trailing\r\n                    // whitespace beyond it. Another way of thinking about this is that the zero-length name\r\n                    // is assumed to be at the end of any whitespace beyond the pipe character.\r\n                    //\r\n                    // Therefore, we push the end of the `ParseSpan` for this pipe all the way up to the\r\n                    // beginning of the next token, or until the end of input if the next token is EOF.\r\n                    fullSpanEnd = this.next.index !== -1 ? this.next.index : this.inputLength + this.offset;\r\n                    // The `nameSpan` for an empty pipe name is zero-length at the end of any whitespace\r\n                    // beyond the pipe character.\r\n                    nameSpan = new ParseSpan(fullSpanEnd, fullSpanEnd).toAbsolute(this.absoluteOffset);\r\n                }\r\n                const args = [];\r\n                while (this.consumeOptionalCharacter($COLON)) {\r\n                    args.push(this.parseExpression());\r\n                    // If there are additional expressions beyond the name, then the artificial end for the\r\n                    // name is no longer relevant.\r\n                }\r\n                result = new BindingPipe(this.span(start), this.sourceSpan(start, fullSpanEnd), result, nameId, args, nameSpan);\r\n            } while (this.consumeOptionalOperator('|'));\r\n        }\r\n        return result;\r\n    }\r\n    parseExpression() {\r\n        return this.parseConditional();\r\n    }\r\n    parseConditional() {\r\n        const start = this.inputIndex;\r\n        const result = this.parseLogicalOr();\r\n        if (this.consumeOptionalOperator('?')) {\r\n            const yes = this.parsePipe();\r\n            let no;\r\n            if (!this.consumeOptionalCharacter($COLON)) {\r\n                const end = this.inputIndex;\r\n                const expression = this.input.substring(start, end);\r\n                this.error(`Conditional expression ${expression} requires all 3 expressions`);\r\n                no = new EmptyExpr(this.span(start), this.sourceSpan(start));\r\n            }\r\n            else {\r\n                no = this.parsePipe();\r\n            }\r\n            return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);\r\n        }\r\n        else {\r\n            return result;\r\n        }\r\n    }\r\n    parseLogicalOr() {\r\n        // '||'\r\n        const start = this.inputIndex;\r\n        let result = this.parseLogicalAnd();\r\n        while (this.consumeOptionalOperator('||')) {\r\n            const right = this.parseLogicalAnd();\r\n            result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);\r\n        }\r\n        return result;\r\n    }\r\n    parseLogicalAnd() {\r\n        // '&&'\r\n        const start = this.inputIndex;\r\n        let result = this.parseNullishCoalescing();\r\n        while (this.consumeOptionalOperator('&&')) {\r\n            const right = this.parseNullishCoalescing();\r\n            result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);\r\n        }\r\n        return result;\r\n    }\r\n    parseNullishCoalescing() {\r\n        // '??'\r\n        const start = this.inputIndex;\r\n        let result = this.parseEquality();\r\n        while (this.consumeOptionalOperator('??')) {\r\n            const right = this.parseEquality();\r\n            result = new Binary(this.span(start), this.sourceSpan(start), '??', result, right);\r\n        }\r\n        return result;\r\n    }\r\n    parseEquality() {\r\n        // '==','!=','===','!=='\r\n        const start = this.inputIndex;\r\n        let result = this.parseRelational();\r\n        while (this.next.type == TokenType$1.Operator) {\r\n            const operator = this.next.strValue;\r\n            switch (operator) {\r\n                case '==':\r\n                case '===':\r\n                case '!=':\r\n                case '!==':\r\n                    this.advance();\r\n                    const right = this.parseRelational();\r\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\r\n                    continue;\r\n            }\r\n            break;\r\n        }\r\n        return result;\r\n    }\r\n    parseRelational() {\r\n        // '<', '>', '<=', '>='\r\n        const start = this.inputIndex;\r\n        let result = this.parseAdditive();\r\n        while (this.next.type == TokenType$1.Operator) {\r\n            const operator = this.next.strValue;\r\n            switch (operator) {\r\n                case '<':\r\n                case '>':\r\n                case '<=':\r\n                case '>=':\r\n                    this.advance();\r\n                    const right = this.parseAdditive();\r\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\r\n                    continue;\r\n            }\r\n            break;\r\n        }\r\n        return result;\r\n    }\r\n    parseAdditive() {\r\n        // '+', '-'\r\n        const start = this.inputIndex;\r\n        let result = this.parseMultiplicative();\r\n        while (this.next.type == TokenType$1.Operator) {\r\n            const operator = this.next.strValue;\r\n            switch (operator) {\r\n                case '+':\r\n                case '-':\r\n                    this.advance();\r\n                    let right = this.parseMultiplicative();\r\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\r\n                    continue;\r\n            }\r\n            break;\r\n        }\r\n        return result;\r\n    }\r\n    parseMultiplicative() {\r\n        // '*', '%', '/'\r\n        const start = this.inputIndex;\r\n        let result = this.parsePrefix();\r\n        while (this.next.type == TokenType$1.Operator) {\r\n            const operator = this.next.strValue;\r\n            switch (operator) {\r\n                case '*':\r\n                case '%':\r\n                case '/':\r\n                    this.advance();\r\n                    let right = this.parsePrefix();\r\n                    result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\r\n                    continue;\r\n            }\r\n            break;\r\n        }\r\n        return result;\r\n    }\r\n    parsePrefix() {\r\n        if (this.next.type == TokenType$1.Operator) {\r\n            const start = this.inputIndex;\r\n            const operator = this.next.strValue;\r\n            let result;\r\n            switch (operator) {\r\n                case '+':\r\n                    this.advance();\r\n                    result = this.parsePrefix();\r\n                    return Unary.createPlus(this.span(start), this.sourceSpan(start), result);\r\n                case '-':\r\n                    this.advance();\r\n                    result = this.parsePrefix();\r\n                    return Unary.createMinus(this.span(start), this.sourceSpan(start), result);\r\n                case '!':\r\n                    this.advance();\r\n                    result = this.parsePrefix();\r\n                    return new PrefixNot(this.span(start), this.sourceSpan(start), result);\r\n            }\r\n        }\r\n        return this.parseCallChain();\r\n    }\r\n    parseCallChain() {\r\n        const start = this.inputIndex;\r\n        let result = this.parsePrimary();\r\n        while (true) {\r\n            if (this.consumeOptionalCharacter($PERIOD)) {\r\n                result = this.parseAccessMemberOrMethodCall(result, start, false);\r\n            }\r\n            else if (this.consumeOptionalOperator('?.')) {\r\n                result = this.consumeOptionalCharacter($LBRACKET) ?\r\n                    this.parseKeyedReadOrWrite(result, start, true) :\r\n                    this.parseAccessMemberOrMethodCall(result, start, true);\r\n            }\r\n            else if (this.consumeOptionalCharacter($LBRACKET)) {\r\n                result = this.parseKeyedReadOrWrite(result, start, false);\r\n            }\r\n            else if (this.consumeOptionalCharacter($LPAREN)) {\r\n                this.rparensExpected++;\r\n                const args = this.parseCallArguments();\r\n                this.rparensExpected--;\r\n                this.expectCharacter($RPAREN);\r\n                result = new FunctionCall(this.span(start), this.sourceSpan(start), result, args);\r\n            }\r\n            else if (this.consumeOptionalOperator('!')) {\r\n                result = new NonNullAssert(this.span(start), this.sourceSpan(start), result);\r\n            }\r\n            else {\r\n                return result;\r\n            }\r\n        }\r\n    }\r\n    parsePrimary() {\r\n        const start = this.inputIndex;\r\n        if (this.consumeOptionalCharacter($LPAREN)) {\r\n            this.rparensExpected++;\r\n            const result = this.parsePipe();\r\n            this.rparensExpected--;\r\n            this.expectCharacter($RPAREN);\r\n            return result;\r\n        }\r\n        else if (this.next.isKeywordNull()) {\r\n            this.advance();\r\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);\r\n        }\r\n        else if (this.next.isKeywordUndefined()) {\r\n            this.advance();\r\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);\r\n        }\r\n        else if (this.next.isKeywordTrue()) {\r\n            this.advance();\r\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);\r\n        }\r\n        else if (this.next.isKeywordFalse()) {\r\n            this.advance();\r\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);\r\n        }\r\n        else if (this.next.isKeywordThis()) {\r\n            this.advance();\r\n            return new ThisReceiver(this.span(start), this.sourceSpan(start));\r\n        }\r\n        else if (this.consumeOptionalCharacter($LBRACKET)) {\r\n            this.rbracketsExpected++;\r\n            const elements = this.parseExpressionList($RBRACKET);\r\n            this.rbracketsExpected--;\r\n            this.expectCharacter($RBRACKET);\r\n            return new LiteralArray(this.span(start), this.sourceSpan(start), elements);\r\n        }\r\n        else if (this.next.isCharacter($LBRACE)) {\r\n            return this.parseLiteralMap();\r\n        }\r\n        else if (this.next.isIdentifier()) {\r\n            return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start), this.sourceSpan(start)), start, false);\r\n        }\r\n        else if (this.next.isNumber()) {\r\n            const value = this.next.toNumber();\r\n            this.advance();\r\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);\r\n        }\r\n        else if (this.next.isString()) {\r\n            const literalValue = this.next.toString();\r\n            this.advance();\r\n            return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);\r\n        }\r\n        else if (this.next.isPrivateIdentifier()) {\r\n            this._reportErrorForPrivateIdentifier(this.next, null);\r\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\r\n        }\r\n        else if (this.index >= this.tokens.length) {\r\n            this.error(`Unexpected end of expression: ${this.input}`);\r\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\r\n        }\r\n        else {\r\n            this.error(`Unexpected token ${this.next}`);\r\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\r\n        }\r\n    }\r\n    parseExpressionList(terminator) {\r\n        const result = [];\r\n        do {\r\n            if (!this.next.isCharacter(terminator)) {\r\n                result.push(this.parsePipe());\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        } while (this.consumeOptionalCharacter($COMMA));\r\n        return result;\r\n    }\r\n    parseLiteralMap() {\r\n        const keys = [];\r\n        const values = [];\r\n        const start = this.inputIndex;\r\n        this.expectCharacter($LBRACE);\r\n        if (!this.consumeOptionalCharacter($RBRACE)) {\r\n            this.rbracesExpected++;\r\n            do {\r\n                const keyStart = this.inputIndex;\r\n                const quoted = this.next.isString();\r\n                const key = this.expectIdentifierOrKeywordOrString();\r\n                keys.push({ key, quoted });\r\n                // Properties with quoted keys can't use the shorthand syntax.\r\n                if (quoted) {\r\n                    this.expectCharacter($COLON);\r\n                    values.push(this.parsePipe());\r\n                }\r\n                else if (this.consumeOptionalCharacter($COLON)) {\r\n                    values.push(this.parsePipe());\r\n                }\r\n                else {\r\n                    const span = this.span(keyStart);\r\n                    const sourceSpan = this.sourceSpan(keyStart);\r\n                    values.push(new PropertyRead(span, sourceSpan, sourceSpan, new ImplicitReceiver(span, sourceSpan), key));\r\n                }\r\n            } while (this.consumeOptionalCharacter($COMMA));\r\n            this.rbracesExpected--;\r\n            this.expectCharacter($RBRACE);\r\n        }\r\n        return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\r\n    }\r\n    parseAccessMemberOrMethodCall(receiver, start, isSafe) {\r\n        const nameStart = this.inputIndex;\r\n        const id = this.withContext(ParseContextFlags.Writable, () => {\r\n            var _a;\r\n            const id = (_a = this.expectIdentifierOrKeyword()) !== null && _a !== void 0 ? _a : '';\r\n            if (id.length === 0) {\r\n                this.error(`Expected identifier for property access`, receiver.span.end);\r\n            }\r\n            return id;\r\n        });\r\n        const nameSpan = this.sourceSpan(nameStart);\r\n        if (this.consumeOptionalCharacter($LPAREN)) {\r\n            const argumentStart = this.inputIndex;\r\n            this.rparensExpected++;\r\n            const args = this.parseCallArguments();\r\n            const argumentSpan = this.span(argumentStart, this.inputIndex).toAbsolute(this.absoluteOffset);\r\n            this.expectCharacter($RPAREN);\r\n            this.rparensExpected--;\r\n            const span = this.span(start);\r\n            const sourceSpan = this.sourceSpan(start);\r\n            return isSafe ?\r\n                new SafeMethodCall(span, sourceSpan, nameSpan, receiver, id, args, argumentSpan) :\r\n                new MethodCall(span, sourceSpan, nameSpan, receiver, id, args, argumentSpan);\r\n        }\r\n        else {\r\n            if (isSafe) {\r\n                if (this.consumeOptionalOperator('=')) {\r\n                    this.error('The \\'?.\\' operator cannot be used in the assignment');\r\n                    return new EmptyExpr(this.span(start), this.sourceSpan(start));\r\n                }\r\n                else {\r\n                    return new SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, receiver, id);\r\n                }\r\n            }\r\n            else {\r\n                if (this.consumeOptionalOperator('=')) {\r\n                    if (!this.parseAction) {\r\n                        this.error('Bindings cannot contain assignments');\r\n                        return new EmptyExpr(this.span(start), this.sourceSpan(start));\r\n                    }\r\n                    const value = this.parseConditional();\r\n                    return new PropertyWrite(this.span(start), this.sourceSpan(start), nameSpan, receiver, id, value);\r\n                }\r\n                else {\r\n                    return new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, receiver, id);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    parseCallArguments() {\r\n        if (this.next.isCharacter($RPAREN))\r\n            return [];\r\n        const positionals = [];\r\n        do {\r\n            positionals.push(this.parsePipe());\r\n        } while (this.consumeOptionalCharacter($COMMA));\r\n        return positionals;\r\n    }\r\n    /**\r\n     * Parses an identifier, a keyword, a string with an optional `-` in between,\r\n     * and returns the string along with its absolute source span.\r\n     */\r\n    expectTemplateBindingKey() {\r\n        let result = '';\r\n        let operatorFound = false;\r\n        const start = this.currentAbsoluteOffset;\r\n        do {\r\n            result += this.expectIdentifierOrKeywordOrString();\r\n            operatorFound = this.consumeOptionalOperator('-');\r\n            if (operatorFound) {\r\n                result += '-';\r\n            }\r\n        } while (operatorFound);\r\n        return {\r\n            source: result,\r\n            span: new AbsoluteSourceSpan(start, start + result.length),\r\n        };\r\n    }\r\n    /**\r\n     * Parse microsyntax template expression and return a list of bindings or\r\n     * parsing errors in case the given expression is invalid.\r\n     *\r\n     * For example,\r\n     * ```\r\n     *   <div *ngFor=\"let item of items; index as i; trackBy: func\">\r\n     * ```\r\n     * contains five bindings:\r\n     * 1. ngFor -> null\r\n     * 2. item -> NgForOfContext.$implicit\r\n     * 3. ngForOf -> items\r\n     * 4. i -> NgForOfContext.index\r\n     * 5. ngForTrackBy -> func\r\n     *\r\n     * For a full description of the microsyntax grammar, see\r\n     * https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855\r\n     *\r\n     * @param templateKey name of the microsyntax directive, like ngIf, ngFor,\r\n     * without the *, along with its absolute span.\r\n     */\r\n    parseTemplateBindings(templateKey) {\r\n        const bindings = [];\r\n        // The first binding is for the template key itself\r\n        // In *ngFor=\"let item of items\", key = \"ngFor\", value = null\r\n        // In *ngIf=\"cond | pipe\", key = \"ngIf\", value = \"cond | pipe\"\r\n        bindings.push(...this.parseDirectiveKeywordBindings(templateKey));\r\n        while (this.index < this.tokens.length) {\r\n            // If it starts with 'let', then this must be variable declaration\r\n            const letBinding = this.parseLetBinding();\r\n            if (letBinding) {\r\n                bindings.push(letBinding);\r\n            }\r\n            else {\r\n                // Two possible cases here, either `value \"as\" key` or\r\n                // \"directive-keyword expression\". We don't know which case, but both\r\n                // \"value\" and \"directive-keyword\" are template binding key, so consume\r\n                // the key first.\r\n                const key = this.expectTemplateBindingKey();\r\n                // Peek at the next token, if it is \"as\" then this must be variable\r\n                // declaration.\r\n                const binding = this.parseAsBinding(key);\r\n                if (binding) {\r\n                    bindings.push(binding);\r\n                }\r\n                else {\r\n                    // Otherwise the key must be a directive keyword, like \"of\". Transform\r\n                    // the key to actual key. Eg. of -> ngForOf, trackBy -> ngForTrackBy\r\n                    key.source =\r\n                        templateKey.source + key.source.charAt(0).toUpperCase() + key.source.substring(1);\r\n                    bindings.push(...this.parseDirectiveKeywordBindings(key));\r\n                }\r\n            }\r\n            this.consumeStatementTerminator();\r\n        }\r\n        return new TemplateBindingParseResult(bindings, [] /* warnings */, this.errors);\r\n    }\r\n    parseKeyedReadOrWrite(receiver, start, isSafe) {\r\n        return this.withContext(ParseContextFlags.Writable, () => {\r\n            this.rbracketsExpected++;\r\n            const key = this.parsePipe();\r\n            if (key instanceof EmptyExpr) {\r\n                this.error(`Key access cannot be empty`);\r\n            }\r\n            this.rbracketsExpected--;\r\n            this.expectCharacter($RBRACKET);\r\n            if (this.consumeOptionalOperator('=')) {\r\n                if (isSafe) {\r\n                    this.error('The \\'?.\\' operator cannot be used in the assignment');\r\n                }\r\n                else {\r\n                    const value = this.parseConditional();\r\n                    return new KeyedWrite(this.span(start), this.sourceSpan(start), receiver, key, value);\r\n                }\r\n            }\r\n            else {\r\n                return isSafe ? new SafeKeyedRead(this.span(start), this.sourceSpan(start), receiver, key) :\r\n                    new KeyedRead(this.span(start), this.sourceSpan(start), receiver, key);\r\n            }\r\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\r\n        });\r\n    }\r\n    /**\r\n     * Parse a directive keyword, followed by a mandatory expression.\r\n     * For example, \"of items\", \"trackBy: func\".\r\n     * The bindings are: ngForOf -> items, ngForTrackBy -> func\r\n     * There could be an optional \"as\" binding that follows the expression.\r\n     * For example,\r\n     * ```\r\n     *   *ngFor=\"let item of items | slice:0:1 as collection\".\r\n     *                    ^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^\r\n     *               keyword    bound target   optional 'as' binding\r\n     * ```\r\n     *\r\n     * @param key binding key, for example, ngFor, ngIf, ngForOf, along with its\r\n     * absolute span.\r\n     */\r\n    parseDirectiveKeywordBindings(key) {\r\n        const bindings = [];\r\n        this.consumeOptionalCharacter($COLON); // trackBy: trackByFunction\r\n        const value = this.getDirectiveBoundTarget();\r\n        let spanEnd = this.currentAbsoluteOffset;\r\n        // The binding could optionally be followed by \"as\". For example,\r\n        // *ngIf=\"cond | pipe as x\". In this case, the key in the \"as\" binding\r\n        // is \"x\" and the value is the template key itself (\"ngIf\"). Note that the\r\n        // 'key' in the current context now becomes the \"value\" in the next binding.\r\n        const asBinding = this.parseAsBinding(key);\r\n        if (!asBinding) {\r\n            this.consumeStatementTerminator();\r\n            spanEnd = this.currentAbsoluteOffset;\r\n        }\r\n        const sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);\r\n        bindings.push(new ExpressionBinding(sourceSpan, key, value));\r\n        if (asBinding) {\r\n            bindings.push(asBinding);\r\n        }\r\n        return bindings;\r\n    }\r\n    /**\r\n     * Return the expression AST for the bound target of a directive keyword\r\n     * binding. For example,\r\n     * ```\r\n     *   *ngIf=\"condition | pipe\"\r\n     *          ^^^^^^^^^^^^^^^^ bound target for \"ngIf\"\r\n     *   *ngFor=\"let item of items\"\r\n     *                       ^^^^^ bound target for \"ngForOf\"\r\n     * ```\r\n     */\r\n    getDirectiveBoundTarget() {\r\n        if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {\r\n            return null;\r\n        }\r\n        const ast = this.parsePipe(); // example: \"condition | async\"\r\n        const { start, end } = ast.span;\r\n        const value = this.input.substring(start, end);\r\n        return new ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);\r\n    }\r\n    /**\r\n     * Return the binding for a variable declared using `as`. Note that the order\r\n     * of the key-value pair in this declaration is reversed. For example,\r\n     * ```\r\n     *   *ngFor=\"let item of items; index as i\"\r\n     *                              ^^^^^    ^\r\n     *                              value    key\r\n     * ```\r\n     *\r\n     * @param value name of the value in the declaration, \"ngIf\" in the example\r\n     * above, along with its absolute span.\r\n     */\r\n    parseAsBinding(value) {\r\n        if (!this.peekKeywordAs()) {\r\n            return null;\r\n        }\r\n        this.advance(); // consume the 'as' keyword\r\n        const key = this.expectTemplateBindingKey();\r\n        this.consumeStatementTerminator();\r\n        const sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);\r\n        return new VariableBinding(sourceSpan, key, value);\r\n    }\r\n    /**\r\n     * Return the binding for a variable declared using `let`. For example,\r\n     * ```\r\n     *   *ngFor=\"let item of items; let i=index;\"\r\n     *           ^^^^^^^^           ^^^^^^^^^^^\r\n     * ```\r\n     * In the first binding, `item` is bound to `NgForOfContext.$implicit`.\r\n     * In the second binding, `i` is bound to `NgForOfContext.index`.\r\n     */\r\n    parseLetBinding() {\r\n        if (!this.peekKeywordLet()) {\r\n            return null;\r\n        }\r\n        const spanStart = this.currentAbsoluteOffset;\r\n        this.advance(); // consume the 'let' keyword\r\n        const key = this.expectTemplateBindingKey();\r\n        let value = null;\r\n        if (this.consumeOptionalOperator('=')) {\r\n            value = this.expectTemplateBindingKey();\r\n        }\r\n        this.consumeStatementTerminator();\r\n        const sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);\r\n        return new VariableBinding(sourceSpan, key, value);\r\n    }\r\n    /**\r\n     * Consume the optional statement terminator: semicolon or comma.\r\n     */\r\n    consumeStatementTerminator() {\r\n        this.consumeOptionalCharacter($SEMICOLON) || this.consumeOptionalCharacter($COMMA);\r\n    }\r\n    /**\r\n     * Records an error and skips over the token stream until reaching a recoverable point. See\r\n     * `this.skip` for more details on token skipping.\r\n     */\r\n    error(message, index = null) {\r\n        this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\r\n        this.skip();\r\n    }\r\n    locationText(index = null) {\r\n        if (index == null)\r\n            index = this.index;\r\n        return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :\r\n            `at the end of the expression`;\r\n    }\r\n    /**\r\n     * Records an error for an unexpected private identifier being discovered.\r\n     * @param token Token representing a private identifier.\r\n     * @param extraMessage Optional additional message being appended to the error.\r\n     */\r\n    _reportErrorForPrivateIdentifier(token, extraMessage) {\r\n        let errorMessage = `Private identifiers are not supported. Unexpected private identifier: ${token}`;\r\n        if (extraMessage !== null) {\r\n            errorMessage += `, ${extraMessage}`;\r\n        }\r\n        this.error(errorMessage);\r\n    }\r\n    /**\r\n     * Error recovery should skip tokens until it encounters a recovery point.\r\n     *\r\n     * The following are treated as unconditional recovery points:\r\n     *   - end of input\r\n     *   - ';' (parseChain() is always the root production, and it expects a ';')\r\n     *   - '|' (since pipes may be chained and each pipe expression may be treated independently)\r\n     *\r\n     * The following are conditional recovery points:\r\n     *   - ')', '}', ']' if one of calling productions is expecting one of these symbols\r\n     *     - This allows skip() to recover from errors such as '(a.) + 1' allowing more of the AST to\r\n     *       be retained (it doesn't skip any tokens as the ')' is retained because of the '(' begins\r\n     *       an '(' <expr> ')' production).\r\n     *       The recovery points of grouping symbols must be conditional as they must be skipped if\r\n     *       none of the calling productions are not expecting the closing token else we will never\r\n     *       make progress in the case of an extraneous group closing symbol (such as a stray ')').\r\n     *       That is, we skip a closing symbol if we are not in a grouping production.\r\n     *   - '=' in a `Writable` context\r\n     *     - In this context, we are able to recover after seeing the `=` operator, which\r\n     *       signals the presence of an independent rvalue expression following the `=` operator.\r\n     *\r\n     * If a production expects one of these token it increments the corresponding nesting count,\r\n     * and then decrements it just prior to checking if the token is in the input.\r\n     */\r\n    skip() {\r\n        let n = this.next;\r\n        while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) &&\r\n            !n.isOperator('|') && (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) &&\r\n            (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) &&\r\n            (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET)) &&\r\n            (!(this.context & ParseContextFlags.Writable) || !n.isOperator('='))) {\r\n            if (this.next.isError()) {\r\n                this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));\r\n            }\r\n            this.advance();\r\n            n = this.next;\r\n        }\r\n    }\r\n}\r\nclass SimpleExpressionChecker {\r\n    constructor() {\r\n        this.errors = [];\r\n    }\r\n    visitImplicitReceiver(ast, context) { }\r\n    visitThisReceiver(ast, context) { }\r\n    visitInterpolation(ast, context) { }\r\n    visitLiteralPrimitive(ast, context) { }\r\n    visitPropertyRead(ast, context) { }\r\n    visitPropertyWrite(ast, context) { }\r\n    visitSafePropertyRead(ast, context) { }\r\n    visitMethodCall(ast, context) { }\r\n    visitSafeMethodCall(ast, context) { }\r\n    visitFunctionCall(ast, context) { }\r\n    visitLiteralArray(ast, context) {\r\n        this.visitAll(ast.expressions, context);\r\n    }\r\n    visitLiteralMap(ast, context) {\r\n        this.visitAll(ast.values, context);\r\n    }\r\n    visitUnary(ast, context) { }\r\n    visitBinary(ast, context) { }\r\n    visitPrefixNot(ast, context) { }\r\n    visitNonNullAssert(ast, context) { }\r\n    visitConditional(ast, context) { }\r\n    visitPipe(ast, context) {\r\n        this.errors.push('pipes');\r\n    }\r\n    visitKeyedRead(ast, context) { }\r\n    visitKeyedWrite(ast, context) { }\r\n    visitAll(asts, context) {\r\n        return asts.map(node => node.visit(this, context));\r\n    }\r\n    visitChain(ast, context) { }\r\n    visitQuote(ast, context) { }\r\n    visitSafeKeyedRead(ast, context) { }\r\n}\r\n/**\r\n * This class implements SimpleExpressionChecker used in View Engine and performs more strict checks\r\n * to make sure host bindings do not contain pipes. In View Engine, having pipes in host bindings is\r\n * not supported as well, but in some cases (like `!(value | async)`) the error is not triggered at\r\n * compile time. In order to preserve View Engine behavior, more strict checks are introduced for\r\n * Ivy mode only.\r\n */\r\nclass IvySimpleExpressionChecker extends RecursiveAstVisitor$1 {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.errors = [];\r\n    }\r\n    visitPipe() {\r\n        this.errors.push('pipes');\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nfunction mapEntry(key, value) {\r\n    return { key, value, quoted: false };\r\n}\r\nfunction mapLiteral(obj, quoted = false) {\r\n    return literalMap(Object.keys(obj).map(key => ({\r\n        key,\r\n        quoted,\r\n        value: obj[key],\r\n    })));\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n// =================================================================================================\r\n// =================================================================================================\r\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\r\n// =================================================================================================\r\n// =================================================================================================\r\n//\r\n//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!\r\n//                               Reach out to mprobst for details.\r\n//\r\n// =================================================================================================\r\n/** Map from tagName|propertyName to SecurityContext. Properties applying to all tags use '*'. */\r\nlet _SECURITY_SCHEMA;\r\nfunction SECURITY_SCHEMA() {\r\n    if (!_SECURITY_SCHEMA) {\r\n        _SECURITY_SCHEMA = {};\r\n        // Case is insignificant below, all element and attribute names are lower-cased for lookup.\r\n        registerContext(SecurityContext.HTML, [\r\n            'iframe|srcdoc',\r\n            '*|innerHTML',\r\n            '*|outerHTML',\r\n        ]);\r\n        registerContext(SecurityContext.STYLE, ['*|style']);\r\n        // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.\r\n        registerContext(SecurityContext.URL, [\r\n            '*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href',\r\n            'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action',\r\n            'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite',\r\n            'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src',\r\n        ]);\r\n        registerContext(SecurityContext.RESOURCE_URL, [\r\n            'applet|code',\r\n            'applet|codebase',\r\n            'base|href',\r\n            'embed|src',\r\n            'frame|src',\r\n            'head|profile',\r\n            'html|manifest',\r\n            'iframe|src',\r\n            'link|href',\r\n            'media|src',\r\n            'object|codebase',\r\n            'object|data',\r\n            'script|src',\r\n        ]);\r\n    }\r\n    return _SECURITY_SCHEMA;\r\n}\r\nfunction registerContext(ctx, specs) {\r\n    for (const spec of specs)\r\n        _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass ElementSchemaRegistry {\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst BOOLEAN = 'boolean';\r\nconst NUMBER = 'number';\r\nconst STRING = 'string';\r\nconst OBJECT = 'object';\r\n/**\r\n * This array represents the DOM schema. It encodes inheritance, properties, and events.\r\n *\r\n * ## Overview\r\n *\r\n * Each line represents one kind of element. The `element_inheritance` and properties are joined\r\n * using `element_inheritance|properties` syntax.\r\n *\r\n * ## Element Inheritance\r\n *\r\n * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.\r\n * Here the individual elements are separated by `,` (commas). Every element in the list\r\n * has identical properties.\r\n *\r\n * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is\r\n * specified then `\"\"` (blank) element is assumed.\r\n *\r\n * NOTE: The blank element inherits from root `[Element]` element, the super element of all\r\n * elements.\r\n *\r\n * NOTE an element prefix such as `:svg:` has no special meaning to the schema.\r\n *\r\n * ## Properties\r\n *\r\n * Each element has a set of properties separated by `,` (commas). Each property can be prefixed\r\n * by a special character designating its type:\r\n *\r\n * - (no prefix): property is a string.\r\n * - `*`: property represents an event.\r\n * - `!`: property is a boolean.\r\n * - `#`: property is a number.\r\n * - `%`: property is an object.\r\n *\r\n * ## Query\r\n *\r\n * The class creates an internal squas representation which allows to easily answer the query of\r\n * if a given property exist on a given element.\r\n *\r\n * NOTE: We don't yet support querying for types or events.\r\n * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,\r\n *       see dom_element_schema_registry_spec.ts\r\n */\r\n// =================================================================================================\r\n// =================================================================================================\r\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\r\n// =================================================================================================\r\n// =================================================================================================\r\n//\r\n//                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!\r\n//\r\n// Newly added properties must be security reviewed and assigned an appropriate SecurityContext in\r\n// dom_security_schema.ts. Reach out to mprobst & rjamet for details.\r\n//\r\n// =================================================================================================\r\nconst SCHEMA = [\r\n    '[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot' +\r\n        /* added manually to avoid breaking changes */\r\n        ',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored',\r\n    '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',\r\n    'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate',\r\n    'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume',\r\n    ':svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex',\r\n    ':svg:graphics^:svg:|',\r\n    ':svg:animation^:svg:|*begin,*end,*repeat',\r\n    ':svg:geometry^:svg:|',\r\n    ':svg:componentTransferFunction^:svg:|',\r\n    ':svg:gradient^:svg:|',\r\n    ':svg:textContent^:svg:graphics|',\r\n    ':svg:textPositioning^:svg:textContent|',\r\n    'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username',\r\n    'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username',\r\n    'audio^media|',\r\n    'br^[HTMLElement]|clear',\r\n    'base^[HTMLElement]|href,target',\r\n    'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink',\r\n    'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value',\r\n    'canvas^[HTMLElement]|#height,#width',\r\n    'content^[HTMLElement]|select',\r\n    'dl^[HTMLElement]|!compact',\r\n    'datalist^[HTMLElement]|',\r\n    'details^[HTMLElement]|!open',\r\n    'dialog^[HTMLElement]|!open,returnValue',\r\n    'dir^[HTMLElement]|!compact',\r\n    'div^[HTMLElement]|align',\r\n    'embed^[HTMLElement]|align,height,name,src,type,width',\r\n    'fieldset^[HTMLElement]|!disabled,name',\r\n    'font^[HTMLElement]|color,face,size',\r\n    'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target',\r\n    'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src',\r\n    'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows',\r\n    'hr^[HTMLElement]|align,color,!noShade,size,width',\r\n    'head^[HTMLElement]|',\r\n    'h1,h2,h3,h4,h5,h6^[HTMLElement]|align',\r\n    'html^[HTMLElement]|version',\r\n    'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width',\r\n    'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width',\r\n    'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width',\r\n    'li^[HTMLElement]|type,#value',\r\n    'label^[HTMLElement]|htmlFor',\r\n    'legend^[HTMLElement]|align',\r\n    'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type',\r\n    'map^[HTMLElement]|name',\r\n    'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width',\r\n    'menu^[HTMLElement]|!compact',\r\n    'meta^[HTMLElement]|content,httpEquiv,name,scheme',\r\n    'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value',\r\n    'ins,del^[HTMLElement]|cite,dateTime',\r\n    'ol^[HTMLElement]|!compact,!reversed,#start,type',\r\n    'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width',\r\n    'optgroup^[HTMLElement]|!disabled,label',\r\n    'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value',\r\n    'output^[HTMLElement]|defaultValue,%htmlFor,name,value',\r\n    'p^[HTMLElement]|align',\r\n    'param^[HTMLElement]|name,type,value,valueType',\r\n    'picture^[HTMLElement]|',\r\n    'pre^[HTMLElement]|#width',\r\n    'progress^[HTMLElement]|#max,#value',\r\n    'q,blockquote,cite^[HTMLElement]|',\r\n    'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type',\r\n    'select^[HTMLElement]|autocomplete,!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value',\r\n    'shadow^[HTMLElement]|',\r\n    'slot^[HTMLElement]|name',\r\n    'source^[HTMLElement]|media,sizes,src,srcset,type',\r\n    'span^[HTMLElement]|',\r\n    'style^[HTMLElement]|!disabled,media,type',\r\n    'caption^[HTMLElement]|align',\r\n    'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width',\r\n    'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width',\r\n    'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width',\r\n    'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign',\r\n    'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign',\r\n    'template^[HTMLElement]|',\r\n    'textarea^[HTMLElement]|autocapitalize,autocomplete,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap',\r\n    'title^[HTMLElement]|text',\r\n    'track^[HTMLElement]|!default,kind,label,src,srclang',\r\n    'ul^[HTMLElement]|!compact,type',\r\n    'unknown^[HTMLElement]|',\r\n    'video^media|#height,poster,#width',\r\n    ':svg:a^:svg:graphics|',\r\n    ':svg:animate^:svg:animation|',\r\n    ':svg:animateMotion^:svg:animation|',\r\n    ':svg:animateTransform^:svg:animation|',\r\n    ':svg:circle^:svg:geometry|',\r\n    ':svg:clipPath^:svg:graphics|',\r\n    ':svg:defs^:svg:graphics|',\r\n    ':svg:desc^:svg:|',\r\n    ':svg:discard^:svg:|',\r\n    ':svg:ellipse^:svg:geometry|',\r\n    ':svg:feBlend^:svg:|',\r\n    ':svg:feColorMatrix^:svg:|',\r\n    ':svg:feComponentTransfer^:svg:|',\r\n    ':svg:feComposite^:svg:|',\r\n    ':svg:feConvolveMatrix^:svg:|',\r\n    ':svg:feDiffuseLighting^:svg:|',\r\n    ':svg:feDisplacementMap^:svg:|',\r\n    ':svg:feDistantLight^:svg:|',\r\n    ':svg:feDropShadow^:svg:|',\r\n    ':svg:feFlood^:svg:|',\r\n    ':svg:feFuncA^:svg:componentTransferFunction|',\r\n    ':svg:feFuncB^:svg:componentTransferFunction|',\r\n    ':svg:feFuncG^:svg:componentTransferFunction|',\r\n    ':svg:feFuncR^:svg:componentTransferFunction|',\r\n    ':svg:feGaussianBlur^:svg:|',\r\n    ':svg:feImage^:svg:|',\r\n    ':svg:feMerge^:svg:|',\r\n    ':svg:feMergeNode^:svg:|',\r\n    ':svg:feMorphology^:svg:|',\r\n    ':svg:feOffset^:svg:|',\r\n    ':svg:fePointLight^:svg:|',\r\n    ':svg:feSpecularLighting^:svg:|',\r\n    ':svg:feSpotLight^:svg:|',\r\n    ':svg:feTile^:svg:|',\r\n    ':svg:feTurbulence^:svg:|',\r\n    ':svg:filter^:svg:|',\r\n    ':svg:foreignObject^:svg:graphics|',\r\n    ':svg:g^:svg:graphics|',\r\n    ':svg:image^:svg:graphics|',\r\n    ':svg:line^:svg:geometry|',\r\n    ':svg:linearGradient^:svg:gradient|',\r\n    ':svg:mpath^:svg:|',\r\n    ':svg:marker^:svg:|',\r\n    ':svg:mask^:svg:|',\r\n    ':svg:metadata^:svg:|',\r\n    ':svg:path^:svg:geometry|',\r\n    ':svg:pattern^:svg:|',\r\n    ':svg:polygon^:svg:geometry|',\r\n    ':svg:polyline^:svg:geometry|',\r\n    ':svg:radialGradient^:svg:gradient|',\r\n    ':svg:rect^:svg:geometry|',\r\n    ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan',\r\n    ':svg:script^:svg:|type',\r\n    ':svg:set^:svg:animation|',\r\n    ':svg:stop^:svg:|',\r\n    ':svg:style^:svg:|!disabled,media,title,type',\r\n    ':svg:switch^:svg:graphics|',\r\n    ':svg:symbol^:svg:|',\r\n    ':svg:tspan^:svg:textPositioning|',\r\n    ':svg:text^:svg:textPositioning|',\r\n    ':svg:textPath^:svg:textContent|',\r\n    ':svg:title^:svg:|',\r\n    ':svg:use^:svg:graphics|',\r\n    ':svg:view^:svg:|#zoomAndPan',\r\n    'data^[HTMLElement]|value',\r\n    'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name',\r\n    'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default',\r\n    'summary^[HTMLElement]|',\r\n    'time^[HTMLElement]|dateTime',\r\n    ':svg:cursor^:svg:|',\r\n];\r\nconst _ATTR_TO_PROP = {\r\n    'class': 'className',\r\n    'for': 'htmlFor',\r\n    'formaction': 'formAction',\r\n    'innerHtml': 'innerHTML',\r\n    'readonly': 'readOnly',\r\n    'tabindex': 'tabIndex',\r\n};\r\n// Invert _ATTR_TO_PROP.\r\nconst _PROP_TO_ATTR = Object.keys(_ATTR_TO_PROP).reduce((inverted, attr) => {\r\n    inverted[_ATTR_TO_PROP[attr]] = attr;\r\n    return inverted;\r\n}, {});\r\nclass DomElementSchemaRegistry extends ElementSchemaRegistry {\r\n    constructor() {\r\n        super();\r\n        this._schema = {};\r\n        SCHEMA.forEach(encodedType => {\r\n            const type = {};\r\n            const [strType, strProperties] = encodedType.split('|');\r\n            const properties = strProperties.split(',');\r\n            const [typeNames, superName] = strType.split('^');\r\n            typeNames.split(',').forEach(tag => this._schema[tag.toLowerCase()] = type);\r\n            const superType = superName && this._schema[superName.toLowerCase()];\r\n            if (superType) {\r\n                Object.keys(superType).forEach((prop) => {\r\n                    type[prop] = superType[prop];\r\n                });\r\n            }\r\n            properties.forEach((property) => {\r\n                if (property.length > 0) {\r\n                    switch (property[0]) {\r\n                        case '*':\r\n                            // We don't yet support events.\r\n                            // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events\r\n                            // will\r\n                            // almost certainly introduce bad XSS vulnerabilities.\r\n                            // type[property.substring(1)] = EVENT;\r\n                            break;\r\n                        case '!':\r\n                            type[property.substring(1)] = BOOLEAN;\r\n                            break;\r\n                        case '#':\r\n                            type[property.substring(1)] = NUMBER;\r\n                            break;\r\n                        case '%':\r\n                            type[property.substring(1)] = OBJECT;\r\n                            break;\r\n                        default:\r\n                            type[property] = STRING;\r\n                    }\r\n                }\r\n            });\r\n        });\r\n    }\r\n    hasProperty(tagName, propName, schemaMetas) {\r\n        if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {\r\n            return true;\r\n        }\r\n        if (tagName.indexOf('-') > -1) {\r\n            if (isNgContainer(tagName) || isNgContent(tagName)) {\r\n                return false;\r\n            }\r\n            if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\r\n                // Can't tell now as we don't know which properties a custom element will get\r\n                // once it is instantiated\r\n                return true;\r\n            }\r\n        }\r\n        const elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];\r\n        return !!elementProperties[propName];\r\n    }\r\n    hasElement(tagName, schemaMetas) {\r\n        if (schemaMetas.some((schema) => schema.name === NO_ERRORS_SCHEMA.name)) {\r\n            return true;\r\n        }\r\n        if (tagName.indexOf('-') > -1) {\r\n            if (isNgContainer(tagName) || isNgContent(tagName)) {\r\n                return true;\r\n            }\r\n            if (schemaMetas.some((schema) => schema.name === CUSTOM_ELEMENTS_SCHEMA.name)) {\r\n                // Allow any custom elements\r\n                return true;\r\n            }\r\n        }\r\n        return !!this._schema[tagName.toLowerCase()];\r\n    }\r\n    /**\r\n     * securityContext returns the security context for the given property on the given DOM tag.\r\n     *\r\n     * Tag and property name are statically known and cannot change at runtime, i.e. it is not\r\n     * possible to bind a value into a changing attribute or tag name.\r\n     *\r\n     * The filtering is based on a list of allowed tags|attributes. All attributes in the schema\r\n     * above are assumed to have the 'NONE' security context, i.e. that they are safe inert\r\n     * string values. Only specific well known attack vectors are assigned their appropriate context.\r\n     */\r\n    securityContext(tagName, propName, isAttribute) {\r\n        if (isAttribute) {\r\n            // NB: For security purposes, use the mapped property name, not the attribute name.\r\n            propName = this.getMappedPropName(propName);\r\n        }\r\n        // Make sure comparisons are case insensitive, so that case differences between attribute and\r\n        // property names do not have a security impact.\r\n        tagName = tagName.toLowerCase();\r\n        propName = propName.toLowerCase();\r\n        let ctx = SECURITY_SCHEMA()[tagName + '|' + propName];\r\n        if (ctx) {\r\n            return ctx;\r\n        }\r\n        ctx = SECURITY_SCHEMA()['*|' + propName];\r\n        return ctx ? ctx : SecurityContext.NONE;\r\n    }\r\n    getMappedPropName(propName) {\r\n        return _ATTR_TO_PROP[propName] || propName;\r\n    }\r\n    getDefaultComponentElementName() {\r\n        return 'ng-component';\r\n    }\r\n    validateProperty(name) {\r\n        if (name.toLowerCase().startsWith('on')) {\r\n            const msg = `Binding to event property '${name}' is disallowed for security reasons, ` +\r\n                `please use (${name.slice(2)})=...` +\r\n                `\\nIf '${name}' is a directive input, make sure the directive is imported by the` +\r\n                ` current module.`;\r\n            return { error: true, msg: msg };\r\n        }\r\n        else {\r\n            return { error: false };\r\n        }\r\n    }\r\n    validateAttribute(name) {\r\n        if (name.toLowerCase().startsWith('on')) {\r\n            const msg = `Binding to event attribute '${name}' is disallowed for security reasons, ` +\r\n                `please use (${name.slice(2)})=...`;\r\n            return { error: true, msg: msg };\r\n        }\r\n        else {\r\n            return { error: false };\r\n        }\r\n    }\r\n    allKnownElementNames() {\r\n        return Object.keys(this._schema);\r\n    }\r\n    allKnownAttributesOfElement(tagName) {\r\n        const elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];\r\n        // Convert properties to attributes.\r\n        return Object.keys(elementProperties).map(prop => { var _a; return (_a = _PROP_TO_ATTR[prop]) !== null && _a !== void 0 ? _a : prop; });\r\n    }\r\n    normalizeAnimationStyleProperty(propName) {\r\n        return dashCaseToCamelCase(propName);\r\n    }\r\n    normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {\r\n        let unit = '';\r\n        const strVal = val.toString().trim();\r\n        let errorMsg = null;\r\n        if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\r\n            if (typeof val === 'number') {\r\n                unit = 'px';\r\n            }\r\n            else {\r\n                const valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\r\n                if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\r\n                    errorMsg = `Please provide a CSS unit value for ${userProvidedProp}:${val}`;\r\n                }\r\n            }\r\n        }\r\n        return { error: errorMsg, value: strVal + unit };\r\n    }\r\n}\r\nfunction _isPixelDimensionStyle(prop) {\r\n    switch (prop) {\r\n        case 'width':\r\n        case 'height':\r\n        case 'minWidth':\r\n        case 'minHeight':\r\n        case 'maxWidth':\r\n        case 'maxHeight':\r\n        case 'left':\r\n        case 'top':\r\n        case 'bottom':\r\n        case 'right':\r\n        case 'fontSize':\r\n        case 'outlineWidth':\r\n        case 'outlineOffset':\r\n        case 'paddingTop':\r\n        case 'paddingLeft':\r\n        case 'paddingBottom':\r\n        case 'paddingRight':\r\n        case 'marginTop':\r\n        case 'marginLeft':\r\n        case 'marginBottom':\r\n        case 'marginRight':\r\n        case 'borderRadius':\r\n        case 'borderWidth':\r\n        case 'borderTopWidth':\r\n        case 'borderLeftWidth':\r\n        case 'borderRightWidth':\r\n        case 'borderBottomWidth':\r\n        case 'textIndent':\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Set of tagName|propertyName corresponding to Trusted Types sinks. Properties applying to all\r\n * tags use '*'.\r\n *\r\n * Extracted from, and should be kept in sync with\r\n * https://w3c.github.io/webappsec-trusted-types/dist/spec/#integrations\r\n */\r\nconst TRUSTED_TYPES_SINKS = new Set([\r\n    // NOTE: All strings in this set *must* be lowercase!\r\n    // TrustedHTML\r\n    'iframe|srcdoc',\r\n    '*|innerhtml',\r\n    '*|outerhtml',\r\n    // NB: no TrustedScript here, as the corresponding tags are stripped by the compiler.\r\n    // TrustedScriptURL\r\n    'embed|src',\r\n    'object|codebase',\r\n    'object|data',\r\n]);\r\n/**\r\n * isTrustedTypesSink returns true if the given property on the given DOM tag is a Trusted Types\r\n * sink. In that case, use `ElementSchemaRegistry.securityContext` to determine which particular\r\n * Trusted Type is required for values passed to the sink:\r\n * - SecurityContext.HTML corresponds to TrustedHTML\r\n * - SecurityContext.RESOURCE_URL corresponds to TrustedScriptURL\r\n */\r\nfunction isTrustedTypesSink(tagName, propName) {\r\n    // Make sure comparisons are case insensitive, so that case differences between attribute and\r\n    // property names do not have a security impact.\r\n    tagName = tagName.toLowerCase();\r\n    propName = propName.toLowerCase();\r\n    return TRUSTED_TYPES_SINKS.has(tagName + '|' + propName) ||\r\n        TRUSTED_TYPES_SINKS.has('*|' + propName);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst BIND_NAME_REGEXP$1 = /^(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*)$/;\r\n// Group 1 = \"bind-\"\r\nconst KW_BIND_IDX$1 = 1;\r\n// Group 2 = \"let-\"\r\nconst KW_LET_IDX$1 = 2;\r\n// Group 3 = \"ref-/#\"\r\nconst KW_REF_IDX$1 = 3;\r\n// Group 4 = \"on-\"\r\nconst KW_ON_IDX$1 = 4;\r\n// Group 5 = \"bindon-\"\r\nconst KW_BINDON_IDX$1 = 5;\r\n// Group 6 = \"@\"\r\nconst KW_AT_IDX$1 = 6;\r\n// Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\r\nconst IDENT_KW_IDX$1 = 7;\r\nconst BINDING_DELIMS = {\r\n    BANANA_BOX: { start: '[(', end: ')]' },\r\n    PROPERTY: { start: '[', end: ']' },\r\n    EVENT: { start: '(', end: ')' },\r\n};\r\nconst TEMPLATE_ATTR_PREFIX$2 = '*';\r\nfunction htmlAstToRender3Ast(htmlNodes, bindingParser, options) {\r\n    const transformer = new HtmlAstToIvyAst(bindingParser, options);\r\n    const ivyNodes = visitAll$1(transformer, htmlNodes);\r\n    // Errors might originate in either the binding parser or the html to ivy transformer\r\n    const allErrors = bindingParser.errors.concat(transformer.errors);\r\n    const result = {\r\n        nodes: ivyNodes,\r\n        errors: allErrors,\r\n        styleUrls: transformer.styleUrls,\r\n        styles: transformer.styles,\r\n        ngContentSelectors: transformer.ngContentSelectors\r\n    };\r\n    if (options.collectCommentNodes) {\r\n        result.commentNodes = transformer.commentNodes;\r\n    }\r\n    return result;\r\n}\r\nclass HtmlAstToIvyAst {\r\n    constructor(bindingParser, options) {\r\n        this.bindingParser = bindingParser;\r\n        this.options = options;\r\n        this.errors = [];\r\n        this.styles = [];\r\n        this.styleUrls = [];\r\n        this.ngContentSelectors = [];\r\n        // This array will be populated if `Render3ParseOptions['collectCommentNodes']` is true\r\n        this.commentNodes = [];\r\n        this.inI18nBlock = false;\r\n    }\r\n    // HTML visitor\r\n    visitElement(element) {\r\n        const isI18nRootElement = isI18nRootNode(element.i18n);\r\n        if (isI18nRootElement) {\r\n            if (this.inI18nBlock) {\r\n                this.reportError('Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.', element.sourceSpan);\r\n            }\r\n            this.inI18nBlock = true;\r\n        }\r\n        const preparsedElement = preparseElement(element);\r\n        if (preparsedElement.type === PreparsedElementType.SCRIPT) {\r\n            return null;\r\n        }\r\n        else if (preparsedElement.type === PreparsedElementType.STYLE) {\r\n            const contents = textContents(element);\r\n            if (contents !== null) {\r\n                this.styles.push(contents);\r\n            }\r\n            return null;\r\n        }\r\n        else if (preparsedElement.type === PreparsedElementType.STYLESHEET &&\r\n            isStyleUrlResolvable(preparsedElement.hrefAttr)) {\r\n            this.styleUrls.push(preparsedElement.hrefAttr);\r\n            return null;\r\n        }\r\n        // Whether the element is a `<ng-template>`\r\n        const isTemplateElement = isNgTemplate(element.name);\r\n        const parsedProperties = [];\r\n        const boundEvents = [];\r\n        const variables = [];\r\n        const references = [];\r\n        const attributes = [];\r\n        const i18nAttrsMeta = {};\r\n        const templateParsedProperties = [];\r\n        const templateVariables = [];\r\n        // Whether the element has any *-attribute\r\n        let elementHasInlineTemplate = false;\r\n        for (const attribute of element.attrs) {\r\n            let hasBinding = false;\r\n            const normalizedName = normalizeAttributeName(attribute.name);\r\n            // `*attr` defines template bindings\r\n            let isTemplateBinding = false;\r\n            if (attribute.i18n) {\r\n                i18nAttrsMeta[attribute.name] = attribute.i18n;\r\n            }\r\n            if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX$2)) {\r\n                // *-attributes\r\n                if (elementHasInlineTemplate) {\r\n                    this.reportError(`Can't have multiple template bindings on one element. Use only one attribute prefixed with *`, attribute.sourceSpan);\r\n                }\r\n                isTemplateBinding = true;\r\n                elementHasInlineTemplate = true;\r\n                const templateValue = attribute.value;\r\n                const templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX$2.length);\r\n                const parsedVariables = [];\r\n                const absoluteValueOffset = attribute.valueSpan ?\r\n                    attribute.valueSpan.start.offset :\r\n                    // If there is no value span the attribute does not have a value, like `attr` in\r\n                    //`<div attr></div>`. In this case, point to one character beyond the last character of\r\n                    // the attribute name.\r\n                    attribute.sourceSpan.start.offset + attribute.name.length;\r\n                this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables, true /* isIvyAst */);\r\n                templateVariables.push(...parsedVariables.map(v => new Variable(v.name, v.value, v.sourceSpan, v.keySpan, v.valueSpan)));\r\n            }\r\n            else {\r\n                // Check for variables, events, property bindings, interpolation\r\n                hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);\r\n            }\r\n            if (!hasBinding && !isTemplateBinding) {\r\n                // don't include the bindings as attributes as well in the AST\r\n                attributes.push(this.visitAttribute(attribute));\r\n            }\r\n        }\r\n        const children = visitAll$1(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR$1 : this, element.children);\r\n        let parsedElement;\r\n        if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\r\n            // `<ng-content>`\r\n            if (element.children &&\r\n                !element.children.every((node) => isEmptyTextNode(node) || isCommentNode(node))) {\r\n                this.reportError(`<ng-content> element cannot have content.`, element.sourceSpan);\r\n            }\r\n            const selector = preparsedElement.selectAttr;\r\n            const attrs = element.attrs.map(attr => this.visitAttribute(attr));\r\n            parsedElement = new Content(selector, attrs, element.sourceSpan, element.i18n);\r\n            this.ngContentSelectors.push(selector);\r\n        }\r\n        else if (isTemplateElement) {\r\n            // `<ng-template>`\r\n            const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\r\n            parsedElement = new Template(element.name, attributes, attrs.bound, boundEvents, [ /* no template attributes */], children, references, variables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\r\n        }\r\n        else {\r\n            const attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\r\n            parsedElement = new Element(element.name, attributes, attrs.bound, boundEvents, children, references, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\r\n        }\r\n        if (elementHasInlineTemplate) {\r\n            // If this node is an inline-template (e.g. has *ngFor) then we need to create a template\r\n            // node that contains this node.\r\n            // Moreover, if the node is an element, then we need to hoist its attributes to the template\r\n            // node for matching against content projection selectors.\r\n            const attrs = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);\r\n            const templateAttrs = [];\r\n            attrs.literal.forEach(attr => templateAttrs.push(attr));\r\n            attrs.bound.forEach(attr => templateAttrs.push(attr));\r\n            const hoistedAttrs = parsedElement instanceof Element ?\r\n                {\r\n                    attributes: parsedElement.attributes,\r\n                    inputs: parsedElement.inputs,\r\n                    outputs: parsedElement.outputs,\r\n                } :\r\n                { attributes: [], inputs: [], outputs: [] };\r\n            // For <ng-template>s with structural directives on them, avoid passing i18n information to\r\n            // the wrapping template to prevent unnecessary i18n instructions from being generated. The\r\n            // necessary i18n meta information will be extracted from child elements.\r\n            const i18n = isTemplateElement && isI18nRootElement ? undefined : element.i18n;\r\n            // TODO(pk): test for this case\r\n            parsedElement = new Template(parsedElement.name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs, [parsedElement], [ /* no references */], templateVariables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, i18n);\r\n        }\r\n        if (isI18nRootElement) {\r\n            this.inI18nBlock = false;\r\n        }\r\n        return parsedElement;\r\n    }\r\n    visitAttribute(attribute) {\r\n        return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);\r\n    }\r\n    visitText(text) {\r\n        return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.i18n);\r\n    }\r\n    visitExpansion(expansion) {\r\n        if (!expansion.i18n) {\r\n            // do not generate Icu in case it was created\r\n            // outside of i18n block in a template\r\n            return null;\r\n        }\r\n        if (!isI18nRootNode(expansion.i18n)) {\r\n            throw new Error(`Invalid type \"${expansion.i18n.constructor}\" for \"i18n\" property of ${expansion.sourceSpan.toString()}. Expected a \"Message\"`);\r\n        }\r\n        const message = expansion.i18n;\r\n        const vars = {};\r\n        const placeholders = {};\r\n        // extract VARs from ICUs - we process them separately while\r\n        // assembling resulting message via goog.getMsg function, since\r\n        // we need to pass them to top-level goog.getMsg call\r\n        Object.keys(message.placeholders).forEach(key => {\r\n            const value = message.placeholders[key];\r\n            if (key.startsWith(I18N_ICU_VAR_PREFIX)) {\r\n                // Currently when the `plural` or `select` keywords in an ICU contain trailing spaces (e.g.\r\n                // `{count, select , ...}`), these spaces are also included into the key names in ICU vars\r\n                // (e.g. \"VAR_SELECT \"). These trailing spaces are not desirable, since they will later be\r\n                // converted into `_` symbols while normalizing placeholder names, which might lead to\r\n                // mismatches at runtime (i.e. placeholder will not be replaced with the correct value).\r\n                const formattedKey = key.trim();\r\n                const ast = this.bindingParser.parseInterpolationExpression(value.text, value.sourceSpan);\r\n                vars[formattedKey] = new BoundText(ast, value.sourceSpan);\r\n            }\r\n            else {\r\n                placeholders[key] = this._visitTextWithInterpolation(value.text, value.sourceSpan);\r\n            }\r\n        });\r\n        return new Icu(vars, placeholders, expansion.sourceSpan, message);\r\n    }\r\n    visitExpansionCase(expansionCase) {\r\n        return null;\r\n    }\r\n    visitComment(comment) {\r\n        if (this.options.collectCommentNodes) {\r\n            this.commentNodes.push(new Comment(comment.value || '', comment.sourceSpan));\r\n        }\r\n        return null;\r\n    }\r\n    // convert view engine `ParsedProperty` to a format suitable for IVY\r\n    extractAttributes(elementName, properties, i18nPropsMeta) {\r\n        const bound = [];\r\n        const literal = [];\r\n        properties.forEach(prop => {\r\n            const i18n = i18nPropsMeta[prop.name];\r\n            if (prop.isLiteral) {\r\n                literal.push(new TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, prop.keySpan, prop.valueSpan, i18n));\r\n            }\r\n            else {\r\n                // Note that validation is skipped and property mapping is disabled\r\n                // due to the fact that we need to make sure a given prop is not an\r\n                // input of a directive and directive matching happens at runtime.\r\n                const bep = this.bindingParser.createBoundElementProperty(elementName, prop, /* skipValidation */ true, /* mapPropertyName */ false);\r\n                bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));\r\n            }\r\n        });\r\n        return { bound, literal };\r\n    }\r\n    parseAttribute(isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {\r\n        const name = normalizeAttributeName(attribute.name);\r\n        const value = attribute.value;\r\n        const srcSpan = attribute.sourceSpan;\r\n        const absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;\r\n        function createKeySpan(srcSpan, prefix, identifier) {\r\n            // We need to adjust the start location for the keySpan to account for the removed 'data-'\r\n            // prefix from `normalizeAttributeName`.\r\n            const normalizationAdjustment = attribute.name.length - name.length;\r\n            const keySpanStart = srcSpan.start.moveBy(prefix.length + normalizationAdjustment);\r\n            const keySpanEnd = keySpanStart.moveBy(identifier.length);\r\n            return new ParseSourceSpan(keySpanStart, keySpanEnd, keySpanStart, identifier);\r\n        }\r\n        const bindParts = name.match(BIND_NAME_REGEXP$1);\r\n        if (bindParts) {\r\n            if (bindParts[KW_BIND_IDX$1] != null) {\r\n                const identifier = bindParts[IDENT_KW_IDX$1];\r\n                const keySpan = createKeySpan(srcSpan, bindParts[KW_BIND_IDX$1], identifier);\r\n                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\r\n            }\r\n            else if (bindParts[KW_LET_IDX$1]) {\r\n                if (isTemplateElement) {\r\n                    const identifier = bindParts[IDENT_KW_IDX$1];\r\n                    const keySpan = createKeySpan(srcSpan, bindParts[KW_LET_IDX$1], identifier);\r\n                    this.parseVariable(identifier, value, srcSpan, keySpan, attribute.valueSpan, variables);\r\n                }\r\n                else {\r\n                    this.reportError(`\"let-\" is only supported on ng-template elements.`, srcSpan);\r\n                }\r\n            }\r\n            else if (bindParts[KW_REF_IDX$1]) {\r\n                const identifier = bindParts[IDENT_KW_IDX$1];\r\n                const keySpan = createKeySpan(srcSpan, bindParts[KW_REF_IDX$1], identifier);\r\n                this.parseReference(identifier, value, srcSpan, keySpan, attribute.valueSpan, references);\r\n            }\r\n            else if (bindParts[KW_ON_IDX$1]) {\r\n                const events = [];\r\n                const identifier = bindParts[IDENT_KW_IDX$1];\r\n                const keySpan = createKeySpan(srcSpan, bindParts[KW_ON_IDX$1], identifier);\r\n                this.bindingParser.parseEvent(identifier, value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);\r\n                addEvents(events, boundEvents);\r\n            }\r\n            else if (bindParts[KW_BINDON_IDX$1]) {\r\n                const identifier = bindParts[IDENT_KW_IDX$1];\r\n                const keySpan = createKeySpan(srcSpan, bindParts[KW_BINDON_IDX$1], identifier);\r\n                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\r\n                this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan);\r\n            }\r\n            else if (bindParts[KW_AT_IDX$1]) {\r\n                const keySpan = createKeySpan(srcSpan, '', name);\r\n                this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\r\n            }\r\n            return true;\r\n        }\r\n        // We didn't see a kw-prefixed property binding, but we have not yet checked\r\n        // for the []/()/[()] syntax.\r\n        let delims = null;\r\n        if (name.startsWith(BINDING_DELIMS.BANANA_BOX.start)) {\r\n            delims = BINDING_DELIMS.BANANA_BOX;\r\n        }\r\n        else if (name.startsWith(BINDING_DELIMS.PROPERTY.start)) {\r\n            delims = BINDING_DELIMS.PROPERTY;\r\n        }\r\n        else if (name.startsWith(BINDING_DELIMS.EVENT.start)) {\r\n            delims = BINDING_DELIMS.EVENT;\r\n        }\r\n        if (delims !== null &&\r\n            // NOTE: older versions of the parser would match a start/end delimited\r\n            // binding iff the property name was terminated by the ending delimiter\r\n            // and the identifier in the binding was non-empty.\r\n            // TODO(ayazhafiz): update this to handle malformed bindings.\r\n            name.endsWith(delims.end) && name.length > delims.start.length + delims.end.length) {\r\n            const identifier = name.substring(delims.start.length, name.length - delims.end.length);\r\n            const keySpan = createKeySpan(srcSpan, delims.start, identifier);\r\n            if (delims.start === BINDING_DELIMS.BANANA_BOX.start) {\r\n                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\r\n                this.parseAssignmentEvent(identifier, value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents, keySpan);\r\n            }\r\n            else if (delims.start === BINDING_DELIMS.PROPERTY.start) {\r\n                this.bindingParser.parsePropertyBinding(identifier, value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\r\n            }\r\n            else {\r\n                const events = [];\r\n                this.bindingParser.parseEvent(identifier, value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events, keySpan);\r\n                addEvents(events, boundEvents);\r\n            }\r\n            return true;\r\n        }\r\n        // No explicit binding found.\r\n        const keySpan = createKeySpan(srcSpan, '' /* prefix */, name);\r\n        const hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties, keySpan);\r\n        return hasBinding;\r\n    }\r\n    _visitTextWithInterpolation(value, sourceSpan, i18n) {\r\n        const valueNoNgsp = replaceNgsp(value);\r\n        const expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan);\r\n        return expr ? new BoundText(expr, sourceSpan, i18n) : new Text(valueNoNgsp, sourceSpan);\r\n    }\r\n    parseVariable(identifier, value, sourceSpan, keySpan, valueSpan, variables) {\r\n        if (identifier.indexOf('-') > -1) {\r\n            this.reportError(`\"-\" is not allowed in variable names`, sourceSpan);\r\n        }\r\n        else if (identifier.length === 0) {\r\n            this.reportError(`Variable does not have a name`, sourceSpan);\r\n        }\r\n        variables.push(new Variable(identifier, value, sourceSpan, keySpan, valueSpan));\r\n    }\r\n    parseReference(identifier, value, sourceSpan, keySpan, valueSpan, references) {\r\n        if (identifier.indexOf('-') > -1) {\r\n            this.reportError(`\"-\" is not allowed in reference names`, sourceSpan);\r\n        }\r\n        else if (identifier.length === 0) {\r\n            this.reportError(`Reference does not have a name`, sourceSpan);\r\n        }\r\n        else if (references.some(reference => reference.name === identifier)) {\r\n            this.reportError(`Reference \"#${identifier}\" is defined more than once`, sourceSpan);\r\n        }\r\n        references.push(new Reference(identifier, value, sourceSpan, keySpan, valueSpan));\r\n    }\r\n    parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents, keySpan) {\r\n        const events = [];\r\n        this.bindingParser.parseEvent(`${name}Change`, `${expression}=$event`, sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events, keySpan);\r\n        addEvents(events, boundEvents);\r\n    }\r\n    reportError(message, sourceSpan, level = ParseErrorLevel.ERROR) {\r\n        this.errors.push(new ParseError(sourceSpan, message, level));\r\n    }\r\n}\r\nclass NonBindableVisitor$1 {\r\n    visitElement(ast) {\r\n        const preparsedElement = preparseElement(ast);\r\n        if (preparsedElement.type === PreparsedElementType.SCRIPT ||\r\n            preparsedElement.type === PreparsedElementType.STYLE ||\r\n            preparsedElement.type === PreparsedElementType.STYLESHEET) {\r\n            // Skipping <script> for security reasons\r\n            // Skipping <style> and stylesheets as we already processed them\r\n            // in the StyleCompiler\r\n            return null;\r\n        }\r\n        const children = visitAll$1(this, ast.children, null);\r\n        return new Element(ast.name, visitAll$1(this, ast.attrs), \r\n        /* inputs */ [], /* outputs */ [], children, /* references */ [], ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);\r\n    }\r\n    visitComment(comment) {\r\n        return null;\r\n    }\r\n    visitAttribute(attribute) {\r\n        return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.keySpan, attribute.valueSpan, attribute.i18n);\r\n    }\r\n    visitText(text) {\r\n        return new Text(text.value, text.sourceSpan);\r\n    }\r\n    visitExpansion(expansion) {\r\n        return null;\r\n    }\r\n    visitExpansionCase(expansionCase) {\r\n        return null;\r\n    }\r\n}\r\nconst NON_BINDABLE_VISITOR$1 = new NonBindableVisitor$1();\r\nfunction normalizeAttributeName(attrName) {\r\n    return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\r\n}\r\nfunction addEvents(events, boundEvents) {\r\n    boundEvents.push(...events.map(e => BoundEvent.fromParsedEvent(e)));\r\n}\r\nfunction isEmptyTextNode(node) {\r\n    return node instanceof Text$3 && node.value.trim().length == 0;\r\n}\r\nfunction isCommentNode(node) {\r\n    return node instanceof Comment$1;\r\n}\r\nfunction textContents(node) {\r\n    if (node.children.length !== 1 || !(node.children[0] instanceof Text$3)) {\r\n        return null;\r\n    }\r\n    else {\r\n        return node.children[0].value;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nvar TagType;\r\n(function (TagType) {\r\n    TagType[TagType[\"ELEMENT\"] = 0] = \"ELEMENT\";\r\n    TagType[TagType[\"TEMPLATE\"] = 1] = \"TEMPLATE\";\r\n})(TagType || (TagType = {}));\r\n/**\r\n * Generates an object that is used as a shared state between parent and all child contexts.\r\n */\r\nfunction setupRegistry() {\r\n    return { getUniqueId: getSeqNumberGenerator(), icus: new Map() };\r\n}\r\n/**\r\n * I18nContext is a helper class which keeps track of all i18n-related aspects\r\n * (accumulates placeholders, bindings, etc) between i18nStart and i18nEnd instructions.\r\n *\r\n * When we enter a nested template, the top-level context is being passed down\r\n * to the nested component, which uses this context to generate a child instance\r\n * of I18nContext class (to handle nested template) and at the end, reconciles it back\r\n * with the parent context.\r\n *\r\n * @param index Instruction index of i18nStart, which initiates this context\r\n * @param ref Reference to a translation const that represents the content if thus context\r\n * @param level Nestng level defined for child contexts\r\n * @param templateIndex Instruction index of a template which this context belongs to\r\n * @param meta Meta information (id, meaning, description, etc) associated with this context\r\n */\r\nclass I18nContext {\r\n    constructor(index, ref, level = 0, templateIndex = null, meta, registry) {\r\n        this.index = index;\r\n        this.ref = ref;\r\n        this.level = level;\r\n        this.templateIndex = templateIndex;\r\n        this.meta = meta;\r\n        this.registry = registry;\r\n        this.bindings = new Set();\r\n        this.placeholders = new Map();\r\n        this.isEmitted = false;\r\n        this._unresolvedCtxCount = 0;\r\n        this._registry = registry || setupRegistry();\r\n        this.id = this._registry.getUniqueId();\r\n    }\r\n    appendTag(type, node, index, closed) {\r\n        if (node.isVoid && closed) {\r\n            return; // ignore \"close\" for void tags\r\n        }\r\n        const ph = node.isVoid || !closed ? node.startName : node.closeName;\r\n        const content = { type, index, ctx: this.id, isVoid: node.isVoid, closed };\r\n        updatePlaceholderMap(this.placeholders, ph, content);\r\n    }\r\n    get icus() {\r\n        return this._registry.icus;\r\n    }\r\n    get isRoot() {\r\n        return this.level === 0;\r\n    }\r\n    get isResolved() {\r\n        return this._unresolvedCtxCount === 0;\r\n    }\r\n    getSerializedPlaceholders() {\r\n        const result = new Map();\r\n        this.placeholders.forEach((values, key) => result.set(key, values.map(serializePlaceholderValue)));\r\n        return result;\r\n    }\r\n    // public API to accumulate i18n-related content\r\n    appendBinding(binding) {\r\n        this.bindings.add(binding);\r\n    }\r\n    appendIcu(name, ref) {\r\n        updatePlaceholderMap(this._registry.icus, name, ref);\r\n    }\r\n    appendBoundText(node) {\r\n        const phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);\r\n        phs.forEach((values, key) => updatePlaceholderMap(this.placeholders, key, ...values));\r\n    }\r\n    appendTemplate(node, index) {\r\n        // add open and close tags at the same time,\r\n        // since we process nested templates separately\r\n        this.appendTag(TagType.TEMPLATE, node, index, false);\r\n        this.appendTag(TagType.TEMPLATE, node, index, true);\r\n        this._unresolvedCtxCount++;\r\n    }\r\n    appendElement(node, index, closed) {\r\n        this.appendTag(TagType.ELEMENT, node, index, closed);\r\n    }\r\n    appendProjection(node, index) {\r\n        // Add open and close tags at the same time, since `<ng-content>` has no content,\r\n        // so when we come across `<ng-content>` we can register both open and close tags.\r\n        // Note: runtime i18n logic doesn't distinguish `<ng-content>` tag placeholders and\r\n        // regular element tag placeholders, so we generate element placeholders for both types.\r\n        this.appendTag(TagType.ELEMENT, node, index, false);\r\n        this.appendTag(TagType.ELEMENT, node, index, true);\r\n    }\r\n    /**\r\n     * Generates an instance of a child context based on the root one,\r\n     * when we enter a nested template within I18n section.\r\n     *\r\n     * @param index Instruction index of corresponding i18nStart, which initiates this context\r\n     * @param templateIndex Instruction index of a template which this context belongs to\r\n     * @param meta Meta information (id, meaning, description, etc) associated with this context\r\n     *\r\n     * @returns I18nContext instance\r\n     */\r\n    forkChildContext(index, templateIndex, meta) {\r\n        return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);\r\n    }\r\n    /**\r\n     * Reconciles child context into parent one once the end of the i18n block is reached (i18nEnd).\r\n     *\r\n     * @param context Child I18nContext instance to be reconciled with parent context.\r\n     */\r\n    reconcileChildContext(context) {\r\n        // set the right context id for open and close\r\n        // template tags, so we can use it as sub-block ids\r\n        ['start', 'close'].forEach((op) => {\r\n            const key = context.meta[`${op}Name`];\r\n            const phs = this.placeholders.get(key) || [];\r\n            const tag = phs.find(findTemplateFn(this.id, context.templateIndex));\r\n            if (tag) {\r\n                tag.ctx = context.id;\r\n            }\r\n        });\r\n        // reconcile placeholders\r\n        const childPhs = context.placeholders;\r\n        childPhs.forEach((values, key) => {\r\n            const phs = this.placeholders.get(key);\r\n            if (!phs) {\r\n                this.placeholders.set(key, values);\r\n                return;\r\n            }\r\n            // try to find matching template...\r\n            const tmplIdx = phs.findIndex(findTemplateFn(context.id, context.templateIndex));\r\n            if (tmplIdx >= 0) {\r\n                // ... if found - replace it with nested template content\r\n                const isCloseTag = key.startsWith('CLOSE');\r\n                const isTemplateTag = key.endsWith('NG-TEMPLATE');\r\n                if (isTemplateTag) {\r\n                    // current template's content is placed before or after\r\n                    // parent template tag, depending on the open/close atrribute\r\n                    phs.splice(tmplIdx + (isCloseTag ? 0 : 1), 0, ...values);\r\n                }\r\n                else {\r\n                    const idx = isCloseTag ? values.length - 1 : 0;\r\n                    values[idx].tmpl = phs[tmplIdx];\r\n                    phs.splice(tmplIdx, 1, ...values);\r\n                }\r\n            }\r\n            else {\r\n                // ... otherwise just append content to placeholder value\r\n                phs.push(...values);\r\n            }\r\n            this.placeholders.set(key, phs);\r\n        });\r\n        this._unresolvedCtxCount--;\r\n    }\r\n}\r\n//\r\n// Helper methods\r\n//\r\nfunction wrap(symbol, index, contextId, closed) {\r\n    const state = closed ? '/' : '';\r\n    return wrapI18nPlaceholder(`${state}${symbol}${index}`, contextId);\r\n}\r\nfunction wrapTag(symbol, { index, ctx, isVoid }, closed) {\r\n    return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) :\r\n        wrap(symbol, index, ctx, closed);\r\n}\r\nfunction findTemplateFn(ctx, templateIndex) {\r\n    return (token) => typeof token === 'object' && token.type === TagType.TEMPLATE &&\r\n        token.index === templateIndex && token.ctx === ctx;\r\n}\r\nfunction serializePlaceholderValue(value) {\r\n    const element = (data, closed) => wrapTag('#', data, closed);\r\n    const template = (data, closed) => wrapTag('*', data, closed);\r\n    const projection = (data, closed) => wrapTag('!', data, closed);\r\n    switch (value.type) {\r\n        case TagType.ELEMENT:\r\n            // close element tag\r\n            if (value.closed) {\r\n                return element(value, true) + (value.tmpl ? template(value.tmpl, true) : '');\r\n            }\r\n            // open element tag that also initiates a template\r\n            if (value.tmpl) {\r\n                return template(value.tmpl) + element(value) +\r\n                    (value.isVoid ? template(value.tmpl, true) : '');\r\n            }\r\n            return element(value);\r\n        case TagType.TEMPLATE:\r\n            return template(value, value.closed);\r\n        default:\r\n            return value;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass IcuSerializerVisitor {\r\n    visitText(text) {\r\n        return text.value;\r\n    }\r\n    visitContainer(container) {\r\n        return container.children.map(child => child.visit(this)).join('');\r\n    }\r\n    visitIcu(icu) {\r\n        const strCases = Object.keys(icu.cases).map((k) => `${k} {${icu.cases[k].visit(this)}}`);\r\n        const result = `{${icu.expressionPlaceholder}, ${icu.type}, ${strCases.join(' ')}}`;\r\n        return result;\r\n    }\r\n    visitTagPlaceholder(ph) {\r\n        return ph.isVoid ?\r\n            this.formatPh(ph.startName) :\r\n            `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\r\n    }\r\n    visitPlaceholder(ph) {\r\n        return this.formatPh(ph.name);\r\n    }\r\n    visitIcuPlaceholder(ph, context) {\r\n        return this.formatPh(ph.name);\r\n    }\r\n    formatPh(value) {\r\n        return `{${formatI18nPlaceholderName(value, /* useCamelCase */ false)}}`;\r\n    }\r\n}\r\nconst serializer = new IcuSerializerVisitor();\r\nfunction serializeIcuNode(icu) {\r\n    return icu.visit(serializer);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst TAG_TO_PLACEHOLDER_NAMES = {\r\n    'A': 'LINK',\r\n    'B': 'BOLD_TEXT',\r\n    'BR': 'LINE_BREAK',\r\n    'EM': 'EMPHASISED_TEXT',\r\n    'H1': 'HEADING_LEVEL1',\r\n    'H2': 'HEADING_LEVEL2',\r\n    'H3': 'HEADING_LEVEL3',\r\n    'H4': 'HEADING_LEVEL4',\r\n    'H5': 'HEADING_LEVEL5',\r\n    'H6': 'HEADING_LEVEL6',\r\n    'HR': 'HORIZONTAL_RULE',\r\n    'I': 'ITALIC_TEXT',\r\n    'LI': 'LIST_ITEM',\r\n    'LINK': 'MEDIA_LINK',\r\n    'OL': 'ORDERED_LIST',\r\n    'P': 'PARAGRAPH',\r\n    'Q': 'QUOTATION',\r\n    'S': 'STRIKETHROUGH_TEXT',\r\n    'SMALL': 'SMALL_TEXT',\r\n    'SUB': 'SUBSTRIPT',\r\n    'SUP': 'SUPERSCRIPT',\r\n    'TBODY': 'TABLE_BODY',\r\n    'TD': 'TABLE_CELL',\r\n    'TFOOT': 'TABLE_FOOTER',\r\n    'TH': 'TABLE_HEADER_CELL',\r\n    'THEAD': 'TABLE_HEADER',\r\n    'TR': 'TABLE_ROW',\r\n    'TT': 'MONOSPACED_TEXT',\r\n    'U': 'UNDERLINED_TEXT',\r\n    'UL': 'UNORDERED_LIST',\r\n};\r\n/**\r\n * Creates unique names for placeholder with different content.\r\n *\r\n * Returns the same placeholder name when the content is identical.\r\n */\r\nclass PlaceholderRegistry {\r\n    constructor() {\r\n        // Count the occurrence of the base name top generate a unique name\r\n        this._placeHolderNameCounts = {};\r\n        // Maps signature to placeholder names\r\n        this._signatureToName = {};\r\n    }\r\n    getStartTagPlaceholderName(tag, attrs, isVoid) {\r\n        const signature = this._hashTag(tag, attrs, isVoid);\r\n        if (this._signatureToName[signature]) {\r\n            return this._signatureToName[signature];\r\n        }\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        const name = this._generateUniqueName(isVoid ? baseName : `START_${baseName}`);\r\n        this._signatureToName[signature] = name;\r\n        return name;\r\n    }\r\n    getCloseTagPlaceholderName(tag) {\r\n        const signature = this._hashClosingTag(tag);\r\n        if (this._signatureToName[signature]) {\r\n            return this._signatureToName[signature];\r\n        }\r\n        const upperTag = tag.toUpperCase();\r\n        const baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || `TAG_${upperTag}`;\r\n        const name = this._generateUniqueName(`CLOSE_${baseName}`);\r\n        this._signatureToName[signature] = name;\r\n        return name;\r\n    }\r\n    getPlaceholderName(name, content) {\r\n        const upperName = name.toUpperCase();\r\n        const signature = `PH: ${upperName}=${content}`;\r\n        if (this._signatureToName[signature]) {\r\n            return this._signatureToName[signature];\r\n        }\r\n        const uniqueName = this._generateUniqueName(upperName);\r\n        this._signatureToName[signature] = uniqueName;\r\n        return uniqueName;\r\n    }\r\n    getUniquePlaceholder(name) {\r\n        return this._generateUniqueName(name.toUpperCase());\r\n    }\r\n    // Generate a hash for a tag - does not take attribute order into account\r\n    _hashTag(tag, attrs, isVoid) {\r\n        const start = `<${tag}`;\r\n        const strAttrs = Object.keys(attrs).sort().map((name) => ` ${name}=${attrs[name]}`).join('');\r\n        const end = isVoid ? '/>' : `></${tag}>`;\r\n        return start + strAttrs + end;\r\n    }\r\n    _hashClosingTag(tag) {\r\n        return this._hashTag(`/${tag}`, {}, false);\r\n    }\r\n    _generateUniqueName(base) {\r\n        const seen = this._placeHolderNameCounts.hasOwnProperty(base);\r\n        if (!seen) {\r\n            this._placeHolderNameCounts[base] = 1;\r\n            return base;\r\n        }\r\n        const id = this._placeHolderNameCounts[base];\r\n        this._placeHolderNameCounts[base] = id + 1;\r\n        return `${base}_${id}`;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst _expParser = new Parser$1(new Lexer());\r\n/**\r\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\r\n */\r\nfunction createI18nMessageFactory(interpolationConfig) {\r\n    const visitor = new _I18nVisitor(_expParser, interpolationConfig);\r\n    return (nodes, meaning, description, customId, visitNodeFn) => visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);\r\n}\r\nfunction noopVisitNodeFn(_html, i18n) {\r\n    return i18n;\r\n}\r\nclass _I18nVisitor {\r\n    constructor(_expressionParser, _interpolationConfig) {\r\n        this._expressionParser = _expressionParser;\r\n        this._interpolationConfig = _interpolationConfig;\r\n    }\r\n    toI18nMessage(nodes, meaning = '', description = '', customId = '', visitNodeFn) {\r\n        const context = {\r\n            isIcu: nodes.length == 1 && nodes[0] instanceof Expansion,\r\n            icuDepth: 0,\r\n            placeholderRegistry: new PlaceholderRegistry(),\r\n            placeholderToContent: {},\r\n            placeholderToMessage: {},\r\n            visitNodeFn: visitNodeFn || noopVisitNodeFn,\r\n        };\r\n        const i18nodes = visitAll$1(this, nodes, context);\r\n        return new Message(i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description, customId);\r\n    }\r\n    visitElement(el, context) {\r\n        var _a;\r\n        const children = visitAll$1(this, el.children, context);\r\n        const attrs = {};\r\n        el.attrs.forEach(attr => {\r\n            // Do not visit the attributes, translatable ones are top-level ASTs\r\n            attrs[attr.name] = attr.value;\r\n        });\r\n        const isVoid = getHtmlTagDefinition(el.name).isVoid;\r\n        const startPhName = context.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\r\n        context.placeholderToContent[startPhName] = {\r\n            text: el.startSourceSpan.toString(),\r\n            sourceSpan: el.startSourceSpan,\r\n        };\r\n        let closePhName = '';\r\n        if (!isVoid) {\r\n            closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(el.name);\r\n            context.placeholderToContent[closePhName] = {\r\n                text: `</${el.name}>`,\r\n                sourceSpan: (_a = el.endSourceSpan) !== null && _a !== void 0 ? _a : el.sourceSpan,\r\n            };\r\n        }\r\n        const node = new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\r\n        return context.visitNodeFn(el, node);\r\n    }\r\n    visitAttribute(attribute, context) {\r\n        const node = this._visitTextWithInterpolation(attribute.value, attribute.valueSpan || attribute.sourceSpan, context, attribute.i18n);\r\n        return context.visitNodeFn(attribute, node);\r\n    }\r\n    visitText(text, context) {\r\n        const node = this._visitTextWithInterpolation(text.value, text.sourceSpan, context, text.i18n);\r\n        return context.visitNodeFn(text, node);\r\n    }\r\n    visitComment(comment, context) {\r\n        return null;\r\n    }\r\n    visitExpansion(icu, context) {\r\n        context.icuDepth++;\r\n        const i18nIcuCases = {};\r\n        const i18nIcu = new Icu$1(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\r\n        icu.cases.forEach((caze) => {\r\n            i18nIcuCases[caze.value] = new Container(caze.expression.map((node) => node.visit(this, context)), caze.expSourceSpan);\r\n        });\r\n        context.icuDepth--;\r\n        if (context.isIcu || context.icuDepth > 0) {\r\n            // Returns an ICU node when:\r\n            // - the message (vs a part of the message) is an ICU message, or\r\n            // - the ICU message is nested.\r\n            const expPh = context.placeholderRegistry.getUniquePlaceholder(`VAR_${icu.type}`);\r\n            i18nIcu.expressionPlaceholder = expPh;\r\n            context.placeholderToContent[expPh] = {\r\n                text: icu.switchValue,\r\n                sourceSpan: icu.switchValueSourceSpan,\r\n            };\r\n            return context.visitNodeFn(icu, i18nIcu);\r\n        }\r\n        // Else returns a placeholder\r\n        // ICU placeholders should not be replaced with their original content but with the their\r\n        // translations.\r\n        // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\r\n        const phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\r\n        context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);\r\n        const node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\r\n        return context.visitNodeFn(icu, node);\r\n    }\r\n    visitExpansionCase(_icuCase, _context) {\r\n        throw new Error('Unreachable code');\r\n    }\r\n    /**\r\n     * Split the, potentially interpolated, text up into text and placeholder pieces.\r\n     *\r\n     * @param text The potentially interpolated string to be split.\r\n     * @param sourceSpan The span of the whole of the `text` string.\r\n     * @param context The current context of the visitor, used to compute and store placeholders.\r\n     * @param previousI18n Any i18n metadata associated with this `text` from a previous pass.\r\n     */\r\n    _visitTextWithInterpolation(text, sourceSpan, context, previousI18n) {\r\n        const { strings, expressions } = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);\r\n        // No expressions, return a single text.\r\n        if (expressions.length === 0) {\r\n            return new Text$1(text, sourceSpan);\r\n        }\r\n        // Return a sequence of `Text` and `Placeholder` nodes grouped in a `Container`.\r\n        const nodes = [];\r\n        for (let i = 0; i < strings.length - 1; i++) {\r\n            this._addText(nodes, strings[i], sourceSpan);\r\n            this._addPlaceholder(nodes, context, expressions[i], sourceSpan);\r\n        }\r\n        // The last index contains no expression\r\n        this._addText(nodes, strings[strings.length - 1], sourceSpan);\r\n        // Whitespace removal may have invalidated the interpolation source-spans.\r\n        reusePreviousSourceSpans(nodes, previousI18n);\r\n        return new Container(nodes, sourceSpan);\r\n    }\r\n    /**\r\n     * Create a new `Text` node from the `textPiece` and add it to the `nodes` collection.\r\n     *\r\n     * @param nodes The nodes to which the created `Text` node should be added.\r\n     * @param textPiece The text and relative span information for this `Text` node.\r\n     * @param interpolationSpan The span of the whole interpolated text.\r\n     */\r\n    _addText(nodes, textPiece, interpolationSpan) {\r\n        if (textPiece.text.length > 0) {\r\n            // No need to add empty strings\r\n            const stringSpan = getOffsetSourceSpan(interpolationSpan, textPiece);\r\n            nodes.push(new Text$1(textPiece.text, stringSpan));\r\n        }\r\n    }\r\n    /**\r\n     * Create a new `Placeholder` node from the `expression` and add it to the `nodes` collection.\r\n     *\r\n     * @param nodes The nodes to which the created `Text` node should be added.\r\n     * @param context The current context of the visitor, used to compute and store placeholders.\r\n     * @param expression The expression text and relative span information for this `Placeholder`\r\n     *     node.\r\n     * @param interpolationSpan The span of the whole interpolated text.\r\n     */\r\n    _addPlaceholder(nodes, context, expression, interpolationSpan) {\r\n        const sourceSpan = getOffsetSourceSpan(interpolationSpan, expression);\r\n        const baseName = extractPlaceholderName(expression.text) || 'INTERPOLATION';\r\n        const phName = context.placeholderRegistry.getPlaceholderName(baseName, expression.text);\r\n        const text = this._interpolationConfig.start + expression.text + this._interpolationConfig.end;\r\n        context.placeholderToContent[phName] = { text, sourceSpan };\r\n        nodes.push(new Placeholder(expression.text, phName, sourceSpan));\r\n    }\r\n}\r\n/**\r\n * Re-use the source-spans from `previousI18n` metadata for the `nodes`.\r\n *\r\n * Whitespace removal can invalidate the source-spans of interpolation nodes, so we\r\n * reuse the source-span stored from a previous pass before the whitespace was removed.\r\n *\r\n * @param nodes The `Text` and `Placeholder` nodes to be processed.\r\n * @param previousI18n Any i18n metadata for these `nodes` stored from a previous pass.\r\n */\r\nfunction reusePreviousSourceSpans(nodes, previousI18n) {\r\n    if (previousI18n instanceof Message) {\r\n        // The `previousI18n` is an i18n `Message`, so we are processing an `Attribute` with i18n\r\n        // metadata. The `Message` should consist only of a single `Container` that contains the\r\n        // parts (`Text` and `Placeholder`) to process.\r\n        assertSingleContainerMessage(previousI18n);\r\n        previousI18n = previousI18n.nodes[0];\r\n    }\r\n    if (previousI18n instanceof Container) {\r\n        // The `previousI18n` is a `Container`, which means that this is a second i18n extraction pass\r\n        // after whitespace has been removed from the AST ndoes.\r\n        assertEquivalentNodes(previousI18n.children, nodes);\r\n        // Reuse the source-spans from the first pass.\r\n        for (let i = 0; i < nodes.length; i++) {\r\n            nodes[i].sourceSpan = previousI18n.children[i].sourceSpan;\r\n        }\r\n    }\r\n}\r\n/**\r\n * Asserts that the `message` contains exactly one `Container` node.\r\n */\r\nfunction assertSingleContainerMessage(message) {\r\n    const nodes = message.nodes;\r\n    if (nodes.length !== 1 || !(nodes[0] instanceof Container)) {\r\n        throw new Error('Unexpected previous i18n message - expected it to consist of only a single `Container` node.');\r\n    }\r\n}\r\n/**\r\n * Asserts that the `previousNodes` and `node` collections have the same number of elements and\r\n * corresponding elements have the same node type.\r\n */\r\nfunction assertEquivalentNodes(previousNodes, nodes) {\r\n    if (previousNodes.length !== nodes.length) {\r\n        throw new Error('The number of i18n message children changed between first and second pass.');\r\n    }\r\n    if (previousNodes.some((node, i) => nodes[i].constructor !== node.constructor)) {\r\n        throw new Error('The types of the i18n message children changed between first and second pass.');\r\n    }\r\n}\r\n/**\r\n * Create a new `ParseSourceSpan` from the `sourceSpan`, offset by the `start` and `end` values.\r\n */\r\nfunction getOffsetSourceSpan(sourceSpan, { start, end }) {\r\n    return new ParseSourceSpan(sourceSpan.fullStart.moveBy(start), sourceSpan.fullStart.moveBy(end));\r\n}\r\nconst _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\r\nfunction extractPlaceholderName(input) {\r\n    return input.split(_CUSTOM_PH_EXP)[2];\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * An i18n error.\r\n */\r\nclass I18nError extends ParseError {\r\n    constructor(span, msg) {\r\n        super(span, msg);\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst setI18nRefs = (htmlNode, i18nNode) => {\r\n    if (htmlNode instanceof NodeWithI18n) {\r\n        if (i18nNode instanceof IcuPlaceholder && htmlNode.i18n instanceof Message) {\r\n            // This html node represents an ICU but this is a second processing pass, and the legacy id\r\n            // was computed in the previous pass and stored in the `i18n` property as a message.\r\n            // We are about to wipe out that property so capture the previous message to be reused when\r\n            // generating the message for this ICU later. See `_generateI18nMessage()`.\r\n            i18nNode.previousMessage = htmlNode.i18n;\r\n        }\r\n        htmlNode.i18n = i18nNode;\r\n    }\r\n    return i18nNode;\r\n};\r\n/**\r\n * This visitor walks over HTML parse tree and converts information stored in\r\n * i18n-related attributes (\"i18n\" and \"i18n-*\") into i18n meta object that is\r\n * stored with other element's and attribute's information.\r\n */\r\nclass I18nMetaVisitor {\r\n    constructor(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG, keepI18nAttrs = false, enableI18nLegacyMessageIdFormat = false) {\r\n        this.interpolationConfig = interpolationConfig;\r\n        this.keepI18nAttrs = keepI18nAttrs;\r\n        this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat;\r\n        // whether visited nodes contain i18n information\r\n        this.hasI18nMeta = false;\r\n        this._errors = [];\r\n        // i18n message generation factory\r\n        this._createI18nMessage = createI18nMessageFactory(this.interpolationConfig);\r\n    }\r\n    _generateI18nMessage(nodes, meta = '', visitNodeFn) {\r\n        const { meaning, description, customId } = this._parseMetadata(meta);\r\n        const message = this._createI18nMessage(nodes, meaning, description, customId, visitNodeFn);\r\n        this._setMessageId(message, meta);\r\n        this._setLegacyIds(message, meta);\r\n        return message;\r\n    }\r\n    visitAllWithErrors(nodes) {\r\n        const result = nodes.map(node => node.visit(this, null));\r\n        return new ParseTreeResult(result, this._errors);\r\n    }\r\n    visitElement(element) {\r\n        if (hasI18nAttrs(element)) {\r\n            this.hasI18nMeta = true;\r\n            const attrs = [];\r\n            const attrsMeta = {};\r\n            for (const attr of element.attrs) {\r\n                if (attr.name === I18N_ATTR) {\r\n                    // root 'i18n' node attribute\r\n                    const i18n = element.i18n || attr.value;\r\n                    const message = this._generateI18nMessage(element.children, i18n, setI18nRefs);\r\n                    // do not assign empty i18n meta\r\n                    if (message.nodes.length) {\r\n                        element.i18n = message;\r\n                    }\r\n                }\r\n                else if (attr.name.startsWith(I18N_ATTR_PREFIX)) {\r\n                    // 'i18n-*' attributes\r\n                    const name = attr.name.slice(I18N_ATTR_PREFIX.length);\r\n                    if (isTrustedTypesSink(element.name, name)) {\r\n                        this._reportError(attr, `Translating attribute '${name}' is disallowed for security reasons.`);\r\n                    }\r\n                    else {\r\n                        attrsMeta[name] = attr.value;\r\n                    }\r\n                }\r\n                else {\r\n                    // non-i18n attributes\r\n                    attrs.push(attr);\r\n                }\r\n            }\r\n            // set i18n meta for attributes\r\n            if (Object.keys(attrsMeta).length) {\r\n                for (const attr of attrs) {\r\n                    const meta = attrsMeta[attr.name];\r\n                    // do not create translation for empty attributes\r\n                    if (meta !== undefined && attr.value) {\r\n                        attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);\r\n                    }\r\n                }\r\n            }\r\n            if (!this.keepI18nAttrs) {\r\n                // update element's attributes,\r\n                // keeping only non-i18n related ones\r\n                element.attrs = attrs;\r\n            }\r\n        }\r\n        visitAll$1(this, element.children, element.i18n);\r\n        return element;\r\n    }\r\n    visitExpansion(expansion, currentMessage) {\r\n        let message;\r\n        const meta = expansion.i18n;\r\n        this.hasI18nMeta = true;\r\n        if (meta instanceof IcuPlaceholder) {\r\n            // set ICU placeholder name (e.g. \"ICU_1\"),\r\n            // generated while processing root element contents,\r\n            // so we can reference it when we output translation\r\n            const name = meta.name;\r\n            message = this._generateI18nMessage([expansion], meta);\r\n            const icu = icuFromI18nMessage(message);\r\n            icu.name = name;\r\n        }\r\n        else {\r\n            // ICU is a top level message, try to use metadata from container element if provided via\r\n            // `context` argument. Note: context may not be available for standalone ICUs (without\r\n            // wrapping element), so fallback to ICU metadata in this case.\r\n            message = this._generateI18nMessage([expansion], currentMessage || meta);\r\n        }\r\n        expansion.i18n = message;\r\n        return expansion;\r\n    }\r\n    visitText(text) {\r\n        return text;\r\n    }\r\n    visitAttribute(attribute) {\r\n        return attribute;\r\n    }\r\n    visitComment(comment) {\r\n        return comment;\r\n    }\r\n    visitExpansionCase(expansionCase) {\r\n        return expansionCase;\r\n    }\r\n    /**\r\n     * Parse the general form `meta` passed into extract the explicit metadata needed to create a\r\n     * `Message`.\r\n     *\r\n     * There are three possibilities for the `meta` variable\r\n     * 1) a string from an `i18n` template attribute: parse it to extract the metadata values.\r\n     * 2) a `Message` from a previous processing pass: reuse the metadata values in the message.\r\n     * 4) other: ignore this and just process the message metadata as normal\r\n     *\r\n     * @param meta the bucket that holds information about the message\r\n     * @returns the parsed metadata.\r\n     */\r\n    _parseMetadata(meta) {\r\n        return typeof meta === 'string' ? parseI18nMeta(meta) :\r\n            meta instanceof Message ? meta : {};\r\n    }\r\n    /**\r\n     * Generate (or restore) message id if not specified already.\r\n     */\r\n    _setMessageId(message, meta) {\r\n        if (!message.id) {\r\n            message.id = meta instanceof Message && meta.id || decimalDigest(message);\r\n        }\r\n    }\r\n    /**\r\n     * Update the `message` with a `legacyId` if necessary.\r\n     *\r\n     * @param message the message whose legacy id should be set\r\n     * @param meta information about the message being processed\r\n     */\r\n    _setLegacyIds(message, meta) {\r\n        if (this.enableI18nLegacyMessageIdFormat) {\r\n            message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];\r\n        }\r\n        else if (typeof meta !== 'string') {\r\n            // This occurs if we are doing the 2nd pass after whitespace removal (see `parseTemplate()` in\r\n            // `packages/compiler/src/render3/view/template.ts`).\r\n            // In that case we want to reuse the legacy message generated in the 1st pass (see\r\n            // `setI18nRefs()`).\r\n            const previousMessage = meta instanceof Message ?\r\n                meta :\r\n                meta instanceof IcuPlaceholder ? meta.previousMessage : undefined;\r\n            message.legacyIds = previousMessage ? previousMessage.legacyIds : [];\r\n        }\r\n    }\r\n    _reportError(node, msg) {\r\n        this._errors.push(new I18nError(node.sourceSpan, msg));\r\n    }\r\n}\r\n/** I18n separators for metadata **/\r\nconst I18N_MEANING_SEPARATOR = '|';\r\nconst I18N_ID_SEPARATOR = '@@';\r\n/**\r\n * Parses i18n metas like:\r\n *  - \"@@id\",\r\n *  - \"description[@@id]\",\r\n *  - \"meaning|description[@@id]\"\r\n * and returns an object with parsed output.\r\n *\r\n * @param meta String that represents i18n meta\r\n * @returns Object with id, meaning and description fields\r\n */\r\nfunction parseI18nMeta(meta = '') {\r\n    let customId;\r\n    let meaning;\r\n    let description;\r\n    meta = meta.trim();\r\n    if (meta) {\r\n        const idIndex = meta.indexOf(I18N_ID_SEPARATOR);\r\n        const descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);\r\n        let meaningAndDesc;\r\n        [meaningAndDesc, customId] =\r\n            (idIndex > -1) ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];\r\n        [meaning, description] = (descIndex > -1) ?\r\n            [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\r\n            ['', meaningAndDesc];\r\n    }\r\n    return { customId, meaning, description };\r\n}\r\n// Converts i18n meta information for a message (id, description, meaning)\r\n// to a JsDoc statement formatted as expected by the Closure compiler.\r\nfunction i18nMetaToJSDoc(meta) {\r\n    const tags = [];\r\n    if (meta.description) {\r\n        tags.push({ tagName: \"desc\" /* Desc */, text: meta.description });\r\n    }\r\n    if (meta.meaning) {\r\n        tags.push({ tagName: \"meaning\" /* Meaning */, text: meta.meaning });\r\n    }\r\n    return tags.length == 0 ? null : jsDocComment(tags);\r\n}\r\n\r\n/** Closure uses `goog.getMsg(message)` to lookup translations */\r\nconst GOOG_GET_MSG = 'goog.getMsg';\r\nfunction createGoogleGetMsgStatements(variable$1, message, closureVar, params) {\r\n    const messageString = serializeI18nMessageForGetMsg(message);\r\n    const args = [literal(messageString)];\r\n    if (Object.keys(params).length) {\r\n        args.push(mapLiteral(params, true));\r\n    }\r\n    // /**\r\n    //  * @desc description of message\r\n    //  * @meaning meaning of message\r\n    //  */\r\n    // const MSG_... = goog.getMsg(..);\r\n    // I18N_X = MSG_...;\r\n    const googGetMsgStmt = closureVar.set(variable(GOOG_GET_MSG).callFn(args)).toConstDecl();\r\n    const metaComment = i18nMetaToJSDoc(message);\r\n    if (metaComment !== null) {\r\n        googGetMsgStmt.addLeadingComment(metaComment);\r\n    }\r\n    const i18nAssignmentStmt = new ExpressionStatement(variable$1.set(closureVar));\r\n    return [googGetMsgStmt, i18nAssignmentStmt];\r\n}\r\n/**\r\n * This visitor walks over i18n tree and generates its string representation, including ICUs and\r\n * placeholders in `{$placeholder}` (for plain messages) or `{PLACEHOLDER}` (inside ICUs) format.\r\n */\r\nclass GetMsgSerializerVisitor {\r\n    formatPh(value) {\r\n        return `{$${formatI18nPlaceholderName(value)}}`;\r\n    }\r\n    visitText(text) {\r\n        return text.value;\r\n    }\r\n    visitContainer(container) {\r\n        return container.children.map(child => child.visit(this)).join('');\r\n    }\r\n    visitIcu(icu) {\r\n        return serializeIcuNode(icu);\r\n    }\r\n    visitTagPlaceholder(ph) {\r\n        return ph.isVoid ?\r\n            this.formatPh(ph.startName) :\r\n            `${this.formatPh(ph.startName)}${ph.children.map(child => child.visit(this)).join('')}${this.formatPh(ph.closeName)}`;\r\n    }\r\n    visitPlaceholder(ph) {\r\n        return this.formatPh(ph.name);\r\n    }\r\n    visitIcuPlaceholder(ph, context) {\r\n        return this.formatPh(ph.name);\r\n    }\r\n}\r\nconst serializerVisitor$1 = new GetMsgSerializerVisitor();\r\nfunction serializeI18nMessageForGetMsg(message) {\r\n    return message.nodes.map(node => node.visit(serializerVisitor$1, null)).join('');\r\n}\r\n\r\nfunction createLocalizeStatements(variable, message, params) {\r\n    const { messageParts, placeHolders } = serializeI18nMessageForLocalize(message);\r\n    const sourceSpan = getSourceSpan(message);\r\n    const expressions = placeHolders.map(ph => params[ph.text]);\r\n    const localizedString$1 = localizedString(message, messageParts, placeHolders, expressions, sourceSpan);\r\n    const variableInitialization = variable.set(localizedString$1);\r\n    return [new ExpressionStatement(variableInitialization)];\r\n}\r\n/**\r\n * This visitor walks over an i18n tree, capturing literal strings and placeholders.\r\n *\r\n * The result can be used for generating the `$localize` tagged template literals.\r\n */\r\nclass LocalizeSerializerVisitor {\r\n    visitText(text, context) {\r\n        if (context[context.length - 1] instanceof LiteralPiece) {\r\n            // Two literal pieces in a row means that there was some comment node in-between.\r\n            context[context.length - 1].text += text.value;\r\n        }\r\n        else {\r\n            context.push(new LiteralPiece(text.value, text.sourceSpan));\r\n        }\r\n    }\r\n    visitContainer(container, context) {\r\n        container.children.forEach(child => child.visit(this, context));\r\n    }\r\n    visitIcu(icu, context) {\r\n        context.push(new LiteralPiece(serializeIcuNode(icu), icu.sourceSpan));\r\n    }\r\n    visitTagPlaceholder(ph, context) {\r\n        var _a, _b;\r\n        context.push(this.createPlaceholderPiece(ph.startName, (_a = ph.startSourceSpan) !== null && _a !== void 0 ? _a : ph.sourceSpan));\r\n        if (!ph.isVoid) {\r\n            ph.children.forEach(child => child.visit(this, context));\r\n            context.push(this.createPlaceholderPiece(ph.closeName, (_b = ph.endSourceSpan) !== null && _b !== void 0 ? _b : ph.sourceSpan));\r\n        }\r\n    }\r\n    visitPlaceholder(ph, context) {\r\n        context.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));\r\n    }\r\n    visitIcuPlaceholder(ph, context) {\r\n        context.push(this.createPlaceholderPiece(ph.name, ph.sourceSpan));\r\n    }\r\n    createPlaceholderPiece(name, sourceSpan) {\r\n        return new PlaceholderPiece(formatI18nPlaceholderName(name, /* useCamelCase */ false), sourceSpan);\r\n    }\r\n}\r\nconst serializerVisitor$2 = new LocalizeSerializerVisitor();\r\n/**\r\n * Serialize an i18n message into two arrays: messageParts and placeholders.\r\n *\r\n * These arrays will be used to generate `$localize` tagged template literals.\r\n *\r\n * @param message The message to be serialized.\r\n * @returns an object containing the messageParts and placeholders.\r\n */\r\nfunction serializeI18nMessageForLocalize(message) {\r\n    const pieces = [];\r\n    message.nodes.forEach(node => node.visit(serializerVisitor$2, pieces));\r\n    return processMessagePieces(pieces);\r\n}\r\nfunction getSourceSpan(message) {\r\n    const startNode = message.nodes[0];\r\n    const endNode = message.nodes[message.nodes.length - 1];\r\n    return new ParseSourceSpan(startNode.sourceSpan.start, endNode.sourceSpan.end, startNode.sourceSpan.fullStart, startNode.sourceSpan.details);\r\n}\r\n/**\r\n * Convert the list of serialized MessagePieces into two arrays.\r\n *\r\n * One contains the literal string pieces and the other the placeholders that will be replaced by\r\n * expressions when rendering `$localize` tagged template literals.\r\n *\r\n * @param pieces The pieces to process.\r\n * @returns an object containing the messageParts and placeholders.\r\n */\r\nfunction processMessagePieces(pieces) {\r\n    const messageParts = [];\r\n    const placeHolders = [];\r\n    if (pieces[0] instanceof PlaceholderPiece) {\r\n        // The first piece was a placeholder so we need to add an initial empty message part.\r\n        messageParts.push(createEmptyMessagePart(pieces[0].sourceSpan.start));\r\n    }\r\n    for (let i = 0; i < pieces.length; i++) {\r\n        const part = pieces[i];\r\n        if (part instanceof LiteralPiece) {\r\n            messageParts.push(part);\r\n        }\r\n        else {\r\n            placeHolders.push(part);\r\n            if (pieces[i - 1] instanceof PlaceholderPiece) {\r\n                // There were two placeholders in a row, so we need to add an empty message part.\r\n                messageParts.push(createEmptyMessagePart(pieces[i - 1].sourceSpan.end));\r\n            }\r\n        }\r\n    }\r\n    if (pieces[pieces.length - 1] instanceof PlaceholderPiece) {\r\n        // The last piece was a placeholder so we need to add a final empty message part.\r\n        messageParts.push(createEmptyMessagePart(pieces[pieces.length - 1].sourceSpan.end));\r\n    }\r\n    return { messageParts, placeHolders };\r\n}\r\nfunction createEmptyMessagePart(location) {\r\n    return new LiteralPiece('', new ParseSourceSpan(location, location));\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n// Selector attribute name of `<ng-content>`\r\nconst NG_CONTENT_SELECT_ATTR$1 = 'select';\r\n// Attribute name of `ngProjectAs`.\r\nconst NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs';\r\n// Global symbols available only inside event bindings.\r\nconst EVENT_BINDING_SCOPE_GLOBALS = new Set(['$event']);\r\n// List of supported global targets for event listeners\r\nconst GLOBAL_TARGET_RESOLVERS = new Map([['window', Identifiers.resolveWindow], ['document', Identifiers.resolveDocument], ['body', Identifiers.resolveBody]]);\r\nconst LEADING_TRIVIA_CHARS = [' ', '\\n', '\\r', '\\t'];\r\n//  if (rf & flags) { .. }\r\nfunction renderFlagCheckIfStmt(flags, statements) {\r\n    return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null, false), statements);\r\n}\r\nfunction prepareEventListenerParameters(eventAst, handlerName = null, scope = null) {\r\n    const { type, name, target, phase, handler } = eventAst;\r\n    if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {\r\n        throw new Error(`Unexpected global target '${target}' defined for '${name}' event.\r\n        Supported list of global targets: ${Array.from(GLOBAL_TARGET_RESOLVERS.keys())}.`);\r\n    }\r\n    const eventArgumentName = '$event';\r\n    const implicitReceiverAccesses = new Set();\r\n    const implicitReceiverExpr = (scope === null || scope.bindingLevel === 0) ?\r\n        variable(CONTEXT_NAME) :\r\n        scope.getOrCreateSharedContextVar(0);\r\n    const bindingExpr = convertActionBinding(scope, implicitReceiverExpr, handler, 'b', () => error('Unexpected interpolation'), eventAst.handlerSpan, implicitReceiverAccesses, EVENT_BINDING_SCOPE_GLOBALS);\r\n    const statements = [];\r\n    if (scope) {\r\n        // `variableDeclarations` needs to run first, because\r\n        // `restoreViewStatement` depends on the result.\r\n        statements.push(...scope.variableDeclarations());\r\n        statements.unshift(...scope.restoreViewStatement());\r\n    }\r\n    statements.push(...bindingExpr.render3Stmts);\r\n    const eventName = type === 1 /* Animation */ ? prepareSyntheticListenerName(name, phase) : name;\r\n    const fnName = handlerName && sanitizeIdentifier(handlerName);\r\n    const fnArgs = [];\r\n    if (implicitReceiverAccesses.has(eventArgumentName)) {\r\n        fnArgs.push(new FnParam(eventArgumentName, DYNAMIC_TYPE));\r\n    }\r\n    const handlerFn = fn(fnArgs, statements, INFERRED_TYPE, null, fnName);\r\n    const params = [literal(eventName), handlerFn];\r\n    if (target) {\r\n        params.push(literal(false), // `useCapture` flag, defaults to `false`\r\n        importExpr(GLOBAL_TARGET_RESOLVERS.get(target)));\r\n    }\r\n    return params;\r\n}\r\nfunction createComponentDefConsts() {\r\n    return {\r\n        prepareStatements: [],\r\n        constExpressions: [],\r\n        i18nVarRefsCache: new Map(),\r\n    };\r\n}\r\nclass TemplateDefinitionBuilder {\r\n    constructor(constantPool, parentBindingScope, level = 0, contextName, i18nContext, templateIndex, templateName, directiveMatcher, directives, pipeTypeByName, pipes, _namespace, relativeContextFilePath, i18nUseExternalIds, _constants = createComponentDefConsts()) {\r\n        this.constantPool = constantPool;\r\n        this.level = level;\r\n        this.contextName = contextName;\r\n        this.i18nContext = i18nContext;\r\n        this.templateIndex = templateIndex;\r\n        this.templateName = templateName;\r\n        this.directiveMatcher = directiveMatcher;\r\n        this.directives = directives;\r\n        this.pipeTypeByName = pipeTypeByName;\r\n        this.pipes = pipes;\r\n        this._namespace = _namespace;\r\n        this.i18nUseExternalIds = i18nUseExternalIds;\r\n        this._constants = _constants;\r\n        this._dataIndex = 0;\r\n        this._bindingContext = 0;\r\n        this._prefixCode = [];\r\n        /**\r\n         * List of callbacks to generate creation mode instructions. We store them here as we process\r\n         * the template so bindings in listeners are resolved only once all nodes have been visited.\r\n         * This ensures all local refs and context variables are available for matching.\r\n         */\r\n        this._creationCodeFns = [];\r\n        /**\r\n         * List of callbacks to generate update mode instructions. We store them here as we process\r\n         * the template so bindings are resolved only once all nodes have been visited. This ensures\r\n         * all local refs and context variables are available for matching.\r\n         */\r\n        this._updateCodeFns = [];\r\n        /** Index of the currently-selected node. */\r\n        this._currentIndex = 0;\r\n        /** Temporary variable declarations generated from visiting pipes, literals, etc. */\r\n        this._tempVariables = [];\r\n        /**\r\n         * List of callbacks to build nested templates. Nested templates must not be visited until\r\n         * after the parent template has finished visiting all of its nodes. This ensures that all\r\n         * local ref bindings in nested templates are able to find local ref values if the refs\r\n         * are defined after the template declaration.\r\n         */\r\n        this._nestedTemplateFns = [];\r\n        this._unsupported = unsupported;\r\n        // i18n context local to this template\r\n        this.i18n = null;\r\n        // Number of slots to reserve for pureFunctions\r\n        this._pureFunctionSlots = 0;\r\n        // Number of binding slots\r\n        this._bindingSlots = 0;\r\n        // Projection slots found in the template. Projection slots can distribute projected\r\n        // nodes based on a selector, or can just use the wildcard selector to match\r\n        // all nodes which aren't matching any selector.\r\n        this._ngContentReservedSlots = [];\r\n        // Number of non-default selectors found in all parent templates of this template. We need to\r\n        // track it to properly adjust projection slot index in the `projection` instruction.\r\n        this._ngContentSelectorsOffset = 0;\r\n        // Expression that should be used as implicit receiver when converting template\r\n        // expressions to output AST.\r\n        this._implicitReceiverExpr = null;\r\n        // These should be handled in the template or element directly.\r\n        this.visitReference = invalid$1;\r\n        this.visitVariable = invalid$1;\r\n        this.visitTextAttribute = invalid$1;\r\n        this.visitBoundAttribute = invalid$1;\r\n        this.visitBoundEvent = invalid$1;\r\n        this._bindingScope = parentBindingScope.nestedScope(level);\r\n        // Turn the relative context file path into an identifier by replacing non-alphanumeric\r\n        // characters with underscores.\r\n        this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';\r\n        this._valueConverter = new ValueConverter(constantPool, () => this.allocateDataSlot(), (numSlots) => this.allocatePureFunctionSlots(numSlots), (name, localName, slot, value) => {\r\n            const pipeType = pipeTypeByName.get(name);\r\n            if (pipeType) {\r\n                this.pipes.add(pipeType);\r\n            }\r\n            this._bindingScope.set(this.level, localName, value);\r\n            this.creationInstruction(null, Identifiers.pipe, [literal(slot), literal(name)]);\r\n        });\r\n    }\r\n    buildTemplateFunction(nodes, variables, ngContentSelectorsOffset = 0, i18n) {\r\n        this._ngContentSelectorsOffset = ngContentSelectorsOffset;\r\n        if (this._namespace !== Identifiers.namespaceHTML) {\r\n            this.creationInstruction(null, this._namespace);\r\n        }\r\n        // Create variable bindings\r\n        variables.forEach(v => this.registerContextVariables(v));\r\n        // Initiate i18n context in case:\r\n        // - this template has parent i18n context\r\n        // - or the template has i18n meta associated with it,\r\n        //   but it's not initiated by the Element (e.g. <ng-template i18n>)\r\n        const initI18nContext = this.i18nContext ||\r\n            (isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) &&\r\n                !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n));\r\n        const selfClosingI18nInstruction = hasTextChildrenOnly(nodes);\r\n        if (initI18nContext) {\r\n            this.i18nStart(null, i18n, selfClosingI18nInstruction);\r\n        }\r\n        // This is the initial pass through the nodes of this template. In this pass, we\r\n        // queue all creation mode and update mode instructions for generation in the second\r\n        // pass. It's necessary to separate the passes to ensure local refs are defined before\r\n        // resolving bindings. We also count bindings in this pass as we walk bound expressions.\r\n        visitAll(this, nodes);\r\n        // Add total binding count to pure function count so pure function instructions are\r\n        // generated with the correct slot offset when update instructions are processed.\r\n        this._pureFunctionSlots += this._bindingSlots;\r\n        // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and\r\n        // `pipeBind` update instructions), so we have to update the slot offsets manually\r\n        // to account for bindings.\r\n        this._valueConverter.updatePipeSlotOffsets(this._bindingSlots);\r\n        // Nested templates must be processed before creation instructions so template()\r\n        // instructions can be generated with the correct internal const count.\r\n        this._nestedTemplateFns.forEach(buildTemplateFn => buildTemplateFn());\r\n        // Output the `projectionDef` instruction when some `<ng-content>` tags are present.\r\n        // The `projectionDef` instruction is only emitted for the component template and\r\n        // is skipped for nested templates (<ng-template> tags).\r\n        if (this.level === 0 && this._ngContentReservedSlots.length) {\r\n            const parameters = [];\r\n            // By default the `projectionDef` instructions creates one slot for the wildcard\r\n            // selector if no parameters are passed. Therefore we only want to allocate a new\r\n            // array for the projection slots if the default projection slot is not sufficient.\r\n            if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== '*') {\r\n                const r3ReservedSlots = this._ngContentReservedSlots.map(s => s !== '*' ? parseSelectorToR3Selector(s) : s);\r\n                parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));\r\n            }\r\n            // Since we accumulate ngContent selectors while processing template elements,\r\n            // we *prepend* `projectionDef` to creation instructions block, to put it before\r\n            // any `projection` instructions\r\n            this.creationInstruction(null, Identifiers.projectionDef, parameters, /* prepend */ true);\r\n        }\r\n        if (initI18nContext) {\r\n            this.i18nEnd(null, selfClosingI18nInstruction);\r\n        }\r\n        // Generate all the creation mode instructions (e.g. resolve bindings in listeners)\r\n        const creationStatements = this._creationCodeFns.map((fn) => fn());\r\n        // Generate all the update mode instructions (e.g. resolve property or text bindings)\r\n        const updateStatements = this._updateCodeFns.map((fn) => fn());\r\n        //  Variable declaration must occur after binding resolution so we can generate context\r\n        //  instructions that build on each other.\r\n        // e.g. const b = nextContext().$implicit(); const b = nextContext();\r\n        const creationVariables = this._bindingScope.viewSnapshotStatements();\r\n        const updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);\r\n        const creationBlock = creationStatements.length > 0 ?\r\n            [renderFlagCheckIfStmt(1 /* Create */, creationVariables.concat(creationStatements))] :\r\n            [];\r\n        const updateBlock = updateStatements.length > 0 ?\r\n            [renderFlagCheckIfStmt(2 /* Update */, updateVariables.concat(updateStatements))] :\r\n            [];\r\n        return fn(\r\n        // i.e. (rf: RenderFlags, ctx: any)\r\n        [new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [\r\n            // Temporary variable declarations for query refresh (i.e. let _t: any;)\r\n            ...this._prefixCode,\r\n            // Creating mode (i.e. if (rf & RenderFlags.Create) { ... })\r\n            ...creationBlock,\r\n            // Binding and refresh mode (i.e. if (rf & RenderFlags.Update) {...})\r\n            ...updateBlock,\r\n        ], INFERRED_TYPE, null, this.templateName);\r\n    }\r\n    // LocalResolver\r\n    getLocal(name) {\r\n        return this._bindingScope.get(name);\r\n    }\r\n    // LocalResolver\r\n    notifyImplicitReceiverUse() {\r\n        this._bindingScope.notifyImplicitReceiverUse();\r\n    }\r\n    // LocalResolver\r\n    maybeRestoreView(retrievalLevel, localRefLookup) {\r\n        this._bindingScope.maybeRestoreView(retrievalLevel, localRefLookup);\r\n    }\r\n    i18nTranslate(message, params = {}, ref, transformFn) {\r\n        const _ref = ref || this.i18nGenerateMainBlockVar();\r\n        // Closure Compiler requires const names to start with `MSG_` but disallows any other const to\r\n        // start with `MSG_`. We define a variable starting with `MSG_` just for the `goog.getMsg` call\r\n        const closureVar = this.i18nGenerateClosureVar(message.id);\r\n        const statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);\r\n        this._constants.prepareStatements.push(...statements);\r\n        return _ref;\r\n    }\r\n    registerContextVariables(variable$1) {\r\n        const scopedName = this._bindingScope.freshReferenceName();\r\n        const retrievalLevel = this.level;\r\n        const lhs = variable(variable$1.name + scopedName);\r\n        this._bindingScope.set(retrievalLevel, variable$1.name, lhs, 1 /* CONTEXT */, (scope, relativeLevel) => {\r\n            let rhs;\r\n            if (scope.bindingLevel === retrievalLevel) {\r\n                if (scope.isListenerScope() && scope.hasRestoreViewVariable()) {\r\n                    // e.g. restoredCtx.\r\n                    // We have to get the context from a view reference, if one is available, because\r\n                    // the context that was passed in during creation may not be correct anymore.\r\n                    // For more information see: https://github.com/angular/angular/pull/40360.\r\n                    rhs = variable(RESTORED_VIEW_CONTEXT_NAME);\r\n                    scope.notifyRestoredViewContextUse();\r\n                }\r\n                else {\r\n                    // e.g. ctx\r\n                    rhs = variable(CONTEXT_NAME);\r\n                }\r\n            }\r\n            else {\r\n                const sharedCtxVar = scope.getSharedContextName(retrievalLevel);\r\n                // e.g. ctx_r0   OR  x(2);\r\n                rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);\r\n            }\r\n            // e.g. const $item$ = x(2).$implicit;\r\n            return [lhs.set(rhs.prop(variable$1.value || IMPLICIT_REFERENCE)).toConstDecl()];\r\n        });\r\n    }\r\n    i18nAppendBindings(expressions) {\r\n        if (expressions.length > 0) {\r\n            expressions.forEach(expression => this.i18n.appendBinding(expression));\r\n        }\r\n    }\r\n    i18nBindProps(props) {\r\n        const bound = {};\r\n        Object.keys(props).forEach(key => {\r\n            const prop = props[key];\r\n            if (prop instanceof Text) {\r\n                bound[key] = literal(prop.value);\r\n            }\r\n            else {\r\n                const value = prop.value.visit(this._valueConverter);\r\n                this.allocateBindingSlots(value);\r\n                if (value instanceof Interpolation) {\r\n                    const { strings, expressions } = value;\r\n                    const { id, bindings } = this.i18n;\r\n                    const label = assembleI18nBoundString(strings, bindings.size, id);\r\n                    this.i18nAppendBindings(expressions);\r\n                    bound[key] = literal(label);\r\n                }\r\n            }\r\n        });\r\n        return bound;\r\n    }\r\n    // Generates top level vars for i18n blocks (i.e. `i18n_N`).\r\n    i18nGenerateMainBlockVar() {\r\n        return variable(this.constantPool.uniqueName(TRANSLATION_VAR_PREFIX));\r\n    }\r\n    // Generates vars with Closure-specific names for i18n blocks (i.e. `MSG_XXX`).\r\n    i18nGenerateClosureVar(messageId) {\r\n        let name;\r\n        const suffix = this.fileBasedI18nSuffix.toUpperCase();\r\n        if (this.i18nUseExternalIds) {\r\n            const prefix = getTranslationConstPrefix(`EXTERNAL_`);\r\n            const uniqueSuffix = this.constantPool.uniqueName(suffix);\r\n            name = `${prefix}${sanitizeIdentifier(messageId)}$$${uniqueSuffix}`;\r\n        }\r\n        else {\r\n            const prefix = getTranslationConstPrefix(suffix);\r\n            name = this.constantPool.uniqueName(prefix);\r\n        }\r\n        return variable(name);\r\n    }\r\n    i18nUpdateRef(context) {\r\n        const { icus, meta, isRoot, isResolved, isEmitted } = context;\r\n        if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {\r\n            context.isEmitted = true;\r\n            const placeholders = context.getSerializedPlaceholders();\r\n            let icuMapping = {};\r\n            let params = placeholders.size ? placeholdersToParams(placeholders) : {};\r\n            if (icus.size) {\r\n                icus.forEach((refs, key) => {\r\n                    if (refs.length === 1) {\r\n                        // if we have one ICU defined for a given\r\n                        // placeholder - just output its reference\r\n                        params[key] = refs[0];\r\n                    }\r\n                    else {\r\n                        // ... otherwise we need to activate post-processing\r\n                        // to replace ICU placeholders with proper values\r\n                        const placeholder = wrapI18nPlaceholder(`${I18N_ICU_MAPPING_PREFIX}${key}`);\r\n                        params[key] = literal(placeholder);\r\n                        icuMapping[key] = literalArr(refs);\r\n                    }\r\n                });\r\n            }\r\n            // translation requires post processing in 2 cases:\r\n            // - if we have placeholders with multiple values (ex. `START_DIV`: [�#1�, �#2�, ...])\r\n            // - if we have multiple ICUs that refer to the same placeholder name\r\n            const needsPostprocessing = Array.from(placeholders.values()).some((value) => value.length > 1) ||\r\n                Object.keys(icuMapping).length;\r\n            let transformFn;\r\n            if (needsPostprocessing) {\r\n                transformFn = (raw) => {\r\n                    const args = [raw];\r\n                    if (Object.keys(icuMapping).length) {\r\n                        args.push(mapLiteral(icuMapping, true));\r\n                    }\r\n                    return instruction(null, Identifiers.i18nPostprocess, args);\r\n                };\r\n            }\r\n            this.i18nTranslate(meta, params, context.ref, transformFn);\r\n        }\r\n    }\r\n    i18nStart(span = null, meta, selfClosing) {\r\n        const index = this.allocateDataSlot();\r\n        this.i18n = this.i18nContext ?\r\n            this.i18nContext.forkChildContext(index, this.templateIndex, meta) :\r\n            new I18nContext(index, this.i18nGenerateMainBlockVar(), 0, this.templateIndex, meta);\r\n        // generate i18nStart instruction\r\n        const { id, ref } = this.i18n;\r\n        const params = [literal(index), this.addToConsts(ref)];\r\n        if (id > 0) {\r\n            // do not push 3rd argument (sub-block id)\r\n            // into i18nStart call for top level i18n context\r\n            params.push(literal(id));\r\n        }\r\n        this.creationInstruction(span, selfClosing ? Identifiers.i18n : Identifiers.i18nStart, params);\r\n    }\r\n    i18nEnd(span = null, selfClosing) {\r\n        if (!this.i18n) {\r\n            throw new Error('i18nEnd is executed with no i18n context present');\r\n        }\r\n        if (this.i18nContext) {\r\n            this.i18nContext.reconcileChildContext(this.i18n);\r\n            this.i18nUpdateRef(this.i18nContext);\r\n        }\r\n        else {\r\n            this.i18nUpdateRef(this.i18n);\r\n        }\r\n        // setup accumulated bindings\r\n        const { index, bindings } = this.i18n;\r\n        if (bindings.size) {\r\n            const chainBindings = [];\r\n            bindings.forEach(binding => {\r\n                chainBindings.push({ sourceSpan: span, value: () => this.convertPropertyBinding(binding) });\r\n            });\r\n            // for i18n block, advance to the most recent element index (by taking the current number of\r\n            // elements and subtracting one) before invoking `i18nExp` instructions, to make sure the\r\n            // necessary lifecycle hooks of components/directives are properly flushed.\r\n            this.updateInstructionChainWithAdvance(this.getConstCount() - 1, Identifiers.i18nExp, chainBindings);\r\n            this.updateInstruction(span, Identifiers.i18nApply, [literal(index)]);\r\n        }\r\n        if (!selfClosing) {\r\n            this.creationInstruction(span, Identifiers.i18nEnd);\r\n        }\r\n        this.i18n = null; // reset local i18n context\r\n    }\r\n    i18nAttributesInstruction(nodeIndex, attrs, sourceSpan) {\r\n        let hasBindings = false;\r\n        const i18nAttrArgs = [];\r\n        const bindings = [];\r\n        attrs.forEach(attr => {\r\n            const message = attr.i18n;\r\n            const converted = attr.value.visit(this._valueConverter);\r\n            this.allocateBindingSlots(converted);\r\n            if (converted instanceof Interpolation) {\r\n                const placeholders = assembleBoundTextPlaceholders(message);\r\n                const params = placeholdersToParams(placeholders);\r\n                i18nAttrArgs.push(literal(attr.name), this.i18nTranslate(message, params));\r\n                converted.expressions.forEach(expression => {\r\n                    hasBindings = true;\r\n                    bindings.push({\r\n                        sourceSpan,\r\n                        value: () => this.convertPropertyBinding(expression),\r\n                    });\r\n                });\r\n            }\r\n        });\r\n        if (bindings.length > 0) {\r\n            this.updateInstructionChainWithAdvance(nodeIndex, Identifiers.i18nExp, bindings);\r\n        }\r\n        if (i18nAttrArgs.length > 0) {\r\n            const index = literal(this.allocateDataSlot());\r\n            const constIndex = this.addToConsts(literalArr(i18nAttrArgs));\r\n            this.creationInstruction(sourceSpan, Identifiers.i18nAttributes, [index, constIndex]);\r\n            if (hasBindings) {\r\n                this.updateInstruction(sourceSpan, Identifiers.i18nApply, [index]);\r\n            }\r\n        }\r\n    }\r\n    getNamespaceInstruction(namespaceKey) {\r\n        switch (namespaceKey) {\r\n            case 'math':\r\n                return Identifiers.namespaceMathML;\r\n            case 'svg':\r\n                return Identifiers.namespaceSVG;\r\n            default:\r\n                return Identifiers.namespaceHTML;\r\n        }\r\n    }\r\n    addNamespaceInstruction(nsInstruction, element) {\r\n        this._namespace = nsInstruction;\r\n        this.creationInstruction(element.startSourceSpan, nsInstruction);\r\n    }\r\n    /**\r\n     * Adds an update instruction for an interpolated property or attribute, such as\r\n     * `prop=\"{{value}}\"` or `attr.title=\"{{value}}\"`\r\n     */\r\n    interpolatedUpdateInstruction(instruction, elementIndex, attrName, input, value, params) {\r\n        this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, instruction, () => [literal(attrName), ...this.getUpdateInstructionArguments(value), ...params]);\r\n    }\r\n    visitContent(ngContent) {\r\n        const slot = this.allocateDataSlot();\r\n        const projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;\r\n        const parameters = [literal(slot)];\r\n        this._ngContentReservedSlots.push(ngContent.selector);\r\n        const nonContentSelectAttributes = ngContent.attributes.filter(attr => attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR$1);\r\n        const attributes = this.getAttributeExpressions(ngContent.name, nonContentSelectAttributes, [], []);\r\n        if (attributes.length > 0) {\r\n            parameters.push(literal(projectionSlotIdx), literalArr(attributes));\r\n        }\r\n        else if (projectionSlotIdx !== 0) {\r\n            parameters.push(literal(projectionSlotIdx));\r\n        }\r\n        this.creationInstruction(ngContent.sourceSpan, Identifiers.projection, parameters);\r\n        if (this.i18n) {\r\n            this.i18n.appendProjection(ngContent.i18n, slot);\r\n        }\r\n    }\r\n    visitElement(element) {\r\n        var _a, _b;\r\n        const elementIndex = this.allocateDataSlot();\r\n        const stylingBuilder = new StylingBuilder(null);\r\n        let isNonBindableMode = false;\r\n        const isI18nRootElement = isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);\r\n        const outputAttrs = [];\r\n        const [namespaceKey, elementName] = splitNsName(element.name);\r\n        const isNgContainer$1 = isNgContainer(element.name);\r\n        // Handle styling, i18n, ngNonBindable attributes\r\n        for (const attr of element.attributes) {\r\n            const { name, value } = attr;\r\n            if (name === NON_BINDABLE_ATTR) {\r\n                isNonBindableMode = true;\r\n            }\r\n            else if (name === 'style') {\r\n                stylingBuilder.registerStyleAttr(value);\r\n            }\r\n            else if (name === 'class') {\r\n                stylingBuilder.registerClassAttr(value);\r\n            }\r\n            else {\r\n                outputAttrs.push(attr);\r\n            }\r\n        }\r\n        // Match directives on non i18n attributes\r\n        this.matchDirectives(element.name, element);\r\n        // Regular element or ng-container creation mode\r\n        const parameters = [literal(elementIndex)];\r\n        if (!isNgContainer$1) {\r\n            parameters.push(literal(elementName));\r\n        }\r\n        // Add the attributes\r\n        const allOtherInputs = [];\r\n        const boundI18nAttrs = [];\r\n        element.inputs.forEach(input => {\r\n            const stylingInputWasSet = stylingBuilder.registerBoundInput(input);\r\n            if (!stylingInputWasSet) {\r\n                if (input.type === 0 /* Property */ && input.i18n) {\r\n                    boundI18nAttrs.push(input);\r\n                }\r\n                else {\r\n                    allOtherInputs.push(input);\r\n                }\r\n            }\r\n        });\r\n        // add attributes for directive and projection matching purposes\r\n        const attributes = this.getAttributeExpressions(element.name, outputAttrs, allOtherInputs, element.outputs, stylingBuilder, [], boundI18nAttrs);\r\n        parameters.push(this.addAttrsToConsts(attributes));\r\n        // local refs (ex.: <div #foo #bar=\"baz\">)\r\n        const refs = this.prepareRefsArray(element.references);\r\n        parameters.push(this.addToConsts(refs));\r\n        const wasInNamespace = this._namespace;\r\n        const currentNamespace = this.getNamespaceInstruction(namespaceKey);\r\n        // If the namespace is changing now, include an instruction to change it\r\n        // during element creation.\r\n        if (currentNamespace !== wasInNamespace) {\r\n            this.addNamespaceInstruction(currentNamespace, element);\r\n        }\r\n        if (this.i18n) {\r\n            this.i18n.appendElement(element.i18n, elementIndex);\r\n        }\r\n        // Note that we do not append text node instructions and ICUs inside i18n section,\r\n        // so we exclude them while calculating whether current element has children\r\n        const hasChildren = (!isI18nRootElement && this.i18n) ? !hasTextChildrenOnly(element.children) :\r\n            element.children.length > 0;\r\n        const createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes &&\r\n            element.outputs.length === 0 && boundI18nAttrs.length === 0 && !hasChildren;\r\n        const createSelfClosingI18nInstruction = !createSelfClosingInstruction && hasTextChildrenOnly(element.children);\r\n        if (createSelfClosingInstruction) {\r\n            this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers.elementContainer : Identifiers.element, trimTrailingNulls(parameters));\r\n        }\r\n        else {\r\n            this.creationInstruction(element.startSourceSpan, isNgContainer$1 ? Identifiers.elementContainerStart : Identifiers.elementStart, trimTrailingNulls(parameters));\r\n            if (isNonBindableMode) {\r\n                this.creationInstruction(element.startSourceSpan, Identifiers.disableBindings);\r\n            }\r\n            if (boundI18nAttrs.length > 0) {\r\n                this.i18nAttributesInstruction(elementIndex, boundI18nAttrs, (_a = element.startSourceSpan) !== null && _a !== void 0 ? _a : element.sourceSpan);\r\n            }\r\n            // Generate Listeners (outputs)\r\n            if (element.outputs.length > 0) {\r\n                const listeners = element.outputs.map((outputAst) => ({\r\n                    sourceSpan: outputAst.sourceSpan,\r\n                    params: this.prepareListenerParameter(element.name, outputAst, elementIndex)\r\n                }));\r\n                this.creationInstructionChain(Identifiers.listener, listeners);\r\n            }\r\n            // Note: it's important to keep i18n/i18nStart instructions after i18nAttributes and\r\n            // listeners, to make sure i18nAttributes instruction targets current element at runtime.\r\n            if (isI18nRootElement) {\r\n                this.i18nStart(element.startSourceSpan, element.i18n, createSelfClosingI18nInstruction);\r\n            }\r\n        }\r\n        // the code here will collect all update-level styling instructions and add them to the\r\n        // update block of the template function AOT code. Instructions like `styleProp`,\r\n        // `styleMap`, `classMap`, `classProp`\r\n        // are all generated and assigned in the code below.\r\n        const stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);\r\n        const limit = stylingInstructions.length - 1;\r\n        for (let i = 0; i <= limit; i++) {\r\n            const instruction = stylingInstructions[i];\r\n            this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, instruction);\r\n        }\r\n        // the reason why `undefined` is used is because the renderer understands this as a\r\n        // special value to symbolize that there is no RHS to this binding\r\n        // TODO (matsko): revisit this once FW-959 is approached\r\n        const emptyValueBindInstruction = literal(undefined);\r\n        const propertyBindings = [];\r\n        const attributeBindings = [];\r\n        // Generate element input bindings\r\n        allOtherInputs.forEach(input => {\r\n            const inputType = input.type;\r\n            if (inputType === 4 /* Animation */) {\r\n                const value = input.value.visit(this._valueConverter);\r\n                // animation bindings can be presented in the following formats:\r\n                // 1. [@binding]=\"fooExp\"\r\n                // 2. [@binding]=\"{value:fooExp, params:{...}}\"\r\n                // 3. [@binding]\r\n                // 4. @binding\r\n                // All formats will be valid for when a synthetic binding is created.\r\n                // The reasoning for this is because the renderer should get each\r\n                // synthetic binding value in the order of the array that they are\r\n                // defined in...\r\n                const hasValue = value instanceof LiteralPrimitive ? !!value.value : true;\r\n                this.allocateBindingSlots(value);\r\n                propertyBindings.push({\r\n                    name: prepareSyntheticPropertyName(input.name),\r\n                    sourceSpan: input.sourceSpan,\r\n                    value: () => hasValue ? this.convertPropertyBinding(value) : emptyValueBindInstruction\r\n                });\r\n            }\r\n            else {\r\n                // we must skip attributes with associated i18n context, since these attributes are handled\r\n                // separately and corresponding `i18nExp` and `i18nApply` instructions will be generated\r\n                if (input.i18n)\r\n                    return;\r\n                const value = input.value.visit(this._valueConverter);\r\n                if (value !== undefined) {\r\n                    const params = [];\r\n                    const [attrNamespace, attrName] = splitNsName(input.name);\r\n                    const isAttributeBinding = inputType === 1 /* Attribute */;\r\n                    const sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);\r\n                    if (sanitizationRef)\r\n                        params.push(sanitizationRef);\r\n                    if (attrNamespace) {\r\n                        const namespaceLiteral = literal(attrNamespace);\r\n                        if (sanitizationRef) {\r\n                            params.push(namespaceLiteral);\r\n                        }\r\n                        else {\r\n                            // If there wasn't a sanitization ref, we need to add\r\n                            // an extra param so that we can pass in the namespace.\r\n                            params.push(literal(null), namespaceLiteral);\r\n                        }\r\n                    }\r\n                    this.allocateBindingSlots(value);\r\n                    if (inputType === 0 /* Property */) {\r\n                        if (value instanceof Interpolation) {\r\n                            // prop=\"{{value}}\" and friends\r\n                            this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), elementIndex, attrName, input, value, params);\r\n                        }\r\n                        else {\r\n                            // [prop]=\"value\"\r\n                            // Collect all the properties so that we can chain into a single function at the end.\r\n                            propertyBindings.push({\r\n                                name: attrName,\r\n                                sourceSpan: input.sourceSpan,\r\n                                value: () => this.convertPropertyBinding(value),\r\n                                params\r\n                            });\r\n                        }\r\n                    }\r\n                    else if (inputType === 1 /* Attribute */) {\r\n                        if (value instanceof Interpolation && getInterpolationArgsLength(value) > 1) {\r\n                            // attr.name=\"text{{value}}\" and friends\r\n                            this.interpolatedUpdateInstruction(getAttributeInterpolationExpression(value), elementIndex, attrName, input, value, params);\r\n                        }\r\n                        else {\r\n                            const boundValue = value instanceof Interpolation ? value.expressions[0] : value;\r\n                            // [attr.name]=\"value\" or attr.name=\"{{value}}\"\r\n                            // Collect the attribute bindings so that they can be chained at the end.\r\n                            attributeBindings.push({\r\n                                name: attrName,\r\n                                sourceSpan: input.sourceSpan,\r\n                                value: () => this.convertPropertyBinding(boundValue),\r\n                                params\r\n                            });\r\n                        }\r\n                    }\r\n                    else {\r\n                        // class prop\r\n                        this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, Identifiers.classProp, () => {\r\n                            return [\r\n                                literal(elementIndex), literal(attrName), this.convertPropertyBinding(value),\r\n                                ...params\r\n                            ];\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        if (propertyBindings.length > 0) {\r\n            this.updateInstructionChainWithAdvance(elementIndex, Identifiers.property, propertyBindings);\r\n        }\r\n        if (attributeBindings.length > 0) {\r\n            this.updateInstructionChainWithAdvance(elementIndex, Identifiers.attribute, attributeBindings);\r\n        }\r\n        // Traverse element child nodes\r\n        visitAll(this, element.children);\r\n        if (!isI18nRootElement && this.i18n) {\r\n            this.i18n.appendElement(element.i18n, elementIndex, true);\r\n        }\r\n        if (!createSelfClosingInstruction) {\r\n            // Finish element construction mode.\r\n            const span = (_b = element.endSourceSpan) !== null && _b !== void 0 ? _b : element.sourceSpan;\r\n            if (isI18nRootElement) {\r\n                this.i18nEnd(span, createSelfClosingI18nInstruction);\r\n            }\r\n            if (isNonBindableMode) {\r\n                this.creationInstruction(span, Identifiers.enableBindings);\r\n            }\r\n            this.creationInstruction(span, isNgContainer$1 ? Identifiers.elementContainerEnd : Identifiers.elementEnd);\r\n        }\r\n    }\r\n    visitTemplate(template) {\r\n        var _a;\r\n        const NG_TEMPLATE_TAG_NAME = 'ng-template';\r\n        const templateIndex = this.allocateDataSlot();\r\n        if (this.i18n) {\r\n            this.i18n.appendTemplate(template.i18n, templateIndex);\r\n        }\r\n        const tagNameWithoutNamespace = template.tagName ? splitNsName(template.tagName)[1] : template.tagName;\r\n        const contextName = `${this.contextName}${template.tagName ? '_' + sanitizeIdentifier(template.tagName) : ''}_${templateIndex}`;\r\n        const templateName = `${contextName}_Template`;\r\n        const parameters = [\r\n            literal(templateIndex),\r\n            variable(templateName),\r\n            // We don't care about the tag's namespace here, because we infer\r\n            // it based on the parent nodes inside the template instruction.\r\n            literal(tagNameWithoutNamespace),\r\n        ];\r\n        // find directives matching on a given <ng-template> node\r\n        this.matchDirectives(NG_TEMPLATE_TAG_NAME, template);\r\n        // prepare attributes parameter (including attributes used for directive matching)\r\n        const attrsExprs = this.getAttributeExpressions(NG_TEMPLATE_TAG_NAME, template.attributes, template.inputs, template.outputs, undefined /* styles */, template.templateAttrs);\r\n        parameters.push(this.addAttrsToConsts(attrsExprs));\r\n        // local refs (ex.: <ng-template #foo>)\r\n        if (template.references && template.references.length) {\r\n            const refs = this.prepareRefsArray(template.references);\r\n            parameters.push(this.addToConsts(refs));\r\n            parameters.push(importExpr(Identifiers.templateRefExtractor));\r\n        }\r\n        // Create the template function\r\n        const templateVisitor = new TemplateDefinitionBuilder(this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n, templateIndex, templateName, this.directiveMatcher, this.directives, this.pipeTypeByName, this.pipes, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds, this._constants);\r\n        // Nested templates must not be visited until after their parent templates have completed\r\n        // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't\r\n        // be able to support bindings in nested templates to local refs that occur after the\r\n        // template definition. e.g. <div *ngIf=\"showing\">{{ foo }}</div>  <div #foo></div>\r\n        this._nestedTemplateFns.push(() => {\r\n            const templateFunctionExpr = templateVisitor.buildTemplateFunction(template.children, template.variables, this._ngContentReservedSlots.length + this._ngContentSelectorsOffset, template.i18n);\r\n            this.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName));\r\n            if (templateVisitor._ngContentReservedSlots.length) {\r\n                this._ngContentReservedSlots.push(...templateVisitor._ngContentReservedSlots);\r\n            }\r\n        });\r\n        // e.g. template(1, MyComp_Template_1)\r\n        this.creationInstruction(template.sourceSpan, Identifiers.templateCreate, () => {\r\n            parameters.splice(2, 0, literal(templateVisitor.getConstCount()), literal(templateVisitor.getVarCount()));\r\n            return trimTrailingNulls(parameters);\r\n        });\r\n        // handle property bindings e.g. ɵɵproperty('ngForOf', ctx.items), et al;\r\n        this.templatePropertyBindings(templateIndex, template.templateAttrs);\r\n        // Only add normal input/output binding instructions on explicit <ng-template> elements.\r\n        if (tagNameWithoutNamespace === NG_TEMPLATE_TAG_NAME) {\r\n            const [i18nInputs, inputs] = partitionArray(template.inputs, hasI18nMeta);\r\n            // Add i18n attributes that may act as inputs to directives. If such attributes are present,\r\n            // generate `i18nAttributes` instruction. Note: we generate it only for explicit <ng-template>\r\n            // elements, in case of inline templates, corresponding instructions will be generated in the\r\n            // nested template function.\r\n            if (i18nInputs.length > 0) {\r\n                this.i18nAttributesInstruction(templateIndex, i18nInputs, (_a = template.startSourceSpan) !== null && _a !== void 0 ? _a : template.sourceSpan);\r\n            }\r\n            // Add the input bindings\r\n            if (inputs.length > 0) {\r\n                this.templatePropertyBindings(templateIndex, inputs);\r\n            }\r\n            // Generate listeners for directive output\r\n            if (template.outputs.length > 0) {\r\n                const listeners = template.outputs.map((outputAst) => ({\r\n                    sourceSpan: outputAst.sourceSpan,\r\n                    params: this.prepareListenerParameter('ng_template', outputAst, templateIndex)\r\n                }));\r\n                this.creationInstructionChain(Identifiers.listener, listeners);\r\n            }\r\n        }\r\n    }\r\n    visitBoundText(text) {\r\n        if (this.i18n) {\r\n            const value = text.value.visit(this._valueConverter);\r\n            this.allocateBindingSlots(value);\r\n            if (value instanceof Interpolation) {\r\n                this.i18n.appendBoundText(text.i18n);\r\n                this.i18nAppendBindings(value.expressions);\r\n            }\r\n            return;\r\n        }\r\n        const nodeIndex = this.allocateDataSlot();\r\n        this.creationInstruction(text.sourceSpan, Identifiers.text, [literal(nodeIndex)]);\r\n        const value = text.value.visit(this._valueConverter);\r\n        this.allocateBindingSlots(value);\r\n        if (value instanceof Interpolation) {\r\n            this.updateInstructionWithAdvance(nodeIndex, text.sourceSpan, getTextInterpolationExpression(value), () => this.getUpdateInstructionArguments(value));\r\n        }\r\n        else {\r\n            error('Text nodes should be interpolated and never bound directly.');\r\n        }\r\n    }\r\n    visitText(text) {\r\n        // when a text element is located within a translatable\r\n        // block, we exclude this text element from instructions set,\r\n        // since it will be captured in i18n content and processed at runtime\r\n        if (!this.i18n) {\r\n            this.creationInstruction(text.sourceSpan, Identifiers.text, [literal(this.allocateDataSlot()), literal(text.value)]);\r\n        }\r\n    }\r\n    visitIcu(icu) {\r\n        let initWasInvoked = false;\r\n        // if an ICU was created outside of i18n block, we still treat\r\n        // it as a translatable entity and invoke i18nStart and i18nEnd\r\n        // to generate i18n context and the necessary instructions\r\n        if (!this.i18n) {\r\n            initWasInvoked = true;\r\n            this.i18nStart(null, icu.i18n, true);\r\n        }\r\n        const i18n = this.i18n;\r\n        const vars = this.i18nBindProps(icu.vars);\r\n        const placeholders = this.i18nBindProps(icu.placeholders);\r\n        // output ICU directly and keep ICU reference in context\r\n        const message = icu.i18n;\r\n        // we always need post-processing function for ICUs, to make sure that:\r\n        // - all placeholders in a form of {PLACEHOLDER} are replaced with actual values (note:\r\n        // `goog.getMsg` does not process ICUs and uses the `{PLACEHOLDER}` format for placeholders\r\n        // inside ICUs)\r\n        // - all ICU vars (such as `VAR_SELECT` or `VAR_PLURAL`) are replaced with correct values\r\n        const transformFn = (raw) => {\r\n            const params = Object.assign(Object.assign({}, vars), placeholders);\r\n            const formatted = i18nFormatPlaceholderNames(params, /* useCamelCase */ false);\r\n            return instruction(null, Identifiers.i18nPostprocess, [raw, mapLiteral(formatted, true)]);\r\n        };\r\n        // in case the whole i18n message is a single ICU - we do not need to\r\n        // create a separate top-level translation, we can use the root ref instead\r\n        // and make this ICU a top-level translation\r\n        // note: ICU placeholders are replaced with actual values in `i18nPostprocess` function\r\n        // separately, so we do not pass placeholders into `i18nTranslate` function.\r\n        if (isSingleI18nIcu(i18n.meta)) {\r\n            this.i18nTranslate(message, /* placeholders */ {}, i18n.ref, transformFn);\r\n        }\r\n        else {\r\n            // output ICU directly and keep ICU reference in context\r\n            const ref = this.i18nTranslate(message, /* placeholders */ {}, /* ref */ undefined, transformFn);\r\n            i18n.appendIcu(icuFromI18nMessage(message).name, ref);\r\n        }\r\n        if (initWasInvoked) {\r\n            this.i18nEnd(null, true);\r\n        }\r\n        return null;\r\n    }\r\n    allocateDataSlot() {\r\n        return this._dataIndex++;\r\n    }\r\n    getConstCount() {\r\n        return this._dataIndex;\r\n    }\r\n    getVarCount() {\r\n        return this._pureFunctionSlots;\r\n    }\r\n    getConsts() {\r\n        return this._constants;\r\n    }\r\n    getNgContentSelectors() {\r\n        return this._ngContentReservedSlots.length ?\r\n            this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) :\r\n            null;\r\n    }\r\n    bindingContext() {\r\n        return `${this._bindingContext++}`;\r\n    }\r\n    templatePropertyBindings(templateIndex, attrs) {\r\n        const propertyBindings = [];\r\n        attrs.forEach(input => {\r\n            if (input instanceof BoundAttribute) {\r\n                const value = input.value.visit(this._valueConverter);\r\n                if (value !== undefined) {\r\n                    this.allocateBindingSlots(value);\r\n                    if (value instanceof Interpolation) {\r\n                        // Params typically contain attribute namespace and value sanitizer, which is applicable\r\n                        // for regular HTML elements, but not applicable for <ng-template> (since props act as\r\n                        // inputs to directives), so keep params array empty.\r\n                        const params = [];\r\n                        // prop=\"{{value}}\" case\r\n                        this.interpolatedUpdateInstruction(getPropertyInterpolationExpression(value), templateIndex, input.name, input, value, params);\r\n                    }\r\n                    else {\r\n                        // [prop]=\"value\" case\r\n                        propertyBindings.push({\r\n                            name: input.name,\r\n                            sourceSpan: input.sourceSpan,\r\n                            value: () => this.convertPropertyBinding(value)\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        if (propertyBindings.length > 0) {\r\n            this.updateInstructionChainWithAdvance(templateIndex, Identifiers.property, propertyBindings);\r\n        }\r\n    }\r\n    // Bindings must only be resolved after all local refs have been visited, so all\r\n    // instructions are queued in callbacks that execute once the initial pass has completed.\r\n    // Otherwise, we wouldn't be able to support local refs that are defined after their\r\n    // bindings. e.g. {{ foo }} <div #foo></div>\r\n    instructionFn(fns, span, reference, paramsOrFn, prepend = false) {\r\n        fns[prepend ? 'unshift' : 'push'](() => {\r\n            const params = Array.isArray(paramsOrFn) ? paramsOrFn : paramsOrFn();\r\n            return instruction(span, reference, params).toStmt();\r\n        });\r\n    }\r\n    processStylingUpdateInstruction(elementIndex, instruction) {\r\n        let allocateBindingSlots = 0;\r\n        if (instruction) {\r\n            const calls = [];\r\n            instruction.calls.forEach(call => {\r\n                allocateBindingSlots += call.allocateBindingSlots;\r\n                calls.push({\r\n                    sourceSpan: call.sourceSpan,\r\n                    value: () => {\r\n                        return call.params(value => (call.supportsInterpolation && value instanceof Interpolation) ?\r\n                            this.getUpdateInstructionArguments(value) :\r\n                            this.convertPropertyBinding(value));\r\n                    }\r\n                });\r\n            });\r\n            this.updateInstructionChainWithAdvance(elementIndex, instruction.reference, calls);\r\n        }\r\n        return allocateBindingSlots;\r\n    }\r\n    creationInstruction(span, reference, paramsOrFn, prepend) {\r\n        this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);\r\n    }\r\n    creationInstructionChain(reference, calls) {\r\n        const span = calls.length ? calls[0].sourceSpan : null;\r\n        this._creationCodeFns.push(() => {\r\n            return chainedInstruction(reference, calls.map(call => call.params()), span).toStmt();\r\n        });\r\n    }\r\n    updateInstructionWithAdvance(nodeIndex, span, reference, paramsOrFn) {\r\n        this.addAdvanceInstructionIfNecessary(nodeIndex, span);\r\n        this.updateInstruction(span, reference, paramsOrFn);\r\n    }\r\n    updateInstruction(span, reference, paramsOrFn) {\r\n        this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);\r\n    }\r\n    updateInstructionChain(reference, bindings) {\r\n        const span = bindings.length ? bindings[0].sourceSpan : null;\r\n        this._updateCodeFns.push(() => {\r\n            const calls = bindings.map(property => {\r\n                const value = property.value();\r\n                const fnParams = Array.isArray(value) ? value : [value];\r\n                if (property.params) {\r\n                    fnParams.push(...property.params);\r\n                }\r\n                if (property.name) {\r\n                    // We want the property name to always be the first function parameter.\r\n                    fnParams.unshift(literal(property.name));\r\n                }\r\n                return fnParams;\r\n            });\r\n            return chainedInstruction(reference, calls, span).toStmt();\r\n        });\r\n    }\r\n    updateInstructionChainWithAdvance(nodeIndex, reference, bindings) {\r\n        this.addAdvanceInstructionIfNecessary(nodeIndex, bindings.length ? bindings[0].sourceSpan : null);\r\n        this.updateInstructionChain(reference, bindings);\r\n    }\r\n    addAdvanceInstructionIfNecessary(nodeIndex, span) {\r\n        if (nodeIndex !== this._currentIndex) {\r\n            const delta = nodeIndex - this._currentIndex;\r\n            if (delta < 1) {\r\n                throw new Error('advance instruction can only go forwards');\r\n            }\r\n            this.instructionFn(this._updateCodeFns, span, Identifiers.advance, [literal(delta)]);\r\n            this._currentIndex = nodeIndex;\r\n        }\r\n    }\r\n    allocatePureFunctionSlots(numSlots) {\r\n        const originalSlots = this._pureFunctionSlots;\r\n        this._pureFunctionSlots += numSlots;\r\n        return originalSlots;\r\n    }\r\n    allocateBindingSlots(value) {\r\n        this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;\r\n    }\r\n    /**\r\n     * Gets an expression that refers to the implicit receiver. The implicit\r\n     * receiver is always the root level context.\r\n     */\r\n    getImplicitReceiverExpr() {\r\n        if (this._implicitReceiverExpr) {\r\n            return this._implicitReceiverExpr;\r\n        }\r\n        return this._implicitReceiverExpr = this.level === 0 ?\r\n            variable(CONTEXT_NAME) :\r\n            this._bindingScope.getOrCreateSharedContextVar(0);\r\n    }\r\n    convertPropertyBinding(value) {\r\n        const convertedPropertyBinding = convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext(), BindingForm.Expression, () => error('Unexpected interpolation'));\r\n        const valExpr = convertedPropertyBinding.currValExpr;\r\n        this._tempVariables.push(...convertedPropertyBinding.stmts);\r\n        return valExpr;\r\n    }\r\n    /**\r\n     * Gets a list of argument expressions to pass to an update instruction expression. Also updates\r\n     * the temp variables state with temp variables that were identified as needing to be created\r\n     * while visiting the arguments.\r\n     * @param value The original expression we will be resolving an arguments list from.\r\n     */\r\n    getUpdateInstructionArguments(value) {\r\n        const { args, stmts } = convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext());\r\n        this._tempVariables.push(...stmts);\r\n        return args;\r\n    }\r\n    matchDirectives(elementName, elOrTpl) {\r\n        if (this.directiveMatcher) {\r\n            const selector = createCssSelector(elementName, getAttrsForDirectiveMatching(elOrTpl));\r\n            this.directiveMatcher.match(selector, (cssSelector, staticType) => {\r\n                this.directives.add(staticType);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Prepares all attribute expression values for the `TAttributes` array.\r\n     *\r\n     * The purpose of this function is to properly construct an attributes array that\r\n     * is passed into the `elementStart` (or just `element`) functions. Because there\r\n     * are many different types of attributes, the array needs to be constructed in a\r\n     * special way so that `elementStart` can properly evaluate them.\r\n     *\r\n     * The format looks like this:\r\n     *\r\n     * ```\r\n     * attrs = [prop, value, prop2, value2,\r\n     *   PROJECT_AS, selector,\r\n     *   CLASSES, class1, class2,\r\n     *   STYLES, style1, value1, style2, value2,\r\n     *   BINDINGS, name1, name2, name3,\r\n     *   TEMPLATE, name4, name5, name6,\r\n     *   I18N, name7, name8, ...]\r\n     * ```\r\n     *\r\n     * Note that this function will fully ignore all synthetic (@foo) attribute values\r\n     * because those values are intended to always be generated as property instructions.\r\n     */\r\n    getAttributeExpressions(elementName, renderAttributes, inputs, outputs, styles, templateAttrs = [], boundI18nAttrs = []) {\r\n        const alreadySeen = new Set();\r\n        const attrExprs = [];\r\n        let ngProjectAsAttr;\r\n        for (const attr of renderAttributes) {\r\n            if (attr.name === NG_PROJECT_AS_ATTR_NAME) {\r\n                ngProjectAsAttr = attr;\r\n            }\r\n            // Note that static i18n attributes aren't in the i18n array,\r\n            // because they're treated in the same way as regular attributes.\r\n            if (attr.i18n) {\r\n                // When i18n attributes are present on elements with structural directives\r\n                // (e.g. `<div *ngIf title=\"Hello\" i18n-title>`), we want to avoid generating\r\n                // duplicate i18n translation blocks for `ɵɵtemplate` and `ɵɵelement` instruction\r\n                // attributes. So we do a cache lookup to see if suitable i18n translation block\r\n                // already exists.\r\n                const { i18nVarRefsCache } = this._constants;\r\n                let i18nVarRef;\r\n                if (i18nVarRefsCache.has(attr.i18n)) {\r\n                    i18nVarRef = i18nVarRefsCache.get(attr.i18n);\r\n                }\r\n                else {\r\n                    i18nVarRef = this.i18nTranslate(attr.i18n);\r\n                    i18nVarRefsCache.set(attr.i18n, i18nVarRef);\r\n                }\r\n                attrExprs.push(literal(attr.name), i18nVarRef);\r\n            }\r\n            else {\r\n                attrExprs.push(...getAttributeNameLiterals(attr.name), trustedConstAttribute(elementName, attr));\r\n            }\r\n        }\r\n        // Keep ngProjectAs next to the other name, value pairs so we can verify that we match\r\n        // ngProjectAs marker in the attribute name slot.\r\n        if (ngProjectAsAttr) {\r\n            attrExprs.push(...getNgProjectAsLiteral(ngProjectAsAttr));\r\n        }\r\n        function addAttrExpr(key, value) {\r\n            if (typeof key === 'string') {\r\n                if (!alreadySeen.has(key)) {\r\n                    attrExprs.push(...getAttributeNameLiterals(key));\r\n                    value !== undefined && attrExprs.push(value);\r\n                    alreadySeen.add(key);\r\n                }\r\n            }\r\n            else {\r\n                attrExprs.push(literal(key));\r\n            }\r\n        }\r\n        // it's important that this occurs before BINDINGS and TEMPLATE because once `elementStart`\r\n        // comes across the BINDINGS or TEMPLATE markers then it will continue reading each value as\r\n        // as single property value cell by cell.\r\n        if (styles) {\r\n            styles.populateInitialStylingAttrs(attrExprs);\r\n        }\r\n        if (inputs.length || outputs.length) {\r\n            const attrsLengthBeforeInputs = attrExprs.length;\r\n            for (let i = 0; i < inputs.length; i++) {\r\n                const input = inputs[i];\r\n                // We don't want the animation and attribute bindings in the\r\n                // attributes array since they aren't used for directive matching.\r\n                if (input.type !== 4 /* Animation */ && input.type !== 1 /* Attribute */) {\r\n                    addAttrExpr(input.name);\r\n                }\r\n            }\r\n            for (let i = 0; i < outputs.length; i++) {\r\n                const output = outputs[i];\r\n                if (output.type !== 1 /* Animation */) {\r\n                    addAttrExpr(output.name);\r\n                }\r\n            }\r\n            // this is a cheap way of adding the marker only after all the input/output\r\n            // values have been filtered (by not including the animation ones) and added\r\n            // to the expressions. The marker is important because it tells the runtime\r\n            // code that this is where attributes without values start...\r\n            if (attrExprs.length !== attrsLengthBeforeInputs) {\r\n                attrExprs.splice(attrsLengthBeforeInputs, 0, literal(3 /* Bindings */));\r\n            }\r\n        }\r\n        if (templateAttrs.length) {\r\n            attrExprs.push(literal(4 /* Template */));\r\n            templateAttrs.forEach(attr => addAttrExpr(attr.name));\r\n        }\r\n        if (boundI18nAttrs.length) {\r\n            attrExprs.push(literal(6 /* I18n */));\r\n            boundI18nAttrs.forEach(attr => addAttrExpr(attr.name));\r\n        }\r\n        return attrExprs;\r\n    }\r\n    addToConsts(expression) {\r\n        if (isNull(expression)) {\r\n            return TYPED_NULL_EXPR;\r\n        }\r\n        const consts = this._constants.constExpressions;\r\n        // Try to reuse a literal that's already in the array, if possible.\r\n        for (let i = 0; i < consts.length; i++) {\r\n            if (consts[i].isEquivalent(expression)) {\r\n                return literal(i);\r\n            }\r\n        }\r\n        return literal(consts.push(expression) - 1);\r\n    }\r\n    addAttrsToConsts(attrs) {\r\n        return attrs.length > 0 ? this.addToConsts(literalArr(attrs)) : TYPED_NULL_EXPR;\r\n    }\r\n    prepareRefsArray(references) {\r\n        if (!references || references.length === 0) {\r\n            return TYPED_NULL_EXPR;\r\n        }\r\n        const refsParam = flatten(references.map(reference => {\r\n            const slot = this.allocateDataSlot();\r\n            // Generate the update temporary.\r\n            const variableName = this._bindingScope.freshReferenceName();\r\n            const retrievalLevel = this.level;\r\n            const lhs = variable(variableName);\r\n            this._bindingScope.set(retrievalLevel, reference.name, lhs, 0 /* DEFAULT */, (scope, relativeLevel) => {\r\n                // e.g. nextContext(2);\r\n                const nextContextStmt = relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : [];\r\n                // e.g. const $foo$ = reference(1);\r\n                const refExpr = lhs.set(importExpr(Identifiers.reference).callFn([literal(slot)]));\r\n                return nextContextStmt.concat(refExpr.toConstDecl());\r\n            }, true);\r\n            return [reference.name, reference.value];\r\n        }));\r\n        return asLiteral(refsParam);\r\n    }\r\n    prepareListenerParameter(tagName, outputAst, index) {\r\n        return () => {\r\n            const eventName = outputAst.name;\r\n            const bindingFnName = outputAst.type === 1 /* Animation */ ?\r\n                // synthetic @listener.foo values are treated the exact same as are standard listeners\r\n                prepareSyntheticListenerFunctionName(eventName, outputAst.phase) :\r\n                sanitizeIdentifier(eventName);\r\n            const handlerName = `${this.templateName}_${tagName}_${bindingFnName}_${index}_listener`;\r\n            const scope = this._bindingScope.nestedScope(this._bindingScope.bindingLevel, EVENT_BINDING_SCOPE_GLOBALS);\r\n            return prepareEventListenerParameters(outputAst, handlerName, scope);\r\n        };\r\n    }\r\n}\r\nclass ValueConverter extends AstMemoryEfficientTransformer {\r\n    constructor(constantPool, allocateSlot, allocatePureFunctionSlots, definePipe) {\r\n        super();\r\n        this.constantPool = constantPool;\r\n        this.allocateSlot = allocateSlot;\r\n        this.allocatePureFunctionSlots = allocatePureFunctionSlots;\r\n        this.definePipe = definePipe;\r\n        this._pipeBindExprs = [];\r\n    }\r\n    // AstMemoryEfficientTransformer\r\n    visitPipe(pipe, context) {\r\n        // Allocate a slot to create the pipe\r\n        const slot = this.allocateSlot();\r\n        const slotPseudoLocal = `PIPE:${slot}`;\r\n        // Allocate one slot for the result plus one slot per pipe argument\r\n        const pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);\r\n        const target = new PropertyRead(pipe.span, pipe.sourceSpan, pipe.nameSpan, new ImplicitReceiver(pipe.span, pipe.sourceSpan), slotPseudoLocal);\r\n        const { identifier, isVarLength } = pipeBindingCallInfo(pipe.args);\r\n        this.definePipe(pipe.name, slotPseudoLocal, slot, importExpr(identifier));\r\n        const args = [pipe.exp, ...pipe.args];\r\n        const convertedArgs = isVarLength ?\r\n            this.visitAll([new LiteralArray(pipe.span, pipe.sourceSpan, args)]) :\r\n            this.visitAll(args);\r\n        const pipeBindExpr = new FunctionCall(pipe.span, pipe.sourceSpan, target, [\r\n            new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot),\r\n            new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot),\r\n            ...convertedArgs,\r\n        ]);\r\n        this._pipeBindExprs.push(pipeBindExpr);\r\n        return pipeBindExpr;\r\n    }\r\n    updatePipeSlotOffsets(bindingSlots) {\r\n        this._pipeBindExprs.forEach((pipe) => {\r\n            // update the slot offset arg (index 1) to account for binding slots\r\n            const slotOffset = pipe.args[1];\r\n            slotOffset.value += bindingSlots;\r\n        });\r\n    }\r\n    visitLiteralArray(array, context) {\r\n        return new BuiltinFunctionCall(array.span, array.sourceSpan, this.visitAll(array.expressions), values => {\r\n            // If the literal has calculated (non-literal) elements transform it into\r\n            // calls to literal factories that compose the literal and will cache intermediate\r\n            // values.\r\n            const literal = literalArr(values);\r\n            return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);\r\n        });\r\n    }\r\n    visitLiteralMap(map, context) {\r\n        return new BuiltinFunctionCall(map.span, map.sourceSpan, this.visitAll(map.values), values => {\r\n            // If the literal has calculated (non-literal) elements  transform it into\r\n            // calls to literal factories that compose the literal and will cache intermediate\r\n            // values.\r\n            const literal = literalMap(values.map((value, index) => ({ key: map.keys[index].key, value, quoted: map.keys[index].quoted })));\r\n            return getLiteralFactory(this.constantPool, literal, this.allocatePureFunctionSlots);\r\n        });\r\n    }\r\n}\r\n// Pipes always have at least one parameter, the value they operate on\r\nconst pipeBindingIdentifiers = [Identifiers.pipeBind1, Identifiers.pipeBind2, Identifiers.pipeBind3, Identifiers.pipeBind4];\r\nfunction pipeBindingCallInfo(args) {\r\n    const identifier = pipeBindingIdentifiers[args.length];\r\n    return {\r\n        identifier: identifier || Identifiers.pipeBindV,\r\n        isVarLength: !identifier,\r\n    };\r\n}\r\nconst pureFunctionIdentifiers = [\r\n    Identifiers.pureFunction0, Identifiers.pureFunction1, Identifiers.pureFunction2, Identifiers.pureFunction3, Identifiers.pureFunction4,\r\n    Identifiers.pureFunction5, Identifiers.pureFunction6, Identifiers.pureFunction7, Identifiers.pureFunction8\r\n];\r\nfunction pureFunctionCallInfo(args) {\r\n    const identifier = pureFunctionIdentifiers[args.length];\r\n    return {\r\n        identifier: identifier || Identifiers.pureFunctionV,\r\n        isVarLength: !identifier,\r\n    };\r\n}\r\nfunction instruction(span, reference, params) {\r\n    return importExpr(reference, null, span).callFn(params, span);\r\n}\r\n// e.g. x(2);\r\nfunction generateNextContextExpr(relativeLevelDiff) {\r\n    return importExpr(Identifiers.nextContext)\r\n        .callFn(relativeLevelDiff > 1 ? [literal(relativeLevelDiff)] : []);\r\n}\r\nfunction getLiteralFactory(constantPool, literal$1, allocateSlots) {\r\n    const { literalFactory, literalFactoryArguments } = constantPool.getLiteralFactory(literal$1);\r\n    // Allocate 1 slot for the result plus 1 per argument\r\n    const startSlot = allocateSlots(1 + literalFactoryArguments.length);\r\n    const { identifier, isVarLength } = pureFunctionCallInfo(literalFactoryArguments);\r\n    // Literal factories are pure functions that only need to be re-invoked when the parameters\r\n    // change.\r\n    const args = [literal(startSlot), literalFactory];\r\n    if (isVarLength) {\r\n        args.push(literalArr(literalFactoryArguments));\r\n    }\r\n    else {\r\n        args.push(...literalFactoryArguments);\r\n    }\r\n    return importExpr(identifier).callFn(args);\r\n}\r\n/**\r\n * Gets an array of literals that can be added to an expression\r\n * to represent the name and namespace of an attribute. E.g.\r\n * `:xlink:href` turns into `[AttributeMarker.NamespaceURI, 'xlink', 'href']`.\r\n *\r\n * @param name Name of the attribute, including the namespace.\r\n */\r\nfunction getAttributeNameLiterals(name) {\r\n    const [attributeNamespace, attributeName] = splitNsName(name);\r\n    const nameLiteral = literal(attributeName);\r\n    if (attributeNamespace) {\r\n        return [\r\n            literal(0 /* NamespaceURI */), literal(attributeNamespace), nameLiteral\r\n        ];\r\n    }\r\n    return [nameLiteral];\r\n}\r\n/** The prefix used to get a shared context in BindingScope's map. */\r\nconst SHARED_CONTEXT_KEY = '$$shared_ctx$$';\r\nclass BindingScope {\r\n    constructor(bindingLevel = 0, parent = null, globals) {\r\n        this.bindingLevel = bindingLevel;\r\n        this.parent = parent;\r\n        this.globals = globals;\r\n        /** Keeps a map from local variables to their BindingData. */\r\n        this.map = new Map();\r\n        this.referenceNameIndex = 0;\r\n        this.restoreViewVariable = null;\r\n        this.usesRestoredViewContext = false;\r\n        if (globals !== undefined) {\r\n            for (const name of globals) {\r\n                this.set(0, name, variable(name));\r\n            }\r\n        }\r\n    }\r\n    static createRootScope() {\r\n        return new BindingScope();\r\n    }\r\n    get(name) {\r\n        let current = this;\r\n        while (current) {\r\n            let value = current.map.get(name);\r\n            if (value != null) {\r\n                if (current !== this) {\r\n                    // make a local copy and reset the `declare` state\r\n                    value = {\r\n                        retrievalLevel: value.retrievalLevel,\r\n                        lhs: value.lhs,\r\n                        declareLocalCallback: value.declareLocalCallback,\r\n                        declare: false,\r\n                        priority: value.priority,\r\n                        localRef: value.localRef\r\n                    };\r\n                    // Cache the value locally.\r\n                    this.map.set(name, value);\r\n                    // Possibly generate a shared context var\r\n                    this.maybeGenerateSharedContextVar(value);\r\n                    this.maybeRestoreView(value.retrievalLevel, value.localRef);\r\n                }\r\n                if (value.declareLocalCallback && !value.declare) {\r\n                    value.declare = true;\r\n                }\r\n                return value.lhs;\r\n            }\r\n            current = current.parent;\r\n        }\r\n        // If we get to this point, we are looking for a property on the top level component\r\n        // - If level === 0, we are on the top and don't need to re-declare `ctx`.\r\n        // - If level > 0, we are in an embedded view. We need to retrieve the name of the\r\n        // local var we used to store the component context, e.g. const $comp$ = x();\r\n        return this.bindingLevel === 0 ? null : this.getComponentProperty(name);\r\n    }\r\n    /**\r\n     * Create a local variable for later reference.\r\n     *\r\n     * @param retrievalLevel The level from which this value can be retrieved\r\n     * @param name Name of the variable.\r\n     * @param lhs AST representing the left hand side of the `let lhs = rhs;`.\r\n     * @param priority The sorting priority of this var\r\n     * @param declareLocalCallback The callback to invoke when declaring this local var\r\n     * @param localRef Whether or not this is a local ref\r\n     */\r\n    set(retrievalLevel, name, lhs, priority = 0 /* DEFAULT */, declareLocalCallback, localRef) {\r\n        if (this.map.has(name)) {\r\n            if (localRef) {\r\n                // Do not throw an error if it's a local ref and do not update existing value,\r\n                // so the first defined ref is always returned.\r\n                return this;\r\n            }\r\n            error(`The name ${name} is already defined in scope to be ${this.map.get(name)}`);\r\n        }\r\n        this.map.set(name, {\r\n            retrievalLevel: retrievalLevel,\r\n            lhs: lhs,\r\n            declare: false,\r\n            declareLocalCallback: declareLocalCallback,\r\n            priority: priority,\r\n            localRef: localRef || false\r\n        });\r\n        return this;\r\n    }\r\n    // Implemented as part of LocalResolver.\r\n    getLocal(name) {\r\n        return this.get(name);\r\n    }\r\n    // Implemented as part of LocalResolver.\r\n    notifyImplicitReceiverUse() {\r\n        if (this.bindingLevel !== 0) {\r\n            // Since the implicit receiver is accessed in an embedded view, we need to\r\n            // ensure that we declare a shared context variable for the current template\r\n            // in the update variables.\r\n            this.map.get(SHARED_CONTEXT_KEY + 0).declare = true;\r\n        }\r\n    }\r\n    nestedScope(level, globals) {\r\n        const newScope = new BindingScope(level, this, globals);\r\n        if (level > 0)\r\n            newScope.generateSharedContextVar(0);\r\n        return newScope;\r\n    }\r\n    /**\r\n     * Gets or creates a shared context variable and returns its expression. Note that\r\n     * this does not mean that the shared variable will be declared. Variables in the\r\n     * binding scope will be only declared if they are used.\r\n     */\r\n    getOrCreateSharedContextVar(retrievalLevel) {\r\n        const bindingKey = SHARED_CONTEXT_KEY + retrievalLevel;\r\n        if (!this.map.has(bindingKey)) {\r\n            this.generateSharedContextVar(retrievalLevel);\r\n        }\r\n        // Shared context variables are always generated as \"ReadVarExpr\".\r\n        return this.map.get(bindingKey).lhs;\r\n    }\r\n    getSharedContextName(retrievalLevel) {\r\n        const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + retrievalLevel);\r\n        // Shared context variables are always generated as \"ReadVarExpr\".\r\n        return sharedCtxObj && sharedCtxObj.declare ? sharedCtxObj.lhs : null;\r\n    }\r\n    maybeGenerateSharedContextVar(value) {\r\n        if (value.priority === 1 /* CONTEXT */ &&\r\n            value.retrievalLevel < this.bindingLevel) {\r\n            const sharedCtxObj = this.map.get(SHARED_CONTEXT_KEY + value.retrievalLevel);\r\n            if (sharedCtxObj) {\r\n                sharedCtxObj.declare = true;\r\n            }\r\n            else {\r\n                this.generateSharedContextVar(value.retrievalLevel);\r\n            }\r\n        }\r\n    }\r\n    generateSharedContextVar(retrievalLevel) {\r\n        const lhs = variable(CONTEXT_NAME + this.freshReferenceName());\r\n        this.map.set(SHARED_CONTEXT_KEY + retrievalLevel, {\r\n            retrievalLevel: retrievalLevel,\r\n            lhs: lhs,\r\n            declareLocalCallback: (scope, relativeLevel) => {\r\n                // const ctx_r0 = nextContext(2);\r\n                return [lhs.set(generateNextContextExpr(relativeLevel)).toConstDecl()];\r\n            },\r\n            declare: false,\r\n            priority: 2 /* SHARED_CONTEXT */,\r\n            localRef: false\r\n        });\r\n    }\r\n    getComponentProperty(name) {\r\n        const componentValue = this.map.get(SHARED_CONTEXT_KEY + 0);\r\n        componentValue.declare = true;\r\n        this.maybeRestoreView(0, false);\r\n        return componentValue.lhs.prop(name);\r\n    }\r\n    maybeRestoreView(retrievalLevel, localRefLookup) {\r\n        // We want to restore the current view in listener fns if:\r\n        // 1 - we are accessing a value in a parent view, which requires walking the view tree rather\r\n        // than using the ctx arg. In this case, the retrieval and binding level will be different.\r\n        // 2 - we are looking up a local ref, which requires restoring the view where the local\r\n        // ref is stored\r\n        if (this.isListenerScope() && (retrievalLevel < this.bindingLevel || localRefLookup)) {\r\n            if (!this.parent.restoreViewVariable) {\r\n                // parent saves variable to generate a shared `const $s$ = getCurrentView();` instruction\r\n                this.parent.restoreViewVariable = variable(this.parent.freshReferenceName());\r\n            }\r\n            this.restoreViewVariable = this.parent.restoreViewVariable;\r\n        }\r\n    }\r\n    restoreViewStatement() {\r\n        const statements = [];\r\n        if (this.restoreViewVariable) {\r\n            const restoreCall = instruction(null, Identifiers.restoreView, [this.restoreViewVariable]);\r\n            // Either `const restoredCtx = restoreView($state$);` or `restoreView($state$);`\r\n            // depending on whether it is being used.\r\n            statements.push(this.usesRestoredViewContext ?\r\n                variable(RESTORED_VIEW_CONTEXT_NAME).set(restoreCall).toConstDecl() :\r\n                restoreCall.toStmt());\r\n        }\r\n        return statements;\r\n    }\r\n    viewSnapshotStatements() {\r\n        // const $state$ = getCurrentView();\r\n        return this.restoreViewVariable ?\r\n            [this.restoreViewVariable.set(instruction(null, Identifiers.getCurrentView, [])).toConstDecl()] :\r\n            [];\r\n    }\r\n    isListenerScope() {\r\n        return this.parent && this.parent.bindingLevel === this.bindingLevel;\r\n    }\r\n    variableDeclarations() {\r\n        let currentContextLevel = 0;\r\n        return Array.from(this.map.values())\r\n            .filter(value => value.declare)\r\n            .sort((a, b) => b.retrievalLevel - a.retrievalLevel || b.priority - a.priority)\r\n            .reduce((stmts, value) => {\r\n            const levelDiff = this.bindingLevel - value.retrievalLevel;\r\n            const currStmts = value.declareLocalCallback(this, levelDiff - currentContextLevel);\r\n            currentContextLevel = levelDiff;\r\n            return stmts.concat(currStmts);\r\n        }, []);\r\n    }\r\n    freshReferenceName() {\r\n        let current = this;\r\n        // Find the top scope as it maintains the global reference count\r\n        while (current.parent)\r\n            current = current.parent;\r\n        const ref = `${REFERENCE_PREFIX}${current.referenceNameIndex++}`;\r\n        return ref;\r\n    }\r\n    hasRestoreViewVariable() {\r\n        return !!this.restoreViewVariable;\r\n    }\r\n    notifyRestoredViewContextUse() {\r\n        this.usesRestoredViewContext = true;\r\n    }\r\n}\r\n/**\r\n * Creates a `CssSelector` given a tag name and a map of attributes\r\n */\r\nfunction createCssSelector(elementName, attributes) {\r\n    const cssSelector = new CssSelector();\r\n    const elementNameNoNs = splitNsName(elementName)[1];\r\n    cssSelector.setElement(elementNameNoNs);\r\n    Object.getOwnPropertyNames(attributes).forEach((name) => {\r\n        const nameNoNs = splitNsName(name)[1];\r\n        const value = attributes[name];\r\n        cssSelector.addAttribute(nameNoNs, value);\r\n        if (name.toLowerCase() === 'class') {\r\n            const classes = value.trim().split(/\\s+/);\r\n            classes.forEach(className => cssSelector.addClassName(className));\r\n        }\r\n    });\r\n    return cssSelector;\r\n}\r\n/**\r\n * Creates an array of expressions out of an `ngProjectAs` attributes\r\n * which can be added to the instruction parameters.\r\n */\r\nfunction getNgProjectAsLiteral(attribute) {\r\n    // Parse the attribute value into a CssSelectorList. Note that we only take the\r\n    // first selector, because we don't support multiple selectors in ngProjectAs.\r\n    const parsedR3Selector = parseSelectorToR3Selector(attribute.value)[0];\r\n    return [literal(5 /* ProjectAs */), asLiteral(parsedR3Selector)];\r\n}\r\n/**\r\n * Gets the instruction to generate for an interpolated property\r\n * @param interpolation An Interpolation AST\r\n */\r\nfunction getPropertyInterpolationExpression(interpolation) {\r\n    switch (getInterpolationArgsLength(interpolation)) {\r\n        case 1:\r\n            return Identifiers.propertyInterpolate;\r\n        case 3:\r\n            return Identifiers.propertyInterpolate1;\r\n        case 5:\r\n            return Identifiers.propertyInterpolate2;\r\n        case 7:\r\n            return Identifiers.propertyInterpolate3;\r\n        case 9:\r\n            return Identifiers.propertyInterpolate4;\r\n        case 11:\r\n            return Identifiers.propertyInterpolate5;\r\n        case 13:\r\n            return Identifiers.propertyInterpolate6;\r\n        case 15:\r\n            return Identifiers.propertyInterpolate7;\r\n        case 17:\r\n            return Identifiers.propertyInterpolate8;\r\n        default:\r\n            return Identifiers.propertyInterpolateV;\r\n    }\r\n}\r\n/**\r\n * Gets the instruction to generate for an interpolated attribute\r\n * @param interpolation An Interpolation AST\r\n */\r\nfunction getAttributeInterpolationExpression(interpolation) {\r\n    switch (getInterpolationArgsLength(interpolation)) {\r\n        case 3:\r\n            return Identifiers.attributeInterpolate1;\r\n        case 5:\r\n            return Identifiers.attributeInterpolate2;\r\n        case 7:\r\n            return Identifiers.attributeInterpolate3;\r\n        case 9:\r\n            return Identifiers.attributeInterpolate4;\r\n        case 11:\r\n            return Identifiers.attributeInterpolate5;\r\n        case 13:\r\n            return Identifiers.attributeInterpolate6;\r\n        case 15:\r\n            return Identifiers.attributeInterpolate7;\r\n        case 17:\r\n            return Identifiers.attributeInterpolate8;\r\n        default:\r\n            return Identifiers.attributeInterpolateV;\r\n    }\r\n}\r\n/**\r\n * Gets the instruction to generate for interpolated text.\r\n * @param interpolation An Interpolation AST\r\n */\r\nfunction getTextInterpolationExpression(interpolation) {\r\n    switch (getInterpolationArgsLength(interpolation)) {\r\n        case 1:\r\n            return Identifiers.textInterpolate;\r\n        case 3:\r\n            return Identifiers.textInterpolate1;\r\n        case 5:\r\n            return Identifiers.textInterpolate2;\r\n        case 7:\r\n            return Identifiers.textInterpolate3;\r\n        case 9:\r\n            return Identifiers.textInterpolate4;\r\n        case 11:\r\n            return Identifiers.textInterpolate5;\r\n        case 13:\r\n            return Identifiers.textInterpolate6;\r\n        case 15:\r\n            return Identifiers.textInterpolate7;\r\n        case 17:\r\n            return Identifiers.textInterpolate8;\r\n        default:\r\n            return Identifiers.textInterpolateV;\r\n    }\r\n}\r\n/**\r\n * Parse a template into render3 `Node`s and additional metadata, with no other dependencies.\r\n *\r\n * @param template text of the template to parse\r\n * @param templateUrl URL to use for source mapping of the parsed template\r\n * @param options options to modify how the template is parsed\r\n */\r\nfunction parseTemplate(template, templateUrl, options = {}) {\r\n    const { interpolationConfig, preserveWhitespaces, enableI18nLegacyMessageIdFormat } = options;\r\n    const bindingParser = makeBindingParser(interpolationConfig);\r\n    const htmlParser = new HtmlParser();\r\n    const parseResult = htmlParser.parse(template, templateUrl, Object.assign(Object.assign({ leadingTriviaChars: LEADING_TRIVIA_CHARS }, options), { tokenizeExpansionForms: true }));\r\n    if (!options.alwaysAttemptHtmlToR3AstConversion && parseResult.errors &&\r\n        parseResult.errors.length > 0) {\r\n        const parsedTemplate = {\r\n            interpolationConfig,\r\n            preserveWhitespaces,\r\n            errors: parseResult.errors,\r\n            nodes: [],\r\n            styleUrls: [],\r\n            styles: [],\r\n            ngContentSelectors: []\r\n        };\r\n        if (options.collectCommentNodes) {\r\n            parsedTemplate.commentNodes = [];\r\n        }\r\n        return parsedTemplate;\r\n    }\r\n    let rootNodes = parseResult.rootNodes;\r\n    // process i18n meta information (scan attributes, generate ids)\r\n    // before we run whitespace removal process, because existing i18n\r\n    // extraction process (ng extract-i18n) relies on a raw content to generate\r\n    // message ids\r\n    const i18nMetaVisitor = new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ !preserveWhitespaces, enableI18nLegacyMessageIdFormat);\r\n    const i18nMetaResult = i18nMetaVisitor.visitAllWithErrors(rootNodes);\r\n    if (!options.alwaysAttemptHtmlToR3AstConversion && i18nMetaResult.errors &&\r\n        i18nMetaResult.errors.length > 0) {\r\n        const parsedTemplate = {\r\n            interpolationConfig,\r\n            preserveWhitespaces,\r\n            errors: i18nMetaResult.errors,\r\n            nodes: [],\r\n            styleUrls: [],\r\n            styles: [],\r\n            ngContentSelectors: []\r\n        };\r\n        if (options.collectCommentNodes) {\r\n            parsedTemplate.commentNodes = [];\r\n        }\r\n        return parsedTemplate;\r\n    }\r\n    rootNodes = i18nMetaResult.rootNodes;\r\n    if (!preserveWhitespaces) {\r\n        rootNodes = visitAll$1(new WhitespaceVisitor(), rootNodes);\r\n        // run i18n meta visitor again in case whitespaces are removed (because that might affect\r\n        // generated i18n message content) and first pass indicated that i18n content is present in a\r\n        // template. During this pass i18n IDs generated at the first pass will be preserved, so we can\r\n        // mimic existing extraction process (ng extract-i18n)\r\n        if (i18nMetaVisitor.hasI18nMeta) {\r\n            rootNodes = visitAll$1(new I18nMetaVisitor(interpolationConfig, /* keepI18nAttrs */ false), rootNodes);\r\n        }\r\n    }\r\n    const { nodes, errors, styleUrls, styles, ngContentSelectors, commentNodes } = htmlAstToRender3Ast(rootNodes, bindingParser, { collectCommentNodes: !!options.collectCommentNodes });\r\n    errors.push(...parseResult.errors, ...i18nMetaResult.errors);\r\n    const parsedTemplate = {\r\n        interpolationConfig,\r\n        preserveWhitespaces,\r\n        errors: errors.length > 0 ? errors : null,\r\n        nodes,\r\n        styleUrls,\r\n        styles,\r\n        ngContentSelectors\r\n    };\r\n    if (options.collectCommentNodes) {\r\n        parsedTemplate.commentNodes = commentNodes;\r\n    }\r\n    return parsedTemplate;\r\n}\r\nconst elementRegistry = new DomElementSchemaRegistry();\r\n/**\r\n * Construct a `BindingParser` with a default configuration.\r\n */\r\nfunction makeBindingParser(interpolationConfig = DEFAULT_INTERPOLATION_CONFIG) {\r\n    return new BindingParser(new IvyParser(new Lexer()), interpolationConfig, elementRegistry, null, []);\r\n}\r\nfunction resolveSanitizationFn(context, isAttribute) {\r\n    switch (context) {\r\n        case SecurityContext.HTML:\r\n            return importExpr(Identifiers.sanitizeHtml);\r\n        case SecurityContext.SCRIPT:\r\n            return importExpr(Identifiers.sanitizeScript);\r\n        case SecurityContext.STYLE:\r\n            // the compiler does not fill in an instruction for [style.prop?] binding\r\n            // values because the style algorithm knows internally what props are subject\r\n            // to sanitization (only [attr.style] values are explicitly sanitized)\r\n            return isAttribute ? importExpr(Identifiers.sanitizeStyle) : null;\r\n        case SecurityContext.URL:\r\n            return importExpr(Identifiers.sanitizeUrl);\r\n        case SecurityContext.RESOURCE_URL:\r\n            return importExpr(Identifiers.sanitizeResourceUrl);\r\n        default:\r\n            return null;\r\n    }\r\n}\r\nfunction trustedConstAttribute(tagName, attr) {\r\n    const value = asLiteral(attr.value);\r\n    if (isTrustedTypesSink(tagName, attr.name)) {\r\n        switch (elementRegistry.securityContext(tagName, attr.name, /* isAttribute */ true)) {\r\n            case SecurityContext.HTML:\r\n                return taggedTemplate(importExpr(Identifiers.trustConstantHtml), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), undefined, attr.valueSpan);\r\n            // NB: no SecurityContext.SCRIPT here, as the corresponding tags are stripped by the compiler.\r\n            case SecurityContext.RESOURCE_URL:\r\n                return taggedTemplate(importExpr(Identifiers.trustConstantResourceUrl), new TemplateLiteral([new TemplateLiteralElement(attr.value)], []), undefined, attr.valueSpan);\r\n            default:\r\n                return value;\r\n        }\r\n    }\r\n    else {\r\n        return value;\r\n    }\r\n}\r\nfunction isSingleElementTemplate(children) {\r\n    return children.length === 1 && children[0] instanceof Element;\r\n}\r\nfunction isTextNode(node) {\r\n    return node instanceof Text || node instanceof BoundText || node instanceof Icu;\r\n}\r\nfunction hasTextChildrenOnly(children) {\r\n    return children.every(isTextNode);\r\n}\r\n/** Name of the global variable that is used to determine if we use Closure translations or not */\r\nconst NG_I18N_CLOSURE_MODE = 'ngI18nClosureMode';\r\n/**\r\n * Generate statements that define a given translation message.\r\n *\r\n * ```\r\n * var I18N_1;\r\n * if (typeof ngI18nClosureMode !== undefined && ngI18nClosureMode) {\r\n *     var MSG_EXTERNAL_XXX = goog.getMsg(\r\n *          \"Some message with {$interpolation}!\",\r\n *          { \"interpolation\": \"\\uFFFD0\\uFFFD\" }\r\n *     );\r\n *     I18N_1 = MSG_EXTERNAL_XXX;\r\n * }\r\n * else {\r\n *     I18N_1 = $localize`Some message with ${'\\uFFFD0\\uFFFD'}!`;\r\n * }\r\n * ```\r\n *\r\n * @param message The original i18n AST message node\r\n * @param variable The variable that will be assigned the translation, e.g. `I18N_1`.\r\n * @param closureVar The variable for Closure `goog.getMsg` calls, e.g. `MSG_EXTERNAL_XXX`.\r\n * @param params Object mapping placeholder names to their values (e.g.\r\n * `{ \"interpolation\": \"\\uFFFD0\\uFFFD\" }`).\r\n * @param transformFn Optional transformation function that will be applied to the translation (e.g.\r\n * post-processing).\r\n * @returns An array of statements that defined a given translation.\r\n */\r\nfunction getTranslationDeclStmts(message, variable, closureVar, params = {}, transformFn) {\r\n    const statements = [\r\n        declareI18nVariable(variable),\r\n        ifStmt(createClosureModeGuard(), createGoogleGetMsgStatements(variable, message, closureVar, i18nFormatPlaceholderNames(params, /* useCamelCase */ true)), createLocalizeStatements(variable, message, i18nFormatPlaceholderNames(params, /* useCamelCase */ false))),\r\n    ];\r\n    if (transformFn) {\r\n        statements.push(new ExpressionStatement(variable.set(transformFn(variable))));\r\n    }\r\n    return statements;\r\n}\r\n/**\r\n * Create the expression that will be used to guard the closure mode block\r\n * It is equivalent to:\r\n *\r\n * ```\r\n * typeof ngI18nClosureMode !== undefined && ngI18nClosureMode\r\n * ```\r\n */\r\nfunction createClosureModeGuard() {\r\n    return typeofExpr(variable(NG_I18N_CLOSURE_MODE))\r\n        .notIdentical(literal('undefined', STRING_TYPE))\r\n        .and(variable(NG_I18N_CLOSURE_MODE));\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n// This regex matches any binding names that contain the \"attr.\" prefix, e.g. \"attr.required\"\r\n// If there is a match, the first matching group will contain the attribute name to bind.\r\nconst ATTR_REGEX = /attr\\.([^\\]]+)/;\r\nfunction baseDirectiveFields(meta, constantPool, bindingParser) {\r\n    const definitionMap = new DefinitionMap();\r\n    const selectors = parseSelectorToR3Selector(meta.selector);\r\n    // e.g. `type: MyDirective`\r\n    definitionMap.set('type', meta.internalType);\r\n    // e.g. `selectors: [['', 'someDir', '']]`\r\n    if (selectors.length > 0) {\r\n        definitionMap.set('selectors', asLiteral(selectors));\r\n    }\r\n    if (meta.queries.length > 0) {\r\n        // e.g. `contentQueries: (rf, ctx, dirIndex) => { ... }\r\n        definitionMap.set('contentQueries', createContentQueriesFunction(meta.queries, constantPool, meta.name));\r\n    }\r\n    if (meta.viewQueries.length) {\r\n        definitionMap.set('viewQuery', createViewQueriesFunction(meta.viewQueries, constantPool, meta.name));\r\n    }\r\n    // e.g. `hostBindings: (rf, ctx) => { ... }\r\n    definitionMap.set('hostBindings', createHostBindingsFunction(meta.host, meta.typeSourceSpan, bindingParser, constantPool, meta.selector || '', meta.name, definitionMap));\r\n    // e.g 'inputs: {a: 'a'}`\r\n    definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));\r\n    // e.g 'outputs: {a: 'a'}`\r\n    definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));\r\n    if (meta.exportAs !== null) {\r\n        definitionMap.set('exportAs', literalArr(meta.exportAs.map(e => literal(e))));\r\n    }\r\n    return definitionMap;\r\n}\r\n/**\r\n * Add features to the definition map.\r\n */\r\nfunction addFeatures(definitionMap, meta) {\r\n    // e.g. `features: [NgOnChangesFeature]`\r\n    const features = [];\r\n    const providers = meta.providers;\r\n    const viewProviders = meta.viewProviders;\r\n    if (providers || viewProviders) {\r\n        const args = [providers || new LiteralArrayExpr([])];\r\n        if (viewProviders) {\r\n            args.push(viewProviders);\r\n        }\r\n        features.push(importExpr(Identifiers.ProvidersFeature).callFn(args));\r\n    }\r\n    if (meta.usesInheritance) {\r\n        features.push(importExpr(Identifiers.InheritDefinitionFeature));\r\n    }\r\n    if (meta.fullInheritance) {\r\n        features.push(importExpr(Identifiers.CopyDefinitionFeature));\r\n    }\r\n    if (meta.lifecycle.usesOnChanges) {\r\n        features.push(importExpr(Identifiers.NgOnChangesFeature));\r\n    }\r\n    if (features.length) {\r\n        definitionMap.set('features', literalArr(features));\r\n    }\r\n}\r\n/**\r\n * Compile a directive for the render3 runtime as defined by the `R3DirectiveMetadata`.\r\n */\r\nfunction compileDirectiveFromMetadata(meta, constantPool, bindingParser) {\r\n    const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\r\n    addFeatures(definitionMap, meta);\r\n    const expression = importExpr(Identifiers.defineDirective).callFn([definitionMap.toLiteralMap()], undefined, true);\r\n    const type = createDirectiveType(meta);\r\n    return { expression, type, statements: [] };\r\n}\r\n/**\r\n * Compile a component for the render3 runtime as defined by the `R3ComponentMetadata`.\r\n */\r\nfunction compileComponentFromMetadata(meta, constantPool, bindingParser) {\r\n    const definitionMap = baseDirectiveFields(meta, constantPool, bindingParser);\r\n    addFeatures(definitionMap, meta);\r\n    const selector = meta.selector && CssSelector.parse(meta.selector);\r\n    const firstSelector = selector && selector[0];\r\n    // e.g. `attr: [\"class\", \".my.app\"]`\r\n    // This is optional an only included if the first selector of a component specifies attributes.\r\n    if (firstSelector) {\r\n        const selectorAttributes = firstSelector.getAttrs();\r\n        if (selectorAttributes.length) {\r\n            definitionMap.set('attrs', constantPool.getConstLiteral(literalArr(selectorAttributes.map(value => value != null ? literal(value) : literal(undefined))), \r\n            /* forceShared */ true));\r\n        }\r\n    }\r\n    // Generate the CSS matcher that recognize directive\r\n    let directiveMatcher = null;\r\n    if (meta.directives.length > 0) {\r\n        const matcher = new SelectorMatcher();\r\n        for (const { selector, type } of meta.directives) {\r\n            matcher.addSelectables(CssSelector.parse(selector), type);\r\n        }\r\n        directiveMatcher = matcher;\r\n    }\r\n    // e.g. `template: function MyComponent_Template(_ctx, _cm) {...}`\r\n    const templateTypeName = meta.name;\r\n    const templateName = templateTypeName ? `${templateTypeName}_Template` : null;\r\n    const directivesUsed = new Set();\r\n    const pipesUsed = new Set();\r\n    const changeDetection = meta.changeDetection;\r\n    const template = meta.template;\r\n    const templateBuilder = new TemplateDefinitionBuilder(constantPool, BindingScope.createRootScope(), 0, templateTypeName, null, null, templateName, directiveMatcher, directivesUsed, meta.pipes, pipesUsed, Identifiers.namespaceHTML, meta.relativeContextFilePath, meta.i18nUseExternalIds);\r\n    const templateFunctionExpression = templateBuilder.buildTemplateFunction(template.nodes, []);\r\n    // We need to provide this so that dynamically generated components know what\r\n    // projected content blocks to pass through to the component when it is instantiated.\r\n    const ngContentSelectors = templateBuilder.getNgContentSelectors();\r\n    if (ngContentSelectors) {\r\n        definitionMap.set('ngContentSelectors', ngContentSelectors);\r\n    }\r\n    // e.g. `decls: 2`\r\n    definitionMap.set('decls', literal(templateBuilder.getConstCount()));\r\n    // e.g. `vars: 2`\r\n    definitionMap.set('vars', literal(templateBuilder.getVarCount()));\r\n    // Generate `consts` section of ComponentDef:\r\n    // - either as an array:\r\n    //   `consts: [['one', 'two'], ['three', 'four']]`\r\n    // - or as a factory function in case additional statements are present (to support i18n):\r\n    //   `consts: function() { var i18n_0; if (ngI18nClosureMode) {...} else {...} return [i18n_0]; }`\r\n    const { constExpressions, prepareStatements } = templateBuilder.getConsts();\r\n    if (constExpressions.length > 0) {\r\n        let constsExpr = literalArr(constExpressions);\r\n        // Prepare statements are present - turn `consts` into a function.\r\n        if (prepareStatements.length > 0) {\r\n            constsExpr = fn([], [...prepareStatements, new ReturnStatement(constsExpr)]);\r\n        }\r\n        definitionMap.set('consts', constsExpr);\r\n    }\r\n    definitionMap.set('template', templateFunctionExpression);\r\n    // e.g. `directives: [MyDirective]`\r\n    if (directivesUsed.size) {\r\n        const directivesList = literalArr(Array.from(directivesUsed));\r\n        const directivesExpr = compileDeclarationList(directivesList, meta.declarationListEmitMode);\r\n        definitionMap.set('directives', directivesExpr);\r\n    }\r\n    // e.g. `pipes: [MyPipe]`\r\n    if (pipesUsed.size) {\r\n        const pipesList = literalArr(Array.from(pipesUsed));\r\n        const pipesExpr = compileDeclarationList(pipesList, meta.declarationListEmitMode);\r\n        definitionMap.set('pipes', pipesExpr);\r\n    }\r\n    if (meta.encapsulation === null) {\r\n        meta.encapsulation = ViewEncapsulation.Emulated;\r\n    }\r\n    // e.g. `styles: [str1, str2]`\r\n    if (meta.styles && meta.styles.length) {\r\n        const styleValues = meta.encapsulation == ViewEncapsulation.Emulated ?\r\n            compileStyles(meta.styles, CONTENT_ATTR, HOST_ATTR) :\r\n            meta.styles;\r\n        const strings = styleValues.map(str => constantPool.getConstLiteral(literal(str)));\r\n        definitionMap.set('styles', literalArr(strings));\r\n    }\r\n    else if (meta.encapsulation === ViewEncapsulation.Emulated) {\r\n        // If there is no style, don't generate css selectors on elements\r\n        meta.encapsulation = ViewEncapsulation.None;\r\n    }\r\n    // Only set view encapsulation if it's not the default value\r\n    if (meta.encapsulation !== ViewEncapsulation.Emulated) {\r\n        definitionMap.set('encapsulation', literal(meta.encapsulation));\r\n    }\r\n    // e.g. `animation: [trigger('123', [])]`\r\n    if (meta.animations !== null) {\r\n        definitionMap.set('data', literalMap([{ key: 'animation', value: meta.animations, quoted: false }]));\r\n    }\r\n    // Only set the change detection flag if it's defined and it's not the default.\r\n    if (changeDetection != null && changeDetection !== ChangeDetectionStrategy.Default) {\r\n        definitionMap.set('changeDetection', literal(changeDetection));\r\n    }\r\n    const expression = importExpr(Identifiers.defineComponent).callFn([definitionMap.toLiteralMap()], undefined, true);\r\n    const type = createComponentType(meta);\r\n    return { expression, type, statements: [] };\r\n}\r\n/**\r\n * Creates the type specification from the component meta. This type is inserted into .d.ts files\r\n * to be consumed by upstream compilations.\r\n */\r\nfunction createComponentType(meta) {\r\n    const typeParams = createDirectiveTypeParams(meta);\r\n    typeParams.push(stringArrayAsType(meta.template.ngContentSelectors));\r\n    return expressionType(importExpr(Identifiers.ComponentDeclaration, typeParams));\r\n}\r\n/**\r\n * Compiles the array literal of declarations into an expression according to the provided emit\r\n * mode.\r\n */\r\nfunction compileDeclarationList(list, mode) {\r\n    switch (mode) {\r\n        case 0 /* Direct */:\r\n            // directives: [MyDir],\r\n            return list;\r\n        case 1 /* Closure */:\r\n            // directives: function () { return [MyDir]; }\r\n            return fn([], [new ReturnStatement(list)]);\r\n        case 2 /* ClosureResolved */:\r\n            // directives: function () { return [MyDir].map(ng.resolveForwardRef); }\r\n            const resolvedList = list.callMethod('map', [importExpr(Identifiers.resolveForwardRef)]);\r\n            return fn([], [new ReturnStatement(resolvedList)]);\r\n    }\r\n}\r\nfunction prepareQueryParams(query, constantPool) {\r\n    const parameters = [getQueryPredicate(query, constantPool), literal(toQueryFlags(query))];\r\n    if (query.read) {\r\n        parameters.push(query.read);\r\n    }\r\n    return parameters;\r\n}\r\n/**\r\n * Translates query flags into `TQueryFlags` type in packages/core/src/render3/interfaces/query.ts\r\n * @param query\r\n */\r\nfunction toQueryFlags(query) {\r\n    return (query.descendants ? 1 /* descendants */ : 0 /* none */) |\r\n        (query.static ? 2 /* isStatic */ : 0 /* none */) |\r\n        (query.emitDistinctChangesOnly ? 4 /* emitDistinctChangesOnly */ : 0 /* none */);\r\n}\r\nfunction convertAttributesToExpressions(attributes) {\r\n    const values = [];\r\n    for (let key of Object.getOwnPropertyNames(attributes)) {\r\n        const value = attributes[key];\r\n        values.push(literal(key), value);\r\n    }\r\n    return values;\r\n}\r\n// Define and update any content queries\r\nfunction createContentQueriesFunction(queries, constantPool, name) {\r\n    const createStatements = [];\r\n    const updateStatements = [];\r\n    const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\r\n    for (const query of queries) {\r\n        // creation, e.g. r3.contentQuery(dirIndex, somePredicate, true, null);\r\n        createStatements.push(importExpr(Identifiers.contentQuery)\r\n            .callFn([variable('dirIndex'), ...prepareQueryParams(query, constantPool)])\r\n            .toStmt());\r\n        // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\r\n        const temporary = tempAllocator();\r\n        const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);\r\n        const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);\r\n        const updateDirective = variable(CONTEXT_NAME)\r\n            .prop(query.propertyName)\r\n            .set(query.first ? temporary.prop('first') : temporary);\r\n        updateStatements.push(refresh.and(updateDirective).toStmt());\r\n    }\r\n    const contentQueriesFnName = name ? `${name}_ContentQueries` : null;\r\n    return fn([\r\n        new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null),\r\n        new FnParam('dirIndex', null)\r\n    ], [\r\n        renderFlagCheckIfStmt(1 /* Create */, createStatements),\r\n        renderFlagCheckIfStmt(2 /* Update */, updateStatements)\r\n    ], INFERRED_TYPE, null, contentQueriesFnName);\r\n}\r\nfunction stringAsType(str) {\r\n    return expressionType(literal(str));\r\n}\r\nfunction stringMapAsType(map) {\r\n    const mapValues = Object.keys(map).map(key => {\r\n        const value = Array.isArray(map[key]) ? map[key][0] : map[key];\r\n        return {\r\n            key,\r\n            value: literal(value),\r\n            quoted: true,\r\n        };\r\n    });\r\n    return expressionType(literalMap(mapValues));\r\n}\r\nfunction stringArrayAsType(arr) {\r\n    return arr.length > 0 ? expressionType(literalArr(arr.map(value => literal(value)))) :\r\n        NONE_TYPE;\r\n}\r\nfunction createDirectiveTypeParams(meta) {\r\n    // On the type side, remove newlines from the selector as it will need to fit into a TypeScript\r\n    // string literal, which must be on one line.\r\n    const selectorForType = meta.selector !== null ? meta.selector.replace(/\\n/g, '') : null;\r\n    return [\r\n        typeWithParameters(meta.type.type, meta.typeArgumentCount),\r\n        selectorForType !== null ? stringAsType(selectorForType) : NONE_TYPE,\r\n        meta.exportAs !== null ? stringArrayAsType(meta.exportAs) : NONE_TYPE,\r\n        stringMapAsType(meta.inputs),\r\n        stringMapAsType(meta.outputs),\r\n        stringArrayAsType(meta.queries.map(q => q.propertyName)),\r\n    ];\r\n}\r\n/**\r\n * Creates the type specification from the directive meta. This type is inserted into .d.ts files\r\n * to be consumed by upstream compilations.\r\n */\r\nfunction createDirectiveType(meta) {\r\n    const typeParams = createDirectiveTypeParams(meta);\r\n    return expressionType(importExpr(Identifiers.DirectiveDeclaration, typeParams));\r\n}\r\n// Define and update any view queries\r\nfunction createViewQueriesFunction(viewQueries, constantPool, name) {\r\n    const createStatements = [];\r\n    const updateStatements = [];\r\n    const tempAllocator = temporaryAllocator(updateStatements, TEMPORARY_NAME);\r\n    viewQueries.forEach((query) => {\r\n        // creation, e.g. r3.viewQuery(somePredicate, true);\r\n        const queryDefinition = importExpr(Identifiers.viewQuery).callFn(prepareQueryParams(query, constantPool));\r\n        createStatements.push(queryDefinition.toStmt());\r\n        // update, e.g. (r3.queryRefresh(tmp = r3.loadQuery()) && (ctx.someDir = tmp));\r\n        const temporary = tempAllocator();\r\n        const getQueryList = importExpr(Identifiers.loadQuery).callFn([]);\r\n        const refresh = importExpr(Identifiers.queryRefresh).callFn([temporary.set(getQueryList)]);\r\n        const updateDirective = variable(CONTEXT_NAME)\r\n            .prop(query.propertyName)\r\n            .set(query.first ? temporary.prop('first') : temporary);\r\n        updateStatements.push(refresh.and(updateDirective).toStmt());\r\n    });\r\n    const viewQueryFnName = name ? `${name}_Query` : null;\r\n    return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [\r\n        renderFlagCheckIfStmt(1 /* Create */, createStatements),\r\n        renderFlagCheckIfStmt(2 /* Update */, updateStatements)\r\n    ], INFERRED_TYPE, null, viewQueryFnName);\r\n}\r\n// Return a host binding function or null if one is not necessary.\r\nfunction createHostBindingsFunction(hostBindingsMetadata, typeSourceSpan, bindingParser, constantPool, selector, name, definitionMap) {\r\n    const bindingContext = variable(CONTEXT_NAME);\r\n    const styleBuilder = new StylingBuilder(bindingContext);\r\n    const { styleAttr, classAttr } = hostBindingsMetadata.specialAttributes;\r\n    if (styleAttr !== undefined) {\r\n        styleBuilder.registerStyleAttr(styleAttr);\r\n    }\r\n    if (classAttr !== undefined) {\r\n        styleBuilder.registerClassAttr(classAttr);\r\n    }\r\n    const createStatements = [];\r\n    const updateStatements = [];\r\n    const hostBindingSourceSpan = typeSourceSpan;\r\n    const directiveSummary = metadataAsSummary(hostBindingsMetadata);\r\n    // Calculate host event bindings\r\n    const eventBindings = bindingParser.createDirectiveHostEventAsts(directiveSummary, hostBindingSourceSpan);\r\n    if (eventBindings && eventBindings.length) {\r\n        const listeners = createHostListeners(eventBindings, name);\r\n        createStatements.push(...listeners);\r\n    }\r\n    // Calculate the host property bindings\r\n    const bindings = bindingParser.createBoundHostProperties(directiveSummary, hostBindingSourceSpan);\r\n    const allOtherBindings = [];\r\n    // We need to calculate the total amount of binding slots required by\r\n    // all the instructions together before any value conversions happen.\r\n    // Value conversions may require additional slots for interpolation and\r\n    // bindings with pipes. These calculates happen after this block.\r\n    let totalHostVarsCount = 0;\r\n    bindings && bindings.forEach((binding) => {\r\n        const stylingInputWasSet = styleBuilder.registerInputBasedOnName(binding.name, binding.expression, hostBindingSourceSpan);\r\n        if (stylingInputWasSet) {\r\n            totalHostVarsCount += MIN_STYLING_BINDING_SLOTS_REQUIRED;\r\n        }\r\n        else {\r\n            allOtherBindings.push(binding);\r\n            totalHostVarsCount++;\r\n        }\r\n    });\r\n    let valueConverter;\r\n    const getValueConverter = () => {\r\n        if (!valueConverter) {\r\n            const hostVarsCountFn = (numSlots) => {\r\n                const originalVarsCount = totalHostVarsCount;\r\n                totalHostVarsCount += numSlots;\r\n                return originalVarsCount;\r\n            };\r\n            valueConverter = new ValueConverter(constantPool, () => error('Unexpected node'), // new nodes are illegal here\r\n            hostVarsCountFn, () => error('Unexpected pipe')); // pipes are illegal here\r\n        }\r\n        return valueConverter;\r\n    };\r\n    const propertyBindings = [];\r\n    const attributeBindings = [];\r\n    const syntheticHostBindings = [];\r\n    allOtherBindings.forEach((binding) => {\r\n        // resolve literal arrays and literal objects\r\n        const value = binding.expression.visit(getValueConverter());\r\n        const bindingExpr = bindingFn(bindingContext, value);\r\n        const { bindingName, instruction, isAttribute } = getBindingNameAndInstruction(binding);\r\n        const securityContexts = bindingParser.calcPossibleSecurityContexts(selector, bindingName, isAttribute)\r\n            .filter(context => context !== SecurityContext.NONE);\r\n        let sanitizerFn = null;\r\n        if (securityContexts.length) {\r\n            if (securityContexts.length === 2 &&\r\n                securityContexts.indexOf(SecurityContext.URL) > -1 &&\r\n                securityContexts.indexOf(SecurityContext.RESOURCE_URL) > -1) {\r\n                // Special case for some URL attributes (such as \"src\" and \"href\") that may be a part\r\n                // of different security contexts. In this case we use special sanitization function and\r\n                // select the actual sanitizer at runtime based on a tag name that is provided while\r\n                // invoking sanitization function.\r\n                sanitizerFn = importExpr(Identifiers.sanitizeUrlOrResourceUrl);\r\n            }\r\n            else {\r\n                sanitizerFn = resolveSanitizationFn(securityContexts[0], isAttribute);\r\n            }\r\n        }\r\n        const instructionParams = [literal(bindingName), bindingExpr.currValExpr];\r\n        if (sanitizerFn) {\r\n            instructionParams.push(sanitizerFn);\r\n        }\r\n        updateStatements.push(...bindingExpr.stmts);\r\n        if (instruction === Identifiers.hostProperty) {\r\n            propertyBindings.push(instructionParams);\r\n        }\r\n        else if (instruction === Identifiers.attribute) {\r\n            attributeBindings.push(instructionParams);\r\n        }\r\n        else if (instruction === Identifiers.syntheticHostProperty) {\r\n            syntheticHostBindings.push(instructionParams);\r\n        }\r\n        else {\r\n            updateStatements.push(importExpr(instruction).callFn(instructionParams).toStmt());\r\n        }\r\n    });\r\n    if (propertyBindings.length > 0) {\r\n        updateStatements.push(chainedInstruction(Identifiers.hostProperty, propertyBindings).toStmt());\r\n    }\r\n    if (attributeBindings.length > 0) {\r\n        updateStatements.push(chainedInstruction(Identifiers.attribute, attributeBindings).toStmt());\r\n    }\r\n    if (syntheticHostBindings.length > 0) {\r\n        updateStatements.push(chainedInstruction(Identifiers.syntheticHostProperty, syntheticHostBindings).toStmt());\r\n    }\r\n    // since we're dealing with directives/components and both have hostBinding\r\n    // functions, we need to generate a special hostAttrs instruction that deals\r\n    // with both the assignment of styling as well as static attributes to the host\r\n    // element. The instruction below will instruct all initial styling (styling\r\n    // that is inside of a host binding within a directive/component) to be attached\r\n    // to the host element alongside any of the provided host attributes that were\r\n    // collected earlier.\r\n    const hostAttrs = convertAttributesToExpressions(hostBindingsMetadata.attributes);\r\n    styleBuilder.assignHostAttrs(hostAttrs, definitionMap);\r\n    if (styleBuilder.hasBindings) {\r\n        // finally each binding that was registered in the statement above will need to be added to\r\n        // the update block of a component/directive templateFn/hostBindingsFn so that the bindings\r\n        // are evaluated and updated for the element.\r\n        styleBuilder.buildUpdateLevelInstructions(getValueConverter()).forEach(instruction => {\r\n            if (instruction.calls.length > 0) {\r\n                const calls = [];\r\n                instruction.calls.forEach(call => {\r\n                    // we subtract a value of `1` here because the binding slot was already allocated\r\n                    // at the top of this method when all the input bindings were counted.\r\n                    totalHostVarsCount +=\r\n                        Math.max(call.allocateBindingSlots - MIN_STYLING_BINDING_SLOTS_REQUIRED, 0);\r\n                    calls.push(convertStylingCall(call, bindingContext, bindingFn));\r\n                });\r\n                updateStatements.push(chainedInstruction(instruction.reference, calls).toStmt());\r\n            }\r\n        });\r\n    }\r\n    if (totalHostVarsCount) {\r\n        definitionMap.set('hostVars', literal(totalHostVarsCount));\r\n    }\r\n    if (createStatements.length > 0 || updateStatements.length > 0) {\r\n        const hostBindingsFnName = name ? `${name}_HostBindings` : null;\r\n        const statements = [];\r\n        if (createStatements.length > 0) {\r\n            statements.push(renderFlagCheckIfStmt(1 /* Create */, createStatements));\r\n        }\r\n        if (updateStatements.length > 0) {\r\n            statements.push(renderFlagCheckIfStmt(2 /* Update */, updateStatements));\r\n        }\r\n        return fn([new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], statements, INFERRED_TYPE, null, hostBindingsFnName);\r\n    }\r\n    return null;\r\n}\r\nfunction bindingFn(implicit, value) {\r\n    return convertPropertyBinding(null, implicit, value, 'b', BindingForm.Expression, () => error('Unexpected interpolation'));\r\n}\r\nfunction convertStylingCall(call, bindingContext, bindingFn) {\r\n    return call.params(value => bindingFn(bindingContext, value).currValExpr);\r\n}\r\nfunction getBindingNameAndInstruction(binding) {\r\n    let bindingName = binding.name;\r\n    let instruction;\r\n    // Check to see if this is an attr binding or a property binding\r\n    const attrMatches = bindingName.match(ATTR_REGEX);\r\n    if (attrMatches) {\r\n        bindingName = attrMatches[1];\r\n        instruction = Identifiers.attribute;\r\n    }\r\n    else {\r\n        if (binding.isAnimation) {\r\n            bindingName = prepareSyntheticPropertyName(bindingName);\r\n            // host bindings that have a synthetic property (e.g. @foo) should always be rendered\r\n            // in the context of the component and not the parent. Therefore there is a special\r\n            // compatibility instruction available for this purpose.\r\n            instruction = Identifiers.syntheticHostProperty;\r\n        }\r\n        else {\r\n            instruction = Identifiers.hostProperty;\r\n        }\r\n    }\r\n    return { bindingName, instruction, isAttribute: !!attrMatches };\r\n}\r\nfunction createHostListeners(eventBindings, name) {\r\n    const listeners = [];\r\n    const syntheticListeners = [];\r\n    const instructions = [];\r\n    eventBindings.forEach(binding => {\r\n        let bindingName = binding.name && sanitizeIdentifier(binding.name);\r\n        const bindingFnName = binding.type === 1 /* Animation */ ?\r\n            prepareSyntheticListenerFunctionName(bindingName, binding.targetOrPhase) :\r\n            bindingName;\r\n        const handlerName = name && bindingName ? `${name}_${bindingFnName}_HostBindingHandler` : null;\r\n        const params = prepareEventListenerParameters(BoundEvent.fromParsedEvent(binding), handlerName);\r\n        if (binding.type == 1 /* Animation */) {\r\n            syntheticListeners.push(params);\r\n        }\r\n        else {\r\n            listeners.push(params);\r\n        }\r\n    });\r\n    if (syntheticListeners.length > 0) {\r\n        instructions.push(chainedInstruction(Identifiers.syntheticHostListener, syntheticListeners).toStmt());\r\n    }\r\n    if (listeners.length > 0) {\r\n        instructions.push(chainedInstruction(Identifiers.listener, listeners).toStmt());\r\n    }\r\n    return instructions;\r\n}\r\nfunction metadataAsSummary(meta) {\r\n    // clang-format off\r\n    return {\r\n        // This is used by the BindingParser, which only deals with listeners and properties. There's no\r\n        // need to pass attributes to it.\r\n        hostAttributes: {},\r\n        hostListeners: meta.listeners,\r\n        hostProperties: meta.properties,\r\n    };\r\n    // clang-format on\r\n}\r\nconst HOST_REG_EXP$1 = /^(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\))$/;\r\nfunction parseHostBindings(host) {\r\n    const attributes = {};\r\n    const listeners = {};\r\n    const properties = {};\r\n    const specialAttributes = {};\r\n    for (const key of Object.keys(host)) {\r\n        const value = host[key];\r\n        const matches = key.match(HOST_REG_EXP$1);\r\n        if (matches === null) {\r\n            switch (key) {\r\n                case 'class':\r\n                    if (typeof value !== 'string') {\r\n                        // TODO(alxhub): make this a diagnostic.\r\n                        throw new Error(`Class binding must be string`);\r\n                    }\r\n                    specialAttributes.classAttr = value;\r\n                    break;\r\n                case 'style':\r\n                    if (typeof value !== 'string') {\r\n                        // TODO(alxhub): make this a diagnostic.\r\n                        throw new Error(`Style binding must be string`);\r\n                    }\r\n                    specialAttributes.styleAttr = value;\r\n                    break;\r\n                default:\r\n                    if (typeof value === 'string') {\r\n                        attributes[key] = literal(value);\r\n                    }\r\n                    else {\r\n                        attributes[key] = value;\r\n                    }\r\n            }\r\n        }\r\n        else if (matches[1 /* Binding */] != null) {\r\n            if (typeof value !== 'string') {\r\n                // TODO(alxhub): make this a diagnostic.\r\n                throw new Error(`Property binding must be string`);\r\n            }\r\n            // synthetic properties (the ones that have a `@` as a prefix)\r\n            // are still treated the same as regular properties. Therefore\r\n            // there is no point in storing them in a separate map.\r\n            properties[matches[1 /* Binding */]] = value;\r\n        }\r\n        else if (matches[2 /* Event */] != null) {\r\n            if (typeof value !== 'string') {\r\n                // TODO(alxhub): make this a diagnostic.\r\n                throw new Error(`Event binding must be string`);\r\n            }\r\n            listeners[matches[2 /* Event */]] = value;\r\n        }\r\n    }\r\n    return { attributes, listeners, properties, specialAttributes };\r\n}\r\n/**\r\n * Verifies host bindings and returns the list of errors (if any). Empty array indicates that a\r\n * given set of host bindings has no errors.\r\n *\r\n * @param bindings set of host bindings to verify.\r\n * @param sourceSpan source span where host bindings were defined.\r\n * @returns array of errors associated with a given set of host bindings.\r\n */\r\nfunction verifyHostBindings(bindings, sourceSpan) {\r\n    const summary = metadataAsSummary(bindings);\r\n    // TODO: abstract out host bindings verification logic and use it instead of\r\n    // creating events and properties ASTs to detect errors (FW-996)\r\n    const bindingParser = makeBindingParser();\r\n    bindingParser.createDirectiveHostEventAsts(summary, sourceSpan);\r\n    bindingParser.createBoundHostProperties(summary, sourceSpan);\r\n    return bindingParser.errors;\r\n}\r\nfunction compileStyles(styles, selector, hostSelector) {\r\n    const shadowCss = new ShadowCss();\r\n    return styles.map(style => {\r\n        return shadowCss.shimCssText(style, selector, hostSelector);\r\n    });\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * An interface for retrieving documents by URL that the compiler uses\r\n * to load templates.\r\n */\r\nclass ResourceLoader {\r\n    get(url) {\r\n        return '';\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass CompilerFacadeImpl {\r\n    constructor(jitEvaluator = new JitEvaluator()) {\r\n        this.jitEvaluator = jitEvaluator;\r\n        this.FactoryTarget = FactoryTarget;\r\n        this.ResourceLoader = ResourceLoader;\r\n        this.elementSchemaRegistry = new DomElementSchemaRegistry();\r\n    }\r\n    compilePipe(angularCoreEnv, sourceMapUrl, facade) {\r\n        const metadata = {\r\n            name: facade.name,\r\n            type: wrapReference(facade.type),\r\n            internalType: new WrappedNodeExpr(facade.type),\r\n            typeArgumentCount: 0,\r\n            deps: null,\r\n            pipeName: facade.pipeName,\r\n            pure: facade.pure,\r\n        };\r\n        const res = compilePipeFromMetadata(metadata);\r\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\r\n    }\r\n    compilePipeDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\r\n        const meta = convertDeclarePipeFacadeToMetadata(declaration);\r\n        const res = compilePipeFromMetadata(meta);\r\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\r\n    }\r\n    compileInjectable(angularCoreEnv, sourceMapUrl, facade) {\r\n        var _a;\r\n        const { expression, statements } = compileInjectable({\r\n            name: facade.name,\r\n            type: wrapReference(facade.type),\r\n            internalType: new WrappedNodeExpr(facade.type),\r\n            typeArgumentCount: facade.typeArgumentCount,\r\n            providedIn: computeProvidedIn(facade.providedIn),\r\n            useClass: convertToProviderExpression(facade, USE_CLASS),\r\n            useFactory: wrapExpression(facade, USE_FACTORY),\r\n            useValue: convertToProviderExpression(facade, USE_VALUE),\r\n            useExisting: convertToProviderExpression(facade, USE_EXISTING),\r\n            deps: (_a = facade.deps) === null || _a === void 0 ? void 0 : _a.map(convertR3DependencyMetadata),\r\n        }, \r\n        /* resolveForwardRefs */ true);\r\n        return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\r\n    }\r\n    compileInjectableDeclaration(angularCoreEnv, sourceMapUrl, facade) {\r\n        var _a;\r\n        const { expression, statements } = compileInjectable({\r\n            name: facade.type.name,\r\n            type: wrapReference(facade.type),\r\n            internalType: new WrappedNodeExpr(facade.type),\r\n            typeArgumentCount: 0,\r\n            providedIn: computeProvidedIn(facade.providedIn),\r\n            useClass: convertToProviderExpression(facade, USE_CLASS),\r\n            useFactory: wrapExpression(facade, USE_FACTORY),\r\n            useValue: convertToProviderExpression(facade, USE_VALUE),\r\n            useExisting: convertToProviderExpression(facade, USE_EXISTING),\r\n            deps: (_a = facade.deps) === null || _a === void 0 ? void 0 : _a.map(convertR3DeclareDependencyMetadata),\r\n        }, \r\n        /* resolveForwardRefs */ true);\r\n        return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, statements);\r\n    }\r\n    compileInjector(angularCoreEnv, sourceMapUrl, facade) {\r\n        const meta = {\r\n            name: facade.name,\r\n            type: wrapReference(facade.type),\r\n            internalType: new WrappedNodeExpr(facade.type),\r\n            providers: new WrappedNodeExpr(facade.providers),\r\n            imports: facade.imports.map(i => new WrappedNodeExpr(i)),\r\n        };\r\n        const res = compileInjector(meta);\r\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\r\n    }\r\n    compileInjectorDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\r\n        const meta = convertDeclareInjectorFacadeToMetadata(declaration);\r\n        const res = compileInjector(meta);\r\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\r\n    }\r\n    compileNgModule(angularCoreEnv, sourceMapUrl, facade) {\r\n        const meta = {\r\n            type: wrapReference(facade.type),\r\n            internalType: new WrappedNodeExpr(facade.type),\r\n            adjacentType: new WrappedNodeExpr(facade.type),\r\n            bootstrap: facade.bootstrap.map(wrapReference),\r\n            declarations: facade.declarations.map(wrapReference),\r\n            imports: facade.imports.map(wrapReference),\r\n            exports: facade.exports.map(wrapReference),\r\n            emitInline: true,\r\n            containsForwardDecls: false,\r\n            schemas: facade.schemas ? facade.schemas.map(wrapReference) : null,\r\n            id: facade.id ? new WrappedNodeExpr(facade.id) : null,\r\n        };\r\n        const res = compileNgModule(meta);\r\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, []);\r\n    }\r\n    compileNgModuleDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\r\n        const expression = compileNgModuleDeclarationExpression(declaration);\r\n        return this.jitExpression(expression, angularCoreEnv, sourceMapUrl, []);\r\n    }\r\n    compileDirective(angularCoreEnv, sourceMapUrl, facade) {\r\n        const meta = convertDirectiveFacadeToMetadata(facade);\r\n        return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\r\n    }\r\n    compileDirectiveDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\r\n        const typeSourceSpan = this.createParseSourceSpan('Directive', declaration.type.name, sourceMapUrl);\r\n        const meta = convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan);\r\n        return this.compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta);\r\n    }\r\n    compileDirectiveFromMeta(angularCoreEnv, sourceMapUrl, meta) {\r\n        const constantPool = new ConstantPool();\r\n        const bindingParser = makeBindingParser();\r\n        const res = compileDirectiveFromMetadata(meta, constantPool, bindingParser);\r\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\r\n    }\r\n    compileComponent(angularCoreEnv, sourceMapUrl, facade) {\r\n        // Parse the template and check for errors.\r\n        const { template, interpolation } = parseJitTemplate(facade.template, facade.name, sourceMapUrl, facade.preserveWhitespaces, facade.interpolation);\r\n        // Compile the component metadata, including template, into an expression.\r\n        const meta = Object.assign(Object.assign(Object.assign({}, facade), convertDirectiveFacadeToMetadata(facade)), { selector: facade.selector || this.elementSchemaRegistry.getDefaultComponentElementName(), template, declarationListEmitMode: 0 /* Direct */, styles: [...facade.styles, ...template.styles], encapsulation: facade.encapsulation, interpolation, changeDetection: facade.changeDetection, animations: facade.animations != null ? new WrappedNodeExpr(facade.animations) : null, viewProviders: facade.viewProviders != null ? new WrappedNodeExpr(facade.viewProviders) :\r\n                null, relativeContextFilePath: '', i18nUseExternalIds: true });\r\n        const jitExpressionSourceMap = `ng:///${facade.name}.js`;\r\n        return this.compileComponentFromMeta(angularCoreEnv, jitExpressionSourceMap, meta);\r\n    }\r\n    compileComponentDeclaration(angularCoreEnv, sourceMapUrl, declaration) {\r\n        const typeSourceSpan = this.createParseSourceSpan('Component', declaration.type.name, sourceMapUrl);\r\n        const meta = convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl);\r\n        return this.compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta);\r\n    }\r\n    compileComponentFromMeta(angularCoreEnv, sourceMapUrl, meta) {\r\n        const constantPool = new ConstantPool();\r\n        const bindingParser = makeBindingParser(meta.interpolation);\r\n        const res = compileComponentFromMetadata(meta, constantPool, bindingParser);\r\n        return this.jitExpression(res.expression, angularCoreEnv, sourceMapUrl, constantPool.statements);\r\n    }\r\n    compileFactory(angularCoreEnv, sourceMapUrl, meta) {\r\n        const factoryRes = compileFactoryFunction({\r\n            name: meta.name,\r\n            type: wrapReference(meta.type),\r\n            internalType: new WrappedNodeExpr(meta.type),\r\n            typeArgumentCount: meta.typeArgumentCount,\r\n            deps: convertR3DependencyMetadataArray(meta.deps),\r\n            target: meta.target,\r\n        });\r\n        return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\r\n    }\r\n    compileFactoryDeclaration(angularCoreEnv, sourceMapUrl, meta) {\r\n        const factoryRes = compileFactoryFunction({\r\n            name: meta.type.name,\r\n            type: wrapReference(meta.type),\r\n            internalType: new WrappedNodeExpr(meta.type),\r\n            typeArgumentCount: 0,\r\n            deps: meta.deps && meta.deps.map(convertR3DeclareDependencyMetadata),\r\n            target: meta.target,\r\n        });\r\n        return this.jitExpression(factoryRes.expression, angularCoreEnv, sourceMapUrl, factoryRes.statements);\r\n    }\r\n    createParseSourceSpan(kind, typeName, sourceUrl) {\r\n        return r3JitTypeSourceSpan(kind, typeName, sourceUrl);\r\n    }\r\n    /**\r\n     * JIT compiles an expression and returns the result of executing that expression.\r\n     *\r\n     * @param def the definition which will be compiled and executed to get the value to patch\r\n     * @param context an object map of @angular/core symbol names to symbols which will be available\r\n     * in the context of the compiled expression\r\n     * @param sourceUrl a URL to use for the source map of the compiled expression\r\n     * @param preStatements a collection of statements that should be evaluated before the expression.\r\n     */\r\n    jitExpression(def, context, sourceUrl, preStatements) {\r\n        // The ConstantPool may contain Statements which declare variables used in the final expression.\r\n        // Therefore, its statements need to precede the actual JIT operation. The final statement is a\r\n        // declaration of $def which is set to the expression being compiled.\r\n        const statements = [\r\n            ...preStatements,\r\n            new DeclareVarStmt('$def', def, undefined, [StmtModifier.Exported]),\r\n        ];\r\n        const res = this.jitEvaluator.evaluateStatements(sourceUrl, statements, new R3JitReflector(context), /* enableSourceMaps */ true);\r\n        return res['$def'];\r\n    }\r\n}\r\nconst USE_CLASS = Object.keys({ useClass: null })[0];\r\nconst USE_FACTORY = Object.keys({ useFactory: null })[0];\r\nconst USE_VALUE = Object.keys({ useValue: null })[0];\r\nconst USE_EXISTING = Object.keys({ useExisting: null })[0];\r\nfunction convertToR3QueryMetadata(facade) {\r\n    return Object.assign(Object.assign({}, facade), { predicate: Array.isArray(facade.predicate) ? facade.predicate :\r\n            new WrappedNodeExpr(facade.predicate), read: facade.read ? new WrappedNodeExpr(facade.read) : null, static: facade.static, emitDistinctChangesOnly: facade.emitDistinctChangesOnly });\r\n}\r\nfunction convertQueryDeclarationToMetadata(declaration) {\r\n    var _a, _b, _c, _d;\r\n    return {\r\n        propertyName: declaration.propertyName,\r\n        first: (_a = declaration.first) !== null && _a !== void 0 ? _a : false,\r\n        predicate: Array.isArray(declaration.predicate) ? declaration.predicate :\r\n            new WrappedNodeExpr(declaration.predicate),\r\n        descendants: (_b = declaration.descendants) !== null && _b !== void 0 ? _b : false,\r\n        read: declaration.read ? new WrappedNodeExpr(declaration.read) : null,\r\n        static: (_c = declaration.static) !== null && _c !== void 0 ? _c : false,\r\n        emitDistinctChangesOnly: (_d = declaration.emitDistinctChangesOnly) !== null && _d !== void 0 ? _d : true,\r\n    };\r\n}\r\nfunction convertDirectiveFacadeToMetadata(facade) {\r\n    const inputsFromMetadata = parseInputOutputs(facade.inputs || []);\r\n    const outputsFromMetadata = parseInputOutputs(facade.outputs || []);\r\n    const propMetadata = facade.propMetadata;\r\n    const inputsFromType = {};\r\n    const outputsFromType = {};\r\n    for (const field in propMetadata) {\r\n        if (propMetadata.hasOwnProperty(field)) {\r\n            propMetadata[field].forEach(ann => {\r\n                if (isInput(ann)) {\r\n                    inputsFromType[field] =\r\n                        ann.bindingPropertyName ? [ann.bindingPropertyName, field] : field;\r\n                }\r\n                else if (isOutput(ann)) {\r\n                    outputsFromType[field] = ann.bindingPropertyName || field;\r\n                }\r\n            });\r\n        }\r\n    }\r\n    return Object.assign(Object.assign({}, facade), { typeArgumentCount: 0, typeSourceSpan: facade.typeSourceSpan, type: wrapReference(facade.type), internalType: new WrappedNodeExpr(facade.type), deps: null, host: extractHostBindings(facade.propMetadata, facade.typeSourceSpan, facade.host), inputs: Object.assign(Object.assign({}, inputsFromMetadata), inputsFromType), outputs: Object.assign(Object.assign({}, outputsFromMetadata), outputsFromType), queries: facade.queries.map(convertToR3QueryMetadata), providers: facade.providers != null ? new WrappedNodeExpr(facade.providers) : null, viewQueries: facade.viewQueries.map(convertToR3QueryMetadata), fullInheritance: false });\r\n}\r\nfunction convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan) {\r\n    var _a, _b, _c, _d, _e, _f, _g, _h;\r\n    return {\r\n        name: declaration.type.name,\r\n        type: wrapReference(declaration.type),\r\n        typeSourceSpan,\r\n        internalType: new WrappedNodeExpr(declaration.type),\r\n        selector: (_a = declaration.selector) !== null && _a !== void 0 ? _a : null,\r\n        inputs: (_b = declaration.inputs) !== null && _b !== void 0 ? _b : {},\r\n        outputs: (_c = declaration.outputs) !== null && _c !== void 0 ? _c : {},\r\n        host: convertHostDeclarationToMetadata(declaration.host),\r\n        queries: ((_d = declaration.queries) !== null && _d !== void 0 ? _d : []).map(convertQueryDeclarationToMetadata),\r\n        viewQueries: ((_e = declaration.viewQueries) !== null && _e !== void 0 ? _e : []).map(convertQueryDeclarationToMetadata),\r\n        providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) :\r\n            null,\r\n        exportAs: (_f = declaration.exportAs) !== null && _f !== void 0 ? _f : null,\r\n        usesInheritance: (_g = declaration.usesInheritance) !== null && _g !== void 0 ? _g : false,\r\n        lifecycle: { usesOnChanges: (_h = declaration.usesOnChanges) !== null && _h !== void 0 ? _h : false },\r\n        deps: null,\r\n        typeArgumentCount: 0,\r\n        fullInheritance: false,\r\n    };\r\n}\r\nfunction convertHostDeclarationToMetadata(host = {}) {\r\n    var _a, _b, _c;\r\n    return {\r\n        attributes: convertOpaqueValuesToExpressions((_a = host.attributes) !== null && _a !== void 0 ? _a : {}),\r\n        listeners: (_b = host.listeners) !== null && _b !== void 0 ? _b : {},\r\n        properties: (_c = host.properties) !== null && _c !== void 0 ? _c : {},\r\n        specialAttributes: {\r\n            classAttr: host.classAttribute,\r\n            styleAttr: host.styleAttribute,\r\n        },\r\n    };\r\n}\r\nfunction convertOpaqueValuesToExpressions(obj) {\r\n    const result = {};\r\n    for (const key of Object.keys(obj)) {\r\n        result[key] = new WrappedNodeExpr(obj[key]);\r\n    }\r\n    return result;\r\n}\r\nfunction convertDeclareComponentFacadeToMetadata(declaration, typeSourceSpan, sourceMapUrl) {\r\n    var _a, _b, _c, _d, _e, _f;\r\n    const { template, interpolation } = parseJitTemplate(declaration.template, declaration.type.name, sourceMapUrl, (_a = declaration.preserveWhitespaces) !== null && _a !== void 0 ? _a : false, declaration.interpolation);\r\n    return Object.assign(Object.assign({}, convertDeclareDirectiveFacadeToMetadata(declaration, typeSourceSpan)), { template, styles: (_b = declaration.styles) !== null && _b !== void 0 ? _b : [], directives: ((_c = declaration.components) !== null && _c !== void 0 ? _c : [])\r\n            .concat((_d = declaration.directives) !== null && _d !== void 0 ? _d : [])\r\n            .map(convertUsedDirectiveDeclarationToMetadata), pipes: convertUsedPipesToMetadata(declaration.pipes), viewProviders: declaration.viewProviders !== undefined ?\r\n            new WrappedNodeExpr(declaration.viewProviders) :\r\n            null, animations: declaration.animations !== undefined ? new WrappedNodeExpr(declaration.animations) :\r\n            null, changeDetection: (_e = declaration.changeDetection) !== null && _e !== void 0 ? _e : ChangeDetectionStrategy.Default, encapsulation: (_f = declaration.encapsulation) !== null && _f !== void 0 ? _f : ViewEncapsulation.Emulated, interpolation, declarationListEmitMode: 2 /* ClosureResolved */, relativeContextFilePath: '', i18nUseExternalIds: true });\r\n}\r\nfunction convertUsedDirectiveDeclarationToMetadata(declaration) {\r\n    var _a, _b, _c;\r\n    return {\r\n        selector: declaration.selector,\r\n        type: new WrappedNodeExpr(declaration.type),\r\n        inputs: (_a = declaration.inputs) !== null && _a !== void 0 ? _a : [],\r\n        outputs: (_b = declaration.outputs) !== null && _b !== void 0 ? _b : [],\r\n        exportAs: (_c = declaration.exportAs) !== null && _c !== void 0 ? _c : null,\r\n    };\r\n}\r\nfunction convertUsedPipesToMetadata(declaredPipes) {\r\n    const pipes = new Map();\r\n    if (declaredPipes === undefined) {\r\n        return pipes;\r\n    }\r\n    for (const pipeName of Object.keys(declaredPipes)) {\r\n        const pipeType = declaredPipes[pipeName];\r\n        pipes.set(pipeName, new WrappedNodeExpr(pipeType));\r\n    }\r\n    return pipes;\r\n}\r\nfunction parseJitTemplate(template, typeName, sourceMapUrl, preserveWhitespaces, interpolation) {\r\n    const interpolationConfig = interpolation ? InterpolationConfig.fromArray(interpolation) : DEFAULT_INTERPOLATION_CONFIG;\r\n    // Parse the template and check for errors.\r\n    const parsed = parseTemplate(template, sourceMapUrl, { preserveWhitespaces: preserveWhitespaces, interpolationConfig });\r\n    if (parsed.errors !== null) {\r\n        const errors = parsed.errors.map(err => err.toString()).join(', ');\r\n        throw new Error(`Errors during JIT compilation of template for ${typeName}: ${errors}`);\r\n    }\r\n    return { template: parsed, interpolation: interpolationConfig };\r\n}\r\n/**\r\n * Convert the expression, if present to an `R3ProviderExpression`.\r\n *\r\n * In JIT mode we do not want the compiler to wrap the expression in a `forwardRef()` call because,\r\n * if it is referencing a type that has not yet been defined, it will have already been wrapped in\r\n * a `forwardRef()` - either by the application developer or during partial-compilation. Thus we can\r\n * set `isForwardRef` to `false`.\r\n */\r\nfunction convertToProviderExpression(obj, property) {\r\n    if (obj.hasOwnProperty(property)) {\r\n        return createR3ProviderExpression(new WrappedNodeExpr(obj[property]), /* isForwardRef */ false);\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n}\r\nfunction wrapExpression(obj, property) {\r\n    if (obj.hasOwnProperty(property)) {\r\n        return new WrappedNodeExpr(obj[property]);\r\n    }\r\n    else {\r\n        return undefined;\r\n    }\r\n}\r\nfunction computeProvidedIn(providedIn) {\r\n    const expression = (providedIn == null || typeof providedIn === 'string') ?\r\n        new LiteralExpr(providedIn !== null && providedIn !== void 0 ? providedIn : null) :\r\n        new WrappedNodeExpr(providedIn);\r\n    // See `convertToProviderExpression()` for why `isForwardRef` is false.\r\n    return createR3ProviderExpression(expression, /* isForwardRef */ false);\r\n}\r\nfunction convertR3DependencyMetadataArray(facades) {\r\n    return facades == null ? null : facades.map(convertR3DependencyMetadata);\r\n}\r\nfunction convertR3DependencyMetadata(facade) {\r\n    const isAttributeDep = facade.attribute != null; // both `null` and `undefined`\r\n    const rawToken = facade.token === null ? null : new WrappedNodeExpr(facade.token);\r\n    // In JIT mode, if the dep is an `@Attribute()` then we use the attribute name given in\r\n    // `attribute` rather than the `token`.\r\n    const token = isAttributeDep ? new WrappedNodeExpr(facade.attribute) : rawToken;\r\n    return createR3DependencyMetadata(token, isAttributeDep, facade.host, facade.optional, facade.self, facade.skipSelf);\r\n}\r\nfunction convertR3DeclareDependencyMetadata(facade) {\r\n    var _a, _b, _c, _d, _e;\r\n    const isAttributeDep = (_a = facade.attribute) !== null && _a !== void 0 ? _a : false;\r\n    const token = facade.token === null ? null : new WrappedNodeExpr(facade.token);\r\n    return createR3DependencyMetadata(token, isAttributeDep, (_b = facade.host) !== null && _b !== void 0 ? _b : false, (_c = facade.optional) !== null && _c !== void 0 ? _c : false, (_d = facade.self) !== null && _d !== void 0 ? _d : false, (_e = facade.skipSelf) !== null && _e !== void 0 ? _e : false);\r\n}\r\nfunction createR3DependencyMetadata(token, isAttributeDep, host, optional, self, skipSelf) {\r\n    // If the dep is an `@Attribute()` the `attributeNameType` ought to be the `unknown` type.\r\n    // But types are not available at runtime so we just use a literal `\"<unknown>\"` string as a dummy\r\n    // marker.\r\n    const attributeNameType = isAttributeDep ? literal('unknown') : null;\r\n    return { token, attributeNameType, host, optional, self, skipSelf };\r\n}\r\nfunction extractHostBindings(propMetadata, sourceSpan, host) {\r\n    // First parse the declarations from the metadata.\r\n    const bindings = parseHostBindings(host || {});\r\n    // After that check host bindings for errors\r\n    const errors = verifyHostBindings(bindings, sourceSpan);\r\n    if (errors.length) {\r\n        throw new Error(errors.map((error) => error.msg).join('\\n'));\r\n    }\r\n    // Next, loop over the properties of the object, looking for @HostBinding and @HostListener.\r\n    for (const field in propMetadata) {\r\n        if (propMetadata.hasOwnProperty(field)) {\r\n            propMetadata[field].forEach(ann => {\r\n                if (isHostBinding(ann)) {\r\n                    // Since this is a decorator, we know that the value is a class member. Always access it\r\n                    // through `this` so that further down the line it can't be confused for a literal value\r\n                    // (e.g. if there's a property called `true`).\r\n                    bindings.properties[ann.hostPropertyName || field] =\r\n                        getSafePropertyAccessString('this', field);\r\n                }\r\n                else if (isHostListener(ann)) {\r\n                    bindings.listeners[ann.eventName || field] = `${field}(${(ann.args || []).join(',')})`;\r\n                }\r\n            });\r\n        }\r\n    }\r\n    return bindings;\r\n}\r\nfunction isHostBinding(value) {\r\n    return value.ngMetadataName === 'HostBinding';\r\n}\r\nfunction isHostListener(value) {\r\n    return value.ngMetadataName === 'HostListener';\r\n}\r\nfunction isInput(value) {\r\n    return value.ngMetadataName === 'Input';\r\n}\r\nfunction isOutput(value) {\r\n    return value.ngMetadataName === 'Output';\r\n}\r\nfunction parseInputOutputs(values) {\r\n    return values.reduce((map, value) => {\r\n        const [field, property] = value.split(',').map(piece => piece.trim());\r\n        map[field] = property || field;\r\n        return map;\r\n    }, {});\r\n}\r\nfunction convertDeclarePipeFacadeToMetadata(declaration) {\r\n    var _a;\r\n    return {\r\n        name: declaration.type.name,\r\n        type: wrapReference(declaration.type),\r\n        internalType: new WrappedNodeExpr(declaration.type),\r\n        typeArgumentCount: 0,\r\n        pipeName: declaration.name,\r\n        deps: null,\r\n        pure: (_a = declaration.pure) !== null && _a !== void 0 ? _a : true,\r\n    };\r\n}\r\nfunction convertDeclareInjectorFacadeToMetadata(declaration) {\r\n    return {\r\n        name: declaration.type.name,\r\n        type: wrapReference(declaration.type),\r\n        internalType: new WrappedNodeExpr(declaration.type),\r\n        providers: declaration.providers !== undefined ? new WrappedNodeExpr(declaration.providers) :\r\n            null,\r\n        imports: declaration.imports !== undefined ?\r\n            declaration.imports.map(i => new WrappedNodeExpr(i)) :\r\n            [],\r\n    };\r\n}\r\nfunction publishFacade(global) {\r\n    const ng = global.ng || (global.ng = {});\r\n    ng.ɵcompilerFacade = new CompilerFacadeImpl();\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst VERSION$1 = new Version('12.1.0');\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass CompilerConfig {\r\n    constructor({ defaultEncapsulation = ViewEncapsulation.Emulated, useJit = true, jitDevMode = false, missingTranslation = null, preserveWhitespaces, strictInjectionParameters } = {}) {\r\n        this.defaultEncapsulation = defaultEncapsulation;\r\n        this.useJit = !!useJit;\r\n        this.jitDevMode = !!jitDevMode;\r\n        this.missingTranslation = missingTranslation;\r\n        this.preserveWhitespaces = preserveWhitespacesDefault(noUndefined(preserveWhitespaces));\r\n        this.strictInjectionParameters = strictInjectionParameters === true;\r\n    }\r\n}\r\nfunction preserveWhitespacesDefault(preserveWhitespacesOption, defaultSetting = false) {\r\n    return preserveWhitespacesOption === null ? defaultSetting : preserveWhitespacesOption;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass DirectiveNormalizer {\r\n    constructor(_resourceLoader, _urlResolver, _htmlParser, _config) {\r\n        this._resourceLoader = _resourceLoader;\r\n        this._urlResolver = _urlResolver;\r\n        this._htmlParser = _htmlParser;\r\n        this._config = _config;\r\n        this._resourceLoaderCache = new Map();\r\n    }\r\n    clearCache() {\r\n        this._resourceLoaderCache.clear();\r\n    }\r\n    clearCacheFor(normalizedDirective) {\r\n        if (!normalizedDirective.isComponent) {\r\n            return;\r\n        }\r\n        const template = normalizedDirective.template;\r\n        this._resourceLoaderCache.delete(template.templateUrl);\r\n        template.externalStylesheets.forEach((stylesheet) => {\r\n            this._resourceLoaderCache.delete(stylesheet.moduleUrl);\r\n        });\r\n    }\r\n    _fetch(url) {\r\n        let result = this._resourceLoaderCache.get(url);\r\n        if (!result) {\r\n            result = this._resourceLoader.get(url);\r\n            this._resourceLoaderCache.set(url, result);\r\n        }\r\n        return result;\r\n    }\r\n    normalizeTemplate(prenormData) {\r\n        if (isDefined(prenormData.template)) {\r\n            if (isDefined(prenormData.templateUrl)) {\r\n                throw syntaxError(`'${stringify(prenormData\r\n                    .componentType)}' component cannot define both template and templateUrl`);\r\n            }\r\n            if (typeof prenormData.template !== 'string') {\r\n                throw syntaxError(`The template specified for component ${stringify(prenormData.componentType)} is not a string`);\r\n            }\r\n        }\r\n        else if (isDefined(prenormData.templateUrl)) {\r\n            if (typeof prenormData.templateUrl !== 'string') {\r\n                throw syntaxError(`The templateUrl specified for component ${stringify(prenormData.componentType)} is not a string`);\r\n            }\r\n        }\r\n        else {\r\n            throw syntaxError(`No template specified for component ${stringify(prenormData.componentType)}`);\r\n        }\r\n        if (isDefined(prenormData.preserveWhitespaces) &&\r\n            typeof prenormData.preserveWhitespaces !== 'boolean') {\r\n            throw syntaxError(`The preserveWhitespaces option for component ${stringify(prenormData.componentType)} must be a boolean`);\r\n        }\r\n        return SyncAsync.then(this._preParseTemplate(prenormData), (preparsedTemplate) => this._normalizeTemplateMetadata(prenormData, preparsedTemplate));\r\n    }\r\n    _preParseTemplate(prenomData) {\r\n        let template;\r\n        let templateUrl;\r\n        if (prenomData.template != null) {\r\n            template = prenomData.template;\r\n            templateUrl = prenomData.moduleUrl;\r\n        }\r\n        else {\r\n            templateUrl = this._urlResolver.resolve(prenomData.moduleUrl, prenomData.templateUrl);\r\n            template = this._fetch(templateUrl);\r\n        }\r\n        return SyncAsync.then(template, (template) => this._preparseLoadedTemplate(prenomData, template, templateUrl));\r\n    }\r\n    _preparseLoadedTemplate(prenormData, template, templateAbsUrl) {\r\n        const isInline = !!prenormData.template;\r\n        const interpolationConfig = InterpolationConfig.fromArray(prenormData.interpolation);\r\n        const templateUrl = templateSourceUrl({ reference: prenormData.ngModuleType }, { type: { reference: prenormData.componentType } }, { isInline, templateUrl: templateAbsUrl });\r\n        const rootNodesAndErrors = this._htmlParser.parse(template, templateUrl, { tokenizeExpansionForms: true, interpolationConfig });\r\n        if (rootNodesAndErrors.errors.length > 0) {\r\n            const errorString = rootNodesAndErrors.errors.join('\\n');\r\n            throw syntaxError(`Template parse errors:\\n${errorString}`);\r\n        }\r\n        const templateMetadataStyles = this._normalizeStylesheet(new CompileStylesheetMetadata({ styles: prenormData.styles, moduleUrl: prenormData.moduleUrl }));\r\n        const visitor = new TemplatePreparseVisitor();\r\n        visitAll$1(visitor, rootNodesAndErrors.rootNodes);\r\n        const templateStyles = this._normalizeStylesheet(new CompileStylesheetMetadata({ styles: visitor.styles, styleUrls: visitor.styleUrls, moduleUrl: templateAbsUrl }));\r\n        const styles = templateMetadataStyles.styles.concat(templateStyles.styles);\r\n        const inlineStyleUrls = templateMetadataStyles.styleUrls.concat(templateStyles.styleUrls);\r\n        const styleUrls = this\r\n            ._normalizeStylesheet(new CompileStylesheetMetadata({ styleUrls: prenormData.styleUrls, moduleUrl: prenormData.moduleUrl }))\r\n            .styleUrls;\r\n        return {\r\n            template,\r\n            templateUrl: templateAbsUrl,\r\n            isInline,\r\n            htmlAst: rootNodesAndErrors,\r\n            styles,\r\n            inlineStyleUrls,\r\n            styleUrls,\r\n            ngContentSelectors: visitor.ngContentSelectors,\r\n        };\r\n    }\r\n    _normalizeTemplateMetadata(prenormData, preparsedTemplate) {\r\n        return SyncAsync.then(this._loadMissingExternalStylesheets(preparsedTemplate.styleUrls.concat(preparsedTemplate.inlineStyleUrls)), (externalStylesheets) => this._normalizeLoadedTemplateMetadata(prenormData, preparsedTemplate, externalStylesheets));\r\n    }\r\n    _normalizeLoadedTemplateMetadata(prenormData, preparsedTemplate, stylesheets) {\r\n        // Algorithm:\r\n        // - produce exactly 1 entry per original styleUrl in\r\n        // CompileTemplateMetadata.externalStylesheets with all styles inlined\r\n        // - inline all styles that are referenced by the template into CompileTemplateMetadata.styles.\r\n        // Reason: be able to determine how many stylesheets there are even without loading\r\n        // the template nor the stylesheets, so we can create a stub for TypeScript always synchronously\r\n        // (as resource loading may be async)\r\n        const styles = [...preparsedTemplate.styles];\r\n        this._inlineStyles(preparsedTemplate.inlineStyleUrls, stylesheets, styles);\r\n        const styleUrls = preparsedTemplate.styleUrls;\r\n        const externalStylesheets = styleUrls.map(styleUrl => {\r\n            const stylesheet = stylesheets.get(styleUrl);\r\n            const styles = [...stylesheet.styles];\r\n            this._inlineStyles(stylesheet.styleUrls, stylesheets, styles);\r\n            return new CompileStylesheetMetadata({ moduleUrl: styleUrl, styles: styles });\r\n        });\r\n        let encapsulation = prenormData.encapsulation;\r\n        if (encapsulation == null) {\r\n            encapsulation = this._config.defaultEncapsulation;\r\n        }\r\n        if (encapsulation === ViewEncapsulation.Emulated && styles.length === 0 &&\r\n            styleUrls.length === 0) {\r\n            encapsulation = ViewEncapsulation.None;\r\n        }\r\n        return new CompileTemplateMetadata({\r\n            encapsulation,\r\n            template: preparsedTemplate.template,\r\n            templateUrl: preparsedTemplate.templateUrl,\r\n            htmlAst: preparsedTemplate.htmlAst,\r\n            styles,\r\n            styleUrls,\r\n            ngContentSelectors: preparsedTemplate.ngContentSelectors,\r\n            animations: prenormData.animations,\r\n            interpolation: prenormData.interpolation,\r\n            isInline: preparsedTemplate.isInline,\r\n            externalStylesheets,\r\n            preserveWhitespaces: preserveWhitespacesDefault(prenormData.preserveWhitespaces, this._config.preserveWhitespaces),\r\n        });\r\n    }\r\n    _inlineStyles(styleUrls, stylesheets, targetStyles) {\r\n        styleUrls.forEach(styleUrl => {\r\n            const stylesheet = stylesheets.get(styleUrl);\r\n            stylesheet.styles.forEach(style => targetStyles.push(style));\r\n            this._inlineStyles(stylesheet.styleUrls, stylesheets, targetStyles);\r\n        });\r\n    }\r\n    _loadMissingExternalStylesheets(styleUrls, loadedStylesheets = new Map()) {\r\n        return SyncAsync.then(SyncAsync.all(styleUrls.filter((styleUrl) => !loadedStylesheets.has(styleUrl))\r\n            .map(styleUrl => SyncAsync.then(this._fetch(styleUrl), (loadedStyle) => {\r\n            const stylesheet = this._normalizeStylesheet(new CompileStylesheetMetadata({ styles: [loadedStyle], moduleUrl: styleUrl }));\r\n            loadedStylesheets.set(styleUrl, stylesheet);\r\n            return this._loadMissingExternalStylesheets(stylesheet.styleUrls, loadedStylesheets);\r\n        }))), (_) => loadedStylesheets);\r\n    }\r\n    _normalizeStylesheet(stylesheet) {\r\n        const moduleUrl = stylesheet.moduleUrl;\r\n        const allStyleUrls = stylesheet.styleUrls.filter(isStyleUrlResolvable)\r\n            .map(url => this._urlResolver.resolve(moduleUrl, url));\r\n        const allStyles = stylesheet.styles.map(style => {\r\n            const styleWithImports = extractStyleUrls(this._urlResolver, moduleUrl, style);\r\n            allStyleUrls.push(...styleWithImports.styleUrls);\r\n            return styleWithImports.style;\r\n        });\r\n        return new CompileStylesheetMetadata({ styles: allStyles, styleUrls: allStyleUrls, moduleUrl: moduleUrl });\r\n    }\r\n}\r\nclass TemplatePreparseVisitor {\r\n    constructor() {\r\n        this.ngContentSelectors = [];\r\n        this.styles = [];\r\n        this.styleUrls = [];\r\n        this.ngNonBindableStackCount = 0;\r\n    }\r\n    visitElement(ast, context) {\r\n        const preparsedElement = preparseElement(ast);\r\n        switch (preparsedElement.type) {\r\n            case PreparsedElementType.NG_CONTENT:\r\n                if (this.ngNonBindableStackCount === 0) {\r\n                    this.ngContentSelectors.push(preparsedElement.selectAttr);\r\n                }\r\n                break;\r\n            case PreparsedElementType.STYLE:\r\n                let textContent = '';\r\n                ast.children.forEach(child => {\r\n                    if (child instanceof Text$3) {\r\n                        textContent += child.value;\r\n                    }\r\n                });\r\n                this.styles.push(textContent);\r\n                break;\r\n            case PreparsedElementType.STYLESHEET:\r\n                this.styleUrls.push(preparsedElement.hrefAttr);\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        if (preparsedElement.nonBindable) {\r\n            this.ngNonBindableStackCount++;\r\n        }\r\n        visitAll$1(this, ast.children);\r\n        if (preparsedElement.nonBindable) {\r\n            this.ngNonBindableStackCount--;\r\n        }\r\n        return null;\r\n    }\r\n    visitExpansion(ast, context) {\r\n        visitAll$1(this, ast.cases);\r\n    }\r\n    visitExpansionCase(ast, context) {\r\n        visitAll$1(this, ast.expression);\r\n    }\r\n    visitComment(ast, context) {\r\n        return null;\r\n    }\r\n    visitAttribute(ast, context) {\r\n        return null;\r\n    }\r\n    visitText(ast, context) {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst QUERY_METADATA_IDENTIFIERS = [\r\n    createViewChild,\r\n    createViewChildren,\r\n    createContentChild,\r\n    createContentChildren,\r\n];\r\n/*\r\n * Resolve a `Type` for {@link Directive}.\r\n *\r\n * This interface can be overridden by the application developer to create custom behavior.\r\n *\r\n * See {@link Compiler}\r\n */\r\nclass DirectiveResolver {\r\n    constructor(_reflector) {\r\n        this._reflector = _reflector;\r\n    }\r\n    isDirective(type) {\r\n        const typeMetadata = this._reflector.annotations(resolveForwardRef(type));\r\n        return typeMetadata && typeMetadata.some(isDirectiveMetadata);\r\n    }\r\n    resolve(type, throwIfNotFound = true) {\r\n        const typeMetadata = this._reflector.annotations(resolveForwardRef(type));\r\n        if (typeMetadata) {\r\n            const metadata = findLast(typeMetadata, isDirectiveMetadata);\r\n            if (metadata) {\r\n                const propertyMetadata = this._reflector.propMetadata(type);\r\n                const guards = this._reflector.guards(type);\r\n                return this._mergeWithPropertyMetadata(metadata, propertyMetadata, guards, type);\r\n            }\r\n        }\r\n        if (throwIfNotFound) {\r\n            throw new Error(`No Directive annotation found on ${stringify(type)}`);\r\n        }\r\n        return null;\r\n    }\r\n    _mergeWithPropertyMetadata(dm, propertyMetadata, guards, directiveType) {\r\n        const inputs = [];\r\n        const outputs = [];\r\n        const host = {};\r\n        const queries = {};\r\n        Object.keys(propertyMetadata).forEach((propName) => {\r\n            const input = findLast(propertyMetadata[propName], (a) => createInput.isTypeOf(a));\r\n            if (input) {\r\n                if (input.bindingPropertyName) {\r\n                    inputs.push(`${propName}: ${input.bindingPropertyName}`);\r\n                }\r\n                else {\r\n                    inputs.push(propName);\r\n                }\r\n            }\r\n            const output = findLast(propertyMetadata[propName], (a) => createOutput.isTypeOf(a));\r\n            if (output) {\r\n                if (output.bindingPropertyName) {\r\n                    outputs.push(`${propName}: ${output.bindingPropertyName}`);\r\n                }\r\n                else {\r\n                    outputs.push(propName);\r\n                }\r\n            }\r\n            const hostBindings = propertyMetadata[propName].filter(a => createHostBinding.isTypeOf(a));\r\n            hostBindings.forEach(hostBinding => {\r\n                if (hostBinding.hostPropertyName) {\r\n                    const startWith = hostBinding.hostPropertyName[0];\r\n                    if (startWith === '(') {\r\n                        throw new Error(`@HostBinding can not bind to events. Use @HostListener instead.`);\r\n                    }\r\n                    else if (startWith === '[') {\r\n                        throw new Error(`@HostBinding parameter should be a property name, 'class.<name>', or 'attr.<name>'.`);\r\n                    }\r\n                    host[`[${hostBinding.hostPropertyName}]`] = propName;\r\n                }\r\n                else {\r\n                    host[`[${propName}]`] = propName;\r\n                }\r\n            });\r\n            const hostListeners = propertyMetadata[propName].filter(a => createHostListener.isTypeOf(a));\r\n            hostListeners.forEach(hostListener => {\r\n                const args = hostListener.args || [];\r\n                host[`(${hostListener.eventName})`] = `${propName}(${args.join(',')})`;\r\n            });\r\n            const query = findLast(propertyMetadata[propName], (a) => QUERY_METADATA_IDENTIFIERS.some(i => i.isTypeOf(a)));\r\n            if (query) {\r\n                queries[propName] = query;\r\n            }\r\n        });\r\n        return this._merge(dm, inputs, outputs, host, queries, guards, directiveType);\r\n    }\r\n    _extractPublicName(def) {\r\n        return splitAtColon(def, [null, def])[1].trim();\r\n    }\r\n    _dedupeBindings(bindings) {\r\n        const names = new Set();\r\n        const publicNames = new Set();\r\n        const reversedResult = [];\r\n        // go last to first to allow later entries to overwrite previous entries\r\n        for (let i = bindings.length - 1; i >= 0; i--) {\r\n            const binding = bindings[i];\r\n            const name = this._extractPublicName(binding);\r\n            publicNames.add(name);\r\n            if (!names.has(name)) {\r\n                names.add(name);\r\n                reversedResult.push(binding);\r\n            }\r\n        }\r\n        return reversedResult.reverse();\r\n    }\r\n    _merge(directive, inputs, outputs, host, queries, guards, directiveType) {\r\n        const mergedInputs = this._dedupeBindings(directive.inputs ? directive.inputs.concat(inputs) : inputs);\r\n        const mergedOutputs = this._dedupeBindings(directive.outputs ? directive.outputs.concat(outputs) : outputs);\r\n        const mergedHost = directive.host ? Object.assign(Object.assign({}, directive.host), host) : host;\r\n        const mergedQueries = directive.queries ? Object.assign(Object.assign({}, directive.queries), queries) : queries;\r\n        if (createComponent.isTypeOf(directive)) {\r\n            const comp = directive;\r\n            return createComponent({\r\n                selector: comp.selector,\r\n                inputs: mergedInputs,\r\n                outputs: mergedOutputs,\r\n                host: mergedHost,\r\n                exportAs: comp.exportAs,\r\n                moduleId: comp.moduleId,\r\n                queries: mergedQueries,\r\n                changeDetection: comp.changeDetection,\r\n                providers: comp.providers,\r\n                viewProviders: comp.viewProviders,\r\n                entryComponents: comp.entryComponents,\r\n                template: comp.template,\r\n                templateUrl: comp.templateUrl,\r\n                styles: comp.styles,\r\n                styleUrls: comp.styleUrls,\r\n                encapsulation: comp.encapsulation,\r\n                animations: comp.animations,\r\n                interpolation: comp.interpolation,\r\n                preserveWhitespaces: directive.preserveWhitespaces,\r\n            });\r\n        }\r\n        else {\r\n            return createDirective({\r\n                selector: directive.selector,\r\n                inputs: mergedInputs,\r\n                outputs: mergedOutputs,\r\n                host: mergedHost,\r\n                exportAs: directive.exportAs,\r\n                queries: mergedQueries,\r\n                providers: directive.providers,\r\n                guards\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction isDirectiveMetadata(type) {\r\n    return createDirective.isTypeOf(type) || createComponent.isTypeOf(type);\r\n}\r\nfunction findLast(arr, condition) {\r\n    for (let i = arr.length - 1; i >= 0; i--) {\r\n        if (condition(arr[i])) {\r\n            return arr[i];\r\n        }\r\n    }\r\n    return null;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst _I18N_ATTR = 'i18n';\r\nconst _I18N_ATTR_PREFIX = 'i18n-';\r\nconst _I18N_COMMENT_PREFIX_REGEXP = /^i18n:?/;\r\nconst MEANING_SEPARATOR = '|';\r\nconst ID_SEPARATOR = '@@';\r\nlet i18nCommentsWarned = false;\r\n/**\r\n * Extract translatable messages from an html AST\r\n */\r\nfunction extractMessages(nodes, interpolationConfig, implicitTags, implicitAttrs) {\r\n    const visitor = new _Visitor$2(implicitTags, implicitAttrs);\r\n    return visitor.extract(nodes, interpolationConfig);\r\n}\r\nfunction mergeTranslations(nodes, translations, interpolationConfig, implicitTags, implicitAttrs) {\r\n    const visitor = new _Visitor$2(implicitTags, implicitAttrs);\r\n    return visitor.merge(nodes, translations, interpolationConfig);\r\n}\r\nclass ExtractionResult {\r\n    constructor(messages, errors) {\r\n        this.messages = messages;\r\n        this.errors = errors;\r\n    }\r\n}\r\nvar _VisitorMode;\r\n(function (_VisitorMode) {\r\n    _VisitorMode[_VisitorMode[\"Extract\"] = 0] = \"Extract\";\r\n    _VisitorMode[_VisitorMode[\"Merge\"] = 1] = \"Merge\";\r\n})(_VisitorMode || (_VisitorMode = {}));\r\n/**\r\n * This Visitor is used:\r\n * 1. to extract all the translatable strings from an html AST (see `extract()`),\r\n * 2. to replace the translatable strings with the actual translations (see `merge()`)\r\n *\r\n * @internal\r\n */\r\nclass _Visitor$2 {\r\n    constructor(_implicitTags, _implicitAttrs) {\r\n        this._implicitTags = _implicitTags;\r\n        this._implicitAttrs = _implicitAttrs;\r\n    }\r\n    /**\r\n     * Extracts the messages from the tree\r\n     */\r\n    extract(nodes, interpolationConfig) {\r\n        this._init(_VisitorMode.Extract, interpolationConfig);\r\n        nodes.forEach(node => node.visit(this, null));\r\n        if (this._inI18nBlock) {\r\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\r\n        }\r\n        return new ExtractionResult(this._messages, this._errors);\r\n    }\r\n    /**\r\n     * Returns a tree where all translatable nodes are translated\r\n     */\r\n    merge(nodes, translations, interpolationConfig) {\r\n        this._init(_VisitorMode.Merge, interpolationConfig);\r\n        this._translations = translations;\r\n        // Construct a single fake root element\r\n        const wrapper = new Element$1('wrapper', [], nodes, undefined, undefined, undefined);\r\n        const translatedNode = wrapper.visit(this, null);\r\n        if (this._inI18nBlock) {\r\n            this._reportError(nodes[nodes.length - 1], 'Unclosed block');\r\n        }\r\n        return new ParseTreeResult(translatedNode.children, this._errors);\r\n    }\r\n    visitExpansionCase(icuCase, context) {\r\n        // Parse cases for translatable html attributes\r\n        const expression = visitAll$1(this, icuCase.expression, context);\r\n        if (this._mode === _VisitorMode.Merge) {\r\n            return new ExpansionCase(icuCase.value, expression, icuCase.sourceSpan, icuCase.valueSourceSpan, icuCase.expSourceSpan);\r\n        }\r\n    }\r\n    visitExpansion(icu, context) {\r\n        this._mayBeAddBlockChildren(icu);\r\n        const wasInIcu = this._inIcu;\r\n        if (!this._inIcu) {\r\n            // nested ICU messages should not be extracted but top-level translated as a whole\r\n            if (this._isInTranslatableSection) {\r\n                this._addMessage([icu]);\r\n            }\r\n            this._inIcu = true;\r\n        }\r\n        const cases = visitAll$1(this, icu.cases, context);\r\n        if (this._mode === _VisitorMode.Merge) {\r\n            icu = new Expansion(icu.switchValue, icu.type, cases, icu.sourceSpan, icu.switchValueSourceSpan);\r\n        }\r\n        this._inIcu = wasInIcu;\r\n        return icu;\r\n    }\r\n    visitComment(comment, context) {\r\n        const isOpening = _isOpeningComment(comment);\r\n        if (isOpening && this._isInTranslatableSection) {\r\n            this._reportError(comment, 'Could not start a block inside a translatable section');\r\n            return;\r\n        }\r\n        const isClosing = _isClosingComment(comment);\r\n        if (isClosing && !this._inI18nBlock) {\r\n            this._reportError(comment, 'Trying to close an unopened block');\r\n            return;\r\n        }\r\n        if (!this._inI18nNode && !this._inIcu) {\r\n            if (!this._inI18nBlock) {\r\n                if (isOpening) {\r\n                    // deprecated from v5 you should use <ng-container i18n> instead of i18n comments\r\n                    if (!i18nCommentsWarned && console && console.warn) {\r\n                        i18nCommentsWarned = true;\r\n                        const details = comment.sourceSpan.details ? `, ${comment.sourceSpan.details}` : '';\r\n                        // TODO(ocombe): use a log service once there is a public one available\r\n                        console.warn(`I18n comments are deprecated, use an <ng-container> element instead (${comment.sourceSpan.start}${details})`);\r\n                    }\r\n                    this._inI18nBlock = true;\r\n                    this._blockStartDepth = this._depth;\r\n                    this._blockChildren = [];\r\n                    this._blockMeaningAndDesc =\r\n                        comment.value.replace(_I18N_COMMENT_PREFIX_REGEXP, '').trim();\r\n                    this._openTranslatableSection(comment);\r\n                }\r\n            }\r\n            else {\r\n                if (isClosing) {\r\n                    if (this._depth == this._blockStartDepth) {\r\n                        this._closeTranslatableSection(comment, this._blockChildren);\r\n                        this._inI18nBlock = false;\r\n                        const message = this._addMessage(this._blockChildren, this._blockMeaningAndDesc);\r\n                        // merge attributes in sections\r\n                        const nodes = this._translateMessage(comment, message);\r\n                        return visitAll$1(this, nodes);\r\n                    }\r\n                    else {\r\n                        this._reportError(comment, 'I18N blocks should not cross element boundaries');\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    visitText(text, context) {\r\n        if (this._isInTranslatableSection) {\r\n            this._mayBeAddBlockChildren(text);\r\n        }\r\n        return text;\r\n    }\r\n    visitElement(el, context) {\r\n        this._mayBeAddBlockChildren(el);\r\n        this._depth++;\r\n        const wasInI18nNode = this._inI18nNode;\r\n        const wasInImplicitNode = this._inImplicitNode;\r\n        let childNodes = [];\r\n        let translatedChildNodes = undefined;\r\n        // Extract:\r\n        // - top level nodes with the (implicit) \"i18n\" attribute if not already in a section\r\n        // - ICU messages\r\n        const i18nAttr = _getI18nAttr(el);\r\n        const i18nMeta = i18nAttr ? i18nAttr.value : '';\r\n        const isImplicit = this._implicitTags.some(tag => el.name === tag) && !this._inIcu &&\r\n            !this._isInTranslatableSection;\r\n        const isTopLevelImplicit = !wasInImplicitNode && isImplicit;\r\n        this._inImplicitNode = wasInImplicitNode || isImplicit;\r\n        if (!this._isInTranslatableSection && !this._inIcu) {\r\n            if (i18nAttr || isTopLevelImplicit) {\r\n                this._inI18nNode = true;\r\n                const message = this._addMessage(el.children, i18nMeta);\r\n                translatedChildNodes = this._translateMessage(el, message);\r\n            }\r\n            if (this._mode == _VisitorMode.Extract) {\r\n                const isTranslatable = i18nAttr || isTopLevelImplicit;\r\n                if (isTranslatable)\r\n                    this._openTranslatableSection(el);\r\n                visitAll$1(this, el.children);\r\n                if (isTranslatable)\r\n                    this._closeTranslatableSection(el, el.children);\r\n            }\r\n        }\r\n        else {\r\n            if (i18nAttr || isTopLevelImplicit) {\r\n                this._reportError(el, 'Could not mark an element as translatable inside a translatable section');\r\n            }\r\n            if (this._mode == _VisitorMode.Extract) {\r\n                // Descend into child nodes for extraction\r\n                visitAll$1(this, el.children);\r\n            }\r\n        }\r\n        if (this._mode === _VisitorMode.Merge) {\r\n            const visitNodes = translatedChildNodes || el.children;\r\n            visitNodes.forEach(child => {\r\n                const visited = child.visit(this, context);\r\n                if (visited && !this._isInTranslatableSection) {\r\n                    // Do not add the children from translatable sections (= i18n blocks here)\r\n                    // They will be added later in this loop when the block closes (i.e. on `<!-- /i18n -->`)\r\n                    childNodes = childNodes.concat(visited);\r\n                }\r\n            });\r\n        }\r\n        this._visitAttributesOf(el);\r\n        this._depth--;\r\n        this._inI18nNode = wasInI18nNode;\r\n        this._inImplicitNode = wasInImplicitNode;\r\n        if (this._mode === _VisitorMode.Merge) {\r\n            const translatedAttrs = this._translateAttributes(el);\r\n            return new Element$1(el.name, translatedAttrs, childNodes, el.sourceSpan, el.startSourceSpan, el.endSourceSpan);\r\n        }\r\n        return null;\r\n    }\r\n    visitAttribute(attribute, context) {\r\n        throw new Error('unreachable code');\r\n    }\r\n    _init(mode, interpolationConfig) {\r\n        this._mode = mode;\r\n        this._inI18nBlock = false;\r\n        this._inI18nNode = false;\r\n        this._depth = 0;\r\n        this._inIcu = false;\r\n        this._msgCountAtSectionStart = undefined;\r\n        this._errors = [];\r\n        this._messages = [];\r\n        this._inImplicitNode = false;\r\n        this._createI18nMessage = createI18nMessageFactory(interpolationConfig);\r\n    }\r\n    // looks for translatable attributes\r\n    _visitAttributesOf(el) {\r\n        const explicitAttrNameToValue = {};\r\n        const implicitAttrNames = this._implicitAttrs[el.name] || [];\r\n        el.attrs.filter(attr => attr.name.startsWith(_I18N_ATTR_PREFIX))\r\n            .forEach(attr => explicitAttrNameToValue[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\r\n            attr.value);\r\n        el.attrs.forEach(attr => {\r\n            if (attr.name in explicitAttrNameToValue) {\r\n                this._addMessage([attr], explicitAttrNameToValue[attr.name]);\r\n            }\r\n            else if (implicitAttrNames.some(name => attr.name === name)) {\r\n                this._addMessage([attr]);\r\n            }\r\n        });\r\n    }\r\n    // add a translatable message\r\n    _addMessage(ast, msgMeta) {\r\n        if (ast.length == 0 ||\r\n            ast.length == 1 && ast[0] instanceof Attribute && !ast[0].value) {\r\n            // Do not create empty messages\r\n            return null;\r\n        }\r\n        const { meaning, description, id } = _parseMessageMeta(msgMeta);\r\n        const message = this._createI18nMessage(ast, meaning, description, id);\r\n        this._messages.push(message);\r\n        return message;\r\n    }\r\n    // Translates the given message given the `TranslationBundle`\r\n    // This is used for translating elements / blocks - see `_translateAttributes` for attributes\r\n    // no-op when called in extraction mode (returns [])\r\n    _translateMessage(el, message) {\r\n        if (message && this._mode === _VisitorMode.Merge) {\r\n            const nodes = this._translations.get(message);\r\n            if (nodes) {\r\n                return nodes;\r\n            }\r\n            this._reportError(el, `Translation unavailable for message id=\"${this._translations.digest(message)}\"`);\r\n        }\r\n        return [];\r\n    }\r\n    // translate the attributes of an element and remove i18n specific attributes\r\n    _translateAttributes(el) {\r\n        const attributes = el.attrs;\r\n        const i18nParsedMessageMeta = {};\r\n        attributes.forEach(attr => {\r\n            if (attr.name.startsWith(_I18N_ATTR_PREFIX)) {\r\n                i18nParsedMessageMeta[attr.name.slice(_I18N_ATTR_PREFIX.length)] =\r\n                    _parseMessageMeta(attr.value);\r\n            }\r\n        });\r\n        const translatedAttributes = [];\r\n        attributes.forEach((attr) => {\r\n            if (attr.name === _I18N_ATTR || attr.name.startsWith(_I18N_ATTR_PREFIX)) {\r\n                // strip i18n specific attributes\r\n                return;\r\n            }\r\n            if (attr.value && attr.value != '' && i18nParsedMessageMeta.hasOwnProperty(attr.name)) {\r\n                const { meaning, description, id } = i18nParsedMessageMeta[attr.name];\r\n                const message = this._createI18nMessage([attr], meaning, description, id);\r\n                const nodes = this._translations.get(message);\r\n                if (nodes) {\r\n                    if (nodes.length == 0) {\r\n                        translatedAttributes.push(new Attribute(attr.name, '', attr.sourceSpan, undefined /* keySpan */, undefined /* valueSpan */, undefined /* i18n */));\r\n                    }\r\n                    else if (nodes[0] instanceof Text$3) {\r\n                        const value = nodes[0].value;\r\n                        translatedAttributes.push(new Attribute(attr.name, value, attr.sourceSpan, undefined /* keySpan */, undefined /* valueSpan */, undefined /* i18n */));\r\n                    }\r\n                    else {\r\n                        this._reportError(el, `Unexpected translation for attribute \"${attr.name}\" (id=\"${id || this._translations.digest(message)}\")`);\r\n                    }\r\n                }\r\n                else {\r\n                    this._reportError(el, `Translation unavailable for attribute \"${attr.name}\" (id=\"${id || this._translations.digest(message)}\")`);\r\n                }\r\n            }\r\n            else {\r\n                translatedAttributes.push(attr);\r\n            }\r\n        });\r\n        return translatedAttributes;\r\n    }\r\n    /**\r\n     * Add the node as a child of the block when:\r\n     * - we are in a block,\r\n     * - we are not inside a ICU message (those are handled separately),\r\n     * - the node is a \"direct child\" of the block\r\n     */\r\n    _mayBeAddBlockChildren(node) {\r\n        if (this._inI18nBlock && !this._inIcu && this._depth == this._blockStartDepth) {\r\n            this._blockChildren.push(node);\r\n        }\r\n    }\r\n    /**\r\n     * Marks the start of a section, see `_closeTranslatableSection`\r\n     */\r\n    _openTranslatableSection(node) {\r\n        if (this._isInTranslatableSection) {\r\n            this._reportError(node, 'Unexpected section start');\r\n        }\r\n        else {\r\n            this._msgCountAtSectionStart = this._messages.length;\r\n        }\r\n    }\r\n    /**\r\n     * A translatable section could be:\r\n     * - the content of translatable element,\r\n     * - nodes between `<!-- i18n -->` and `<!-- /i18n -->` comments\r\n     */\r\n    get _isInTranslatableSection() {\r\n        return this._msgCountAtSectionStart !== void 0;\r\n    }\r\n    /**\r\n     * Terminates a section.\r\n     *\r\n     * If a section has only one significant children (comments not significant) then we should not\r\n     * keep the message from this children:\r\n     *\r\n     * `<p i18n=\"meaning|description\">{ICU message}</p>` would produce two messages:\r\n     * - one for the <p> content with meaning and description,\r\n     * - another one for the ICU message.\r\n     *\r\n     * In this case the last message is discarded as it contains less information (the AST is\r\n     * otherwise identical).\r\n     *\r\n     * Note that we should still keep messages extracted from attributes inside the section (ie in the\r\n     * ICU message here)\r\n     */\r\n    _closeTranslatableSection(node, directChildren) {\r\n        if (!this._isInTranslatableSection) {\r\n            this._reportError(node, 'Unexpected section end');\r\n            return;\r\n        }\r\n        const startIndex = this._msgCountAtSectionStart;\r\n        const significantChildren = directChildren.reduce((count, node) => count + (node instanceof Comment$1 ? 0 : 1), 0);\r\n        if (significantChildren == 1) {\r\n            for (let i = this._messages.length - 1; i >= startIndex; i--) {\r\n                const ast = this._messages[i].nodes;\r\n                if (!(ast.length == 1 && ast[0] instanceof Text$1)) {\r\n                    this._messages.splice(i, 1);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        this._msgCountAtSectionStart = undefined;\r\n    }\r\n    _reportError(node, msg) {\r\n        this._errors.push(new I18nError(node.sourceSpan, msg));\r\n    }\r\n}\r\nfunction _isOpeningComment(n) {\r\n    return !!(n instanceof Comment$1 && n.value && n.value.startsWith('i18n'));\r\n}\r\nfunction _isClosingComment(n) {\r\n    return !!(n instanceof Comment$1 && n.value && n.value === '/i18n');\r\n}\r\nfunction _getI18nAttr(p) {\r\n    return p.attrs.find(attr => attr.name === _I18N_ATTR) || null;\r\n}\r\nfunction _parseMessageMeta(i18n) {\r\n    if (!i18n)\r\n        return { meaning: '', description: '', id: '' };\r\n    const idIndex = i18n.indexOf(ID_SEPARATOR);\r\n    const descIndex = i18n.indexOf(MEANING_SEPARATOR);\r\n    const [meaningAndDesc, id] = (idIndex > -1) ? [i18n.slice(0, idIndex), i18n.slice(idIndex + 2)] : [i18n, ''];\r\n    const [meaning, description] = (descIndex > -1) ?\r\n        [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] :\r\n        ['', meaningAndDesc];\r\n    return { meaning, description, id: id.trim() };\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass XmlTagDefinition {\r\n    constructor() {\r\n        this.closedByParent = false;\r\n        this.isVoid = false;\r\n        this.ignoreFirstLf = false;\r\n        this.canSelfClose = true;\r\n        this.preventNamespaceInheritance = false;\r\n    }\r\n    requireExtraParent(currentParent) {\r\n        return false;\r\n    }\r\n    isClosedByChild(name) {\r\n        return false;\r\n    }\r\n    getContentType() {\r\n        return TagContentType.PARSABLE_DATA;\r\n    }\r\n}\r\nconst _TAG_DEFINITION = new XmlTagDefinition();\r\nfunction getXmlTagDefinition(tagName) {\r\n    return _TAG_DEFINITION;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass XmlParser extends Parser {\r\n    constructor() {\r\n        super(getXmlTagDefinition);\r\n    }\r\n    parse(source, url, options) {\r\n        return super.parse(source, url, options);\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst _VERSION = '1.2';\r\nconst _XMLNS = 'urn:oasis:names:tc:xliff:document:1.2';\r\n// TODO(vicb): make this a param (s/_/-/)\r\nconst _DEFAULT_SOURCE_LANG = 'en';\r\nconst _PLACEHOLDER_TAG$1 = 'x';\r\nconst _MARKER_TAG = 'mrk';\r\nconst _FILE_TAG = 'file';\r\nconst _SOURCE_TAG$1 = 'source';\r\nconst _SEGMENT_SOURCE_TAG = 'seg-source';\r\nconst _ALT_TRANS_TAG = 'alt-trans';\r\nconst _TARGET_TAG = 'target';\r\nconst _UNIT_TAG = 'trans-unit';\r\nconst _CONTEXT_GROUP_TAG = 'context-group';\r\nconst _CONTEXT_TAG = 'context';\r\n// https://docs.oasis-open.org/xliff/v1.2/os/xliff-core.html\r\n// https://docs.oasis-open.org/xliff/v1.2/xliff-profile-html/xliff-profile-html-1.2.html\r\nclass Xliff extends Serializer {\r\n    write(messages, locale) {\r\n        const visitor = new _WriteVisitor();\r\n        const transUnits = [];\r\n        messages.forEach(message => {\r\n            let contextTags = [];\r\n            message.sources.forEach((source) => {\r\n                let contextGroupTag = new Tag(_CONTEXT_GROUP_TAG, { purpose: 'location' });\r\n                contextGroupTag.children.push(new CR(10), new Tag(_CONTEXT_TAG, { 'context-type': 'sourcefile' }, [new Text$2(source.filePath)]), new CR(10), new Tag(_CONTEXT_TAG, { 'context-type': 'linenumber' }, [new Text$2(`${source.startLine}`)]), new CR(8));\r\n                contextTags.push(new CR(8), contextGroupTag);\r\n            });\r\n            const transUnit = new Tag(_UNIT_TAG, { id: message.id, datatype: 'html' });\r\n            transUnit.children.push(new CR(8), new Tag(_SOURCE_TAG$1, {}, visitor.serialize(message.nodes)), ...contextTags);\r\n            if (message.description) {\r\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'description' }, [new Text$2(message.description)]));\r\n            }\r\n            if (message.meaning) {\r\n                transUnit.children.push(new CR(8), new Tag('note', { priority: '1', from: 'meaning' }, [new Text$2(message.meaning)]));\r\n            }\r\n            transUnit.children.push(new CR(6));\r\n            transUnits.push(new CR(6), transUnit);\r\n        });\r\n        const body = new Tag('body', {}, [...transUnits, new CR(4)]);\r\n        const file = new Tag('file', {\r\n            'source-language': locale || _DEFAULT_SOURCE_LANG,\r\n            datatype: 'plaintext',\r\n            original: 'ng2.template',\r\n        }, [new CR(4), body, new CR(2)]);\r\n        const xliff = new Tag('xliff', { version: _VERSION, xmlns: _XMLNS }, [new CR(2), file, new CR()]);\r\n        return serialize([\r\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\r\n        ]);\r\n    }\r\n    load(content, url) {\r\n        // xliff to xml nodes\r\n        const xliffParser = new XliffParser();\r\n        const { locale, msgIdToHtml, errors } = xliffParser.parse(content, url);\r\n        // xml nodes to i18n nodes\r\n        const i18nNodesByMsgId = {};\r\n        const converter = new XmlToI18n();\r\n        Object.keys(msgIdToHtml).forEach(msgId => {\r\n            const { i18nNodes, errors: e } = converter.convert(msgIdToHtml[msgId], url);\r\n            errors.push(...e);\r\n            i18nNodesByMsgId[msgId] = i18nNodes;\r\n        });\r\n        if (errors.length) {\r\n            throw new Error(`xliff parse errors:\\n${errors.join('\\n')}`);\r\n        }\r\n        return { locale: locale, i18nNodesByMsgId };\r\n    }\r\n    digest(message) {\r\n        return digest(message);\r\n    }\r\n}\r\nclass _WriteVisitor {\r\n    visitText(text, context) {\r\n        return [new Text$2(text.value)];\r\n    }\r\n    visitContainer(container, context) {\r\n        const nodes = [];\r\n        container.children.forEach((node) => nodes.push(...node.visit(this)));\r\n        return nodes;\r\n    }\r\n    visitIcu(icu, context) {\r\n        const nodes = [new Text$2(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\r\n        Object.keys(icu.cases).forEach((c) => {\r\n            nodes.push(new Text$2(`${c} {`), ...icu.cases[c].visit(this), new Text$2(`} `));\r\n        });\r\n        nodes.push(new Text$2(`}`));\r\n        return nodes;\r\n    }\r\n    visitTagPlaceholder(ph, context) {\r\n        const ctype = getCtypeForTag(ph.tag);\r\n        if (ph.isVoid) {\r\n            // void tags have no children nor closing tags\r\n            return [new Tag(_PLACEHOLDER_TAG$1, { id: ph.startName, ctype, 'equiv-text': `<${ph.tag}/>` })];\r\n        }\r\n        const startTagPh = new Tag(_PLACEHOLDER_TAG$1, { id: ph.startName, ctype, 'equiv-text': `<${ph.tag}>` });\r\n        const closeTagPh = new Tag(_PLACEHOLDER_TAG$1, { id: ph.closeName, ctype, 'equiv-text': `</${ph.tag}>` });\r\n        return [startTagPh, ...this.serialize(ph.children), closeTagPh];\r\n    }\r\n    visitPlaceholder(ph, context) {\r\n        return [new Tag(_PLACEHOLDER_TAG$1, { id: ph.name, 'equiv-text': `{{${ph.value}}}` })];\r\n    }\r\n    visitIcuPlaceholder(ph, context) {\r\n        const equivText = `{${ph.value.expression}, ${ph.value.type}, ${Object.keys(ph.value.cases).map((value) => value + ' {...}').join(' ')}}`;\r\n        return [new Tag(_PLACEHOLDER_TAG$1, { id: ph.name, 'equiv-text': equivText })];\r\n    }\r\n    serialize(nodes) {\r\n        return [].concat(...nodes.map(node => node.visit(this)));\r\n    }\r\n}\r\n// TODO(vicb): add error management (structure)\r\n// Extract messages as xml nodes from the xliff file\r\nclass XliffParser {\r\n    constructor() {\r\n        this._locale = null;\r\n    }\r\n    parse(xliff, url) {\r\n        this._unitMlString = null;\r\n        this._msgIdToHtml = {};\r\n        const xml = new XmlParser().parse(xliff, url);\r\n        this._errors = xml.errors;\r\n        visitAll$1(this, xml.rootNodes, null);\r\n        return {\r\n            msgIdToHtml: this._msgIdToHtml,\r\n            errors: this._errors,\r\n            locale: this._locale,\r\n        };\r\n    }\r\n    visitElement(element, context) {\r\n        switch (element.name) {\r\n            case _UNIT_TAG:\r\n                this._unitMlString = null;\r\n                const idAttr = element.attrs.find((attr) => attr.name === 'id');\r\n                if (!idAttr) {\r\n                    this._addError(element, `<${_UNIT_TAG}> misses the \"id\" attribute`);\r\n                }\r\n                else {\r\n                    const id = idAttr.value;\r\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\r\n                        this._addError(element, `Duplicated translations for msg ${id}`);\r\n                    }\r\n                    else {\r\n                        visitAll$1(this, element.children, null);\r\n                        if (typeof this._unitMlString === 'string') {\r\n                            this._msgIdToHtml[id] = this._unitMlString;\r\n                        }\r\n                        else {\r\n                            this._addError(element, `Message ${id} misses a translation`);\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            // ignore those tags\r\n            case _SOURCE_TAG$1:\r\n            case _SEGMENT_SOURCE_TAG:\r\n            case _ALT_TRANS_TAG:\r\n                break;\r\n            case _TARGET_TAG:\r\n                const innerTextStart = element.startSourceSpan.end.offset;\r\n                const innerTextEnd = element.endSourceSpan.start.offset;\r\n                const content = element.startSourceSpan.start.file.content;\r\n                const innerText = content.slice(innerTextStart, innerTextEnd);\r\n                this._unitMlString = innerText;\r\n                break;\r\n            case _FILE_TAG:\r\n                const localeAttr = element.attrs.find((attr) => attr.name === 'target-language');\r\n                if (localeAttr) {\r\n                    this._locale = localeAttr.value;\r\n                }\r\n                visitAll$1(this, element.children, null);\r\n                break;\r\n            default:\r\n                // TODO(vicb): assert file structure, xliff version\r\n                // For now only recurse on unhandled nodes\r\n                visitAll$1(this, element.children, null);\r\n        }\r\n    }\r\n    visitAttribute(attribute, context) { }\r\n    visitText(text, context) { }\r\n    visitComment(comment, context) { }\r\n    visitExpansion(expansion, context) { }\r\n    visitExpansionCase(expansionCase, context) { }\r\n    _addError(node, message) {\r\n        this._errors.push(new I18nError(node.sourceSpan, message));\r\n    }\r\n}\r\n// Convert ml nodes (xliff syntax) to i18n nodes\r\nclass XmlToI18n {\r\n    convert(message, url) {\r\n        const xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });\r\n        this._errors = xmlIcu.errors;\r\n        const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\r\n            [] :\r\n            [].concat(...visitAll$1(this, xmlIcu.rootNodes));\r\n        return {\r\n            i18nNodes: i18nNodes,\r\n            errors: this._errors,\r\n        };\r\n    }\r\n    visitText(text, context) {\r\n        return new Text$1(text.value, text.sourceSpan);\r\n    }\r\n    visitElement(el, context) {\r\n        if (el.name === _PLACEHOLDER_TAG$1) {\r\n            const nameAttr = el.attrs.find((attr) => attr.name === 'id');\r\n            if (nameAttr) {\r\n                return new Placeholder('', nameAttr.value, el.sourceSpan);\r\n            }\r\n            this._addError(el, `<${_PLACEHOLDER_TAG$1}> misses the \"id\" attribute`);\r\n            return null;\r\n        }\r\n        if (el.name === _MARKER_TAG) {\r\n            return [].concat(...visitAll$1(this, el.children));\r\n        }\r\n        this._addError(el, `Unexpected tag`);\r\n        return null;\r\n    }\r\n    visitExpansion(icu, context) {\r\n        const caseMap = {};\r\n        visitAll$1(this, icu.cases).forEach((c) => {\r\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\r\n        });\r\n        return new Icu$1(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\r\n    }\r\n    visitExpansionCase(icuCase, context) {\r\n        return {\r\n            value: icuCase.value,\r\n            nodes: visitAll$1(this, icuCase.expression),\r\n        };\r\n    }\r\n    visitComment(comment, context) { }\r\n    visitAttribute(attribute, context) { }\r\n    _addError(node, message) {\r\n        this._errors.push(new I18nError(node.sourceSpan, message));\r\n    }\r\n}\r\nfunction getCtypeForTag(tag) {\r\n    switch (tag.toLowerCase()) {\r\n        case 'br':\r\n            return 'lb';\r\n        case 'img':\r\n            return 'image';\r\n        default:\r\n            return `x-${tag}`;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst _VERSION$1 = '2.0';\r\nconst _XMLNS$1 = 'urn:oasis:names:tc:xliff:document:2.0';\r\n// TODO(vicb): make this a param (s/_/-/)\r\nconst _DEFAULT_SOURCE_LANG$1 = 'en';\r\nconst _PLACEHOLDER_TAG$2 = 'ph';\r\nconst _PLACEHOLDER_SPANNING_TAG = 'pc';\r\nconst _MARKER_TAG$1 = 'mrk';\r\nconst _XLIFF_TAG = 'xliff';\r\nconst _SOURCE_TAG$2 = 'source';\r\nconst _TARGET_TAG$1 = 'target';\r\nconst _UNIT_TAG$1 = 'unit';\r\n// https://docs.oasis-open.org/xliff/xliff-core/v2.0/os/xliff-core-v2.0-os.html\r\nclass Xliff2 extends Serializer {\r\n    write(messages, locale) {\r\n        const visitor = new _WriteVisitor$1();\r\n        const units = [];\r\n        messages.forEach(message => {\r\n            const unit = new Tag(_UNIT_TAG$1, { id: message.id });\r\n            const notes = new Tag('notes');\r\n            if (message.description || message.meaning) {\r\n                if (message.description) {\r\n                    notes.children.push(new CR(8), new Tag('note', { category: 'description' }, [new Text$2(message.description)]));\r\n                }\r\n                if (message.meaning) {\r\n                    notes.children.push(new CR(8), new Tag('note', { category: 'meaning' }, [new Text$2(message.meaning)]));\r\n                }\r\n            }\r\n            message.sources.forEach((source) => {\r\n                notes.children.push(new CR(8), new Tag('note', { category: 'location' }, [\r\n                    new Text$2(`${source.filePath}:${source.startLine}${source.endLine !== source.startLine ? ',' + source.endLine : ''}`)\r\n                ]));\r\n            });\r\n            notes.children.push(new CR(6));\r\n            unit.children.push(new CR(6), notes);\r\n            const segment = new Tag('segment');\r\n            segment.children.push(new CR(8), new Tag(_SOURCE_TAG$2, {}, visitor.serialize(message.nodes)), new CR(6));\r\n            unit.children.push(new CR(6), segment, new CR(4));\r\n            units.push(new CR(4), unit);\r\n        });\r\n        const file = new Tag('file', { 'original': 'ng.template', id: 'ngi18n' }, [...units, new CR(2)]);\r\n        const xliff = new Tag(_XLIFF_TAG, { version: _VERSION$1, xmlns: _XMLNS$1, srcLang: locale || _DEFAULT_SOURCE_LANG$1 }, [new CR(2), file, new CR()]);\r\n        return serialize([\r\n            new Declaration({ version: '1.0', encoding: 'UTF-8' }), new CR(), xliff, new CR()\r\n        ]);\r\n    }\r\n    load(content, url) {\r\n        // xliff to xml nodes\r\n        const xliff2Parser = new Xliff2Parser();\r\n        const { locale, msgIdToHtml, errors } = xliff2Parser.parse(content, url);\r\n        // xml nodes to i18n nodes\r\n        const i18nNodesByMsgId = {};\r\n        const converter = new XmlToI18n$1();\r\n        Object.keys(msgIdToHtml).forEach(msgId => {\r\n            const { i18nNodes, errors: e } = converter.convert(msgIdToHtml[msgId], url);\r\n            errors.push(...e);\r\n            i18nNodesByMsgId[msgId] = i18nNodes;\r\n        });\r\n        if (errors.length) {\r\n            throw new Error(`xliff2 parse errors:\\n${errors.join('\\n')}`);\r\n        }\r\n        return { locale: locale, i18nNodesByMsgId };\r\n    }\r\n    digest(message) {\r\n        return decimalDigest(message);\r\n    }\r\n}\r\nclass _WriteVisitor$1 {\r\n    visitText(text, context) {\r\n        return [new Text$2(text.value)];\r\n    }\r\n    visitContainer(container, context) {\r\n        const nodes = [];\r\n        container.children.forEach((node) => nodes.push(...node.visit(this)));\r\n        return nodes;\r\n    }\r\n    visitIcu(icu, context) {\r\n        const nodes = [new Text$2(`{${icu.expressionPlaceholder}, ${icu.type}, `)];\r\n        Object.keys(icu.cases).forEach((c) => {\r\n            nodes.push(new Text$2(`${c} {`), ...icu.cases[c].visit(this), new Text$2(`} `));\r\n        });\r\n        nodes.push(new Text$2(`}`));\r\n        return nodes;\r\n    }\r\n    visitTagPlaceholder(ph, context) {\r\n        const type = getTypeForTag(ph.tag);\r\n        if (ph.isVoid) {\r\n            const tagPh = new Tag(_PLACEHOLDER_TAG$2, {\r\n                id: (this._nextPlaceholderId++).toString(),\r\n                equiv: ph.startName,\r\n                type: type,\r\n                disp: `<${ph.tag}/>`,\r\n            });\r\n            return [tagPh];\r\n        }\r\n        const tagPc = new Tag(_PLACEHOLDER_SPANNING_TAG, {\r\n            id: (this._nextPlaceholderId++).toString(),\r\n            equivStart: ph.startName,\r\n            equivEnd: ph.closeName,\r\n            type: type,\r\n            dispStart: `<${ph.tag}>`,\r\n            dispEnd: `</${ph.tag}>`,\r\n        });\r\n        const nodes = [].concat(...ph.children.map(node => node.visit(this)));\r\n        if (nodes.length) {\r\n            nodes.forEach((node) => tagPc.children.push(node));\r\n        }\r\n        else {\r\n            tagPc.children.push(new Text$2(''));\r\n        }\r\n        return [tagPc];\r\n    }\r\n    visitPlaceholder(ph, context) {\r\n        const idStr = (this._nextPlaceholderId++).toString();\r\n        return [new Tag(_PLACEHOLDER_TAG$2, {\r\n                id: idStr,\r\n                equiv: ph.name,\r\n                disp: `{{${ph.value}}}`,\r\n            })];\r\n    }\r\n    visitIcuPlaceholder(ph, context) {\r\n        const cases = Object.keys(ph.value.cases).map((value) => value + ' {...}').join(' ');\r\n        const idStr = (this._nextPlaceholderId++).toString();\r\n        return [new Tag(_PLACEHOLDER_TAG$2, { id: idStr, equiv: ph.name, disp: `{${ph.value.expression}, ${ph.value.type}, ${cases}}` })];\r\n    }\r\n    serialize(nodes) {\r\n        this._nextPlaceholderId = 0;\r\n        return [].concat(...nodes.map(node => node.visit(this)));\r\n    }\r\n}\r\n// Extract messages as xml nodes from the xliff file\r\nclass Xliff2Parser {\r\n    constructor() {\r\n        this._locale = null;\r\n    }\r\n    parse(xliff, url) {\r\n        this._unitMlString = null;\r\n        this._msgIdToHtml = {};\r\n        const xml = new XmlParser().parse(xliff, url);\r\n        this._errors = xml.errors;\r\n        visitAll$1(this, xml.rootNodes, null);\r\n        return {\r\n            msgIdToHtml: this._msgIdToHtml,\r\n            errors: this._errors,\r\n            locale: this._locale,\r\n        };\r\n    }\r\n    visitElement(element, context) {\r\n        switch (element.name) {\r\n            case _UNIT_TAG$1:\r\n                this._unitMlString = null;\r\n                const idAttr = element.attrs.find((attr) => attr.name === 'id');\r\n                if (!idAttr) {\r\n                    this._addError(element, `<${_UNIT_TAG$1}> misses the \"id\" attribute`);\r\n                }\r\n                else {\r\n                    const id = idAttr.value;\r\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\r\n                        this._addError(element, `Duplicated translations for msg ${id}`);\r\n                    }\r\n                    else {\r\n                        visitAll$1(this, element.children, null);\r\n                        if (typeof this._unitMlString === 'string') {\r\n                            this._msgIdToHtml[id] = this._unitMlString;\r\n                        }\r\n                        else {\r\n                            this._addError(element, `Message ${id} misses a translation`);\r\n                        }\r\n                    }\r\n                }\r\n                break;\r\n            case _SOURCE_TAG$2:\r\n                // ignore source message\r\n                break;\r\n            case _TARGET_TAG$1:\r\n                const innerTextStart = element.startSourceSpan.end.offset;\r\n                const innerTextEnd = element.endSourceSpan.start.offset;\r\n                const content = element.startSourceSpan.start.file.content;\r\n                const innerText = content.slice(innerTextStart, innerTextEnd);\r\n                this._unitMlString = innerText;\r\n                break;\r\n            case _XLIFF_TAG:\r\n                const localeAttr = element.attrs.find((attr) => attr.name === 'trgLang');\r\n                if (localeAttr) {\r\n                    this._locale = localeAttr.value;\r\n                }\r\n                const versionAttr = element.attrs.find((attr) => attr.name === 'version');\r\n                if (versionAttr) {\r\n                    const version = versionAttr.value;\r\n                    if (version !== '2.0') {\r\n                        this._addError(element, `The XLIFF file version ${version} is not compatible with XLIFF 2.0 serializer`);\r\n                    }\r\n                    else {\r\n                        visitAll$1(this, element.children, null);\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                visitAll$1(this, element.children, null);\r\n        }\r\n    }\r\n    visitAttribute(attribute, context) { }\r\n    visitText(text, context) { }\r\n    visitComment(comment, context) { }\r\n    visitExpansion(expansion, context) { }\r\n    visitExpansionCase(expansionCase, context) { }\r\n    _addError(node, message) {\r\n        this._errors.push(new I18nError(node.sourceSpan, message));\r\n    }\r\n}\r\n// Convert ml nodes (xliff syntax) to i18n nodes\r\nclass XmlToI18n$1 {\r\n    convert(message, url) {\r\n        const xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });\r\n        this._errors = xmlIcu.errors;\r\n        const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\r\n            [] :\r\n            [].concat(...visitAll$1(this, xmlIcu.rootNodes));\r\n        return {\r\n            i18nNodes,\r\n            errors: this._errors,\r\n        };\r\n    }\r\n    visitText(text, context) {\r\n        return new Text$1(text.value, text.sourceSpan);\r\n    }\r\n    visitElement(el, context) {\r\n        switch (el.name) {\r\n            case _PLACEHOLDER_TAG$2:\r\n                const nameAttr = el.attrs.find((attr) => attr.name === 'equiv');\r\n                if (nameAttr) {\r\n                    return [new Placeholder('', nameAttr.value, el.sourceSpan)];\r\n                }\r\n                this._addError(el, `<${_PLACEHOLDER_TAG$2}> misses the \"equiv\" attribute`);\r\n                break;\r\n            case _PLACEHOLDER_SPANNING_TAG:\r\n                const startAttr = el.attrs.find((attr) => attr.name === 'equivStart');\r\n                const endAttr = el.attrs.find((attr) => attr.name === 'equivEnd');\r\n                if (!startAttr) {\r\n                    this._addError(el, `<${_PLACEHOLDER_TAG$2}> misses the \"equivStart\" attribute`);\r\n                }\r\n                else if (!endAttr) {\r\n                    this._addError(el, `<${_PLACEHOLDER_TAG$2}> misses the \"equivEnd\" attribute`);\r\n                }\r\n                else {\r\n                    const startId = startAttr.value;\r\n                    const endId = endAttr.value;\r\n                    const nodes = [];\r\n                    return nodes.concat(new Placeholder('', startId, el.sourceSpan), ...el.children.map(node => node.visit(this, null)), new Placeholder('', endId, el.sourceSpan));\r\n                }\r\n                break;\r\n            case _MARKER_TAG$1:\r\n                return [].concat(...visitAll$1(this, el.children));\r\n            default:\r\n                this._addError(el, `Unexpected tag`);\r\n        }\r\n        return null;\r\n    }\r\n    visitExpansion(icu, context) {\r\n        const caseMap = {};\r\n        visitAll$1(this, icu.cases).forEach((c) => {\r\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\r\n        });\r\n        return new Icu$1(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\r\n    }\r\n    visitExpansionCase(icuCase, context) {\r\n        return {\r\n            value: icuCase.value,\r\n            nodes: [].concat(...visitAll$1(this, icuCase.expression)),\r\n        };\r\n    }\r\n    visitComment(comment, context) { }\r\n    visitAttribute(attribute, context) { }\r\n    _addError(node, message) {\r\n        this._errors.push(new I18nError(node.sourceSpan, message));\r\n    }\r\n}\r\nfunction getTypeForTag(tag) {\r\n    switch (tag.toLowerCase()) {\r\n        case 'br':\r\n        case 'b':\r\n        case 'i':\r\n        case 'u':\r\n            return 'fmt';\r\n        case 'img':\r\n            return 'image';\r\n        case 'a':\r\n            return 'link';\r\n        default:\r\n            return 'other';\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst _TRANSLATIONS_TAG = 'translationbundle';\r\nconst _TRANSLATION_TAG = 'translation';\r\nconst _PLACEHOLDER_TAG$3 = 'ph';\r\nclass Xtb extends Serializer {\r\n    write(messages, locale) {\r\n        throw new Error('Unsupported');\r\n    }\r\n    load(content, url) {\r\n        // xtb to xml nodes\r\n        const xtbParser = new XtbParser();\r\n        const { locale, msgIdToHtml, errors } = xtbParser.parse(content, url);\r\n        // xml nodes to i18n nodes\r\n        const i18nNodesByMsgId = {};\r\n        const converter = new XmlToI18n$2();\r\n        // Because we should be able to load xtb files that rely on features not supported by angular,\r\n        // we need to delay the conversion of html to i18n nodes so that non angular messages are not\r\n        // converted\r\n        Object.keys(msgIdToHtml).forEach(msgId => {\r\n            const valueFn = function () {\r\n                const { i18nNodes, errors } = converter.convert(msgIdToHtml[msgId], url);\r\n                if (errors.length) {\r\n                    throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\r\n                }\r\n                return i18nNodes;\r\n            };\r\n            createLazyProperty(i18nNodesByMsgId, msgId, valueFn);\r\n        });\r\n        if (errors.length) {\r\n            throw new Error(`xtb parse errors:\\n${errors.join('\\n')}`);\r\n        }\r\n        return { locale: locale, i18nNodesByMsgId };\r\n    }\r\n    digest(message) {\r\n        return digest$1(message);\r\n    }\r\n    createNameMapper(message) {\r\n        return new SimplePlaceholderMapper(message, toPublicName);\r\n    }\r\n}\r\nfunction createLazyProperty(messages, id, valueFn) {\r\n    Object.defineProperty(messages, id, {\r\n        configurable: true,\r\n        enumerable: true,\r\n        get: function () {\r\n            const value = valueFn();\r\n            Object.defineProperty(messages, id, { enumerable: true, value });\r\n            return value;\r\n        },\r\n        set: _ => {\r\n            throw new Error('Could not overwrite an XTB translation');\r\n        },\r\n    });\r\n}\r\n// Extract messages as xml nodes from the xtb file\r\nclass XtbParser {\r\n    constructor() {\r\n        this._locale = null;\r\n    }\r\n    parse(xtb, url) {\r\n        this._bundleDepth = 0;\r\n        this._msgIdToHtml = {};\r\n        // We can not parse the ICU messages at this point as some messages might not originate\r\n        // from Angular that could not be lex'd.\r\n        const xml = new XmlParser().parse(xtb, url);\r\n        this._errors = xml.errors;\r\n        visitAll$1(this, xml.rootNodes);\r\n        return {\r\n            msgIdToHtml: this._msgIdToHtml,\r\n            errors: this._errors,\r\n            locale: this._locale,\r\n        };\r\n    }\r\n    visitElement(element, context) {\r\n        switch (element.name) {\r\n            case _TRANSLATIONS_TAG:\r\n                this._bundleDepth++;\r\n                if (this._bundleDepth > 1) {\r\n                    this._addError(element, `<${_TRANSLATIONS_TAG}> elements can not be nested`);\r\n                }\r\n                const langAttr = element.attrs.find((attr) => attr.name === 'lang');\r\n                if (langAttr) {\r\n                    this._locale = langAttr.value;\r\n                }\r\n                visitAll$1(this, element.children, null);\r\n                this._bundleDepth--;\r\n                break;\r\n            case _TRANSLATION_TAG:\r\n                const idAttr = element.attrs.find((attr) => attr.name === 'id');\r\n                if (!idAttr) {\r\n                    this._addError(element, `<${_TRANSLATION_TAG}> misses the \"id\" attribute`);\r\n                }\r\n                else {\r\n                    const id = idAttr.value;\r\n                    if (this._msgIdToHtml.hasOwnProperty(id)) {\r\n                        this._addError(element, `Duplicated translations for msg ${id}`);\r\n                    }\r\n                    else {\r\n                        const innerTextStart = element.startSourceSpan.end.offset;\r\n                        const innerTextEnd = element.endSourceSpan.start.offset;\r\n                        const content = element.startSourceSpan.start.file.content;\r\n                        const innerText = content.slice(innerTextStart, innerTextEnd);\r\n                        this._msgIdToHtml[id] = innerText;\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                this._addError(element, 'Unexpected tag');\r\n        }\r\n    }\r\n    visitAttribute(attribute, context) { }\r\n    visitText(text, context) { }\r\n    visitComment(comment, context) { }\r\n    visitExpansion(expansion, context) { }\r\n    visitExpansionCase(expansionCase, context) { }\r\n    _addError(node, message) {\r\n        this._errors.push(new I18nError(node.sourceSpan, message));\r\n    }\r\n}\r\n// Convert ml nodes (xtb syntax) to i18n nodes\r\nclass XmlToI18n$2 {\r\n    convert(message, url) {\r\n        const xmlIcu = new XmlParser().parse(message, url, { tokenizeExpansionForms: true });\r\n        this._errors = xmlIcu.errors;\r\n        const i18nNodes = this._errors.length > 0 || xmlIcu.rootNodes.length == 0 ?\r\n            [] :\r\n            visitAll$1(this, xmlIcu.rootNodes);\r\n        return {\r\n            i18nNodes,\r\n            errors: this._errors,\r\n        };\r\n    }\r\n    visitText(text, context) {\r\n        return new Text$1(text.value, text.sourceSpan);\r\n    }\r\n    visitExpansion(icu, context) {\r\n        const caseMap = {};\r\n        visitAll$1(this, icu.cases).forEach(c => {\r\n            caseMap[c.value] = new Container(c.nodes, icu.sourceSpan);\r\n        });\r\n        return new Icu$1(icu.switchValue, icu.type, caseMap, icu.sourceSpan);\r\n    }\r\n    visitExpansionCase(icuCase, context) {\r\n        return {\r\n            value: icuCase.value,\r\n            nodes: visitAll$1(this, icuCase.expression),\r\n        };\r\n    }\r\n    visitElement(el, context) {\r\n        if (el.name === _PLACEHOLDER_TAG$3) {\r\n            const nameAttr = el.attrs.find((attr) => attr.name === 'name');\r\n            if (nameAttr) {\r\n                return new Placeholder('', nameAttr.value, el.sourceSpan);\r\n            }\r\n            this._addError(el, `<${_PLACEHOLDER_TAG$3}> misses the \"name\" attribute`);\r\n        }\r\n        else {\r\n            this._addError(el, `Unexpected tag`);\r\n        }\r\n        return null;\r\n    }\r\n    visitComment(comment, context) { }\r\n    visitAttribute(attribute, context) { }\r\n    _addError(node, message) {\r\n        this._errors.push(new I18nError(node.sourceSpan, message));\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A container for translated messages\r\n */\r\nclass TranslationBundle {\r\n    constructor(_i18nNodesByMsgId = {}, locale, digest, mapperFactory, missingTranslationStrategy = MissingTranslationStrategy.Warning, console) {\r\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\r\n        this.digest = digest;\r\n        this.mapperFactory = mapperFactory;\r\n        this._i18nToHtml = new I18nToHtmlVisitor(_i18nNodesByMsgId, locale, digest, mapperFactory, missingTranslationStrategy, console);\r\n    }\r\n    // Creates a `TranslationBundle` by parsing the given `content` with the `serializer`.\r\n    static load(content, url, serializer, missingTranslationStrategy, console) {\r\n        const { locale, i18nNodesByMsgId } = serializer.load(content, url);\r\n        const digestFn = (m) => serializer.digest(m);\r\n        const mapperFactory = (m) => serializer.createNameMapper(m);\r\n        return new TranslationBundle(i18nNodesByMsgId, locale, digestFn, mapperFactory, missingTranslationStrategy, console);\r\n    }\r\n    // Returns the translation as HTML nodes from the given source message.\r\n    get(srcMsg) {\r\n        const html = this._i18nToHtml.convert(srcMsg);\r\n        if (html.errors.length) {\r\n            throw new Error(html.errors.join('\\n'));\r\n        }\r\n        return html.nodes;\r\n    }\r\n    has(srcMsg) {\r\n        return this.digest(srcMsg) in this._i18nNodesByMsgId;\r\n    }\r\n}\r\nclass I18nToHtmlVisitor {\r\n    constructor(_i18nNodesByMsgId = {}, _locale, _digest, _mapperFactory, _missingTranslationStrategy, _console) {\r\n        this._i18nNodesByMsgId = _i18nNodesByMsgId;\r\n        this._locale = _locale;\r\n        this._digest = _digest;\r\n        this._mapperFactory = _mapperFactory;\r\n        this._missingTranslationStrategy = _missingTranslationStrategy;\r\n        this._console = _console;\r\n        this._contextStack = [];\r\n        this._errors = [];\r\n    }\r\n    convert(srcMsg) {\r\n        this._contextStack.length = 0;\r\n        this._errors.length = 0;\r\n        // i18n to text\r\n        const text = this._convertToText(srcMsg);\r\n        // text to html\r\n        const url = srcMsg.nodes[0].sourceSpan.start.file.url;\r\n        const html = new HtmlParser().parse(text, url, { tokenizeExpansionForms: true });\r\n        return {\r\n            nodes: html.rootNodes,\r\n            errors: [...this._errors, ...html.errors],\r\n        };\r\n    }\r\n    visitText(text, context) {\r\n        // `convert()` uses an `HtmlParser` to return `html.Node`s\r\n        // we should then make sure that any special characters are escaped\r\n        return escapeXml(text.value);\r\n    }\r\n    visitContainer(container, context) {\r\n        return container.children.map(n => n.visit(this)).join('');\r\n    }\r\n    visitIcu(icu, context) {\r\n        const cases = Object.keys(icu.cases).map(k => `${k} {${icu.cases[k].visit(this)}}`);\r\n        // TODO(vicb): Once all format switch to using expression placeholders\r\n        // we should throw when the placeholder is not in the source message\r\n        const exp = this._srcMsg.placeholders.hasOwnProperty(icu.expression) ?\r\n            this._srcMsg.placeholders[icu.expression].text :\r\n            icu.expression;\r\n        return `{${exp}, ${icu.type}, ${cases.join(' ')}}`;\r\n    }\r\n    visitPlaceholder(ph, context) {\r\n        const phName = this._mapper(ph.name);\r\n        if (this._srcMsg.placeholders.hasOwnProperty(phName)) {\r\n            return this._srcMsg.placeholders[phName].text;\r\n        }\r\n        if (this._srcMsg.placeholderToMessage.hasOwnProperty(phName)) {\r\n            return this._convertToText(this._srcMsg.placeholderToMessage[phName]);\r\n        }\r\n        this._addError(ph, `Unknown placeholder \"${ph.name}\"`);\r\n        return '';\r\n    }\r\n    // Loaded message contains only placeholders (vs tag and icu placeholders).\r\n    // However when a translation can not be found, we need to serialize the source message\r\n    // which can contain tag placeholders\r\n    visitTagPlaceholder(ph, context) {\r\n        const tag = `${ph.tag}`;\r\n        const attrs = Object.keys(ph.attrs).map(name => `${name}=\"${ph.attrs[name]}\"`).join(' ');\r\n        if (ph.isVoid) {\r\n            return `<${tag} ${attrs}/>`;\r\n        }\r\n        const children = ph.children.map((c) => c.visit(this)).join('');\r\n        return `<${tag} ${attrs}>${children}</${tag}>`;\r\n    }\r\n    // Loaded message contains only placeholders (vs tag and icu placeholders).\r\n    // However when a translation can not be found, we need to serialize the source message\r\n    // which can contain tag placeholders\r\n    visitIcuPlaceholder(ph, context) {\r\n        // An ICU placeholder references the source message to be serialized\r\n        return this._convertToText(this._srcMsg.placeholderToMessage[ph.name]);\r\n    }\r\n    /**\r\n     * Convert a source message to a translated text string:\r\n     * - text nodes are replaced with their translation,\r\n     * - placeholders are replaced with their content,\r\n     * - ICU nodes are converted to ICU expressions.\r\n     */\r\n    _convertToText(srcMsg) {\r\n        const id = this._digest(srcMsg);\r\n        const mapper = this._mapperFactory ? this._mapperFactory(srcMsg) : null;\r\n        let nodes;\r\n        this._contextStack.push({ msg: this._srcMsg, mapper: this._mapper });\r\n        this._srcMsg = srcMsg;\r\n        if (this._i18nNodesByMsgId.hasOwnProperty(id)) {\r\n            // When there is a translation use its nodes as the source\r\n            // And create a mapper to convert serialized placeholder names to internal names\r\n            nodes = this._i18nNodesByMsgId[id];\r\n            this._mapper = (name) => mapper ? mapper.toInternalName(name) : name;\r\n        }\r\n        else {\r\n            // When no translation has been found\r\n            // - report an error / a warning / nothing,\r\n            // - use the nodes from the original message\r\n            // - placeholders are already internal and need no mapper\r\n            if (this._missingTranslationStrategy === MissingTranslationStrategy.Error) {\r\n                const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\r\n                this._addError(srcMsg.nodes[0], `Missing translation for message \"${id}\"${ctx}`);\r\n            }\r\n            else if (this._console &&\r\n                this._missingTranslationStrategy === MissingTranslationStrategy.Warning) {\r\n                const ctx = this._locale ? ` for locale \"${this._locale}\"` : '';\r\n                this._console.warn(`Missing translation for message \"${id}\"${ctx}`);\r\n            }\r\n            nodes = srcMsg.nodes;\r\n            this._mapper = (name) => name;\r\n        }\r\n        const text = nodes.map(node => node.visit(this)).join('');\r\n        const context = this._contextStack.pop();\r\n        this._srcMsg = context.msg;\r\n        this._mapper = context.mapper;\r\n        return text;\r\n    }\r\n    _addError(el, msg) {\r\n        this._errors.push(new I18nError(el.sourceSpan, msg));\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass I18NHtmlParser {\r\n    constructor(_htmlParser, translations, translationsFormat, missingTranslation = MissingTranslationStrategy.Warning, console) {\r\n        this._htmlParser = _htmlParser;\r\n        if (translations) {\r\n            const serializer = createSerializer(translationsFormat);\r\n            this._translationBundle =\r\n                TranslationBundle.load(translations, 'i18n', serializer, missingTranslation, console);\r\n        }\r\n        else {\r\n            this._translationBundle =\r\n                new TranslationBundle({}, null, digest, undefined, missingTranslation, console);\r\n        }\r\n    }\r\n    parse(source, url, options = {}) {\r\n        const interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\r\n        const parseResult = this._htmlParser.parse(source, url, Object.assign({ interpolationConfig }, options));\r\n        if (parseResult.errors.length) {\r\n            return new ParseTreeResult(parseResult.rootNodes, parseResult.errors);\r\n        }\r\n        return mergeTranslations(parseResult.rootNodes, this._translationBundle, interpolationConfig, [], {});\r\n    }\r\n}\r\nfunction createSerializer(format) {\r\n    format = (format || 'xlf').toLowerCase();\r\n    switch (format) {\r\n        case 'xmb':\r\n            return new Xmb();\r\n        case 'xtb':\r\n            return new Xtb();\r\n        case 'xliff2':\r\n        case 'xlf2':\r\n            return new Xliff2();\r\n        case 'xliff':\r\n        case 'xlf':\r\n        default:\r\n            return new Xliff();\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst QUOTED_KEYS = '$quoted$';\r\nfunction convertValueToOutputAst(ctx, value, type = null) {\r\n    return visitValue(value, new _ValueOutputAstTransformer(ctx), type);\r\n}\r\nclass _ValueOutputAstTransformer {\r\n    constructor(ctx) {\r\n        this.ctx = ctx;\r\n    }\r\n    visitArray(arr, type) {\r\n        const values = [];\r\n        // Note Array.map() must not be used to convert the values because it will\r\n        // skip over empty elements in arrays constructed using `new Array(length)`,\r\n        // resulting in `undefined` elements. This breaks the type guarantee that\r\n        // all values in `o.LiteralArrayExpr` are of type `o.Expression`.\r\n        // See test case in `value_util_spec.ts`.\r\n        for (let i = 0; i < arr.length; ++i) {\r\n            values.push(visitValue(arr[i], this, null /* context */));\r\n        }\r\n        return literalArr(values, type);\r\n    }\r\n    visitStringMap(map, type) {\r\n        const entries = [];\r\n        const quotedSet = new Set(map && map[QUOTED_KEYS]);\r\n        Object.keys(map).forEach(key => {\r\n            entries.push(new LiteralMapEntry(key, visitValue(map[key], this, null), quotedSet.has(key)));\r\n        });\r\n        return new LiteralMapExpr(entries, type);\r\n    }\r\n    visitPrimitive(value, type) {\r\n        return literal(value, type);\r\n    }\r\n    visitOther(value, type) {\r\n        if (value instanceof Expression) {\r\n            return value;\r\n        }\r\n        else {\r\n            return this.ctx.importExpr(value);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nfunction mapEntry$1(key, value) {\r\n    return { key, value, quoted: false };\r\n}\r\nclass InjectableCompiler {\r\n    constructor(reflector, alwaysGenerateDef) {\r\n        this.reflector = reflector;\r\n        this.alwaysGenerateDef = alwaysGenerateDef;\r\n        this.tokenInjector = reflector.resolveExternalReference(Identifiers$1.Injector);\r\n    }\r\n    depsArray(deps, ctx) {\r\n        return deps.map(dep => {\r\n            let token = dep;\r\n            let args = [token];\r\n            let flags = 0 /* Default */;\r\n            if (Array.isArray(dep)) {\r\n                for (let i = 0; i < dep.length; i++) {\r\n                    const v = dep[i];\r\n                    if (v) {\r\n                        if (v.ngMetadataName === 'Optional') {\r\n                            flags |= 8 /* Optional */;\r\n                        }\r\n                        else if (v.ngMetadataName === 'SkipSelf') {\r\n                            flags |= 4 /* SkipSelf */;\r\n                        }\r\n                        else if (v.ngMetadataName === 'Self') {\r\n                            flags |= 2 /* Self */;\r\n                        }\r\n                        else if (v.ngMetadataName === 'Inject') {\r\n                            token = v.token;\r\n                        }\r\n                        else {\r\n                            token = v;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            let tokenExpr;\r\n            if (typeof token === 'string') {\r\n                tokenExpr = literal(token);\r\n            }\r\n            else if (token === this.tokenInjector) {\r\n                tokenExpr = importExpr(Identifiers$1.INJECTOR);\r\n            }\r\n            else {\r\n                tokenExpr = ctx.importExpr(token);\r\n            }\r\n            if (flags !== 0 /* Default */) {\r\n                args = [tokenExpr, literal(flags)];\r\n            }\r\n            else {\r\n                args = [tokenExpr];\r\n            }\r\n            return importExpr(Identifiers$1.inject).callFn(args);\r\n        });\r\n    }\r\n    factoryFor(injectable, ctx) {\r\n        let retValue;\r\n        if (injectable.useExisting) {\r\n            retValue = importExpr(Identifiers$1.inject).callFn([ctx.importExpr(injectable.useExisting)]);\r\n        }\r\n        else if (injectable.useFactory) {\r\n            const deps = injectable.deps || [];\r\n            if (deps.length > 0) {\r\n                retValue = ctx.importExpr(injectable.useFactory).callFn(this.depsArray(deps, ctx));\r\n            }\r\n            else {\r\n                return ctx.importExpr(injectable.useFactory);\r\n            }\r\n        }\r\n        else if (injectable.useValue) {\r\n            retValue = convertValueToOutputAst(ctx, injectable.useValue);\r\n        }\r\n        else {\r\n            const clazz = injectable.useClass || injectable.symbol;\r\n            const depArgs = this.depsArray(this.reflector.parameters(clazz), ctx);\r\n            retValue = new InstantiateExpr(ctx.importExpr(clazz), depArgs);\r\n        }\r\n        return fn([], [new ReturnStatement(retValue)], undefined, undefined, injectable.symbol.name + '_Factory');\r\n    }\r\n    injectableDef(injectable, ctx) {\r\n        let providedIn = NULL_EXPR;\r\n        if (injectable.providedIn !== undefined) {\r\n            if (injectable.providedIn === null) {\r\n                providedIn = NULL_EXPR;\r\n            }\r\n            else if (typeof injectable.providedIn === 'string') {\r\n                providedIn = literal(injectable.providedIn);\r\n            }\r\n            else {\r\n                providedIn = ctx.importExpr(injectable.providedIn);\r\n            }\r\n        }\r\n        const def = [\r\n            mapEntry$1('factory', this.factoryFor(injectable, ctx)),\r\n            mapEntry$1('token', ctx.importExpr(injectable.type.reference)),\r\n            mapEntry$1('providedIn', providedIn),\r\n        ];\r\n        return importExpr(Identifiers.ɵɵdefineInjectable).callFn([literalMap(def)], undefined, true);\r\n    }\r\n    compile(injectable, ctx) {\r\n        if (this.alwaysGenerateDef || injectable.providedIn !== undefined) {\r\n            const className = identifierName(injectable.type);\r\n            const clazz = new ClassStmt(className, null, [\r\n                new ClassField('ɵprov', INFERRED_TYPE, [StmtModifier.Static], this.injectableDef(injectable, ctx)),\r\n            ], [], new ClassMethod(null, [], []), []);\r\n            ctx.statements.push(clazz);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst STRIP_SRC_FILE_SUFFIXES = /(\\.ts|\\.d\\.ts|\\.js|\\.jsx|\\.tsx)$/;\r\nconst GENERATED_FILE = /\\.ngfactory\\.|\\.ngsummary\\./;\r\nconst JIT_SUMMARY_FILE = /\\.ngsummary\\./;\r\nconst JIT_SUMMARY_NAME = /NgSummary$/;\r\nfunction ngfactoryFilePath(filePath, forceSourceFile = false) {\r\n    const urlWithSuffix = splitTypescriptSuffix(filePath, forceSourceFile);\r\n    return `${urlWithSuffix[0]}.ngfactory${normalizeGenFileSuffix(urlWithSuffix[1])}`;\r\n}\r\nfunction stripGeneratedFileSuffix(filePath) {\r\n    return filePath.replace(GENERATED_FILE, '.');\r\n}\r\nfunction isGeneratedFile(filePath) {\r\n    return GENERATED_FILE.test(filePath);\r\n}\r\nfunction splitTypescriptSuffix(path, forceSourceFile = false) {\r\n    if (path.endsWith('.d.ts')) {\r\n        return [path.slice(0, -5), forceSourceFile ? '.ts' : '.d.ts'];\r\n    }\r\n    const lastDot = path.lastIndexOf('.');\r\n    if (lastDot !== -1) {\r\n        return [path.substring(0, lastDot), path.substring(lastDot)];\r\n    }\r\n    return [path, ''];\r\n}\r\nfunction normalizeGenFileSuffix(srcFileSuffix) {\r\n    return srcFileSuffix === '.tsx' ? '.ts' : srcFileSuffix;\r\n}\r\nfunction summaryFileName(fileName) {\r\n    const fileNameWithoutSuffix = fileName.replace(STRIP_SRC_FILE_SUFFIXES, '');\r\n    return `${fileNameWithoutSuffix}.ngsummary.json`;\r\n}\r\nfunction summaryForJitFileName(fileName, forceSourceFile = false) {\r\n    const urlWithSuffix = splitTypescriptSuffix(stripGeneratedFileSuffix(fileName), forceSourceFile);\r\n    return `${urlWithSuffix[0]}.ngsummary${urlWithSuffix[1]}`;\r\n}\r\nfunction stripSummaryForJitFileSuffix(filePath) {\r\n    return filePath.replace(JIT_SUMMARY_FILE, '.');\r\n}\r\nfunction summaryForJitName(symbolName) {\r\n    return `${symbolName}NgSummary`;\r\n}\r\nfunction stripSummaryForJitNameSuffix(symbolName) {\r\n    return symbolName.replace(JIT_SUMMARY_NAME, '');\r\n}\r\nconst LOWERED_SYMBOL = /\\u0275\\d+/;\r\nfunction isLoweredSymbol(name) {\r\n    return LOWERED_SYMBOL.test(name);\r\n}\r\nfunction createLoweredSymbol(id) {\r\n    return `\\u0275${id}`;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nvar LifecycleHooks;\r\n(function (LifecycleHooks) {\r\n    LifecycleHooks[LifecycleHooks[\"OnInit\"] = 0] = \"OnInit\";\r\n    LifecycleHooks[LifecycleHooks[\"OnDestroy\"] = 1] = \"OnDestroy\";\r\n    LifecycleHooks[LifecycleHooks[\"DoCheck\"] = 2] = \"DoCheck\";\r\n    LifecycleHooks[LifecycleHooks[\"OnChanges\"] = 3] = \"OnChanges\";\r\n    LifecycleHooks[LifecycleHooks[\"AfterContentInit\"] = 4] = \"AfterContentInit\";\r\n    LifecycleHooks[LifecycleHooks[\"AfterContentChecked\"] = 5] = \"AfterContentChecked\";\r\n    LifecycleHooks[LifecycleHooks[\"AfterViewInit\"] = 6] = \"AfterViewInit\";\r\n    LifecycleHooks[LifecycleHooks[\"AfterViewChecked\"] = 7] = \"AfterViewChecked\";\r\n})(LifecycleHooks || (LifecycleHooks = {}));\r\nconst LIFECYCLE_HOOKS_VALUES = [\r\n    LifecycleHooks.OnInit, LifecycleHooks.OnDestroy, LifecycleHooks.DoCheck, LifecycleHooks.OnChanges,\r\n    LifecycleHooks.AfterContentInit, LifecycleHooks.AfterContentChecked, LifecycleHooks.AfterViewInit,\r\n    LifecycleHooks.AfterViewChecked\r\n];\r\nfunction hasLifecycleHook(reflector, hook, token) {\r\n    return reflector.hasLifecycleHook(token, getHookName(hook));\r\n}\r\nfunction getAllLifecycleHooks(reflector, token) {\r\n    return LIFECYCLE_HOOKS_VALUES.filter(hook => hasLifecycleHook(reflector, hook, token));\r\n}\r\nfunction getHookName(hook) {\r\n    switch (hook) {\r\n        case LifecycleHooks.OnInit:\r\n            return 'ngOnInit';\r\n        case LifecycleHooks.OnDestroy:\r\n            return 'ngOnDestroy';\r\n        case LifecycleHooks.DoCheck:\r\n            return 'ngDoCheck';\r\n        case LifecycleHooks.OnChanges:\r\n            return 'ngOnChanges';\r\n        case LifecycleHooks.AfterContentInit:\r\n            return 'ngAfterContentInit';\r\n        case LifecycleHooks.AfterContentChecked:\r\n            return 'ngAfterContentChecked';\r\n        case LifecycleHooks.AfterViewInit:\r\n            return 'ngAfterViewInit';\r\n        case LifecycleHooks.AfterViewChecked:\r\n            return 'ngAfterViewChecked';\r\n        default:\r\n            // This default case is not needed by TypeScript compiler, as the switch is exhaustive.\r\n            // However Closure Compiler does not understand that and reports an error in typed mode.\r\n            // The `throw new Error` below works around the problem, and the unexpected: never variable\r\n            // makes sure tsc still checks this code is unreachable.\r\n            const unexpected = hook;\r\n            throw new Error(`unexpected ${unexpected}`);\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst ERROR_COMPONENT_TYPE = 'ngComponentType';\r\nconst MISSING_NG_MODULE_METADATA_ERROR_DATA = 'ngMissingNgModuleMetadataErrorData';\r\nfunction getMissingNgModuleMetadataErrorData(error) {\r\n    var _a;\r\n    return (_a = error[MISSING_NG_MODULE_METADATA_ERROR_DATA]) !== null && _a !== void 0 ? _a : null;\r\n}\r\n// Design notes:\r\n// - don't lazily create metadata:\r\n//   For some metadata, we need to do async work sometimes,\r\n//   so the user has to kick off this loading.\r\n//   But we want to report errors even when the async work is\r\n//   not required to check that the user would have been able\r\n//   to wait correctly.\r\nclass CompileMetadataResolver {\r\n    constructor(_config, _htmlParser, _ngModuleResolver, _directiveResolver, _pipeResolver, _summaryResolver, _schemaRegistry, _directiveNormalizer, _console, _staticSymbolCache, _reflector, _errorCollector) {\r\n        this._config = _config;\r\n        this._htmlParser = _htmlParser;\r\n        this._ngModuleResolver = _ngModuleResolver;\r\n        this._directiveResolver = _directiveResolver;\r\n        this._pipeResolver = _pipeResolver;\r\n        this._summaryResolver = _summaryResolver;\r\n        this._schemaRegistry = _schemaRegistry;\r\n        this._directiveNormalizer = _directiveNormalizer;\r\n        this._console = _console;\r\n        this._staticSymbolCache = _staticSymbolCache;\r\n        this._reflector = _reflector;\r\n        this._errorCollector = _errorCollector;\r\n        this._nonNormalizedDirectiveCache = new Map();\r\n        this._directiveCache = new Map();\r\n        this._summaryCache = new Map();\r\n        this._pipeCache = new Map();\r\n        this._ngModuleCache = new Map();\r\n        this._ngModuleOfTypes = new Map();\r\n        this._shallowModuleCache = new Map();\r\n    }\r\n    getReflector() {\r\n        return this._reflector;\r\n    }\r\n    clearCacheFor(type) {\r\n        const dirMeta = this._directiveCache.get(type);\r\n        this._directiveCache.delete(type);\r\n        this._nonNormalizedDirectiveCache.delete(type);\r\n        this._summaryCache.delete(type);\r\n        this._pipeCache.delete(type);\r\n        this._ngModuleOfTypes.delete(type);\r\n        // Clear all of the NgModule as they contain transitive information!\r\n        this._ngModuleCache.clear();\r\n        if (dirMeta) {\r\n            this._directiveNormalizer.clearCacheFor(dirMeta);\r\n        }\r\n    }\r\n    clearCache() {\r\n        this._directiveCache.clear();\r\n        this._nonNormalizedDirectiveCache.clear();\r\n        this._summaryCache.clear();\r\n        this._pipeCache.clear();\r\n        this._ngModuleCache.clear();\r\n        this._ngModuleOfTypes.clear();\r\n        this._directiveNormalizer.clearCache();\r\n    }\r\n    _createProxyClass(baseType, name) {\r\n        let delegate = null;\r\n        const proxyClass = function () {\r\n            if (!delegate) {\r\n                throw new Error(`Illegal state: Class ${name} for type ${stringify(baseType)} is not compiled yet!`);\r\n            }\r\n            return delegate.apply(this, arguments);\r\n        };\r\n        proxyClass.setDelegate = (d) => {\r\n            delegate = d;\r\n            proxyClass.prototype = d.prototype;\r\n        };\r\n        // Make stringify work correctly\r\n        proxyClass.overriddenName = name;\r\n        return proxyClass;\r\n    }\r\n    getGeneratedClass(dirType, name) {\r\n        if (dirType instanceof StaticSymbol) {\r\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), name);\r\n        }\r\n        else {\r\n            return this._createProxyClass(dirType, name);\r\n        }\r\n    }\r\n    getComponentViewClass(dirType) {\r\n        return this.getGeneratedClass(dirType, viewClassName(dirType, 0));\r\n    }\r\n    getHostComponentViewClass(dirType) {\r\n        return this.getGeneratedClass(dirType, hostViewClassName(dirType));\r\n    }\r\n    getHostComponentType(dirType) {\r\n        const name = `${identifierName({ reference: dirType })}_Host`;\r\n        if (dirType instanceof StaticSymbol) {\r\n            return this._staticSymbolCache.get(dirType.filePath, name);\r\n        }\r\n        return this._createProxyClass(dirType, name);\r\n    }\r\n    getRendererType(dirType) {\r\n        if (dirType instanceof StaticSymbol) {\r\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), rendererTypeName(dirType));\r\n        }\r\n        else {\r\n            // returning an object as proxy,\r\n            // that we fill later during runtime compilation.\r\n            return {};\r\n        }\r\n    }\r\n    getComponentFactory(selector, dirType, inputs, outputs) {\r\n        if (dirType instanceof StaticSymbol) {\r\n            return this._staticSymbolCache.get(ngfactoryFilePath(dirType.filePath), componentFactoryName(dirType));\r\n        }\r\n        else {\r\n            const hostView = this.getHostComponentViewClass(dirType);\r\n            // Note: ngContentSelectors will be filled later once the template is\r\n            // loaded.\r\n            const createComponentFactory = this._reflector.resolveExternalReference(Identifiers$1.createComponentFactory);\r\n            return createComponentFactory(selector, dirType, hostView, inputs, outputs, []);\r\n        }\r\n    }\r\n    initComponentFactory(factory, ngContentSelectors) {\r\n        if (!(factory instanceof StaticSymbol)) {\r\n            factory.ngContentSelectors.push(...ngContentSelectors);\r\n        }\r\n    }\r\n    _loadSummary(type, kind) {\r\n        let typeSummary = this._summaryCache.get(type);\r\n        if (!typeSummary) {\r\n            const summary = this._summaryResolver.resolveSummary(type);\r\n            typeSummary = summary ? summary.type : null;\r\n            this._summaryCache.set(type, typeSummary || null);\r\n        }\r\n        return typeSummary && typeSummary.summaryKind === kind ? typeSummary : null;\r\n    }\r\n    getHostComponentMetadata(compMeta, hostViewType) {\r\n        const hostType = this.getHostComponentType(compMeta.type.reference);\r\n        if (!hostViewType) {\r\n            hostViewType = this.getHostComponentViewClass(hostType);\r\n        }\r\n        // Note: ! is ok here as this method should only be called with normalized directive\r\n        // metadata, which always fills in the selector.\r\n        const template = CssSelector.parse(compMeta.selector)[0].getMatchingElementTemplate();\r\n        const templateUrl = '';\r\n        const htmlAst = this._htmlParser.parse(template, templateUrl);\r\n        return CompileDirectiveMetadata.create({\r\n            isHost: true,\r\n            type: { reference: hostType, diDeps: [], lifecycleHooks: [] },\r\n            template: new CompileTemplateMetadata({\r\n                encapsulation: ViewEncapsulation.None,\r\n                template,\r\n                templateUrl,\r\n                htmlAst,\r\n                styles: [],\r\n                styleUrls: [],\r\n                ngContentSelectors: [],\r\n                animations: [],\r\n                isInline: true,\r\n                externalStylesheets: [],\r\n                interpolation: null,\r\n                preserveWhitespaces: false,\r\n            }),\r\n            exportAs: null,\r\n            changeDetection: ChangeDetectionStrategy.Default,\r\n            inputs: [],\r\n            outputs: [],\r\n            host: {},\r\n            isComponent: true,\r\n            selector: '*',\r\n            providers: [],\r\n            viewProviders: [],\r\n            queries: [],\r\n            guards: {},\r\n            viewQueries: [],\r\n            componentViewType: hostViewType,\r\n            rendererType: { id: '__Host__', encapsulation: ViewEncapsulation.None, styles: [], data: {} },\r\n            entryComponents: [],\r\n            componentFactory: null\r\n        });\r\n    }\r\n    loadDirectiveMetadata(ngModuleType, directiveType, isSync) {\r\n        if (this._directiveCache.has(directiveType)) {\r\n            return null;\r\n        }\r\n        directiveType = resolveForwardRef(directiveType);\r\n        const { annotation, metadata } = this.getNonNormalizedDirectiveMetadata(directiveType);\r\n        const createDirectiveMetadata = (templateMetadata) => {\r\n            const normalizedDirMeta = new CompileDirectiveMetadata({\r\n                isHost: false,\r\n                type: metadata.type,\r\n                isComponent: metadata.isComponent,\r\n                selector: metadata.selector,\r\n                exportAs: metadata.exportAs,\r\n                changeDetection: metadata.changeDetection,\r\n                inputs: metadata.inputs,\r\n                outputs: metadata.outputs,\r\n                hostListeners: metadata.hostListeners,\r\n                hostProperties: metadata.hostProperties,\r\n                hostAttributes: metadata.hostAttributes,\r\n                providers: metadata.providers,\r\n                viewProviders: metadata.viewProviders,\r\n                queries: metadata.queries,\r\n                guards: metadata.guards,\r\n                viewQueries: metadata.viewQueries,\r\n                entryComponents: metadata.entryComponents,\r\n                componentViewType: metadata.componentViewType,\r\n                rendererType: metadata.rendererType,\r\n                componentFactory: metadata.componentFactory,\r\n                template: templateMetadata\r\n            });\r\n            if (templateMetadata) {\r\n                this.initComponentFactory(metadata.componentFactory, templateMetadata.ngContentSelectors);\r\n            }\r\n            this._directiveCache.set(directiveType, normalizedDirMeta);\r\n            this._summaryCache.set(directiveType, normalizedDirMeta.toSummary());\r\n            return null;\r\n        };\r\n        if (metadata.isComponent) {\r\n            const template = metadata.template;\r\n            const templateMeta = this._directiveNormalizer.normalizeTemplate({\r\n                ngModuleType,\r\n                componentType: directiveType,\r\n                moduleUrl: this._reflector.componentModuleUrl(directiveType, annotation),\r\n                encapsulation: template.encapsulation,\r\n                template: template.template,\r\n                templateUrl: template.templateUrl,\r\n                styles: template.styles,\r\n                styleUrls: template.styleUrls,\r\n                animations: template.animations,\r\n                interpolation: template.interpolation,\r\n                preserveWhitespaces: template.preserveWhitespaces\r\n            });\r\n            if (isPromise(templateMeta) && isSync) {\r\n                this._reportError(componentStillLoadingError(directiveType), directiveType);\r\n                return null;\r\n            }\r\n            return SyncAsync.then(templateMeta, createDirectiveMetadata);\r\n        }\r\n        else {\r\n            // directive\r\n            createDirectiveMetadata(null);\r\n            return null;\r\n        }\r\n    }\r\n    getNonNormalizedDirectiveMetadata(directiveType) {\r\n        directiveType = resolveForwardRef(directiveType);\r\n        if (!directiveType) {\r\n            return null;\r\n        }\r\n        let cacheEntry = this._nonNormalizedDirectiveCache.get(directiveType);\r\n        if (cacheEntry) {\r\n            return cacheEntry;\r\n        }\r\n        const dirMeta = this._directiveResolver.resolve(directiveType, false);\r\n        if (!dirMeta) {\r\n            return null;\r\n        }\r\n        let nonNormalizedTemplateMetadata = undefined;\r\n        if (createComponent.isTypeOf(dirMeta)) {\r\n            // component\r\n            const compMeta = dirMeta;\r\n            assertArrayOfStrings('styles', compMeta.styles);\r\n            assertArrayOfStrings('styleUrls', compMeta.styleUrls);\r\n            assertInterpolationSymbols('interpolation', compMeta.interpolation);\r\n            const animations = compMeta.animations;\r\n            nonNormalizedTemplateMetadata = new CompileTemplateMetadata({\r\n                encapsulation: noUndefined(compMeta.encapsulation),\r\n                template: noUndefined(compMeta.template),\r\n                templateUrl: noUndefined(compMeta.templateUrl),\r\n                htmlAst: null,\r\n                styles: compMeta.styles || [],\r\n                styleUrls: compMeta.styleUrls || [],\r\n                animations: animations || [],\r\n                interpolation: noUndefined(compMeta.interpolation),\r\n                isInline: !!compMeta.template,\r\n                externalStylesheets: [],\r\n                ngContentSelectors: [],\r\n                preserveWhitespaces: noUndefined(dirMeta.preserveWhitespaces),\r\n            });\r\n        }\r\n        let changeDetectionStrategy = null;\r\n        let viewProviders = [];\r\n        let entryComponentMetadata = [];\r\n        let selector = dirMeta.selector;\r\n        if (createComponent.isTypeOf(dirMeta)) {\r\n            // Component\r\n            const compMeta = dirMeta;\r\n            changeDetectionStrategy = compMeta.changeDetection;\r\n            if (compMeta.viewProviders) {\r\n                viewProviders = this._getProvidersMetadata(compMeta.viewProviders, entryComponentMetadata, `viewProviders for \"${stringifyType(directiveType)}\"`, [], directiveType);\r\n            }\r\n            if (compMeta.entryComponents) {\r\n                entryComponentMetadata = flattenAndDedupeArray(compMeta.entryComponents)\r\n                    .map((type) => this._getEntryComponentMetadata(type))\r\n                    .concat(entryComponentMetadata);\r\n            }\r\n            if (!selector) {\r\n                selector = this._schemaRegistry.getDefaultComponentElementName();\r\n            }\r\n        }\r\n        else {\r\n            // Directive\r\n            if (!selector) {\r\n                selector = null;\r\n            }\r\n        }\r\n        let providers = [];\r\n        if (dirMeta.providers != null) {\r\n            providers = this._getProvidersMetadata(dirMeta.providers, entryComponentMetadata, `providers for \"${stringifyType(directiveType)}\"`, [], directiveType);\r\n        }\r\n        let queries = [];\r\n        let viewQueries = [];\r\n        if (dirMeta.queries != null) {\r\n            queries = this._getQueriesMetadata(dirMeta.queries, false, directiveType);\r\n            viewQueries = this._getQueriesMetadata(dirMeta.queries, true, directiveType);\r\n        }\r\n        const metadata = CompileDirectiveMetadata.create({\r\n            isHost: false,\r\n            selector: selector,\r\n            exportAs: noUndefined(dirMeta.exportAs),\r\n            isComponent: !!nonNormalizedTemplateMetadata,\r\n            type: this._getTypeMetadata(directiveType),\r\n            template: nonNormalizedTemplateMetadata,\r\n            changeDetection: changeDetectionStrategy,\r\n            inputs: dirMeta.inputs || [],\r\n            outputs: dirMeta.outputs || [],\r\n            host: dirMeta.host || {},\r\n            providers: providers || [],\r\n            viewProviders: viewProviders || [],\r\n            queries: queries || [],\r\n            guards: dirMeta.guards || {},\r\n            viewQueries: viewQueries || [],\r\n            entryComponents: entryComponentMetadata,\r\n            componentViewType: nonNormalizedTemplateMetadata ? this.getComponentViewClass(directiveType) :\r\n                null,\r\n            rendererType: nonNormalizedTemplateMetadata ? this.getRendererType(directiveType) : null,\r\n            componentFactory: null\r\n        });\r\n        if (nonNormalizedTemplateMetadata) {\r\n            metadata.componentFactory =\r\n                this.getComponentFactory(selector, directiveType, metadata.inputs, metadata.outputs);\r\n        }\r\n        cacheEntry = { metadata, annotation: dirMeta };\r\n        this._nonNormalizedDirectiveCache.set(directiveType, cacheEntry);\r\n        return cacheEntry;\r\n    }\r\n    /**\r\n     * Gets the metadata for the given directive.\r\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\r\n     */\r\n    getDirectiveMetadata(directiveType) {\r\n        const dirMeta = this._directiveCache.get(directiveType);\r\n        if (!dirMeta) {\r\n            this._reportError(syntaxError(`Illegal state: getDirectiveMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Directive ${stringifyType(directiveType)}.`), directiveType);\r\n        }\r\n        return dirMeta;\r\n    }\r\n    getDirectiveSummary(dirType) {\r\n        const dirSummary = this._loadSummary(dirType, CompileSummaryKind.Directive);\r\n        if (!dirSummary) {\r\n            this._reportError(syntaxError(`Illegal state: Could not load the summary for directive ${stringifyType(dirType)}.`), dirType);\r\n        }\r\n        return dirSummary;\r\n    }\r\n    isDirective(type) {\r\n        return !!this._loadSummary(type, CompileSummaryKind.Directive) ||\r\n            this._directiveResolver.isDirective(type);\r\n    }\r\n    isAbstractDirective(type) {\r\n        const summary = this._loadSummary(type, CompileSummaryKind.Directive);\r\n        if (summary && !summary.isComponent) {\r\n            return !summary.selector;\r\n        }\r\n        const meta = this._directiveResolver.resolve(type, false);\r\n        if (meta && !createComponent.isTypeOf(meta)) {\r\n            return !meta.selector;\r\n        }\r\n        return false;\r\n    }\r\n    isPipe(type) {\r\n        return !!this._loadSummary(type, CompileSummaryKind.Pipe) ||\r\n            this._pipeResolver.isPipe(type);\r\n    }\r\n    isNgModule(type) {\r\n        return !!this._loadSummary(type, CompileSummaryKind.NgModule) ||\r\n            this._ngModuleResolver.isNgModule(type);\r\n    }\r\n    getNgModuleSummary(moduleType, alreadyCollecting = null) {\r\n        let moduleSummary = this._loadSummary(moduleType, CompileSummaryKind.NgModule);\r\n        if (!moduleSummary) {\r\n            const moduleMeta = this.getNgModuleMetadata(moduleType, false, alreadyCollecting);\r\n            moduleSummary = moduleMeta ? moduleMeta.toSummary() : null;\r\n            if (moduleSummary) {\r\n                this._summaryCache.set(moduleType, moduleSummary);\r\n            }\r\n        }\r\n        return moduleSummary;\r\n    }\r\n    /**\r\n     * Loads the declared directives and pipes of an NgModule.\r\n     */\r\n    loadNgModuleDirectiveAndPipeMetadata(moduleType, isSync, throwIfNotFound = true) {\r\n        const ngModule = this.getNgModuleMetadata(moduleType, throwIfNotFound);\r\n        const loading = [];\r\n        if (ngModule) {\r\n            ngModule.declaredDirectives.forEach((id) => {\r\n                const promise = this.loadDirectiveMetadata(moduleType, id.reference, isSync);\r\n                if (promise) {\r\n                    loading.push(promise);\r\n                }\r\n            });\r\n            ngModule.declaredPipes.forEach((id) => this._loadPipeMetadata(id.reference));\r\n        }\r\n        return Promise.all(loading);\r\n    }\r\n    getShallowModuleMetadata(moduleType) {\r\n        let compileMeta = this._shallowModuleCache.get(moduleType);\r\n        if (compileMeta) {\r\n            return compileMeta;\r\n        }\r\n        const ngModuleMeta = findLast(this._reflector.shallowAnnotations(moduleType), createNgModule.isTypeOf);\r\n        compileMeta = {\r\n            type: this._getTypeMetadata(moduleType),\r\n            rawExports: ngModuleMeta.exports,\r\n            rawImports: ngModuleMeta.imports,\r\n            rawProviders: ngModuleMeta.providers,\r\n        };\r\n        this._shallowModuleCache.set(moduleType, compileMeta);\r\n        return compileMeta;\r\n    }\r\n    getNgModuleMetadata(moduleType, throwIfNotFound = true, alreadyCollecting = null) {\r\n        moduleType = resolveForwardRef(moduleType);\r\n        let compileMeta = this._ngModuleCache.get(moduleType);\r\n        if (compileMeta) {\r\n            return compileMeta;\r\n        }\r\n        const meta = this._ngModuleResolver.resolve(moduleType, throwIfNotFound);\r\n        if (!meta) {\r\n            return null;\r\n        }\r\n        const declaredDirectives = [];\r\n        const exportedNonModuleIdentifiers = [];\r\n        const declaredPipes = [];\r\n        const importedModules = [];\r\n        const exportedModules = [];\r\n        const providers = [];\r\n        const entryComponents = [];\r\n        const bootstrapComponents = [];\r\n        const schemas = [];\r\n        if (meta.imports) {\r\n            flattenAndDedupeArray(meta.imports).forEach((importedType) => {\r\n                let importedModuleType = undefined;\r\n                if (isValidType(importedType)) {\r\n                    importedModuleType = importedType;\r\n                }\r\n                else if (importedType && importedType.ngModule) {\r\n                    const moduleWithProviders = importedType;\r\n                    importedModuleType = moduleWithProviders.ngModule;\r\n                    if (moduleWithProviders.providers) {\r\n                        providers.push(...this._getProvidersMetadata(moduleWithProviders.providers, entryComponents, `provider for the NgModule '${stringifyType(importedModuleType)}'`, [], importedType));\r\n                    }\r\n                }\r\n                if (importedModuleType) {\r\n                    if (this._checkSelfImport(moduleType, importedModuleType))\r\n                        return;\r\n                    if (!alreadyCollecting)\r\n                        alreadyCollecting = new Set();\r\n                    if (alreadyCollecting.has(importedModuleType)) {\r\n                        this._reportError(syntaxError(`${this._getTypeDescriptor(importedModuleType)} '${stringifyType(importedType)}' is imported recursively by the module '${stringifyType(moduleType)}'.`), moduleType);\r\n                        return;\r\n                    }\r\n                    alreadyCollecting.add(importedModuleType);\r\n                    const importedModuleSummary = this.getNgModuleSummary(importedModuleType, alreadyCollecting);\r\n                    alreadyCollecting.delete(importedModuleType);\r\n                    if (!importedModuleSummary) {\r\n                        const err = syntaxError(`Unexpected ${this._getTypeDescriptor(importedType)} '${stringifyType(importedType)}' imported by the module '${stringifyType(moduleType)}'. Please add a @NgModule annotation.`);\r\n                        // If possible, record additional context for this error to enable more useful\r\n                        // diagnostics on the compiler side.\r\n                        if (importedType instanceof StaticSymbol) {\r\n                            err[MISSING_NG_MODULE_METADATA_ERROR_DATA] = {\r\n                                fileName: importedType.filePath,\r\n                                className: importedType.name,\r\n                            };\r\n                        }\r\n                        this._reportError(err, moduleType);\r\n                        return;\r\n                    }\r\n                    importedModules.push(importedModuleSummary);\r\n                }\r\n                else {\r\n                    this._reportError(syntaxError(`Unexpected value '${stringifyType(importedType)}' imported by the module '${stringifyType(moduleType)}'`), moduleType);\r\n                    return;\r\n                }\r\n            });\r\n        }\r\n        if (meta.exports) {\r\n            flattenAndDedupeArray(meta.exports).forEach((exportedType) => {\r\n                if (!isValidType(exportedType)) {\r\n                    this._reportError(syntaxError(`Unexpected value '${stringifyType(exportedType)}' exported by the module '${stringifyType(moduleType)}'`), moduleType);\r\n                    return;\r\n                }\r\n                if (!alreadyCollecting)\r\n                    alreadyCollecting = new Set();\r\n                if (alreadyCollecting.has(exportedType)) {\r\n                    this._reportError(syntaxError(`${this._getTypeDescriptor(exportedType)} '${stringify(exportedType)}' is exported recursively by the module '${stringifyType(moduleType)}'`), moduleType);\r\n                    return;\r\n                }\r\n                alreadyCollecting.add(exportedType);\r\n                const exportedModuleSummary = this.getNgModuleSummary(exportedType, alreadyCollecting);\r\n                alreadyCollecting.delete(exportedType);\r\n                if (exportedModuleSummary) {\r\n                    exportedModules.push(exportedModuleSummary);\r\n                }\r\n                else {\r\n                    exportedNonModuleIdentifiers.push(this._getIdentifierMetadata(exportedType));\r\n                }\r\n            });\r\n        }\r\n        // Note: This will be modified later, so we rely on\r\n        // getting a new instance every time!\r\n        const transitiveModule = this._getTransitiveNgModuleMetadata(importedModules, exportedModules);\r\n        if (meta.declarations) {\r\n            flattenAndDedupeArray(meta.declarations).forEach((declaredType) => {\r\n                if (!isValidType(declaredType)) {\r\n                    this._reportError(syntaxError(`Unexpected value '${stringifyType(declaredType)}' declared by the module '${stringifyType(moduleType)}'`), moduleType);\r\n                    return;\r\n                }\r\n                const declaredIdentifier = this._getIdentifierMetadata(declaredType);\r\n                if (this.isDirective(declaredType)) {\r\n                    if (this.isAbstractDirective(declaredType)) {\r\n                        this._reportError(syntaxError(`Directive ${stringifyType(declaredType)} has no selector, please add it!`), declaredType);\r\n                    }\r\n                    transitiveModule.addDirective(declaredIdentifier);\r\n                    declaredDirectives.push(declaredIdentifier);\r\n                    this._addTypeToModule(declaredType, moduleType);\r\n                }\r\n                else if (this.isPipe(declaredType)) {\r\n                    transitiveModule.addPipe(declaredIdentifier);\r\n                    transitiveModule.pipes.push(declaredIdentifier);\r\n                    declaredPipes.push(declaredIdentifier);\r\n                    this._addTypeToModule(declaredType, moduleType);\r\n                }\r\n                else {\r\n                    this._reportError(syntaxError(`Unexpected ${this._getTypeDescriptor(declaredType)} '${stringifyType(declaredType)}' declared by the module '${stringifyType(moduleType)}'. Please add a @Pipe/@Directive/@Component annotation.`), moduleType);\r\n                    return;\r\n                }\r\n            });\r\n        }\r\n        const exportedDirectives = [];\r\n        const exportedPipes = [];\r\n        exportedNonModuleIdentifiers.forEach((exportedId) => {\r\n            if (transitiveModule.directivesSet.has(exportedId.reference)) {\r\n                exportedDirectives.push(exportedId);\r\n                transitiveModule.addExportedDirective(exportedId);\r\n            }\r\n            else if (transitiveModule.pipesSet.has(exportedId.reference)) {\r\n                exportedPipes.push(exportedId);\r\n                transitiveModule.addExportedPipe(exportedId);\r\n            }\r\n            else {\r\n                this._reportError(syntaxError(`Can't export ${this._getTypeDescriptor(exportedId.reference)} ${stringifyType(exportedId.reference)} from ${stringifyType(moduleType)} as it was neither declared nor imported!`), moduleType);\r\n                return;\r\n            }\r\n        });\r\n        // The providers of the module have to go last\r\n        // so that they overwrite any other provider we already added.\r\n        if (meta.providers) {\r\n            providers.push(...this._getProvidersMetadata(meta.providers, entryComponents, `provider for the NgModule '${stringifyType(moduleType)}'`, [], moduleType));\r\n        }\r\n        if (meta.entryComponents) {\r\n            entryComponents.push(...flattenAndDedupeArray(meta.entryComponents)\r\n                .map(type => this._getEntryComponentMetadata(type)));\r\n        }\r\n        if (meta.bootstrap) {\r\n            flattenAndDedupeArray(meta.bootstrap).forEach(type => {\r\n                if (!isValidType(type)) {\r\n                    this._reportError(syntaxError(`Unexpected value '${stringifyType(type)}' used in the bootstrap property of module '${stringifyType(moduleType)}'`), moduleType);\r\n                    return;\r\n                }\r\n                bootstrapComponents.push(this._getIdentifierMetadata(type));\r\n            });\r\n        }\r\n        entryComponents.push(...bootstrapComponents.map(type => this._getEntryComponentMetadata(type.reference)));\r\n        if (meta.schemas) {\r\n            schemas.push(...flattenAndDedupeArray(meta.schemas));\r\n        }\r\n        compileMeta = new CompileNgModuleMetadata({\r\n            type: this._getTypeMetadata(moduleType),\r\n            providers,\r\n            entryComponents,\r\n            bootstrapComponents,\r\n            schemas,\r\n            declaredDirectives,\r\n            exportedDirectives,\r\n            declaredPipes,\r\n            exportedPipes,\r\n            importedModules,\r\n            exportedModules,\r\n            transitiveModule,\r\n            id: meta.id || null,\r\n        });\r\n        entryComponents.forEach((id) => transitiveModule.addEntryComponent(id));\r\n        providers.forEach((provider) => transitiveModule.addProvider(provider, compileMeta.type));\r\n        transitiveModule.addModule(compileMeta.type);\r\n        this._ngModuleCache.set(moduleType, compileMeta);\r\n        return compileMeta;\r\n    }\r\n    _checkSelfImport(moduleType, importedModuleType) {\r\n        if (moduleType === importedModuleType) {\r\n            this._reportError(syntaxError(`'${stringifyType(moduleType)}' module can't import itself`), moduleType);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    _getTypeDescriptor(type) {\r\n        if (isValidType(type)) {\r\n            if (this.isDirective(type)) {\r\n                return 'directive';\r\n            }\r\n            if (this.isPipe(type)) {\r\n                return 'pipe';\r\n            }\r\n            if (this.isNgModule(type)) {\r\n                return 'module';\r\n            }\r\n        }\r\n        if (type.provide) {\r\n            return 'provider';\r\n        }\r\n        return 'value';\r\n    }\r\n    _addTypeToModule(type, moduleType) {\r\n        const oldModule = this._ngModuleOfTypes.get(type);\r\n        if (oldModule && oldModule !== moduleType) {\r\n            this._reportError(syntaxError(`Type ${stringifyType(type)} is part of the declarations of 2 modules: ${stringifyType(oldModule)} and ${stringifyType(moduleType)}! ` +\r\n                `Please consider moving ${stringifyType(type)} to a higher module that imports ${stringifyType(oldModule)} and ${stringifyType(moduleType)}. ` +\r\n                `You can also create a new NgModule that exports and includes ${stringifyType(type)} then import that NgModule in ${stringifyType(oldModule)} and ${stringifyType(moduleType)}.`), moduleType);\r\n            return;\r\n        }\r\n        this._ngModuleOfTypes.set(type, moduleType);\r\n    }\r\n    _getTransitiveNgModuleMetadata(importedModules, exportedModules) {\r\n        // collect `providers` / `entryComponents` from all imported and all exported modules\r\n        const result = new TransitiveCompileNgModuleMetadata();\r\n        const modulesByToken = new Map();\r\n        importedModules.concat(exportedModules).forEach((modSummary) => {\r\n            modSummary.modules.forEach((mod) => result.addModule(mod));\r\n            modSummary.entryComponents.forEach((comp) => result.addEntryComponent(comp));\r\n            const addedTokens = new Set();\r\n            modSummary.providers.forEach((entry) => {\r\n                const tokenRef = tokenReference(entry.provider.token);\r\n                let prevModules = modulesByToken.get(tokenRef);\r\n                if (!prevModules) {\r\n                    prevModules = new Set();\r\n                    modulesByToken.set(tokenRef, prevModules);\r\n                }\r\n                const moduleRef = entry.module.reference;\r\n                // Note: the providers of one module may still contain multiple providers\r\n                // per token (e.g. for multi providers), and we need to preserve these.\r\n                if (addedTokens.has(tokenRef) || !prevModules.has(moduleRef)) {\r\n                    prevModules.add(moduleRef);\r\n                    addedTokens.add(tokenRef);\r\n                    result.addProvider(entry.provider, entry.module);\r\n                }\r\n            });\r\n        });\r\n        exportedModules.forEach((modSummary) => {\r\n            modSummary.exportedDirectives.forEach((id) => result.addExportedDirective(id));\r\n            modSummary.exportedPipes.forEach((id) => result.addExportedPipe(id));\r\n        });\r\n        importedModules.forEach((modSummary) => {\r\n            modSummary.exportedDirectives.forEach((id) => result.addDirective(id));\r\n            modSummary.exportedPipes.forEach((id) => result.addPipe(id));\r\n        });\r\n        return result;\r\n    }\r\n    _getIdentifierMetadata(type) {\r\n        type = resolveForwardRef(type);\r\n        return { reference: type };\r\n    }\r\n    isInjectable(type) {\r\n        const annotations = this._reflector.tryAnnotations(type);\r\n        return annotations.some(ann => createInjectable.isTypeOf(ann));\r\n    }\r\n    getInjectableSummary(type) {\r\n        return {\r\n            summaryKind: CompileSummaryKind.Injectable,\r\n            type: this._getTypeMetadata(type, null, false)\r\n        };\r\n    }\r\n    getInjectableMetadata(type, dependencies = null, throwOnUnknownDeps = true) {\r\n        const typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);\r\n        const typeMetadata = typeSummary ?\r\n            typeSummary.type :\r\n            this._getTypeMetadata(type, dependencies, throwOnUnknownDeps);\r\n        const annotations = this._reflector.annotations(type).filter(ann => createInjectable.isTypeOf(ann));\r\n        if (annotations.length === 0) {\r\n            return null;\r\n        }\r\n        const meta = annotations[annotations.length - 1];\r\n        return {\r\n            symbol: type,\r\n            type: typeMetadata,\r\n            providedIn: meta.providedIn,\r\n            useValue: meta.useValue,\r\n            useClass: meta.useClass,\r\n            useExisting: meta.useExisting,\r\n            useFactory: meta.useFactory,\r\n            deps: meta.deps,\r\n        };\r\n    }\r\n    _getTypeMetadata(type, dependencies = null, throwOnUnknownDeps = true) {\r\n        const identifier = this._getIdentifierMetadata(type);\r\n        return {\r\n            reference: identifier.reference,\r\n            diDeps: this._getDependenciesMetadata(identifier.reference, dependencies, throwOnUnknownDeps),\r\n            lifecycleHooks: getAllLifecycleHooks(this._reflector, identifier.reference),\r\n        };\r\n    }\r\n    _getFactoryMetadata(factory, dependencies = null) {\r\n        factory = resolveForwardRef(factory);\r\n        return { reference: factory, diDeps: this._getDependenciesMetadata(factory, dependencies) };\r\n    }\r\n    /**\r\n     * Gets the metadata for the given pipe.\r\n     * This assumes `loadNgModuleDirectiveAndPipeMetadata` has been called first.\r\n     */\r\n    getPipeMetadata(pipeType) {\r\n        const pipeMeta = this._pipeCache.get(pipeType);\r\n        if (!pipeMeta) {\r\n            this._reportError(syntaxError(`Illegal state: getPipeMetadata can only be called after loadNgModuleDirectiveAndPipeMetadata for a module that declares it. Pipe ${stringifyType(pipeType)}.`), pipeType);\r\n        }\r\n        return pipeMeta || null;\r\n    }\r\n    getPipeSummary(pipeType) {\r\n        const pipeSummary = this._loadSummary(pipeType, CompileSummaryKind.Pipe);\r\n        if (!pipeSummary) {\r\n            this._reportError(syntaxError(`Illegal state: Could not load the summary for pipe ${stringifyType(pipeType)}.`), pipeType);\r\n        }\r\n        return pipeSummary;\r\n    }\r\n    getOrLoadPipeMetadata(pipeType) {\r\n        let pipeMeta = this._pipeCache.get(pipeType);\r\n        if (!pipeMeta) {\r\n            pipeMeta = this._loadPipeMetadata(pipeType);\r\n        }\r\n        return pipeMeta;\r\n    }\r\n    _loadPipeMetadata(pipeType) {\r\n        pipeType = resolveForwardRef(pipeType);\r\n        const pipeAnnotation = this._pipeResolver.resolve(pipeType);\r\n        const pipeMeta = new CompilePipeMetadata({\r\n            type: this._getTypeMetadata(pipeType),\r\n            name: pipeAnnotation.name,\r\n            pure: !!pipeAnnotation.pure\r\n        });\r\n        this._pipeCache.set(pipeType, pipeMeta);\r\n        this._summaryCache.set(pipeType, pipeMeta.toSummary());\r\n        return pipeMeta;\r\n    }\r\n    _getDependenciesMetadata(typeOrFunc, dependencies, throwOnUnknownDeps = true) {\r\n        let hasUnknownDeps = false;\r\n        const params = dependencies || this._reflector.parameters(typeOrFunc) || [];\r\n        const dependenciesMetadata = params.map((param) => {\r\n            let isAttribute = false;\r\n            let isHost = false;\r\n            let isSelf = false;\r\n            let isSkipSelf = false;\r\n            let isOptional = false;\r\n            let token = null;\r\n            if (Array.isArray(param)) {\r\n                param.forEach((paramEntry) => {\r\n                    if (createHost.isTypeOf(paramEntry)) {\r\n                        isHost = true;\r\n                    }\r\n                    else if (createSelf.isTypeOf(paramEntry)) {\r\n                        isSelf = true;\r\n                    }\r\n                    else if (createSkipSelf.isTypeOf(paramEntry)) {\r\n                        isSkipSelf = true;\r\n                    }\r\n                    else if (createOptional.isTypeOf(paramEntry)) {\r\n                        isOptional = true;\r\n                    }\r\n                    else if (createAttribute.isTypeOf(paramEntry)) {\r\n                        isAttribute = true;\r\n                        token = paramEntry.attributeName;\r\n                    }\r\n                    else if (createInject.isTypeOf(paramEntry)) {\r\n                        token = paramEntry.token;\r\n                    }\r\n                    else if (createInjectionToken.isTypeOf(paramEntry) ||\r\n                        paramEntry instanceof StaticSymbol) {\r\n                        token = paramEntry;\r\n                    }\r\n                    else if (isValidType(paramEntry) && token == null) {\r\n                        token = paramEntry;\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                token = param;\r\n            }\r\n            if (token == null) {\r\n                hasUnknownDeps = true;\r\n                return {};\r\n            }\r\n            return {\r\n                isAttribute,\r\n                isHost,\r\n                isSelf,\r\n                isSkipSelf,\r\n                isOptional,\r\n                token: this._getTokenMetadata(token)\r\n            };\r\n        });\r\n        if (hasUnknownDeps) {\r\n            const depsTokens = dependenciesMetadata.map((dep) => dep.token ? stringifyType(dep.token) : '?').join(', ');\r\n            const message = `Can't resolve all parameters for ${stringifyType(typeOrFunc)}: (${depsTokens}).`;\r\n            if (throwOnUnknownDeps || this._config.strictInjectionParameters) {\r\n                this._reportError(syntaxError(message), typeOrFunc);\r\n            }\r\n        }\r\n        return dependenciesMetadata;\r\n    }\r\n    _getTokenMetadata(token) {\r\n        token = resolveForwardRef(token);\r\n        let compileToken;\r\n        if (typeof token === 'string') {\r\n            compileToken = { value: token };\r\n        }\r\n        else {\r\n            compileToken = { identifier: { reference: token } };\r\n        }\r\n        return compileToken;\r\n    }\r\n    _getProvidersMetadata(providers, targetEntryComponents, debugInfo, compileProviders = [], type) {\r\n        providers.forEach((provider, providerIdx) => {\r\n            if (Array.isArray(provider)) {\r\n                this._getProvidersMetadata(provider, targetEntryComponents, debugInfo, compileProviders);\r\n            }\r\n            else {\r\n                provider = resolveForwardRef(provider);\r\n                let providerMeta = undefined;\r\n                if (provider && typeof provider === 'object' && provider.hasOwnProperty('provide')) {\r\n                    this._validateProvider(provider);\r\n                    providerMeta = new ProviderMeta(provider.provide, provider);\r\n                }\r\n                else if (isValidType(provider)) {\r\n                    providerMeta = new ProviderMeta(provider, { useClass: provider });\r\n                }\r\n                else if (provider === void 0) {\r\n                    this._reportError(syntaxError(`Encountered undefined provider! Usually this means you have a circular dependencies. This might be caused by using 'barrel' index.ts files.`));\r\n                    return;\r\n                }\r\n                else {\r\n                    const providersInfo = providers\r\n                        .reduce((soFar, seenProvider, seenProviderIdx) => {\r\n                        if (seenProviderIdx < providerIdx) {\r\n                            soFar.push(`${stringifyType(seenProvider)}`);\r\n                        }\r\n                        else if (seenProviderIdx == providerIdx) {\r\n                            soFar.push(`?${stringifyType(seenProvider)}?`);\r\n                        }\r\n                        else if (seenProviderIdx == providerIdx + 1) {\r\n                            soFar.push('...');\r\n                        }\r\n                        return soFar;\r\n                    }, [])\r\n                        .join(', ');\r\n                    this._reportError(syntaxError(`Invalid ${debugInfo ?\r\n                        debugInfo :\r\n                        'provider'} - only instances of Provider and Type are allowed, got: [${providersInfo}]`), type);\r\n                    return;\r\n                }\r\n                if (providerMeta.token ===\r\n                    this._reflector.resolveExternalReference(Identifiers$1.ANALYZE_FOR_ENTRY_COMPONENTS)) {\r\n                    targetEntryComponents.push(...this._getEntryComponentsFromProvider(providerMeta, type));\r\n                }\r\n                else {\r\n                    compileProviders.push(this.getProviderMetadata(providerMeta));\r\n                }\r\n            }\r\n        });\r\n        return compileProviders;\r\n    }\r\n    _validateProvider(provider) {\r\n        if (provider.hasOwnProperty('useClass') && provider.useClass == null) {\r\n            this._reportError(syntaxError(`Invalid provider for ${stringifyType(provider.provide)}. useClass cannot be ${provider.useClass}.\r\n           Usually it happens when:\r\n           1. There's a circular dependency (might be caused by using index.ts (barrel) files).\r\n           2. Class was used before it was declared. Use forwardRef in this case.`));\r\n        }\r\n    }\r\n    _getEntryComponentsFromProvider(provider, type) {\r\n        const components = [];\r\n        const collectedIdentifiers = [];\r\n        if (provider.useFactory || provider.useExisting || provider.useClass) {\r\n            this._reportError(syntaxError(`The ANALYZE_FOR_ENTRY_COMPONENTS token only supports useValue!`), type);\r\n            return [];\r\n        }\r\n        if (!provider.multi) {\r\n            this._reportError(syntaxError(`The ANALYZE_FOR_ENTRY_COMPONENTS token only supports 'multi = true'!`), type);\r\n            return [];\r\n        }\r\n        extractIdentifiers(provider.useValue, collectedIdentifiers);\r\n        collectedIdentifiers.forEach((identifier) => {\r\n            const entry = this._getEntryComponentMetadata(identifier.reference, false);\r\n            if (entry) {\r\n                components.push(entry);\r\n            }\r\n        });\r\n        return components;\r\n    }\r\n    _getEntryComponentMetadata(dirType, throwIfNotFound = true) {\r\n        const dirMeta = this.getNonNormalizedDirectiveMetadata(dirType);\r\n        if (dirMeta && dirMeta.metadata.isComponent) {\r\n            return { componentType: dirType, componentFactory: dirMeta.metadata.componentFactory };\r\n        }\r\n        const dirSummary = this._loadSummary(dirType, CompileSummaryKind.Directive);\r\n        if (dirSummary && dirSummary.isComponent) {\r\n            return { componentType: dirType, componentFactory: dirSummary.componentFactory };\r\n        }\r\n        if (throwIfNotFound) {\r\n            throw syntaxError(`${dirType.name} cannot be used as an entry component.`);\r\n        }\r\n        return null;\r\n    }\r\n    _getInjectableTypeMetadata(type, dependencies = null) {\r\n        const typeSummary = this._loadSummary(type, CompileSummaryKind.Injectable);\r\n        if (typeSummary) {\r\n            return typeSummary.type;\r\n        }\r\n        return this._getTypeMetadata(type, dependencies);\r\n    }\r\n    getProviderMetadata(provider) {\r\n        let compileDeps = undefined;\r\n        let compileTypeMetadata = null;\r\n        let compileFactoryMetadata = null;\r\n        let token = this._getTokenMetadata(provider.token);\r\n        if (provider.useClass) {\r\n            compileTypeMetadata =\r\n                this._getInjectableTypeMetadata(provider.useClass, provider.dependencies);\r\n            compileDeps = compileTypeMetadata.diDeps;\r\n            if (provider.token === provider.useClass) {\r\n                // use the compileTypeMetadata as it contains information about lifecycleHooks...\r\n                token = { identifier: compileTypeMetadata };\r\n            }\r\n        }\r\n        else if (provider.useFactory) {\r\n            compileFactoryMetadata = this._getFactoryMetadata(provider.useFactory, provider.dependencies);\r\n            compileDeps = compileFactoryMetadata.diDeps;\r\n        }\r\n        return {\r\n            token: token,\r\n            useClass: compileTypeMetadata,\r\n            useValue: provider.useValue,\r\n            useFactory: compileFactoryMetadata,\r\n            useExisting: provider.useExisting ? this._getTokenMetadata(provider.useExisting) : undefined,\r\n            deps: compileDeps,\r\n            multi: provider.multi\r\n        };\r\n    }\r\n    _getQueriesMetadata(queries, isViewQuery, directiveType) {\r\n        const res = [];\r\n        Object.keys(queries).forEach((propertyName) => {\r\n            const query = queries[propertyName];\r\n            if (query.isViewQuery === isViewQuery) {\r\n                res.push(this._getQueryMetadata(query, propertyName, directiveType));\r\n            }\r\n        });\r\n        return res;\r\n    }\r\n    _queryVarBindings(selector) {\r\n        return selector.split(/\\s*,\\s*/);\r\n    }\r\n    _getQueryMetadata(q, propertyName, typeOrFunc) {\r\n        let selectors;\r\n        if (typeof q.selector === 'string') {\r\n            selectors =\r\n                this._queryVarBindings(q.selector).map(varName => this._getTokenMetadata(varName));\r\n        }\r\n        else {\r\n            if (!q.selector) {\r\n                this._reportError(syntaxError(`Can't construct a query for the property \"${propertyName}\" of \"${stringifyType(typeOrFunc)}\" since the query selector wasn't defined.`), typeOrFunc);\r\n                selectors = [];\r\n            }\r\n            else {\r\n                selectors = [this._getTokenMetadata(q.selector)];\r\n            }\r\n        }\r\n        return {\r\n            selectors,\r\n            first: q.first,\r\n            descendants: q.descendants,\r\n            emitDistinctChangesOnly: q.emitDistinctChangesOnly,\r\n            propertyName,\r\n            read: q.read ? this._getTokenMetadata(q.read) : null,\r\n            static: q.static\r\n        };\r\n    }\r\n    _reportError(error, type, otherType) {\r\n        if (this._errorCollector) {\r\n            this._errorCollector(error, type);\r\n            if (otherType) {\r\n                this._errorCollector(error, otherType);\r\n            }\r\n        }\r\n        else {\r\n            throw error;\r\n        }\r\n    }\r\n}\r\nfunction flattenArray(tree, out = []) {\r\n    if (tree) {\r\n        for (let i = 0; i < tree.length; i++) {\r\n            const item = resolveForwardRef(tree[i]);\r\n            if (Array.isArray(item)) {\r\n                flattenArray(item, out);\r\n            }\r\n            else {\r\n                out.push(item);\r\n            }\r\n        }\r\n    }\r\n    return out;\r\n}\r\nfunction dedupeArray(array) {\r\n    if (array) {\r\n        return Array.from(new Set(array));\r\n    }\r\n    return [];\r\n}\r\nfunction flattenAndDedupeArray(tree) {\r\n    return dedupeArray(flattenArray(tree));\r\n}\r\nfunction isValidType(value) {\r\n    return (value instanceof StaticSymbol) || (value instanceof Type);\r\n}\r\nfunction extractIdentifiers(value, targetIdentifiers) {\r\n    visitValue(value, new _CompileValueConverter(), targetIdentifiers);\r\n}\r\nclass _CompileValueConverter extends ValueTransformer {\r\n    visitOther(value, targetIdentifiers) {\r\n        targetIdentifiers.push({ reference: value });\r\n    }\r\n}\r\nfunction stringifyType(type) {\r\n    if (type instanceof StaticSymbol) {\r\n        return `${type.name} in ${type.filePath}`;\r\n    }\r\n    else {\r\n        return stringify(type);\r\n    }\r\n}\r\n/**\r\n * Indicates that a component is still being loaded in a synchronous compile.\r\n */\r\nfunction componentStillLoadingError(compType) {\r\n    const error = Error(`Can't compile synchronously as ${stringify(compType)} is still being loaded!`);\r\n    error[ERROR_COMPONENT_TYPE] = compType;\r\n    return error;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nfunction providerDef(ctx, providerAst) {\r\n    let flags = 0 /* None */;\r\n    if (!providerAst.eager) {\r\n        flags |= 4096 /* LazyProvider */;\r\n    }\r\n    if (providerAst.providerType === ProviderAstType.PrivateService) {\r\n        flags |= 8192 /* PrivateProvider */;\r\n    }\r\n    if (providerAst.isModule) {\r\n        flags |= 1073741824 /* TypeModuleProvider */;\r\n    }\r\n    providerAst.lifecycleHooks.forEach((lifecycleHook) => {\r\n        // for regular providers, we only support ngOnDestroy\r\n        if (lifecycleHook === LifecycleHooks.OnDestroy ||\r\n            providerAst.providerType === ProviderAstType.Directive ||\r\n            providerAst.providerType === ProviderAstType.Component) {\r\n            flags |= lifecycleHookToNodeFlag(lifecycleHook);\r\n        }\r\n    });\r\n    const { providerExpr, flags: providerFlags, depsExpr } = providerAst.multiProvider ?\r\n        multiProviderDef(ctx, flags, providerAst.providers) :\r\n        singleProviderDef(ctx, flags, providerAst.providerType, providerAst.providers[0]);\r\n    return {\r\n        providerExpr,\r\n        flags: providerFlags,\r\n        depsExpr,\r\n        tokenExpr: tokenExpr(ctx, providerAst.token),\r\n    };\r\n}\r\nfunction multiProviderDef(ctx, flags, providers) {\r\n    const allDepDefs = [];\r\n    const allParams = [];\r\n    const exprs = providers.map((provider, providerIndex) => {\r\n        let expr;\r\n        if (provider.useClass) {\r\n            const depExprs = convertDeps(providerIndex, provider.deps || provider.useClass.diDeps);\r\n            expr = ctx.importExpr(provider.useClass.reference).instantiate(depExprs);\r\n        }\r\n        else if (provider.useFactory) {\r\n            const depExprs = convertDeps(providerIndex, provider.deps || provider.useFactory.diDeps);\r\n            expr = ctx.importExpr(provider.useFactory.reference).callFn(depExprs);\r\n        }\r\n        else if (provider.useExisting) {\r\n            const depExprs = convertDeps(providerIndex, [{ token: provider.useExisting }]);\r\n            expr = depExprs[0];\r\n        }\r\n        else {\r\n            expr = convertValueToOutputAst(ctx, provider.useValue);\r\n        }\r\n        return expr;\r\n    });\r\n    const providerExpr = fn(allParams, [new ReturnStatement(literalArr(exprs))], INFERRED_TYPE);\r\n    return {\r\n        providerExpr,\r\n        flags: flags | 1024 /* TypeFactoryProvider */,\r\n        depsExpr: literalArr(allDepDefs)\r\n    };\r\n    function convertDeps(providerIndex, deps) {\r\n        return deps.map((dep, depIndex) => {\r\n            const paramName = `p${providerIndex}_${depIndex}`;\r\n            allParams.push(new FnParam(paramName, DYNAMIC_TYPE));\r\n            allDepDefs.push(depDef(ctx, dep));\r\n            return variable(paramName);\r\n        });\r\n    }\r\n}\r\nfunction singleProviderDef(ctx, flags, providerType, providerMeta) {\r\n    let providerExpr;\r\n    let deps;\r\n    if (providerType === ProviderAstType.Directive || providerType === ProviderAstType.Component) {\r\n        providerExpr = ctx.importExpr(providerMeta.useClass.reference);\r\n        flags |= 16384 /* TypeDirective */;\r\n        deps = providerMeta.deps || providerMeta.useClass.diDeps;\r\n    }\r\n    else {\r\n        if (providerMeta.useClass) {\r\n            providerExpr = ctx.importExpr(providerMeta.useClass.reference);\r\n            flags |= 512 /* TypeClassProvider */;\r\n            deps = providerMeta.deps || providerMeta.useClass.diDeps;\r\n        }\r\n        else if (providerMeta.useFactory) {\r\n            providerExpr = ctx.importExpr(providerMeta.useFactory.reference);\r\n            flags |= 1024 /* TypeFactoryProvider */;\r\n            deps = providerMeta.deps || providerMeta.useFactory.diDeps;\r\n        }\r\n        else if (providerMeta.useExisting) {\r\n            providerExpr = NULL_EXPR;\r\n            flags |= 2048 /* TypeUseExistingProvider */;\r\n            deps = [{ token: providerMeta.useExisting }];\r\n        }\r\n        else {\r\n            providerExpr = convertValueToOutputAst(ctx, providerMeta.useValue);\r\n            flags |= 256 /* TypeValueProvider */;\r\n            deps = [];\r\n        }\r\n    }\r\n    const depsExpr = literalArr(deps.map(dep => depDef(ctx, dep)));\r\n    return { providerExpr, flags, depsExpr };\r\n}\r\nfunction tokenExpr(ctx, tokenMeta) {\r\n    return tokenMeta.identifier ? ctx.importExpr(tokenMeta.identifier.reference) :\r\n        literal(tokenMeta.value);\r\n}\r\nfunction depDef(ctx, dep) {\r\n    // Note: the following fields have already been normalized out by provider_analyzer:\r\n    // - isAttribute, isHost\r\n    const expr = dep.isValue ? convertValueToOutputAst(ctx, dep.value) : tokenExpr(ctx, dep.token);\r\n    let flags = 0 /* None */;\r\n    if (dep.isSkipSelf) {\r\n        flags |= 1 /* SkipSelf */;\r\n    }\r\n    if (dep.isOptional) {\r\n        flags |= 2 /* Optional */;\r\n    }\r\n    if (dep.isSelf) {\r\n        flags |= 4 /* Self */;\r\n    }\r\n    if (dep.isValue) {\r\n        flags |= 8 /* Value */;\r\n    }\r\n    return flags === 0 /* None */ ? expr : literalArr([literal(flags), expr]);\r\n}\r\nfunction lifecycleHookToNodeFlag(lifecycleHook) {\r\n    let nodeFlag = 0 /* None */;\r\n    switch (lifecycleHook) {\r\n        case LifecycleHooks.AfterContentChecked:\r\n            nodeFlag = 2097152 /* AfterContentChecked */;\r\n            break;\r\n        case LifecycleHooks.AfterContentInit:\r\n            nodeFlag = 1048576 /* AfterContentInit */;\r\n            break;\r\n        case LifecycleHooks.AfterViewChecked:\r\n            nodeFlag = 8388608 /* AfterViewChecked */;\r\n            break;\r\n        case LifecycleHooks.AfterViewInit:\r\n            nodeFlag = 4194304 /* AfterViewInit */;\r\n            break;\r\n        case LifecycleHooks.DoCheck:\r\n            nodeFlag = 262144 /* DoCheck */;\r\n            break;\r\n        case LifecycleHooks.OnChanges:\r\n            nodeFlag = 524288 /* OnChanges */;\r\n            break;\r\n        case LifecycleHooks.OnDestroy:\r\n            nodeFlag = 131072 /* OnDestroy */;\r\n            break;\r\n        case LifecycleHooks.OnInit:\r\n            nodeFlag = 65536 /* OnInit */;\r\n            break;\r\n    }\r\n    return nodeFlag;\r\n}\r\nfunction componentFactoryResolverProviderDef(reflector, ctx, flags, entryComponents) {\r\n    const entryComponentFactories = entryComponents.map((entryComponent) => ctx.importExpr(entryComponent.componentFactory));\r\n    const token = createTokenForExternalReference(reflector, Identifiers$1.ComponentFactoryResolver);\r\n    const classMeta = {\r\n        diDeps: [\r\n            { isValue: true, value: literalArr(entryComponentFactories) },\r\n            { token: token, isSkipSelf: true, isOptional: true },\r\n            { token: createTokenForExternalReference(reflector, Identifiers$1.NgModuleRef) },\r\n        ],\r\n        lifecycleHooks: [],\r\n        reference: reflector.resolveExternalReference(Identifiers$1.CodegenComponentFactoryResolver)\r\n    };\r\n    const { providerExpr, flags: providerFlags, depsExpr } = singleProviderDef(ctx, flags, ProviderAstType.PrivateService, {\r\n        token,\r\n        multi: false,\r\n        useClass: classMeta,\r\n    });\r\n    return { providerExpr, flags: providerFlags, depsExpr, tokenExpr: tokenExpr(ctx, token) };\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass NgModuleCompileResult {\r\n    constructor(ngModuleFactoryVar) {\r\n        this.ngModuleFactoryVar = ngModuleFactoryVar;\r\n    }\r\n}\r\nconst LOG_VAR = variable('_l');\r\nclass NgModuleCompiler {\r\n    constructor(reflector) {\r\n        this.reflector = reflector;\r\n    }\r\n    compile(ctx, ngModuleMeta, extraProviders) {\r\n        const sourceSpan = typeSourceSpan('NgModule', ngModuleMeta.type);\r\n        const entryComponentFactories = ngModuleMeta.transitiveModule.entryComponents;\r\n        const bootstrapComponents = ngModuleMeta.bootstrapComponents;\r\n        const providerParser = new NgModuleProviderAnalyzer(this.reflector, ngModuleMeta, extraProviders, sourceSpan);\r\n        const providerDefs = [componentFactoryResolverProviderDef(this.reflector, ctx, 0 /* None */, entryComponentFactories)]\r\n            .concat(providerParser.parse().map((provider) => providerDef(ctx, provider)))\r\n            .map(({ providerExpr, depsExpr, flags, tokenExpr }) => {\r\n            return importExpr(Identifiers$1.moduleProviderDef).callFn([\r\n                literal(flags), tokenExpr, providerExpr, depsExpr\r\n            ]);\r\n        });\r\n        const ngModuleDef = importExpr(Identifiers$1.moduleDef).callFn([literalArr(providerDefs)]);\r\n        const ngModuleDefFactory = fn([new FnParam(LOG_VAR.name)], [new ReturnStatement(ngModuleDef)], INFERRED_TYPE);\r\n        const ngModuleFactoryVar = `${identifierName(ngModuleMeta.type)}NgFactory`;\r\n        this._createNgModuleFactory(ctx, ngModuleMeta.type.reference, importExpr(Identifiers$1.createModuleFactory).callFn([\r\n            ctx.importExpr(ngModuleMeta.type.reference),\r\n            literalArr(bootstrapComponents.map(id => ctx.importExpr(id.reference))),\r\n            ngModuleDefFactory\r\n        ]));\r\n        if (ngModuleMeta.id) {\r\n            const id = typeof ngModuleMeta.id === 'string' ? literal(ngModuleMeta.id) :\r\n                ctx.importExpr(ngModuleMeta.id);\r\n            const registerFactoryStmt = importExpr(Identifiers$1.RegisterModuleFactoryFn)\r\n                .callFn([id, variable(ngModuleFactoryVar)])\r\n                .toStmt();\r\n            ctx.statements.push(registerFactoryStmt);\r\n        }\r\n        return new NgModuleCompileResult(ngModuleFactoryVar);\r\n    }\r\n    createStub(ctx, ngModuleReference) {\r\n        this._createNgModuleFactory(ctx, ngModuleReference, NULL_EXPR);\r\n    }\r\n    _createNgModuleFactory(ctx, reference, value) {\r\n        const ngModuleFactoryVar = `${identifierName({ reference: reference })}NgFactory`;\r\n        const ngModuleFactoryStmt = variable(ngModuleFactoryVar)\r\n            .set(value)\r\n            .toDeclStmt(importType(Identifiers$1.NgModuleFactory, [expressionType(ctx.importExpr(reference))], [TypeModifier.Const]), [StmtModifier.Final, StmtModifier.Exported]);\r\n        ctx.statements.push(ngModuleFactoryStmt);\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Resolves types to {@link NgModule}.\r\n */\r\nclass NgModuleResolver {\r\n    constructor(_reflector) {\r\n        this._reflector = _reflector;\r\n    }\r\n    isNgModule(type) {\r\n        return this._reflector.annotations(type).some(createNgModule.isTypeOf);\r\n    }\r\n    resolve(type, throwIfNotFound = true) {\r\n        const ngModuleMeta = findLast(this._reflector.annotations(type), createNgModule.isTypeOf);\r\n        if (ngModuleMeta) {\r\n            return ngModuleMeta;\r\n        }\r\n        else {\r\n            if (throwIfNotFound) {\r\n                throw new Error(`No NgModule metadata found for '${stringify(type)}'.`);\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nfunction debugOutputAstAsTypeScript(ast) {\r\n    const converter = new _TsEmitterVisitor();\r\n    const ctx = EmitterVisitorContext.createRoot();\r\n    const asts = Array.isArray(ast) ? ast : [ast];\r\n    asts.forEach((ast) => {\r\n        if (ast instanceof Statement) {\r\n            ast.visitStatement(converter, ctx);\r\n        }\r\n        else if (ast instanceof Expression) {\r\n            ast.visitExpression(converter, ctx);\r\n        }\r\n        else if (ast instanceof Type$1) {\r\n            ast.visitType(converter, ctx);\r\n        }\r\n        else {\r\n            throw new Error(`Don't know how to print debug info for ${ast}`);\r\n        }\r\n    });\r\n    return ctx.toSource();\r\n}\r\nclass TypeScriptEmitter {\r\n    emitStatementsAndContext(genFilePath, stmts, preamble = '', emitSourceMaps = true, referenceFilter, importFilter) {\r\n        const converter = new _TsEmitterVisitor(referenceFilter, importFilter);\r\n        const ctx = EmitterVisitorContext.createRoot();\r\n        converter.visitAllStatements(stmts, ctx);\r\n        const preambleLines = preamble ? preamble.split('\\n') : [];\r\n        converter.reexports.forEach((reexports, exportedModuleName) => {\r\n            const reexportsCode = reexports.map(reexport => `${reexport.name} as ${reexport.as}`).join(',');\r\n            preambleLines.push(`export {${reexportsCode}} from '${exportedModuleName}';`);\r\n        });\r\n        converter.importsWithPrefixes.forEach((prefix, importedModuleName) => {\r\n            // Note: can't write the real word for import as it screws up system.js auto detection...\r\n            preambleLines.push(`imp` +\r\n                `ort * as ${prefix} from '${importedModuleName}';`);\r\n        });\r\n        const sm = emitSourceMaps ?\r\n            ctx.toSourceMapGenerator(genFilePath, preambleLines.length).toJsComment() :\r\n            '';\r\n        const lines = [...preambleLines, ctx.toSource(), sm];\r\n        if (sm) {\r\n            // always add a newline at the end, as some tools have bugs without it.\r\n            lines.push('');\r\n        }\r\n        ctx.setPreambleLineCount(preambleLines.length);\r\n        return { sourceText: lines.join('\\n'), context: ctx };\r\n    }\r\n    emitStatements(genFilePath, stmts, preamble = '') {\r\n        return this.emitStatementsAndContext(genFilePath, stmts, preamble).sourceText;\r\n    }\r\n}\r\nclass _TsEmitterVisitor extends AbstractEmitterVisitor {\r\n    constructor(referenceFilter, importFilter) {\r\n        super(false);\r\n        this.referenceFilter = referenceFilter;\r\n        this.importFilter = importFilter;\r\n        this.typeExpression = 0;\r\n        this.importsWithPrefixes = new Map();\r\n        this.reexports = new Map();\r\n    }\r\n    visitType(t, ctx, defaultType = 'any') {\r\n        if (t) {\r\n            this.typeExpression++;\r\n            t.visitType(this, ctx);\r\n            this.typeExpression--;\r\n        }\r\n        else {\r\n            ctx.print(null, defaultType);\r\n        }\r\n    }\r\n    visitLiteralExpr(ast, ctx) {\r\n        const value = ast.value;\r\n        if (value == null && ast.type != INFERRED_TYPE) {\r\n            ctx.print(ast, `(${value} as any)`);\r\n            return null;\r\n        }\r\n        return super.visitLiteralExpr(ast, ctx);\r\n    }\r\n    // Temporary workaround to support strictNullCheck enabled consumers of ngc emit.\r\n    // In SNC mode, [] have the type never[], so we cast here to any[].\r\n    // TODO: narrow the cast to a more explicit type, or use a pattern that does not\r\n    // start with [].concat. see https://github.com/angular/angular/pull/11846\r\n    visitLiteralArrayExpr(ast, ctx) {\r\n        if (ast.entries.length === 0) {\r\n            ctx.print(ast, '(');\r\n        }\r\n        const result = super.visitLiteralArrayExpr(ast, ctx);\r\n        if (ast.entries.length === 0) {\r\n            ctx.print(ast, ' as any[])');\r\n        }\r\n        return result;\r\n    }\r\n    visitExternalExpr(ast, ctx) {\r\n        this._visitIdentifier(ast.value, ast.typeParams, ctx);\r\n        return null;\r\n    }\r\n    visitAssertNotNullExpr(ast, ctx) {\r\n        const result = super.visitAssertNotNullExpr(ast, ctx);\r\n        ctx.print(ast, '!');\r\n        return result;\r\n    }\r\n    visitDeclareVarStmt(stmt, ctx) {\r\n        if (stmt.hasModifier(StmtModifier.Exported) && stmt.value instanceof ExternalExpr &&\r\n            !stmt.type) {\r\n            // check for a reexport\r\n            const { name, moduleName } = stmt.value.value;\r\n            if (moduleName) {\r\n                let reexports = this.reexports.get(moduleName);\r\n                if (!reexports) {\r\n                    reexports = [];\r\n                    this.reexports.set(moduleName, reexports);\r\n                }\r\n                reexports.push({ name: name, as: stmt.name });\r\n                return null;\r\n            }\r\n        }\r\n        if (stmt.hasModifier(StmtModifier.Exported)) {\r\n            ctx.print(stmt, `export `);\r\n        }\r\n        if (stmt.hasModifier(StmtModifier.Final)) {\r\n            ctx.print(stmt, `const`);\r\n        }\r\n        else {\r\n            ctx.print(stmt, `var`);\r\n        }\r\n        ctx.print(stmt, ` ${stmt.name}`);\r\n        this._printColonType(stmt.type, ctx);\r\n        if (stmt.value) {\r\n            ctx.print(stmt, ` = `);\r\n            stmt.value.visitExpression(this, ctx);\r\n        }\r\n        ctx.println(stmt, `;`);\r\n        return null;\r\n    }\r\n    visitWrappedNodeExpr(ast, ctx) {\r\n        throw new Error('Cannot visit a WrappedNodeExpr when outputting Typescript.');\r\n    }\r\n    visitCastExpr(ast, ctx) {\r\n        ctx.print(ast, `(<`);\r\n        ast.type.visitType(this, ctx);\r\n        ctx.print(ast, `>`);\r\n        ast.value.visitExpression(this, ctx);\r\n        ctx.print(ast, `)`);\r\n        return null;\r\n    }\r\n    visitInstantiateExpr(ast, ctx) {\r\n        ctx.print(ast, `new `);\r\n        this.typeExpression++;\r\n        ast.classExpr.visitExpression(this, ctx);\r\n        this.typeExpression--;\r\n        ctx.print(ast, `(`);\r\n        this.visitAllExpressions(ast.args, ctx, ',');\r\n        ctx.print(ast, `)`);\r\n        return null;\r\n    }\r\n    visitDeclareClassStmt(stmt, ctx) {\r\n        ctx.pushClass(stmt);\r\n        if (stmt.hasModifier(StmtModifier.Exported)) {\r\n            ctx.print(stmt, `export `);\r\n        }\r\n        ctx.print(stmt, `class ${stmt.name}`);\r\n        if (stmt.parent != null) {\r\n            ctx.print(stmt, ` extends `);\r\n            this.typeExpression++;\r\n            stmt.parent.visitExpression(this, ctx);\r\n            this.typeExpression--;\r\n        }\r\n        ctx.println(stmt, ` {`);\r\n        ctx.incIndent();\r\n        stmt.fields.forEach((field) => this._visitClassField(field, ctx));\r\n        if (stmt.constructorMethod != null) {\r\n            this._visitClassConstructor(stmt, ctx);\r\n        }\r\n        stmt.getters.forEach((getter) => this._visitClassGetter(getter, ctx));\r\n        stmt.methods.forEach((method) => this._visitClassMethod(method, ctx));\r\n        ctx.decIndent();\r\n        ctx.println(stmt, `}`);\r\n        ctx.popClass();\r\n        return null;\r\n    }\r\n    _visitClassField(field, ctx) {\r\n        if (field.hasModifier(StmtModifier.Private)) {\r\n            // comment out as a workaround for #10967\r\n            ctx.print(null, `/*private*/ `);\r\n        }\r\n        if (field.hasModifier(StmtModifier.Static)) {\r\n            ctx.print(null, 'static ');\r\n        }\r\n        ctx.print(null, field.name);\r\n        this._printColonType(field.type, ctx);\r\n        if (field.initializer) {\r\n            ctx.print(null, ' = ');\r\n            field.initializer.visitExpression(this, ctx);\r\n        }\r\n        ctx.println(null, `;`);\r\n    }\r\n    _visitClassGetter(getter, ctx) {\r\n        if (getter.hasModifier(StmtModifier.Private)) {\r\n            ctx.print(null, `private `);\r\n        }\r\n        ctx.print(null, `get ${getter.name}()`);\r\n        this._printColonType(getter.type, ctx);\r\n        ctx.println(null, ` {`);\r\n        ctx.incIndent();\r\n        this.visitAllStatements(getter.body, ctx);\r\n        ctx.decIndent();\r\n        ctx.println(null, `}`);\r\n    }\r\n    _visitClassConstructor(stmt, ctx) {\r\n        ctx.print(stmt, `constructor(`);\r\n        this._visitParams(stmt.constructorMethod.params, ctx);\r\n        ctx.println(stmt, `) {`);\r\n        ctx.incIndent();\r\n        this.visitAllStatements(stmt.constructorMethod.body, ctx);\r\n        ctx.decIndent();\r\n        ctx.println(stmt, `}`);\r\n    }\r\n    _visitClassMethod(method, ctx) {\r\n        if (method.hasModifier(StmtModifier.Private)) {\r\n            ctx.print(null, `private `);\r\n        }\r\n        ctx.print(null, `${method.name}(`);\r\n        this._visitParams(method.params, ctx);\r\n        ctx.print(null, `)`);\r\n        this._printColonType(method.type, ctx, 'void');\r\n        ctx.println(null, ` {`);\r\n        ctx.incIndent();\r\n        this.visitAllStatements(method.body, ctx);\r\n        ctx.decIndent();\r\n        ctx.println(null, `}`);\r\n    }\r\n    visitFunctionExpr(ast, ctx) {\r\n        if (ast.name) {\r\n            ctx.print(ast, 'function ');\r\n            ctx.print(ast, ast.name);\r\n        }\r\n        ctx.print(ast, `(`);\r\n        this._visitParams(ast.params, ctx);\r\n        ctx.print(ast, `)`);\r\n        this._printColonType(ast.type, ctx, 'void');\r\n        if (!ast.name) {\r\n            ctx.print(ast, ` => `);\r\n        }\r\n        ctx.println(ast, '{');\r\n        ctx.incIndent();\r\n        this.visitAllStatements(ast.statements, ctx);\r\n        ctx.decIndent();\r\n        ctx.print(ast, `}`);\r\n        return null;\r\n    }\r\n    visitDeclareFunctionStmt(stmt, ctx) {\r\n        if (stmt.hasModifier(StmtModifier.Exported)) {\r\n            ctx.print(stmt, `export `);\r\n        }\r\n        ctx.print(stmt, `function ${stmt.name}(`);\r\n        this._visitParams(stmt.params, ctx);\r\n        ctx.print(stmt, `)`);\r\n        this._printColonType(stmt.type, ctx, 'void');\r\n        ctx.println(stmt, ` {`);\r\n        ctx.incIndent();\r\n        this.visitAllStatements(stmt.statements, ctx);\r\n        ctx.decIndent();\r\n        ctx.println(stmt, `}`);\r\n        return null;\r\n    }\r\n    visitTryCatchStmt(stmt, ctx) {\r\n        ctx.println(stmt, `try {`);\r\n        ctx.incIndent();\r\n        this.visitAllStatements(stmt.bodyStmts, ctx);\r\n        ctx.decIndent();\r\n        ctx.println(stmt, `} catch (${CATCH_ERROR_VAR$1.name}) {`);\r\n        ctx.incIndent();\r\n        const catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack', null)).toDeclStmt(null, [\r\n                StmtModifier.Final\r\n            ])].concat(stmt.catchStmts);\r\n        this.visitAllStatements(catchStmts, ctx);\r\n        ctx.decIndent();\r\n        ctx.println(stmt, `}`);\r\n        return null;\r\n    }\r\n    visitBuiltinType(type, ctx) {\r\n        let typeStr;\r\n        switch (type.name) {\r\n            case BuiltinTypeName.Bool:\r\n                typeStr = 'boolean';\r\n                break;\r\n            case BuiltinTypeName.Dynamic:\r\n                typeStr = 'any';\r\n                break;\r\n            case BuiltinTypeName.Function:\r\n                typeStr = 'Function';\r\n                break;\r\n            case BuiltinTypeName.Number:\r\n                typeStr = 'number';\r\n                break;\r\n            case BuiltinTypeName.Int:\r\n                typeStr = 'number';\r\n                break;\r\n            case BuiltinTypeName.String:\r\n                typeStr = 'string';\r\n                break;\r\n            case BuiltinTypeName.None:\r\n                typeStr = 'never';\r\n                break;\r\n            default:\r\n                throw new Error(`Unsupported builtin type ${type.name}`);\r\n        }\r\n        ctx.print(null, typeStr);\r\n        return null;\r\n    }\r\n    visitExpressionType(ast, ctx) {\r\n        ast.value.visitExpression(this, ctx);\r\n        if (ast.typeParams !== null) {\r\n            ctx.print(null, '<');\r\n            this.visitAllObjects(type => this.visitType(type, ctx), ast.typeParams, ctx, ',');\r\n            ctx.print(null, '>');\r\n        }\r\n        return null;\r\n    }\r\n    visitArrayType(type, ctx) {\r\n        this.visitType(type.of, ctx);\r\n        ctx.print(null, `[]`);\r\n        return null;\r\n    }\r\n    visitMapType(type, ctx) {\r\n        ctx.print(null, `{[key: string]:`);\r\n        this.visitType(type.valueType, ctx);\r\n        ctx.print(null, `}`);\r\n        return null;\r\n    }\r\n    getBuiltinMethodName(method) {\r\n        let name;\r\n        switch (method) {\r\n            case BuiltinMethod.ConcatArray:\r\n                name = 'concat';\r\n                break;\r\n            case BuiltinMethod.SubscribeObservable:\r\n                name = 'subscribe';\r\n                break;\r\n            case BuiltinMethod.Bind:\r\n                name = 'bind';\r\n                break;\r\n            default:\r\n                throw new Error(`Unknown builtin method: ${method}`);\r\n        }\r\n        return name;\r\n    }\r\n    _visitParams(params, ctx) {\r\n        this.visitAllObjects(param => {\r\n            ctx.print(null, param.name);\r\n            this._printColonType(param.type, ctx);\r\n        }, params, ctx, ',');\r\n    }\r\n    _visitIdentifier(value, typeParams, ctx) {\r\n        const { name, moduleName } = value;\r\n        if (this.referenceFilter && this.referenceFilter(value)) {\r\n            ctx.print(null, '(null as any)');\r\n            return;\r\n        }\r\n        if (moduleName && (!this.importFilter || !this.importFilter(value))) {\r\n            let prefix = this.importsWithPrefixes.get(moduleName);\r\n            if (prefix == null) {\r\n                prefix = `i${this.importsWithPrefixes.size}`;\r\n                this.importsWithPrefixes.set(moduleName, prefix);\r\n            }\r\n            ctx.print(null, `${prefix}.`);\r\n        }\r\n        ctx.print(null, name);\r\n        if (this.typeExpression > 0) {\r\n            // If we are in a type expression that refers to a generic type then supply\r\n            // the required type parameters. If there were not enough type parameters\r\n            // supplied, supply any as the type. Outside a type expression the reference\r\n            // should not supply type parameters and be treated as a simple value reference\r\n            // to the constructor function itself.\r\n            const suppliedParameters = typeParams || [];\r\n            if (suppliedParameters.length > 0) {\r\n                ctx.print(null, `<`);\r\n                this.visitAllObjects(type => type.visitType(this, ctx), typeParams, ctx, ',');\r\n                ctx.print(null, `>`);\r\n            }\r\n        }\r\n    }\r\n    _printColonType(type, ctx, defaultType) {\r\n        if (type !== INFERRED_TYPE) {\r\n            ctx.print(null, ':');\r\n            this.visitType(type, ctx, defaultType);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Resolve a `Type` for {@link Pipe}.\r\n *\r\n * This interface can be overridden by the application developer to create custom behavior.\r\n *\r\n * See {@link Compiler}\r\n */\r\nclass PipeResolver {\r\n    constructor(_reflector) {\r\n        this._reflector = _reflector;\r\n    }\r\n    isPipe(type) {\r\n        const typeMetadata = this._reflector.annotations(resolveForwardRef(type));\r\n        return typeMetadata && typeMetadata.some(createPipe.isTypeOf);\r\n    }\r\n    /**\r\n     * Return {@link Pipe} for a given `Type`.\r\n     */\r\n    resolve(type, throwIfNotFound = true) {\r\n        const metas = this._reflector.annotations(resolveForwardRef(type));\r\n        if (metas) {\r\n            const annotation = findLast(metas, createPipe.isTypeOf);\r\n            if (annotation) {\r\n                return annotation;\r\n            }\r\n        }\r\n        if (throwIfNotFound) {\r\n            throw new Error(`No Pipe decorator found on ${stringify(type)}`);\r\n        }\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Generates code that is used to type check templates.\r\n */\r\nclass TypeCheckCompiler {\r\n    constructor(options, reflector) {\r\n        this.options = options;\r\n        this.reflector = reflector;\r\n    }\r\n    /**\r\n     * Important notes:\r\n     * - This must not produce new `import` statements, but only refer to types outside\r\n     *   of the file via the variables provided via externalReferenceVars.\r\n     *   This allows Typescript to reuse the old program's structure as no imports have changed.\r\n     * - This must not produce any exports, as this would pollute the .d.ts file\r\n     *   and also violate the point above.\r\n     */\r\n    compileComponent(componentId, component, template, usedPipes, externalReferenceVars, ctx) {\r\n        const pipes = new Map();\r\n        usedPipes.forEach(p => pipes.set(p.name, p.type.reference));\r\n        let embeddedViewCount = 0;\r\n        const viewBuilderFactory = (parent, guards) => {\r\n            const embeddedViewIndex = embeddedViewCount++;\r\n            return new ViewBuilder(this.options, this.reflector, externalReferenceVars, parent, component.type.reference, component.isHost, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory);\r\n        };\r\n        const visitor = viewBuilderFactory(null, []);\r\n        visitor.visitAll([], template);\r\n        return visitor.build(componentId);\r\n    }\r\n}\r\nconst DYNAMIC_VAR_NAME = '_any';\r\nclass TypeCheckLocalResolver {\r\n    notifyImplicitReceiverUse() { }\r\n    maybeRestoreView() { }\r\n    getLocal(name) {\r\n        if (name === EventHandlerVars.event.name) {\r\n            // References to the event should not be type-checked.\r\n            // TODO(chuckj): determine a better type for the event.\r\n            return variable(DYNAMIC_VAR_NAME);\r\n        }\r\n        return null;\r\n    }\r\n}\r\nconst defaultResolver = new TypeCheckLocalResolver();\r\nclass ViewBuilder {\r\n    constructor(options, reflector, externalReferenceVars, parent, component, isHostComponent, embeddedViewIndex, pipes, guards, ctx, viewBuilderFactory) {\r\n        this.options = options;\r\n        this.reflector = reflector;\r\n        this.externalReferenceVars = externalReferenceVars;\r\n        this.parent = parent;\r\n        this.component = component;\r\n        this.isHostComponent = isHostComponent;\r\n        this.embeddedViewIndex = embeddedViewIndex;\r\n        this.pipes = pipes;\r\n        this.guards = guards;\r\n        this.ctx = ctx;\r\n        this.viewBuilderFactory = viewBuilderFactory;\r\n        this.refOutputVars = new Map();\r\n        this.variables = [];\r\n        this.children = [];\r\n        this.updates = [];\r\n        this.actions = [];\r\n    }\r\n    getOutputVar(type) {\r\n        let varName;\r\n        if (type === this.component && this.isHostComponent) {\r\n            varName = DYNAMIC_VAR_NAME;\r\n        }\r\n        else if (type instanceof StaticSymbol) {\r\n            varName = this.externalReferenceVars.get(type);\r\n        }\r\n        else {\r\n            varName = DYNAMIC_VAR_NAME;\r\n        }\r\n        if (!varName) {\r\n            throw new Error(`Illegal State: referring to a type without a variable ${JSON.stringify(type)}`);\r\n        }\r\n        return varName;\r\n    }\r\n    getTypeGuardExpressions(ast) {\r\n        const result = [...this.guards];\r\n        for (let directive of ast.directives) {\r\n            for (let input of directive.inputs) {\r\n                const guard = directive.directive.guards[input.directiveName];\r\n                if (guard) {\r\n                    const useIf = guard === 'UseIf';\r\n                    result.push({\r\n                        guard,\r\n                        useIf,\r\n                        expression: {\r\n                            context: this.component,\r\n                            value: input.value,\r\n                            sourceSpan: input.sourceSpan,\r\n                        },\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    visitAll(variables, astNodes) {\r\n        this.variables = variables;\r\n        templateVisitAll(this, astNodes);\r\n    }\r\n    build(componentId, targetStatements = []) {\r\n        this.children.forEach((child) => child.build(componentId, targetStatements));\r\n        let viewStmts = [variable(DYNAMIC_VAR_NAME).set(NULL_EXPR).toDeclStmt(DYNAMIC_TYPE)];\r\n        let bindingCount = 0;\r\n        this.updates.forEach((expression) => {\r\n            const { sourceSpan, context, value } = this.preprocessUpdateExpression(expression);\r\n            const bindingId = `${bindingCount++}`;\r\n            const nameResolver = context === this.component ? this : defaultResolver;\r\n            const { stmts, currValExpr } = convertPropertyBinding(nameResolver, variable(this.getOutputVar(context)), value, bindingId, BindingForm.General);\r\n            stmts.push(new ExpressionStatement(currValExpr));\r\n            viewStmts.push(...stmts.map((stmt) => applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\r\n        });\r\n        this.actions.forEach(({ sourceSpan, context, value }) => {\r\n            const bindingId = `${bindingCount++}`;\r\n            const nameResolver = context === this.component ? this : defaultResolver;\r\n            const { stmts } = convertActionBinding(nameResolver, variable(this.getOutputVar(context)), value, bindingId);\r\n            viewStmts.push(...stmts.map((stmt) => applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\r\n        });\r\n        if (this.guards.length) {\r\n            let guardExpression = undefined;\r\n            for (const guard of this.guards) {\r\n                const { context, value } = this.preprocessUpdateExpression(guard.expression);\r\n                const bindingId = `${bindingCount++}`;\r\n                const nameResolver = context === this.component ? this : defaultResolver;\r\n                // We only support support simple expressions and ignore others as they\r\n                // are unlikely to affect type narrowing.\r\n                const { stmts, currValExpr } = convertPropertyBinding(nameResolver, variable(this.getOutputVar(context)), value, bindingId, BindingForm.TrySimple);\r\n                if (stmts.length == 0) {\r\n                    const guardClause = guard.useIf ? currValExpr : this.ctx.importExpr(guard.guard).callFn([currValExpr]);\r\n                    guardExpression = guardExpression ? guardExpression.and(guardClause) : guardClause;\r\n                }\r\n            }\r\n            if (guardExpression) {\r\n                viewStmts = [new IfStmt(guardExpression, viewStmts)];\r\n            }\r\n        }\r\n        const viewName = `_View_${componentId}_${this.embeddedViewIndex}`;\r\n        const viewFactory = new DeclareFunctionStmt(viewName, [], viewStmts);\r\n        targetStatements.push(viewFactory);\r\n        return targetStatements;\r\n    }\r\n    visitBoundText(ast, context) {\r\n        const astWithSource = ast.value;\r\n        const inter = astWithSource.ast;\r\n        inter.expressions.forEach((expr) => this.updates.push({ context: this.component, value: expr, sourceSpan: ast.sourceSpan }));\r\n    }\r\n    visitEmbeddedTemplate(ast, context) {\r\n        this.visitElementOrTemplate(ast);\r\n        // Note: The old view compiler used to use an `any` type\r\n        // for the context in any embedded view.\r\n        // We keep this behaivor behind a flag for now.\r\n        if (this.options.fullTemplateTypeCheck) {\r\n            // Find any applicable type guards. For example, NgIf has a type guard on ngIf\r\n            // (see NgIf.ngIfTypeGuard) that can be used to indicate that a template is only\r\n            // stamped out if ngIf is truthy so any bindings in the template can assume that,\r\n            // if a nullable type is used for ngIf, that expression is not null or undefined.\r\n            const guards = this.getTypeGuardExpressions(ast);\r\n            const childVisitor = this.viewBuilderFactory(this, guards);\r\n            this.children.push(childVisitor);\r\n            childVisitor.visitAll(ast.variables, ast.children);\r\n        }\r\n    }\r\n    visitElement(ast, context) {\r\n        this.visitElementOrTemplate(ast);\r\n        let inputDefs = [];\r\n        let updateRendererExpressions = [];\r\n        let outputDefs = [];\r\n        ast.inputs.forEach((inputAst) => {\r\n            this.updates.push({ context: this.component, value: inputAst.value, sourceSpan: inputAst.sourceSpan });\r\n        });\r\n        templateVisitAll(this, ast.children);\r\n    }\r\n    visitElementOrTemplate(ast) {\r\n        ast.directives.forEach((dirAst) => {\r\n            this.visitDirective(dirAst);\r\n        });\r\n        ast.references.forEach((ref) => {\r\n            let outputVarType = null;\r\n            // Note: The old view compiler used to use an `any` type\r\n            // for directives exposed via `exportAs`.\r\n            // We keep this behaivor behind a flag for now.\r\n            if (ref.value && ref.value.identifier && this.options.fullTemplateTypeCheck) {\r\n                outputVarType = ref.value.identifier.reference;\r\n            }\r\n            else {\r\n                outputVarType = BuiltinTypeName.Dynamic;\r\n            }\r\n            this.refOutputVars.set(ref.name, outputVarType);\r\n        });\r\n        ast.outputs.forEach((outputAst) => {\r\n            this.actions.push({ context: this.component, value: outputAst.handler, sourceSpan: outputAst.sourceSpan });\r\n        });\r\n    }\r\n    visitDirective(dirAst) {\r\n        const dirType = dirAst.directive.type.reference;\r\n        dirAst.inputs.forEach((input) => this.updates.push({ context: this.component, value: input.value, sourceSpan: input.sourceSpan }));\r\n        // Note: The old view compiler used to use an `any` type\r\n        // for expressions in host properties / events.\r\n        // We keep this behaivor behind a flag for now.\r\n        if (this.options.fullTemplateTypeCheck) {\r\n            dirAst.hostProperties.forEach((inputAst) => this.updates.push({ context: dirType, value: inputAst.value, sourceSpan: inputAst.sourceSpan }));\r\n            dirAst.hostEvents.forEach((hostEventAst) => this.actions.push({\r\n                context: dirType,\r\n                value: hostEventAst.handler,\r\n                sourceSpan: hostEventAst.sourceSpan\r\n            }));\r\n        }\r\n    }\r\n    notifyImplicitReceiverUse() { }\r\n    maybeRestoreView() { }\r\n    getLocal(name) {\r\n        if (name == EventHandlerVars.event.name) {\r\n            return variable(this.getOutputVar(BuiltinTypeName.Dynamic));\r\n        }\r\n        for (let currBuilder = this; currBuilder; currBuilder = currBuilder.parent) {\r\n            let outputVarType;\r\n            // check references\r\n            outputVarType = currBuilder.refOutputVars.get(name);\r\n            if (outputVarType == null) {\r\n                // check variables\r\n                const varAst = currBuilder.variables.find((varAst) => varAst.name === name);\r\n                if (varAst) {\r\n                    outputVarType = BuiltinTypeName.Dynamic;\r\n                }\r\n            }\r\n            if (outputVarType != null) {\r\n                return variable(this.getOutputVar(outputVarType));\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    pipeOutputVar(name) {\r\n        const pipe = this.pipes.get(name);\r\n        if (!pipe) {\r\n            throw new Error(`Illegal State: Could not find pipe ${name} in template of ${this.component}`);\r\n        }\r\n        return this.getOutputVar(pipe);\r\n    }\r\n    preprocessUpdateExpression(expression) {\r\n        return {\r\n            sourceSpan: expression.sourceSpan,\r\n            context: expression.context,\r\n            value: convertPropertyBindingBuiltins({\r\n                createLiteralArrayConverter: (argCount) => (args) => {\r\n                    const arr = literalArr(args);\r\n                    // Note: The old view compiler used to use an `any` type\r\n                    // for arrays.\r\n                    return this.options.fullTemplateTypeCheck ? arr : arr.cast(DYNAMIC_TYPE);\r\n                },\r\n                createLiteralMapConverter: (keys) => (values) => {\r\n                    const entries = keys.map((k, i) => ({\r\n                        key: k.key,\r\n                        value: values[i],\r\n                        quoted: k.quoted,\r\n                    }));\r\n                    const map = literalMap(entries);\r\n                    // Note: The old view compiler used to use an `any` type\r\n                    // for maps.\r\n                    return this.options.fullTemplateTypeCheck ? map : map.cast(DYNAMIC_TYPE);\r\n                },\r\n                createPipeConverter: (name, argCount) => (args) => {\r\n                    // Note: The old view compiler used to use an `any` type\r\n                    // for pipes.\r\n                    const pipeExpr = this.options.fullTemplateTypeCheck ?\r\n                        variable(this.pipeOutputVar(name)) :\r\n                        variable(this.getOutputVar(BuiltinTypeName.Dynamic));\r\n                    return pipeExpr.callMethod('transform', args);\r\n                },\r\n            }, expression.value)\r\n        };\r\n    }\r\n    visitNgContent(ast, context) { }\r\n    visitText(ast, context) { }\r\n    visitDirectiveProperty(ast, context) { }\r\n    visitReference(ast, context) { }\r\n    visitVariable(ast, context) { }\r\n    visitEvent(ast, context) { }\r\n    visitElementProperty(ast, context) { }\r\n    visitAttr(ast, context) { }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst CLASS_ATTR$1 = 'class';\r\nconst STYLE_ATTR = 'style';\r\nconst IMPLICIT_TEMPLATE_VAR = '\\$implicit';\r\nclass ViewCompileResult {\r\n    constructor(viewClassVar, rendererTypeVar) {\r\n        this.viewClassVar = viewClassVar;\r\n        this.rendererTypeVar = rendererTypeVar;\r\n    }\r\n}\r\nclass ViewCompiler {\r\n    constructor(_reflector) {\r\n        this._reflector = _reflector;\r\n    }\r\n    compileComponent(outputCtx, component, template, styles, usedPipes) {\r\n        let embeddedViewCount = 0;\r\n        let renderComponentVarName = undefined;\r\n        if (!component.isHost) {\r\n            const template = component.template;\r\n            const customRenderData = [];\r\n            if (template.animations && template.animations.length) {\r\n                customRenderData.push(new LiteralMapEntry('animation', convertValueToOutputAst(outputCtx, template.animations), true));\r\n            }\r\n            const renderComponentVar = variable(rendererTypeName(component.type.reference));\r\n            renderComponentVarName = renderComponentVar.name;\r\n            outputCtx.statements.push(renderComponentVar\r\n                .set(importExpr(Identifiers$1.createRendererType2).callFn([new LiteralMapExpr([\r\n                    new LiteralMapEntry('encapsulation', literal(template.encapsulation), false),\r\n                    new LiteralMapEntry('styles', styles, false),\r\n                    new LiteralMapEntry('data', new LiteralMapExpr(customRenderData), false)\r\n                ])]))\r\n                .toDeclStmt(importType(Identifiers$1.RendererType2), [StmtModifier.Final, StmtModifier.Exported]));\r\n        }\r\n        const viewBuilderFactory = (parent) => {\r\n            const embeddedViewIndex = embeddedViewCount++;\r\n            return new ViewBuilder$1(this._reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, viewBuilderFactory);\r\n        };\r\n        const visitor = viewBuilderFactory(null);\r\n        visitor.visitAll([], template);\r\n        outputCtx.statements.push(...visitor.build());\r\n        return new ViewCompileResult(visitor.viewName, renderComponentVarName);\r\n    }\r\n}\r\nconst LOG_VAR$1 = variable('_l');\r\nconst VIEW_VAR = variable('_v');\r\nconst CHECK_VAR = variable('_ck');\r\nconst COMP_VAR = variable('_co');\r\nconst EVENT_NAME_VAR = variable('en');\r\nconst ALLOW_DEFAULT_VAR = variable(`ad`);\r\nclass ViewBuilder$1 {\r\n    constructor(reflector, outputCtx, parent, component, embeddedViewIndex, usedPipes, viewBuilderFactory) {\r\n        this.reflector = reflector;\r\n        this.outputCtx = outputCtx;\r\n        this.parent = parent;\r\n        this.component = component;\r\n        this.embeddedViewIndex = embeddedViewIndex;\r\n        this.usedPipes = usedPipes;\r\n        this.viewBuilderFactory = viewBuilderFactory;\r\n        this.nodes = [];\r\n        this.purePipeNodeIndices = Object.create(null);\r\n        // Need Object.create so that we don't have builtin values...\r\n        this.refNodeIndices = Object.create(null);\r\n        this.variables = [];\r\n        this.children = [];\r\n        // TODO(tbosch): The old view compiler used to use an `any` type\r\n        // for the context in any embedded view. We keep this behaivor for now\r\n        // to be able to introduce the new view compiler without too many errors.\r\n        this.compType = this.embeddedViewIndex > 0 ?\r\n            DYNAMIC_TYPE :\r\n            expressionType(outputCtx.importExpr(this.component.type.reference));\r\n        this.viewName = viewClassName(this.component.type.reference, this.embeddedViewIndex);\r\n    }\r\n    visitAll(variables, astNodes) {\r\n        this.variables = variables;\r\n        // create the pipes for the pure pipes immediately, so that we know their indices.\r\n        if (!this.parent) {\r\n            this.usedPipes.forEach((pipe) => {\r\n                if (pipe.pure) {\r\n                    this.purePipeNodeIndices[pipe.name] = this._createPipe(null, pipe);\r\n                }\r\n            });\r\n        }\r\n        if (!this.parent) {\r\n            this.component.viewQueries.forEach((query, queryIndex) => {\r\n                // Note: queries start with id 1 so we can use the number in a Bloom filter!\r\n                const queryId = queryIndex + 1;\r\n                const bindingType = query.first ? 0 /* First */ : 1 /* All */;\r\n                const flags = 134217728 /* TypeViewQuery */ | calcQueryFlags(query);\r\n                this.nodes.push(() => ({\r\n                    sourceSpan: null,\r\n                    nodeFlags: flags,\r\n                    nodeDef: importExpr(Identifiers$1.queryDef).callFn([\r\n                        literal(flags), literal(queryId),\r\n                        new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType), false)])\r\n                    ])\r\n                }));\r\n            });\r\n        }\r\n        templateVisitAll(this, astNodes);\r\n        if (this.parent && (astNodes.length === 0 || needsAdditionalRootNode(astNodes))) {\r\n            // if the view is an embedded view, then we need to add an additional root node in some cases\r\n            this.nodes.push(() => ({\r\n                sourceSpan: null,\r\n                nodeFlags: 1 /* TypeElement */,\r\n                nodeDef: importExpr(Identifiers$1.anchorDef).callFn([\r\n                    literal(0 /* None */), NULL_EXPR, NULL_EXPR, literal(0)\r\n                ])\r\n            }));\r\n        }\r\n    }\r\n    build(targetStatements = []) {\r\n        this.children.forEach((child) => child.build(targetStatements));\r\n        const { updateRendererStmts, updateDirectivesStmts, nodeDefExprs } = this._createNodeExpressions();\r\n        const updateRendererFn = this._createUpdateFn(updateRendererStmts);\r\n        const updateDirectivesFn = this._createUpdateFn(updateDirectivesStmts);\r\n        let viewFlags = 0 /* None */;\r\n        if (!this.parent && this.component.changeDetection === ChangeDetectionStrategy.OnPush) {\r\n            viewFlags |= 2 /* OnPush */;\r\n        }\r\n        const viewFactory = new DeclareFunctionStmt(this.viewName, [new FnParam(LOG_VAR$1.name)], [new ReturnStatement(importExpr(Identifiers$1.viewDef).callFn([\r\n                literal(viewFlags),\r\n                literalArr(nodeDefExprs),\r\n                updateDirectivesFn,\r\n                updateRendererFn,\r\n            ]))], importType(Identifiers$1.ViewDefinition), this.embeddedViewIndex === 0 ? [StmtModifier.Exported] : []);\r\n        targetStatements.push(viewFactory);\r\n        return targetStatements;\r\n    }\r\n    _createUpdateFn(updateStmts) {\r\n        let updateFn;\r\n        if (updateStmts.length > 0) {\r\n            const preStmts = [];\r\n            if (!this.component.isHost && findReadVarNames(updateStmts).has(COMP_VAR.name)) {\r\n                preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\r\n            }\r\n            updateFn = fn([\r\n                new FnParam(CHECK_VAR.name, INFERRED_TYPE),\r\n                new FnParam(VIEW_VAR.name, INFERRED_TYPE)\r\n            ], [...preStmts, ...updateStmts], INFERRED_TYPE);\r\n        }\r\n        else {\r\n            updateFn = NULL_EXPR;\r\n        }\r\n        return updateFn;\r\n    }\r\n    visitNgContent(ast, context) {\r\n        // ngContentDef(ngContentIndex: number, index: number): NodeDef;\r\n        this.nodes.push(() => ({\r\n            sourceSpan: ast.sourceSpan,\r\n            nodeFlags: 8 /* TypeNgContent */,\r\n            nodeDef: importExpr(Identifiers$1.ngContentDef)\r\n                .callFn([literal(ast.ngContentIndex), literal(ast.index)])\r\n        }));\r\n    }\r\n    visitText(ast, context) {\r\n        // Static text nodes have no check function\r\n        const checkIndex = -1;\r\n        this.nodes.push(() => ({\r\n            sourceSpan: ast.sourceSpan,\r\n            nodeFlags: 2 /* TypeText */,\r\n            nodeDef: importExpr(Identifiers$1.textDef).callFn([\r\n                literal(checkIndex),\r\n                literal(ast.ngContentIndex),\r\n                literalArr([literal(ast.value)]),\r\n            ])\r\n        }));\r\n    }\r\n    visitBoundText(ast, context) {\r\n        const nodeIndex = this.nodes.length;\r\n        // reserve the space in the nodeDefs array\r\n        this.nodes.push(null);\r\n        const astWithSource = ast.value;\r\n        const inter = astWithSource.ast;\r\n        const updateRendererExpressions = inter.expressions.map((expr, bindingIndex) => this._preprocessUpdateExpression({ nodeIndex, bindingIndex, sourceSpan: ast.sourceSpan, context: COMP_VAR, value: expr }));\r\n        // Check index is the same as the node index during compilation\r\n        // They might only differ at runtime\r\n        const checkIndex = nodeIndex;\r\n        this.nodes[nodeIndex] = () => ({\r\n            sourceSpan: ast.sourceSpan,\r\n            nodeFlags: 2 /* TypeText */,\r\n            nodeDef: importExpr(Identifiers$1.textDef).callFn([\r\n                literal(checkIndex),\r\n                literal(ast.ngContentIndex),\r\n                literalArr(inter.strings.map(s => literal(s))),\r\n            ]),\r\n            updateRenderer: updateRendererExpressions\r\n        });\r\n    }\r\n    visitEmbeddedTemplate(ast, context) {\r\n        const nodeIndex = this.nodes.length;\r\n        // reserve the space in the nodeDefs array\r\n        this.nodes.push(null);\r\n        const { flags, queryMatchesExpr, hostEvents } = this._visitElementOrTemplate(nodeIndex, ast);\r\n        const childVisitor = this.viewBuilderFactory(this);\r\n        this.children.push(childVisitor);\r\n        childVisitor.visitAll(ast.variables, ast.children);\r\n        const childCount = this.nodes.length - nodeIndex - 1;\r\n        // anchorDef(\r\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], ngContentIndex: number,\r\n        //   childCount: number, handleEventFn?: ElementHandleEventFn, templateFactory?:\r\n        //   ViewDefinitionFactory): NodeDef;\r\n        this.nodes[nodeIndex] = () => ({\r\n            sourceSpan: ast.sourceSpan,\r\n            nodeFlags: 1 /* TypeElement */ | flags,\r\n            nodeDef: importExpr(Identifiers$1.anchorDef).callFn([\r\n                literal(flags),\r\n                queryMatchesExpr,\r\n                literal(ast.ngContentIndex),\r\n                literal(childCount),\r\n                this._createElementHandleEventFn(nodeIndex, hostEvents),\r\n                variable(childVisitor.viewName),\r\n            ])\r\n        });\r\n    }\r\n    visitElement(ast, context) {\r\n        const nodeIndex = this.nodes.length;\r\n        // reserve the space in the nodeDefs array so we can add children\r\n        this.nodes.push(null);\r\n        // Using a null element name creates an anchor.\r\n        const elName = isNgContainer(ast.name) ? null : ast.name;\r\n        const { flags, usedEvents, queryMatchesExpr, hostBindings: dirHostBindings, hostEvents } = this._visitElementOrTemplate(nodeIndex, ast);\r\n        let inputDefs = [];\r\n        let updateRendererExpressions = [];\r\n        let outputDefs = [];\r\n        if (elName) {\r\n            const hostBindings = ast.inputs\r\n                .map((inputAst) => ({\r\n                context: COMP_VAR,\r\n                inputAst,\r\n                dirAst: null,\r\n            }))\r\n                .concat(dirHostBindings);\r\n            if (hostBindings.length) {\r\n                updateRendererExpressions =\r\n                    hostBindings.map((hostBinding, bindingIndex) => this._preprocessUpdateExpression({\r\n                        context: hostBinding.context,\r\n                        nodeIndex,\r\n                        bindingIndex,\r\n                        sourceSpan: hostBinding.inputAst.sourceSpan,\r\n                        value: hostBinding.inputAst.value\r\n                    }));\r\n                inputDefs = hostBindings.map(hostBinding => elementBindingDef(hostBinding.inputAst, hostBinding.dirAst));\r\n            }\r\n            outputDefs = usedEvents.map(([target, eventName]) => literalArr([literal(target), literal(eventName)]));\r\n        }\r\n        templateVisitAll(this, ast.children);\r\n        const childCount = this.nodes.length - nodeIndex - 1;\r\n        const compAst = ast.directives.find(dirAst => dirAst.directive.isComponent);\r\n        let compRendererType = NULL_EXPR;\r\n        let compView = NULL_EXPR;\r\n        if (compAst) {\r\n            compView = this.outputCtx.importExpr(compAst.directive.componentViewType);\r\n            compRendererType = this.outputCtx.importExpr(compAst.directive.rendererType);\r\n        }\r\n        // Check index is the same as the node index during compilation\r\n        // They might only differ at runtime\r\n        const checkIndex = nodeIndex;\r\n        this.nodes[nodeIndex] = () => ({\r\n            sourceSpan: ast.sourceSpan,\r\n            nodeFlags: 1 /* TypeElement */ | flags,\r\n            nodeDef: importExpr(Identifiers$1.elementDef).callFn([\r\n                literal(checkIndex),\r\n                literal(flags),\r\n                queryMatchesExpr,\r\n                literal(ast.ngContentIndex),\r\n                literal(childCount),\r\n                literal(elName),\r\n                elName ? fixedAttrsDef(ast) : NULL_EXPR,\r\n                inputDefs.length ? literalArr(inputDefs) : NULL_EXPR,\r\n                outputDefs.length ? literalArr(outputDefs) : NULL_EXPR,\r\n                this._createElementHandleEventFn(nodeIndex, hostEvents),\r\n                compView,\r\n                compRendererType,\r\n            ]),\r\n            updateRenderer: updateRendererExpressions\r\n        });\r\n    }\r\n    _visitElementOrTemplate(nodeIndex, ast) {\r\n        let flags = 0 /* None */;\r\n        if (ast.hasViewContainer) {\r\n            flags |= 16777216 /* EmbeddedViews */;\r\n        }\r\n        const usedEvents = new Map();\r\n        ast.outputs.forEach((event) => {\r\n            const { name, target } = elementEventNameAndTarget(event, null);\r\n            usedEvents.set(elementEventFullName(target, name), [target, name]);\r\n        });\r\n        ast.directives.forEach((dirAst) => {\r\n            dirAst.hostEvents.forEach((event) => {\r\n                const { name, target } = elementEventNameAndTarget(event, dirAst);\r\n                usedEvents.set(elementEventFullName(target, name), [target, name]);\r\n            });\r\n        });\r\n        const hostBindings = [];\r\n        const hostEvents = [];\r\n        this._visitComponentFactoryResolverProvider(ast.directives);\r\n        ast.providers.forEach(providerAst => {\r\n            let dirAst = undefined;\r\n            ast.directives.forEach(localDirAst => {\r\n                if (localDirAst.directive.type.reference === tokenReference(providerAst.token)) {\r\n                    dirAst = localDirAst;\r\n                }\r\n            });\r\n            if (dirAst) {\r\n                const { hostBindings: dirHostBindings, hostEvents: dirHostEvents } = this._visitDirective(providerAst, dirAst, ast.references, ast.queryMatches, usedEvents);\r\n                hostBindings.push(...dirHostBindings);\r\n                hostEvents.push(...dirHostEvents);\r\n            }\r\n            else {\r\n                this._visitProvider(providerAst, ast.queryMatches);\r\n            }\r\n        });\r\n        let queryMatchExprs = [];\r\n        ast.queryMatches.forEach((match) => {\r\n            let valueType = undefined;\r\n            if (tokenReference(match.value) ===\r\n                this.reflector.resolveExternalReference(Identifiers$1.ElementRef)) {\r\n                valueType = 0 /* ElementRef */;\r\n            }\r\n            else if (tokenReference(match.value) ===\r\n                this.reflector.resolveExternalReference(Identifiers$1.ViewContainerRef)) {\r\n                valueType = 3 /* ViewContainerRef */;\r\n            }\r\n            else if (tokenReference(match.value) ===\r\n                this.reflector.resolveExternalReference(Identifiers$1.TemplateRef)) {\r\n                valueType = 2 /* TemplateRef */;\r\n            }\r\n            if (valueType != null) {\r\n                queryMatchExprs.push(literalArr([literal(match.queryId), literal(valueType)]));\r\n            }\r\n        });\r\n        ast.references.forEach((ref) => {\r\n            let valueType = undefined;\r\n            if (!ref.value) {\r\n                valueType = 1 /* RenderElement */;\r\n            }\r\n            else if (tokenReference(ref.value) ===\r\n                this.reflector.resolveExternalReference(Identifiers$1.TemplateRef)) {\r\n                valueType = 2 /* TemplateRef */;\r\n            }\r\n            if (valueType != null) {\r\n                this.refNodeIndices[ref.name] = nodeIndex;\r\n                queryMatchExprs.push(literalArr([literal(ref.name), literal(valueType)]));\r\n            }\r\n        });\r\n        ast.outputs.forEach((outputAst) => {\r\n            hostEvents.push({ context: COMP_VAR, eventAst: outputAst, dirAst: null });\r\n        });\r\n        return {\r\n            flags,\r\n            usedEvents: Array.from(usedEvents.values()),\r\n            queryMatchesExpr: queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,\r\n            hostBindings,\r\n            hostEvents: hostEvents\r\n        };\r\n    }\r\n    _visitDirective(providerAst, dirAst, refs, queryMatches, usedEvents) {\r\n        const nodeIndex = this.nodes.length;\r\n        // reserve the space in the nodeDefs array so we can add children\r\n        this.nodes.push(null);\r\n        dirAst.directive.queries.forEach((query, queryIndex) => {\r\n            const queryId = dirAst.contentQueryStartId + queryIndex;\r\n            const flags = 67108864 /* TypeContentQuery */ | calcQueryFlags(query);\r\n            const bindingType = query.first ? 0 /* First */ : 1 /* All */;\r\n            this.nodes.push(() => ({\r\n                sourceSpan: dirAst.sourceSpan,\r\n                nodeFlags: flags,\r\n                nodeDef: importExpr(Identifiers$1.queryDef).callFn([\r\n                    literal(flags), literal(queryId),\r\n                    new LiteralMapExpr([new LiteralMapEntry(query.propertyName, literal(bindingType), false)])\r\n                ]),\r\n            }));\r\n        });\r\n        // Note: the operation below might also create new nodeDefs,\r\n        // but we don't want them to be a child of a directive,\r\n        // as they might be a provider/pipe on their own.\r\n        // I.e. we only allow queries as children of directives nodes.\r\n        const childCount = this.nodes.length - nodeIndex - 1;\r\n        let { flags, queryMatchExprs, providerExpr, depsExpr } = this._visitProviderOrDirective(providerAst, queryMatches);\r\n        refs.forEach((ref) => {\r\n            if (ref.value && tokenReference(ref.value) === tokenReference(providerAst.token)) {\r\n                this.refNodeIndices[ref.name] = nodeIndex;\r\n                queryMatchExprs.push(literalArr([literal(ref.name), literal(4 /* Provider */)]));\r\n            }\r\n        });\r\n        if (dirAst.directive.isComponent) {\r\n            flags |= 32768 /* Component */;\r\n        }\r\n        const inputDefs = dirAst.inputs.map((inputAst, inputIndex) => {\r\n            const mapValue = literalArr([literal(inputIndex), literal(inputAst.directiveName)]);\r\n            // Note: it's important to not quote the key so that we can capture renames by minifiers!\r\n            return new LiteralMapEntry(inputAst.directiveName, mapValue, false);\r\n        });\r\n        const outputDefs = [];\r\n        const dirMeta = dirAst.directive;\r\n        Object.keys(dirMeta.outputs).forEach((propName) => {\r\n            const eventName = dirMeta.outputs[propName];\r\n            if (usedEvents.has(eventName)) {\r\n                // Note: it's important to not quote the key so that we can capture renames by minifiers!\r\n                outputDefs.push(new LiteralMapEntry(propName, literal(eventName), false));\r\n            }\r\n        });\r\n        let updateDirectiveExpressions = [];\r\n        if (dirAst.inputs.length || (flags & (262144 /* DoCheck */ | 65536 /* OnInit */)) > 0) {\r\n            updateDirectiveExpressions =\r\n                dirAst.inputs.map((input, bindingIndex) => this._preprocessUpdateExpression({\r\n                    nodeIndex,\r\n                    bindingIndex,\r\n                    sourceSpan: input.sourceSpan,\r\n                    context: COMP_VAR,\r\n                    value: input.value\r\n                }));\r\n        }\r\n        const dirContextExpr = importExpr(Identifiers$1.nodeValue).callFn([VIEW_VAR, literal(nodeIndex)]);\r\n        const hostBindings = dirAst.hostProperties.map((inputAst) => ({\r\n            context: dirContextExpr,\r\n            dirAst,\r\n            inputAst,\r\n        }));\r\n        const hostEvents = dirAst.hostEvents.map((hostEventAst) => ({\r\n            context: dirContextExpr,\r\n            eventAst: hostEventAst,\r\n            dirAst,\r\n        }));\r\n        // Check index is the same as the node index during compilation\r\n        // They might only differ at runtime\r\n        const checkIndex = nodeIndex;\r\n        this.nodes[nodeIndex] = () => ({\r\n            sourceSpan: dirAst.sourceSpan,\r\n            nodeFlags: 16384 /* TypeDirective */ | flags,\r\n            nodeDef: importExpr(Identifiers$1.directiveDef).callFn([\r\n                literal(checkIndex),\r\n                literal(flags),\r\n                queryMatchExprs.length ? literalArr(queryMatchExprs) : NULL_EXPR,\r\n                literal(childCount),\r\n                providerExpr,\r\n                depsExpr,\r\n                inputDefs.length ? new LiteralMapExpr(inputDefs) : NULL_EXPR,\r\n                outputDefs.length ? new LiteralMapExpr(outputDefs) : NULL_EXPR,\r\n            ]),\r\n            updateDirectives: updateDirectiveExpressions,\r\n            directive: dirAst.directive.type,\r\n        });\r\n        return { hostBindings, hostEvents };\r\n    }\r\n    _visitProvider(providerAst, queryMatches) {\r\n        this._addProviderNode(this._visitProviderOrDirective(providerAst, queryMatches));\r\n    }\r\n    _visitComponentFactoryResolverProvider(directives) {\r\n        const componentDirMeta = directives.find(dirAst => dirAst.directive.isComponent);\r\n        if (componentDirMeta && componentDirMeta.directive.entryComponents.length) {\r\n            const { providerExpr, depsExpr, flags, tokenExpr } = componentFactoryResolverProviderDef(this.reflector, this.outputCtx, 8192 /* PrivateProvider */, componentDirMeta.directive.entryComponents);\r\n            this._addProviderNode({\r\n                providerExpr,\r\n                depsExpr,\r\n                flags,\r\n                tokenExpr,\r\n                queryMatchExprs: [],\r\n                sourceSpan: componentDirMeta.sourceSpan\r\n            });\r\n        }\r\n    }\r\n    _addProviderNode(data) {\r\n        // providerDef(\r\n        //   flags: NodeFlags, matchedQueries: [string, QueryValueType][], token:any,\r\n        //   value: any, deps: ([DepFlags, any] | any)[]): NodeDef;\r\n        this.nodes.push(() => ({\r\n            sourceSpan: data.sourceSpan,\r\n            nodeFlags: data.flags,\r\n            nodeDef: importExpr(Identifiers$1.providerDef).callFn([\r\n                literal(data.flags),\r\n                data.queryMatchExprs.length ? literalArr(data.queryMatchExprs) : NULL_EXPR,\r\n                data.tokenExpr, data.providerExpr, data.depsExpr\r\n            ])\r\n        }));\r\n    }\r\n    _visitProviderOrDirective(providerAst, queryMatches) {\r\n        let flags = 0 /* None */;\r\n        let queryMatchExprs = [];\r\n        queryMatches.forEach((match) => {\r\n            if (tokenReference(match.value) === tokenReference(providerAst.token)) {\r\n                queryMatchExprs.push(literalArr([literal(match.queryId), literal(4 /* Provider */)]));\r\n            }\r\n        });\r\n        const { providerExpr, depsExpr, flags: providerFlags, tokenExpr } = providerDef(this.outputCtx, providerAst);\r\n        return {\r\n            flags: flags | providerFlags,\r\n            queryMatchExprs,\r\n            providerExpr,\r\n            depsExpr,\r\n            tokenExpr,\r\n            sourceSpan: providerAst.sourceSpan\r\n        };\r\n    }\r\n    getLocal(name) {\r\n        if (name == EventHandlerVars.event.name) {\r\n            return EventHandlerVars.event;\r\n        }\r\n        let currViewExpr = VIEW_VAR;\r\n        for (let currBuilder = this; currBuilder; currBuilder = currBuilder.parent,\r\n            currViewExpr = currViewExpr.prop('parent').cast(DYNAMIC_TYPE)) {\r\n            // check references\r\n            const refNodeIndex = currBuilder.refNodeIndices[name];\r\n            if (refNodeIndex != null) {\r\n                return importExpr(Identifiers$1.nodeValue).callFn([currViewExpr, literal(refNodeIndex)]);\r\n            }\r\n            // check variables\r\n            const varAst = currBuilder.variables.find((varAst) => varAst.name === name);\r\n            if (varAst) {\r\n                const varValue = varAst.value || IMPLICIT_TEMPLATE_VAR;\r\n                return currViewExpr.prop('context').prop(varValue);\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    notifyImplicitReceiverUse() {\r\n        // Not needed in ViewEngine as ViewEngine walks through the generated\r\n        // expressions to figure out if the implicit receiver is used and needs\r\n        // to be generated as part of the pre-update statements.\r\n    }\r\n    maybeRestoreView() {\r\n        // Not necessary in ViewEngine, because view restoration is an Ivy concept.\r\n    }\r\n    _createLiteralArrayConverter(sourceSpan, argCount) {\r\n        if (argCount === 0) {\r\n            const valueExpr = importExpr(Identifiers$1.EMPTY_ARRAY);\r\n            return () => valueExpr;\r\n        }\r\n        const checkIndex = this.nodes.length;\r\n        this.nodes.push(() => ({\r\n            sourceSpan,\r\n            nodeFlags: 32 /* TypePureArray */,\r\n            nodeDef: importExpr(Identifiers$1.pureArrayDef).callFn([\r\n                literal(checkIndex),\r\n                literal(argCount),\r\n            ])\r\n        }));\r\n        return (args) => callCheckStmt(checkIndex, args);\r\n    }\r\n    _createLiteralMapConverter(sourceSpan, keys) {\r\n        if (keys.length === 0) {\r\n            const valueExpr = importExpr(Identifiers$1.EMPTY_MAP);\r\n            return () => valueExpr;\r\n        }\r\n        const map = literalMap(keys.map((e, i) => (Object.assign(Object.assign({}, e), { value: literal(i) }))));\r\n        const checkIndex = this.nodes.length;\r\n        this.nodes.push(() => ({\r\n            sourceSpan,\r\n            nodeFlags: 64 /* TypePureObject */,\r\n            nodeDef: importExpr(Identifiers$1.pureObjectDef).callFn([\r\n                literal(checkIndex),\r\n                map,\r\n            ])\r\n        }));\r\n        return (args) => callCheckStmt(checkIndex, args);\r\n    }\r\n    _createPipeConverter(expression, name, argCount) {\r\n        const pipe = this.usedPipes.find((pipeSummary) => pipeSummary.name === name);\r\n        if (pipe.pure) {\r\n            const checkIndex = this.nodes.length;\r\n            this.nodes.push(() => ({\r\n                sourceSpan: expression.sourceSpan,\r\n                nodeFlags: 128 /* TypePurePipe */,\r\n                nodeDef: importExpr(Identifiers$1.purePipeDef).callFn([\r\n                    literal(checkIndex),\r\n                    literal(argCount),\r\n                ])\r\n            }));\r\n            // find underlying pipe in the component view\r\n            let compViewExpr = VIEW_VAR;\r\n            let compBuilder = this;\r\n            while (compBuilder.parent) {\r\n                compBuilder = compBuilder.parent;\r\n                compViewExpr = compViewExpr.prop('parent').cast(DYNAMIC_TYPE);\r\n            }\r\n            const pipeNodeIndex = compBuilder.purePipeNodeIndices[name];\r\n            const pipeValueExpr = importExpr(Identifiers$1.nodeValue).callFn([compViewExpr, literal(pipeNodeIndex)]);\r\n            return (args) => callUnwrapValue(expression.nodeIndex, expression.bindingIndex, callCheckStmt(checkIndex, [pipeValueExpr].concat(args)));\r\n        }\r\n        else {\r\n            const nodeIndex = this._createPipe(expression.sourceSpan, pipe);\r\n            const nodeValueExpr = importExpr(Identifiers$1.nodeValue).callFn([VIEW_VAR, literal(nodeIndex)]);\r\n            return (args) => callUnwrapValue(expression.nodeIndex, expression.bindingIndex, nodeValueExpr.callMethod('transform', args));\r\n        }\r\n    }\r\n    _createPipe(sourceSpan, pipe) {\r\n        const nodeIndex = this.nodes.length;\r\n        let flags = 0 /* None */;\r\n        pipe.type.lifecycleHooks.forEach((lifecycleHook) => {\r\n            // for pipes, we only support ngOnDestroy\r\n            if (lifecycleHook === LifecycleHooks.OnDestroy) {\r\n                flags |= lifecycleHookToNodeFlag(lifecycleHook);\r\n            }\r\n        });\r\n        const depExprs = pipe.type.diDeps.map((diDep) => depDef(this.outputCtx, diDep));\r\n        // function pipeDef(\r\n        //   flags: NodeFlags, ctor: any, deps: ([DepFlags, any] | any)[]): NodeDef\r\n        this.nodes.push(() => ({\r\n            sourceSpan,\r\n            nodeFlags: 16 /* TypePipe */,\r\n            nodeDef: importExpr(Identifiers$1.pipeDef).callFn([\r\n                literal(flags), this.outputCtx.importExpr(pipe.type.reference), literalArr(depExprs)\r\n            ])\r\n        }));\r\n        return nodeIndex;\r\n    }\r\n    /**\r\n     * For the AST in `UpdateExpression.value`:\r\n     * - create nodes for pipes, literal arrays and, literal maps,\r\n     * - update the AST to replace pipes, literal arrays and, literal maps with calls to check fn.\r\n     *\r\n     * WARNING: This might create new nodeDefs (for pipes and literal arrays and literal maps)!\r\n     */\r\n    _preprocessUpdateExpression(expression) {\r\n        return {\r\n            nodeIndex: expression.nodeIndex,\r\n            bindingIndex: expression.bindingIndex,\r\n            sourceSpan: expression.sourceSpan,\r\n            context: expression.context,\r\n            value: convertPropertyBindingBuiltins({\r\n                createLiteralArrayConverter: (argCount) => this._createLiteralArrayConverter(expression.sourceSpan, argCount),\r\n                createLiteralMapConverter: (keys) => this._createLiteralMapConverter(expression.sourceSpan, keys),\r\n                createPipeConverter: (name, argCount) => this._createPipeConverter(expression, name, argCount)\r\n            }, expression.value)\r\n        };\r\n    }\r\n    _createNodeExpressions() {\r\n        const self = this;\r\n        let updateBindingCount = 0;\r\n        const updateRendererStmts = [];\r\n        const updateDirectivesStmts = [];\r\n        const nodeDefExprs = this.nodes.map((factory, nodeIndex) => {\r\n            const { nodeDef, nodeFlags, updateDirectives, updateRenderer, sourceSpan } = factory();\r\n            if (updateRenderer) {\r\n                updateRendererStmts.push(...createUpdateStatements(nodeIndex, sourceSpan, updateRenderer, false));\r\n            }\r\n            if (updateDirectives) {\r\n                updateDirectivesStmts.push(...createUpdateStatements(nodeIndex, sourceSpan, updateDirectives, (nodeFlags & (262144 /* DoCheck */ | 65536 /* OnInit */)) > 0));\r\n            }\r\n            // We use a comma expression to call the log function before\r\n            // the nodeDef function, but still use the result of the nodeDef function\r\n            // as the value.\r\n            // Note: We only add the logger to elements / text nodes,\r\n            // so we don't generate too much code.\r\n            const logWithNodeDef = nodeFlags & 3 /* CatRenderNode */ ?\r\n                new CommaExpr([LOG_VAR$1.callFn([]).callFn([]), nodeDef]) :\r\n                nodeDef;\r\n            return applySourceSpanToExpressionIfNeeded(logWithNodeDef, sourceSpan);\r\n        });\r\n        return { updateRendererStmts, updateDirectivesStmts, nodeDefExprs };\r\n        function createUpdateStatements(nodeIndex, sourceSpan, expressions, allowEmptyExprs) {\r\n            const updateStmts = [];\r\n            const exprs = expressions.map(({ sourceSpan, context, value }) => {\r\n                const bindingId = `${updateBindingCount++}`;\r\n                const nameResolver = context === COMP_VAR ? self : null;\r\n                const { stmts, currValExpr } = convertPropertyBinding(nameResolver, context, value, bindingId, BindingForm.General);\r\n                updateStmts.push(...stmts.map((stmt) => applySourceSpanToStatementIfNeeded(stmt, sourceSpan)));\r\n                return applySourceSpanToExpressionIfNeeded(currValExpr, sourceSpan);\r\n            });\r\n            if (expressions.length || allowEmptyExprs) {\r\n                updateStmts.push(applySourceSpanToStatementIfNeeded(callCheckStmt(nodeIndex, exprs).toStmt(), sourceSpan));\r\n            }\r\n            return updateStmts;\r\n        }\r\n    }\r\n    _createElementHandleEventFn(nodeIndex, handlers) {\r\n        const handleEventStmts = [];\r\n        let handleEventBindingCount = 0;\r\n        handlers.forEach(({ context, eventAst, dirAst }) => {\r\n            const bindingId = `${handleEventBindingCount++}`;\r\n            const nameResolver = context === COMP_VAR ? this : null;\r\n            const { stmts, allowDefault } = convertActionBinding(nameResolver, context, eventAst.handler, bindingId);\r\n            const trueStmts = stmts;\r\n            if (allowDefault) {\r\n                trueStmts.push(ALLOW_DEFAULT_VAR.set(allowDefault.and(ALLOW_DEFAULT_VAR)).toStmt());\r\n            }\r\n            const { target: eventTarget, name: eventName } = elementEventNameAndTarget(eventAst, dirAst);\r\n            const fullEventName = elementEventFullName(eventTarget, eventName);\r\n            handleEventStmts.push(applySourceSpanToStatementIfNeeded(new IfStmt(literal(fullEventName).identical(EVENT_NAME_VAR), trueStmts), eventAst.sourceSpan));\r\n        });\r\n        let handleEventFn;\r\n        if (handleEventStmts.length > 0) {\r\n            const preStmts = [ALLOW_DEFAULT_VAR.set(literal(true)).toDeclStmt(BOOL_TYPE)];\r\n            if (!this.component.isHost && findReadVarNames(handleEventStmts).has(COMP_VAR.name)) {\r\n                preStmts.push(COMP_VAR.set(VIEW_VAR.prop('component')).toDeclStmt(this.compType));\r\n            }\r\n            handleEventFn = fn([\r\n                new FnParam(VIEW_VAR.name, INFERRED_TYPE),\r\n                new FnParam(EVENT_NAME_VAR.name, INFERRED_TYPE),\r\n                new FnParam(EventHandlerVars.event.name, INFERRED_TYPE)\r\n            ], [...preStmts, ...handleEventStmts, new ReturnStatement(ALLOW_DEFAULT_VAR)], INFERRED_TYPE);\r\n        }\r\n        else {\r\n            handleEventFn = NULL_EXPR;\r\n        }\r\n        return handleEventFn;\r\n    }\r\n    visitDirective(ast, context) { }\r\n    visitDirectiveProperty(ast, context) { }\r\n    visitReference(ast, context) { }\r\n    visitVariable(ast, context) { }\r\n    visitEvent(ast, context) { }\r\n    visitElementProperty(ast, context) { }\r\n    visitAttr(ast, context) { }\r\n}\r\nfunction needsAdditionalRootNode(astNodes) {\r\n    const lastAstNode = astNodes[astNodes.length - 1];\r\n    if (lastAstNode instanceof EmbeddedTemplateAst) {\r\n        return lastAstNode.hasViewContainer;\r\n    }\r\n    if (lastAstNode instanceof ElementAst) {\r\n        if (isNgContainer(lastAstNode.name) && lastAstNode.children.length) {\r\n            return needsAdditionalRootNode(lastAstNode.children);\r\n        }\r\n        return lastAstNode.hasViewContainer;\r\n    }\r\n    return lastAstNode instanceof NgContentAst;\r\n}\r\nfunction elementBindingDef(inputAst, dirAst) {\r\n    const inputType = inputAst.type;\r\n    switch (inputType) {\r\n        case 1 /* Attribute */:\r\n            return literalArr([\r\n                literal(1 /* TypeElementAttribute */), literal(inputAst.name),\r\n                literal(inputAst.securityContext)\r\n            ]);\r\n        case 0 /* Property */:\r\n            return literalArr([\r\n                literal(8 /* TypeProperty */), literal(inputAst.name),\r\n                literal(inputAst.securityContext)\r\n            ]);\r\n        case 4 /* Animation */:\r\n            const bindingType = 8 /* TypeProperty */ |\r\n                (dirAst && dirAst.directive.isComponent ? 32 /* SyntheticHostProperty */ :\r\n                    16 /* SyntheticProperty */);\r\n            return literalArr([\r\n                literal(bindingType), literal('@' + inputAst.name), literal(inputAst.securityContext)\r\n            ]);\r\n        case 2 /* Class */:\r\n            return literalArr([literal(2 /* TypeElementClass */), literal(inputAst.name), NULL_EXPR]);\r\n        case 3 /* Style */:\r\n            return literalArr([\r\n                literal(4 /* TypeElementStyle */), literal(inputAst.name), literal(inputAst.unit)\r\n            ]);\r\n        default:\r\n            // This default case is not needed by TypeScript compiler, as the switch is exhaustive.\r\n            // However Closure Compiler does not understand that and reports an error in typed mode.\r\n            // The `throw new Error` below works around the problem, and the unexpected: never variable\r\n            // makes sure tsc still checks this code is unreachable.\r\n            const unexpected = inputType;\r\n            throw new Error(`unexpected ${unexpected}`);\r\n    }\r\n}\r\nfunction fixedAttrsDef(elementAst) {\r\n    const mapResult = Object.create(null);\r\n    elementAst.attrs.forEach(attrAst => {\r\n        mapResult[attrAst.name] = attrAst.value;\r\n    });\r\n    elementAst.directives.forEach(dirAst => {\r\n        Object.keys(dirAst.directive.hostAttributes).forEach(name => {\r\n            const value = dirAst.directive.hostAttributes[name];\r\n            const prevValue = mapResult[name];\r\n            mapResult[name] = prevValue != null ? mergeAttributeValue(name, prevValue, value) : value;\r\n        });\r\n    });\r\n    // Note: We need to sort to get a defined output order\r\n    // for tests and for caching generated artifacts...\r\n    return literalArr(Object.keys(mapResult).sort().map((attrName) => literalArr([literal(attrName), literal(mapResult[attrName])])));\r\n}\r\nfunction mergeAttributeValue(attrName, attrValue1, attrValue2) {\r\n    if (attrName == CLASS_ATTR$1 || attrName == STYLE_ATTR) {\r\n        return `${attrValue1} ${attrValue2}`;\r\n    }\r\n    else {\r\n        return attrValue2;\r\n    }\r\n}\r\nfunction callCheckStmt(nodeIndex, exprs) {\r\n    if (exprs.length > 10) {\r\n        return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(1 /* Dynamic */), literalArr(exprs)]);\r\n    }\r\n    else {\r\n        return CHECK_VAR.callFn([VIEW_VAR, literal(nodeIndex), literal(0 /* Inline */), ...exprs]);\r\n    }\r\n}\r\nfunction callUnwrapValue(nodeIndex, bindingIdx, expr) {\r\n    return importExpr(Identifiers$1.unwrapValue).callFn([\r\n        VIEW_VAR, literal(nodeIndex), literal(bindingIdx), expr\r\n    ]);\r\n}\r\nfunction elementEventNameAndTarget(eventAst, dirAst) {\r\n    if (eventAst.isAnimation) {\r\n        return {\r\n            name: `@${eventAst.name}.${eventAst.phase}`,\r\n            target: dirAst && dirAst.directive.isComponent ? 'component' : null\r\n        };\r\n    }\r\n    else {\r\n        return eventAst;\r\n    }\r\n}\r\nfunction calcQueryFlags(query) {\r\n    let flags = 0 /* None */;\r\n    // Note: We only make queries static that query for a single item and the user specifically\r\n    // set the to be static. This is because of backwards compatibility with the old view compiler...\r\n    if (query.first && query.static) {\r\n        flags |= 268435456 /* StaticQuery */;\r\n    }\r\n    else {\r\n        flags |= 536870912 /* DynamicQuery */;\r\n    }\r\n    if (query.emitDistinctChangesOnly) {\r\n        flags |= -2147483648 /* EmitDistinctChangesOnly */;\r\n    }\r\n    return flags;\r\n}\r\nfunction elementEventFullName(target, name) {\r\n    return target ? `${target}:${name}` : name;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * A container for message extracted from the templates.\r\n */\r\nclass MessageBundle {\r\n    constructor(_htmlParser, _implicitTags, _implicitAttrs, _locale = null) {\r\n        this._htmlParser = _htmlParser;\r\n        this._implicitTags = _implicitTags;\r\n        this._implicitAttrs = _implicitAttrs;\r\n        this._locale = _locale;\r\n        this._messages = [];\r\n    }\r\n    updateFromTemplate(html, url, interpolationConfig) {\r\n        const htmlParserResult = this._htmlParser.parse(html, url, { tokenizeExpansionForms: true, interpolationConfig });\r\n        if (htmlParserResult.errors.length) {\r\n            return htmlParserResult.errors;\r\n        }\r\n        const i18nParserResult = extractMessages(htmlParserResult.rootNodes, interpolationConfig, this._implicitTags, this._implicitAttrs);\r\n        if (i18nParserResult.errors.length) {\r\n            return i18nParserResult.errors;\r\n        }\r\n        this._messages.push(...i18nParserResult.messages);\r\n        return [];\r\n    }\r\n    // Return the message in the internal format\r\n    // The public (serialized) format might be different, see the `write` method.\r\n    getMessages() {\r\n        return this._messages;\r\n    }\r\n    write(serializer, filterSources) {\r\n        const messages = {};\r\n        const mapperVisitor = new MapPlaceholderNames();\r\n        // Deduplicate messages based on their ID\r\n        this._messages.forEach(message => {\r\n            const id = serializer.digest(message);\r\n            if (!messages.hasOwnProperty(id)) {\r\n                messages[id] = message;\r\n            }\r\n            else {\r\n                messages[id].sources.push(...message.sources);\r\n            }\r\n        });\r\n        // Transform placeholder names using the serializer mapping\r\n        const msgList = Object.keys(messages).map(id => {\r\n            const mapper = serializer.createNameMapper(messages[id]);\r\n            const src = messages[id];\r\n            const nodes = mapper ? mapperVisitor.convert(src.nodes, mapper) : src.nodes;\r\n            let transformedMessage = new Message(nodes, {}, {}, src.meaning, src.description, id);\r\n            transformedMessage.sources = src.sources;\r\n            if (filterSources) {\r\n                transformedMessage.sources.forEach((source) => source.filePath = filterSources(source.filePath));\r\n            }\r\n            return transformedMessage;\r\n        });\r\n        return serializer.write(msgList, this._locale);\r\n    }\r\n}\r\n// Transform an i18n AST by renaming the placeholder nodes with the given mapper\r\nclass MapPlaceholderNames extends CloneVisitor {\r\n    convert(nodes, mapper) {\r\n        return mapper ? nodes.map(n => n.visit(this, mapper)) : nodes;\r\n    }\r\n    visitTagPlaceholder(ph, mapper) {\r\n        const startName = mapper.toPublicName(ph.startName);\r\n        const closeName = ph.closeName ? mapper.toPublicName(ph.closeName) : ph.closeName;\r\n        const children = ph.children.map(n => n.visit(this, mapper));\r\n        return new TagPlaceholder(ph.tag, ph.attrs, startName, closeName, children, ph.isVoid, ph.sourceSpan, ph.startSourceSpan, ph.endSourceSpan);\r\n    }\r\n    visitPlaceholder(ph, mapper) {\r\n        return new Placeholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\r\n    }\r\n    visitIcuPlaceholder(ph, mapper) {\r\n        return new IcuPlaceholder(ph.value, mapper.toPublicName(ph.name), ph.sourceSpan);\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass GeneratedFile {\r\n    constructor(srcFileUrl, genFileUrl, sourceOrStmts) {\r\n        this.srcFileUrl = srcFileUrl;\r\n        this.genFileUrl = genFileUrl;\r\n        if (typeof sourceOrStmts === 'string') {\r\n            this.source = sourceOrStmts;\r\n            this.stmts = null;\r\n        }\r\n        else {\r\n            this.source = null;\r\n            this.stmts = sourceOrStmts;\r\n        }\r\n    }\r\n    isEquivalent(other) {\r\n        if (this.genFileUrl !== other.genFileUrl) {\r\n            return false;\r\n        }\r\n        if (this.source) {\r\n            return this.source === other.source;\r\n        }\r\n        if (other.stmts == null) {\r\n            return false;\r\n        }\r\n        // Note: the constructor guarantees that if this.source is not filled,\r\n        // then this.stmts is.\r\n        return areAllEquivalent(this.stmts, other.stmts);\r\n    }\r\n}\r\nfunction toTypeScript(file, preamble = '') {\r\n    if (!file.stmts) {\r\n        throw new Error(`Illegal state: No stmts present on GeneratedFile ${file.genFileUrl}`);\r\n    }\r\n    return new TypeScriptEmitter().emitStatements(file.genFileUrl, file.stmts, preamble);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nfunction listLazyRoutes(moduleMeta, reflector) {\r\n    const allLazyRoutes = [];\r\n    for (const { provider, module } of moduleMeta.transitiveModule.providers) {\r\n        if (tokenReference(provider.token) === reflector.ROUTES) {\r\n            const loadChildren = _collectLoadChildren(provider.useValue);\r\n            for (const route of loadChildren) {\r\n                allLazyRoutes.push(parseLazyRoute(route, reflector, module.reference));\r\n            }\r\n        }\r\n    }\r\n    return allLazyRoutes;\r\n}\r\nfunction _collectLoadChildren(routes, target = []) {\r\n    if (typeof routes === 'string') {\r\n        target.push(routes);\r\n    }\r\n    else if (Array.isArray(routes)) {\r\n        for (const route of routes) {\r\n            _collectLoadChildren(route, target);\r\n        }\r\n    }\r\n    else if (routes.loadChildren) {\r\n        _collectLoadChildren(routes.loadChildren, target);\r\n    }\r\n    else if (routes.children) {\r\n        _collectLoadChildren(routes.children, target);\r\n    }\r\n    return target;\r\n}\r\nfunction parseLazyRoute(route, reflector, module) {\r\n    const [routePath, routeName] = route.split('#');\r\n    const referencedModule = reflector.resolveExternalReference({\r\n        moduleName: routePath,\r\n        name: routeName,\r\n    }, module ? module.filePath : undefined);\r\n    return { route: route, module: module || referencedModule, referencedModule };\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst TS = /^(?!.*\\.d\\.ts$).*\\.ts$/;\r\nclass ResolvedStaticSymbol {\r\n    constructor(symbol, metadata) {\r\n        this.symbol = symbol;\r\n        this.metadata = metadata;\r\n    }\r\n}\r\nconst SUPPORTED_SCHEMA_VERSION = 4;\r\n/**\r\n * This class is responsible for loading metadata per symbol,\r\n * and normalizing references between symbols.\r\n *\r\n * Internally, it only uses symbols without members,\r\n * and deduces the values for symbols with members based\r\n * on these symbols.\r\n */\r\nclass StaticSymbolResolver {\r\n    constructor(host, staticSymbolCache, summaryResolver, errorRecorder) {\r\n        this.host = host;\r\n        this.staticSymbolCache = staticSymbolCache;\r\n        this.summaryResolver = summaryResolver;\r\n        this.errorRecorder = errorRecorder;\r\n        this.metadataCache = new Map();\r\n        // Note: this will only contain StaticSymbols without members!\r\n        this.resolvedSymbols = new Map();\r\n        // Note: this will only contain StaticSymbols without members!\r\n        this.importAs = new Map();\r\n        this.symbolResourcePaths = new Map();\r\n        this.symbolFromFile = new Map();\r\n        this.knownFileNameToModuleNames = new Map();\r\n    }\r\n    resolveSymbol(staticSymbol) {\r\n        if (staticSymbol.members.length > 0) {\r\n            return this._resolveSymbolMembers(staticSymbol);\r\n        }\r\n        // Note: always ask for a summary first,\r\n        // as we might have read shallow metadata via a .d.ts file\r\n        // for the symbol.\r\n        const resultFromSummary = this._resolveSymbolFromSummary(staticSymbol);\r\n        if (resultFromSummary) {\r\n            return resultFromSummary;\r\n        }\r\n        const resultFromCache = this.resolvedSymbols.get(staticSymbol);\r\n        if (resultFromCache) {\r\n            return resultFromCache;\r\n        }\r\n        // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\r\n        // have summaries, only .d.ts files. So we always need to check both, the summary\r\n        // and metadata.\r\n        this._createSymbolsOf(staticSymbol.filePath);\r\n        return this.resolvedSymbols.get(staticSymbol);\r\n    }\r\n    /**\r\n     * getImportAs produces a symbol that can be used to import the given symbol.\r\n     * The import might be different than the symbol if the symbol is exported from\r\n     * a library with a summary; in which case we want to import the symbol from the\r\n     * ngfactory re-export instead of directly to avoid introducing a direct dependency\r\n     * on an otherwise indirect dependency.\r\n     *\r\n     * @param staticSymbol the symbol for which to generate a import symbol\r\n     */\r\n    getImportAs(staticSymbol, useSummaries = true) {\r\n        if (staticSymbol.members.length) {\r\n            const baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);\r\n            const baseImportAs = this.getImportAs(baseSymbol, useSummaries);\r\n            return baseImportAs ?\r\n                this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) :\r\n                null;\r\n        }\r\n        const summarizedFileName = stripSummaryForJitFileSuffix(staticSymbol.filePath);\r\n        if (summarizedFileName !== staticSymbol.filePath) {\r\n            const summarizedName = stripSummaryForJitNameSuffix(staticSymbol.name);\r\n            const baseSymbol = this.getStaticSymbol(summarizedFileName, summarizedName, staticSymbol.members);\r\n            const baseImportAs = this.getImportAs(baseSymbol, useSummaries);\r\n            return baseImportAs ? this.getStaticSymbol(summaryForJitFileName(baseImportAs.filePath), summaryForJitName(baseImportAs.name), baseSymbol.members) :\r\n                null;\r\n        }\r\n        let result = (useSummaries && this.summaryResolver.getImportAs(staticSymbol)) || null;\r\n        if (!result) {\r\n            result = this.importAs.get(staticSymbol);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * getResourcePath produces the path to the original location of the symbol and should\r\n     * be used to determine the relative location of resource references recorded in\r\n     * symbol metadata.\r\n     */\r\n    getResourcePath(staticSymbol) {\r\n        return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;\r\n    }\r\n    /**\r\n     * getTypeArity returns the number of generic type parameters the given symbol\r\n     * has. If the symbol is not a type the result is null.\r\n     */\r\n    getTypeArity(staticSymbol) {\r\n        // If the file is a factory/ngsummary file, don't resolve the symbol as doing so would\r\n        // cause the metadata for an factory/ngsummary file to be loaded which doesn't exist.\r\n        // All references to generated classes must include the correct arity whenever\r\n        // generating code.\r\n        if (isGeneratedFile(staticSymbol.filePath)) {\r\n            return null;\r\n        }\r\n        let resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(staticSymbol));\r\n        while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\r\n            resolvedSymbol = unwrapResolvedMetadata(this.resolveSymbol(resolvedSymbol.metadata));\r\n        }\r\n        return (resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity) || null;\r\n    }\r\n    getKnownModuleName(filePath) {\r\n        return this.knownFileNameToModuleNames.get(filePath) || null;\r\n    }\r\n    recordImportAs(sourceSymbol, targetSymbol) {\r\n        sourceSymbol.assertNoMembers();\r\n        targetSymbol.assertNoMembers();\r\n        this.importAs.set(sourceSymbol, targetSymbol);\r\n    }\r\n    recordModuleNameForFileName(fileName, moduleName) {\r\n        this.knownFileNameToModuleNames.set(fileName, moduleName);\r\n    }\r\n    /**\r\n     * Invalidate all information derived from the given file and return the\r\n     * static symbols contained in the file.\r\n     *\r\n     * @param fileName the file to invalidate\r\n     */\r\n    invalidateFile(fileName) {\r\n        this.metadataCache.delete(fileName);\r\n        const symbols = this.symbolFromFile.get(fileName);\r\n        if (!symbols) {\r\n            return [];\r\n        }\r\n        this.symbolFromFile.delete(fileName);\r\n        for (const symbol of symbols) {\r\n            this.resolvedSymbols.delete(symbol);\r\n            this.importAs.delete(symbol);\r\n            this.symbolResourcePaths.delete(symbol);\r\n        }\r\n        return symbols;\r\n    }\r\n    /** @internal */\r\n    ignoreErrorsFor(cb) {\r\n        const recorder = this.errorRecorder;\r\n        this.errorRecorder = () => { };\r\n        try {\r\n            return cb();\r\n        }\r\n        finally {\r\n            this.errorRecorder = recorder;\r\n        }\r\n    }\r\n    _resolveSymbolMembers(staticSymbol) {\r\n        const members = staticSymbol.members;\r\n        const baseResolvedSymbol = this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\r\n        if (!baseResolvedSymbol) {\r\n            return null;\r\n        }\r\n        let baseMetadata = unwrapResolvedMetadata(baseResolvedSymbol.metadata);\r\n        if (baseMetadata instanceof StaticSymbol) {\r\n            return new ResolvedStaticSymbol(staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\r\n        }\r\n        else if (baseMetadata && baseMetadata.__symbolic === 'class') {\r\n            if (baseMetadata.statics && members.length === 1) {\r\n                return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\r\n            }\r\n        }\r\n        else {\r\n            let value = baseMetadata;\r\n            for (let i = 0; i < members.length && value; i++) {\r\n                value = value[members[i]];\r\n            }\r\n            return new ResolvedStaticSymbol(staticSymbol, value);\r\n        }\r\n        return null;\r\n    }\r\n    _resolveSymbolFromSummary(staticSymbol) {\r\n        const summary = this.summaryResolver.resolveSummary(staticSymbol);\r\n        return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\r\n    }\r\n    /**\r\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\r\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\r\n     *\r\n     * @param declarationFile the absolute path of the file where the symbol is declared\r\n     * @param name the name of the type.\r\n     * @param members a symbol for a static member of the named type\r\n     */\r\n    getStaticSymbol(declarationFile, name, members) {\r\n        return this.staticSymbolCache.get(declarationFile, name, members);\r\n    }\r\n    /**\r\n     * hasDecorators checks a file's metadata for the presence of decorators without evaluating the\r\n     * metadata.\r\n     *\r\n     * @param filePath the absolute path to examine for decorators.\r\n     * @returns true if any class in the file has a decorator.\r\n     */\r\n    hasDecorators(filePath) {\r\n        const metadata = this.getModuleMetadata(filePath);\r\n        if (metadata['metadata']) {\r\n            return Object.keys(metadata['metadata']).some((metadataKey) => {\r\n                const entry = metadata['metadata'][metadataKey];\r\n                return entry && entry.__symbolic === 'class' && entry.decorators;\r\n            });\r\n        }\r\n        return false;\r\n    }\r\n    getSymbolsOf(filePath) {\r\n        const summarySymbols = this.summaryResolver.getSymbolsOf(filePath);\r\n        if (summarySymbols) {\r\n            return summarySymbols;\r\n        }\r\n        // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\r\n        // have summaries, only .d.ts files, but `summaryResolver.isLibraryFile` returns true.\r\n        this._createSymbolsOf(filePath);\r\n        return this.symbolFromFile.get(filePath) || [];\r\n    }\r\n    _createSymbolsOf(filePath) {\r\n        if (this.symbolFromFile.has(filePath)) {\r\n            return;\r\n        }\r\n        const resolvedSymbols = [];\r\n        const metadata = this.getModuleMetadata(filePath);\r\n        if (metadata['importAs']) {\r\n            // Index bundle indices should use the importAs module name defined\r\n            // in the bundle.\r\n            this.knownFileNameToModuleNames.set(filePath, metadata['importAs']);\r\n        }\r\n        // handle the symbols in one of the re-export location\r\n        if (metadata['exports']) {\r\n            for (const moduleExport of metadata['exports']) {\r\n                // handle the symbols in the list of explicitly re-exported symbols.\r\n                if (moduleExport.export) {\r\n                    moduleExport.export.forEach((exportSymbol) => {\r\n                        let symbolName;\r\n                        if (typeof exportSymbol === 'string') {\r\n                            symbolName = exportSymbol;\r\n                        }\r\n                        else {\r\n                            symbolName = exportSymbol.as;\r\n                        }\r\n                        symbolName = unescapeIdentifier(symbolName);\r\n                        let symName = symbolName;\r\n                        if (typeof exportSymbol !== 'string') {\r\n                            symName = unescapeIdentifier(exportSymbol.name);\r\n                        }\r\n                        const resolvedModule = this.resolveModule(moduleExport.from, filePath);\r\n                        if (resolvedModule) {\r\n                            const targetSymbol = this.getStaticSymbol(resolvedModule, symName);\r\n                            const sourceSymbol = this.getStaticSymbol(filePath, symbolName);\r\n                            resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    // Handle the symbols loaded by 'export *' directives.\r\n                    const resolvedModule = this.resolveModule(moduleExport.from, filePath);\r\n                    if (resolvedModule && resolvedModule !== filePath) {\r\n                        const nestedExports = this.getSymbolsOf(resolvedModule);\r\n                        nestedExports.forEach((targetSymbol) => {\r\n                            const sourceSymbol = this.getStaticSymbol(filePath, targetSymbol.name);\r\n                            resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        // handle the actual metadata. Has to be after the exports\r\n        // as there might be collisions in the names, and we want the symbols\r\n        // of the current module to win ofter reexports.\r\n        if (metadata['metadata']) {\r\n            // handle direct declarations of the symbol\r\n            const topLevelSymbolNames = new Set(Object.keys(metadata['metadata']).map(unescapeIdentifier));\r\n            const origins = metadata['origins'] || {};\r\n            Object.keys(metadata['metadata']).forEach((metadataKey) => {\r\n                const symbolMeta = metadata['metadata'][metadataKey];\r\n                const name = unescapeIdentifier(metadataKey);\r\n                const symbol = this.getStaticSymbol(filePath, name);\r\n                const origin = origins.hasOwnProperty(metadataKey) && origins[metadataKey];\r\n                if (origin) {\r\n                    // If the symbol is from a bundled index, use the declaration location of the\r\n                    // symbol so relative references (such as './my.html') will be calculated\r\n                    // correctly.\r\n                    const originFilePath = this.resolveModule(origin, filePath);\r\n                    if (!originFilePath) {\r\n                        this.reportError(new Error(`Couldn't resolve original symbol for ${origin} from ${this.host.getOutputName(filePath)}`));\r\n                    }\r\n                    else {\r\n                        this.symbolResourcePaths.set(symbol, originFilePath);\r\n                    }\r\n                }\r\n                resolvedSymbols.push(this.createResolvedSymbol(symbol, filePath, topLevelSymbolNames, symbolMeta));\r\n            });\r\n        }\r\n        const uniqueSymbols = new Set();\r\n        for (const resolvedSymbol of resolvedSymbols) {\r\n            this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol);\r\n            uniqueSymbols.add(resolvedSymbol.symbol);\r\n        }\r\n        this.symbolFromFile.set(filePath, Array.from(uniqueSymbols));\r\n    }\r\n    createResolvedSymbol(sourceSymbol, topLevelPath, topLevelSymbolNames, metadata) {\r\n        // For classes that don't have Angular summaries / metadata,\r\n        // we only keep their arity, but nothing else\r\n        // (e.g. their constructor parameters).\r\n        // We do this to prevent introducing deep imports\r\n        // as we didn't generate .ngfactory.ts files with proper reexports.\r\n        const isTsFile = TS.test(sourceSymbol.filePath);\r\n        if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && !isTsFile && metadata &&\r\n            metadata['__symbolic'] === 'class') {\r\n            const transformedMeta = { __symbolic: 'class', arity: metadata.arity };\r\n            return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\r\n        }\r\n        let _originalFileMemo;\r\n        const getOriginalName = () => {\r\n            if (!_originalFileMemo) {\r\n                // Guess what the original file name is from the reference. If it has a `.d.ts` extension\r\n                // replace it with `.ts`. If it already has `.ts` just leave it in place. If it doesn't have\r\n                // .ts or .d.ts, append `.ts'. Also, if it is in `node_modules`, trim the `node_module`\r\n                // location as it is not important to finding the file.\r\n                _originalFileMemo =\r\n                    this.host.getOutputName(topLevelPath.replace(/((\\.ts)|(\\.d\\.ts)|)$/, '.ts')\r\n                        .replace(/^.*node_modules[/\\\\]/, ''));\r\n            }\r\n            return _originalFileMemo;\r\n        };\r\n        const self = this;\r\n        class ReferenceTransformer extends ValueTransformer {\r\n            visitStringMap(map, functionParams) {\r\n                const symbolic = map['__symbolic'];\r\n                if (symbolic === 'function') {\r\n                    const oldLen = functionParams.length;\r\n                    functionParams.push(...(map['parameters'] || []));\r\n                    const result = super.visitStringMap(map, functionParams);\r\n                    functionParams.length = oldLen;\r\n                    return result;\r\n                }\r\n                else if (symbolic === 'reference') {\r\n                    const module = map['module'];\r\n                    const name = map['name'] ? unescapeIdentifier(map['name']) : map['name'];\r\n                    if (!name) {\r\n                        return null;\r\n                    }\r\n                    let filePath;\r\n                    if (module) {\r\n                        filePath = self.resolveModule(module, sourceSymbol.filePath);\r\n                        if (!filePath) {\r\n                            return {\r\n                                __symbolic: 'error',\r\n                                message: `Could not resolve ${module} relative to ${self.host.getMetadataFor(sourceSymbol.filePath)}.`,\r\n                                line: map['line'],\r\n                                character: map['character'],\r\n                                fileName: getOriginalName()\r\n                            };\r\n                        }\r\n                        return {\r\n                            __symbolic: 'resolved',\r\n                            symbol: self.getStaticSymbol(filePath, name),\r\n                            line: map['line'],\r\n                            character: map['character'],\r\n                            fileName: getOriginalName()\r\n                        };\r\n                    }\r\n                    else if (functionParams.indexOf(name) >= 0) {\r\n                        // reference to a function parameter\r\n                        return { __symbolic: 'reference', name: name };\r\n                    }\r\n                    else {\r\n                        if (topLevelSymbolNames.has(name)) {\r\n                            return self.getStaticSymbol(topLevelPath, name);\r\n                        }\r\n                        // ambient value\r\n                        null;\r\n                    }\r\n                }\r\n                else if (symbolic === 'error') {\r\n                    return Object.assign(Object.assign({}, map), { fileName: getOriginalName() });\r\n                }\r\n                else {\r\n                    return super.visitStringMap(map, functionParams);\r\n                }\r\n            }\r\n        }\r\n        const transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);\r\n        let unwrappedTransformedMeta = unwrapResolvedMetadata(transformedMeta);\r\n        if (unwrappedTransformedMeta instanceof StaticSymbol) {\r\n            return this.createExport(sourceSymbol, unwrappedTransformedMeta);\r\n        }\r\n        return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\r\n    }\r\n    createExport(sourceSymbol, targetSymbol) {\r\n        sourceSymbol.assertNoMembers();\r\n        targetSymbol.assertNoMembers();\r\n        if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) &&\r\n            this.summaryResolver.isLibraryFile(targetSymbol.filePath)) {\r\n            // This case is for an ng library importing symbols from a plain ts library\r\n            // transitively.\r\n            // Note: We rely on the fact that we discover symbols in the direction\r\n            // from source files to library files\r\n            this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);\r\n        }\r\n        return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);\r\n    }\r\n    reportError(error, context, path) {\r\n        if (this.errorRecorder) {\r\n            this.errorRecorder(error, (context && context.filePath) || path);\r\n        }\r\n        else {\r\n            throw error;\r\n        }\r\n    }\r\n    /**\r\n     * @param module an absolute path to a module file.\r\n     */\r\n    getModuleMetadata(module) {\r\n        let moduleMetadata = this.metadataCache.get(module);\r\n        if (!moduleMetadata) {\r\n            const moduleMetadatas = this.host.getMetadataFor(module);\r\n            if (moduleMetadatas) {\r\n                let maxVersion = -1;\r\n                moduleMetadatas.forEach((md) => {\r\n                    if (md && md['version'] > maxVersion) {\r\n                        maxVersion = md['version'];\r\n                        moduleMetadata = md;\r\n                    }\r\n                });\r\n            }\r\n            if (!moduleMetadata) {\r\n                moduleMetadata =\r\n                    { __symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {} };\r\n            }\r\n            if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\r\n                const errorMessage = moduleMetadata['version'] == 2 ?\r\n                    `Unsupported metadata version ${moduleMetadata['version']} for module ${module}. This module should be compiled with a newer version of ngc` :\r\n                    `Metadata version mismatch for module ${this.host.getOutputName(module)}, found version ${moduleMetadata['version']}, expected ${SUPPORTED_SCHEMA_VERSION}`;\r\n                this.reportError(new Error(errorMessage));\r\n            }\r\n            this.metadataCache.set(module, moduleMetadata);\r\n        }\r\n        return moduleMetadata;\r\n    }\r\n    getSymbolByModule(module, symbolName, containingFile) {\r\n        const filePath = this.resolveModule(module, containingFile);\r\n        if (!filePath) {\r\n            this.reportError(new Error(`Could not resolve module ${module}${containingFile ? ' relative to ' + this.host.getOutputName(containingFile) : ''}`));\r\n            return this.getStaticSymbol(`ERROR:${module}`, symbolName);\r\n        }\r\n        return this.getStaticSymbol(filePath, symbolName);\r\n    }\r\n    resolveModule(module, containingFile) {\r\n        try {\r\n            return this.host.moduleNameToFileName(module, containingFile);\r\n        }\r\n        catch (e) {\r\n            console.error(`Could not resolve module '${module}' relative to file ${containingFile}`);\r\n            this.reportError(e, undefined, containingFile);\r\n        }\r\n        return null;\r\n    }\r\n}\r\n// Remove extra underscore from escaped identifier.\r\n// See https://github.com/Microsoft/TypeScript/blob/master/src/compiler/utilities.ts\r\nfunction unescapeIdentifier(identifier) {\r\n    return identifier.startsWith('___') ? identifier.substr(1) : identifier;\r\n}\r\nfunction unwrapResolvedMetadata(metadata) {\r\n    if (metadata && metadata.__symbolic === 'resolved') {\r\n        return metadata.symbol;\r\n    }\r\n    return metadata;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nfunction serializeSummaries(srcFileName, forJitCtx, summaryResolver, symbolResolver, symbols, types, createExternalSymbolReexports = false) {\r\n    const toJsonSerializer = new ToJsonSerializer(symbolResolver, summaryResolver, srcFileName);\r\n    // for symbols, we use everything except for the class metadata itself\r\n    // (we keep the statics though), as the class metadata is contained in the\r\n    // CompileTypeSummary.\r\n    symbols.forEach((resolvedSymbol) => toJsonSerializer.addSummary({ symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata }));\r\n    // Add type summaries.\r\n    types.forEach(({ summary, metadata }) => {\r\n        toJsonSerializer.addSummary({ symbol: summary.type.reference, metadata: undefined, type: summary });\r\n    });\r\n    const { json, exportAs } = toJsonSerializer.serialize(createExternalSymbolReexports);\r\n    if (forJitCtx) {\r\n        const forJitSerializer = new ForJitSerializer(forJitCtx, symbolResolver, summaryResolver);\r\n        types.forEach(({ summary, metadata }) => {\r\n            forJitSerializer.addSourceType(summary, metadata);\r\n        });\r\n        toJsonSerializer.unprocessedSymbolSummariesBySymbol.forEach((summary) => {\r\n            if (summaryResolver.isLibraryFile(summary.symbol.filePath) && summary.type) {\r\n                forJitSerializer.addLibType(summary.type);\r\n            }\r\n        });\r\n        forJitSerializer.serialize(exportAs);\r\n    }\r\n    return { json, exportAs };\r\n}\r\nfunction deserializeSummaries(symbolCache, summaryResolver, libraryFileName, json) {\r\n    const deserializer = new FromJsonDeserializer(symbolCache, summaryResolver);\r\n    return deserializer.deserialize(libraryFileName, json);\r\n}\r\nfunction createForJitStub(outputCtx, reference) {\r\n    return createSummaryForJitFunction(outputCtx, reference, NULL_EXPR);\r\n}\r\nfunction createSummaryForJitFunction(outputCtx, reference, value) {\r\n    const fnName = summaryForJitName(reference.name);\r\n    outputCtx.statements.push(fn([], [new ReturnStatement(value)], new ArrayType(DYNAMIC_TYPE)).toDeclStmt(fnName, [\r\n        StmtModifier.Final, StmtModifier.Exported\r\n    ]));\r\n}\r\nclass ToJsonSerializer extends ValueTransformer {\r\n    constructor(symbolResolver, summaryResolver, srcFileName) {\r\n        super();\r\n        this.symbolResolver = symbolResolver;\r\n        this.summaryResolver = summaryResolver;\r\n        this.srcFileName = srcFileName;\r\n        // Note: This only contains symbols without members.\r\n        this.symbols = [];\r\n        this.indexBySymbol = new Map();\r\n        this.reexportedBy = new Map();\r\n        // This now contains a `__symbol: number` in the place of\r\n        // StaticSymbols, but otherwise has the same shape as the original objects.\r\n        this.processedSummaryBySymbol = new Map();\r\n        this.processedSummaries = [];\r\n        this.unprocessedSymbolSummariesBySymbol = new Map();\r\n        this.moduleName = symbolResolver.getKnownModuleName(srcFileName);\r\n    }\r\n    addSummary(summary) {\r\n        let unprocessedSummary = this.unprocessedSymbolSummariesBySymbol.get(summary.symbol);\r\n        let processedSummary = this.processedSummaryBySymbol.get(summary.symbol);\r\n        if (!unprocessedSummary) {\r\n            unprocessedSummary = { symbol: summary.symbol, metadata: undefined };\r\n            this.unprocessedSymbolSummariesBySymbol.set(summary.symbol, unprocessedSummary);\r\n            processedSummary = { symbol: this.processValue(summary.symbol, 0 /* None */) };\r\n            this.processedSummaries.push(processedSummary);\r\n            this.processedSummaryBySymbol.set(summary.symbol, processedSummary);\r\n        }\r\n        if (!unprocessedSummary.metadata && summary.metadata) {\r\n            let metadata = summary.metadata || {};\r\n            if (metadata.__symbolic === 'class') {\r\n                // For classes, we keep everything except their class decorators.\r\n                // We need to keep e.g. the ctor args, method names, method decorators\r\n                // so that the class can be extended in another compilation unit.\r\n                // We don't keep the class decorators as\r\n                // 1) they refer to data\r\n                //   that should not cause a rebuild of downstream compilation units\r\n                //   (e.g. inline templates of @Component, or @NgModule.declarations)\r\n                // 2) their data is already captured in TypeSummaries, e.g. DirectiveSummary.\r\n                const clone = {};\r\n                Object.keys(metadata).forEach((propName) => {\r\n                    if (propName !== 'decorators') {\r\n                        clone[propName] = metadata[propName];\r\n                    }\r\n                });\r\n                metadata = clone;\r\n            }\r\n            else if (isCall(metadata)) {\r\n                if (!isFunctionCall(metadata) && !isMethodCallOnVariable(metadata)) {\r\n                    // Don't store complex calls as we won't be able to simplify them anyways later on.\r\n                    metadata = {\r\n                        __symbolic: 'error',\r\n                        message: 'Complex function calls are not supported.',\r\n                    };\r\n                }\r\n            }\r\n            // Note: We need to keep storing ctor calls for e.g.\r\n            // `export const x = new InjectionToken(...)`\r\n            unprocessedSummary.metadata = metadata;\r\n            processedSummary.metadata = this.processValue(metadata, 1 /* ResolveValue */);\r\n            if (metadata instanceof StaticSymbol &&\r\n                this.summaryResolver.isLibraryFile(metadata.filePath)) {\r\n                const declarationSymbol = this.symbols[this.indexBySymbol.get(metadata)];\r\n                if (!isLoweredSymbol(declarationSymbol.name)) {\r\n                    // Note: symbols that were introduced during codegen in the user file can have a reexport\r\n                    // if a user used `export *`. However, we can't rely on this as tsickle will change\r\n                    // `export *` into named exports, using only the information from the typechecker.\r\n                    // As we introduce the new symbols after typecheck, Tsickle does not know about them,\r\n                    // and omits them when expanding `export *`.\r\n                    // So we have to keep reexporting these symbols manually via .ngfactory files.\r\n                    this.reexportedBy.set(declarationSymbol, summary.symbol);\r\n                }\r\n            }\r\n        }\r\n        if (!unprocessedSummary.type && summary.type) {\r\n            unprocessedSummary.type = summary.type;\r\n            // Note: We don't add the summaries of all referenced symbols as for the ResolvedSymbols,\r\n            // as the type summaries already contain the transitive data that they require\r\n            // (in a minimal way).\r\n            processedSummary.type = this.processValue(summary.type, 0 /* None */);\r\n            // except for reexported directives / pipes, so we need to store\r\n            // their summaries explicitly.\r\n            if (summary.type.summaryKind === CompileSummaryKind.NgModule) {\r\n                const ngModuleSummary = summary.type;\r\n                ngModuleSummary.exportedDirectives.concat(ngModuleSummary.exportedPipes).forEach((id) => {\r\n                    const symbol = id.reference;\r\n                    if (this.summaryResolver.isLibraryFile(symbol.filePath) &&\r\n                        !this.unprocessedSymbolSummariesBySymbol.has(symbol)) {\r\n                        const summary = this.summaryResolver.resolveSummary(symbol);\r\n                        if (summary) {\r\n                            this.addSummary(summary);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @param createExternalSymbolReexports Whether external static symbols should be re-exported.\r\n     * This can be enabled if external symbols should be re-exported by the current module in\r\n     * order to avoid dynamically generated module dependencies which can break strict dependency\r\n     * enforcements (as in Google3). Read more here: https://github.com/angular/angular/issues/25644\r\n     */\r\n    serialize(createExternalSymbolReexports) {\r\n        const exportAs = [];\r\n        const json = JSON.stringify({\r\n            moduleName: this.moduleName,\r\n            summaries: this.processedSummaries,\r\n            symbols: this.symbols.map((symbol, index) => {\r\n                symbol.assertNoMembers();\r\n                let importAs = undefined;\r\n                if (this.summaryResolver.isLibraryFile(symbol.filePath)) {\r\n                    const reexportSymbol = this.reexportedBy.get(symbol);\r\n                    if (reexportSymbol) {\r\n                        // In case the given external static symbol is already manually exported by the\r\n                        // user, we just proxy the external static symbol reference to the manual export.\r\n                        // This ensures that the AOT compiler imports the external symbol through the\r\n                        // user export and does not introduce another dependency which is not needed.\r\n                        importAs = this.indexBySymbol.get(reexportSymbol);\r\n                    }\r\n                    else if (createExternalSymbolReexports) {\r\n                        // In this case, the given external static symbol is *not* manually exported by\r\n                        // the user, and we manually create a re-export in the factory file so that we\r\n                        // don't introduce another module dependency. This is useful when running within\r\n                        // Bazel so that the AOT compiler does not introduce any module dependencies\r\n                        // which can break the strict dependency enforcement. (e.g. as in Google3)\r\n                        // Read more about this here: https://github.com/angular/angular/issues/25644\r\n                        const summary = this.unprocessedSymbolSummariesBySymbol.get(symbol);\r\n                        if (!summary || !summary.metadata || summary.metadata.__symbolic !== 'interface') {\r\n                            importAs = `${symbol.name}_${index}`;\r\n                            exportAs.push({ symbol, exportAs: importAs });\r\n                        }\r\n                    }\r\n                }\r\n                return {\r\n                    __symbol: index,\r\n                    name: symbol.name,\r\n                    filePath: this.summaryResolver.toSummaryFileName(symbol.filePath, this.srcFileName),\r\n                    importAs: importAs\r\n                };\r\n            })\r\n        });\r\n        return { json, exportAs };\r\n    }\r\n    processValue(value, flags) {\r\n        return visitValue(value, this, flags);\r\n    }\r\n    visitOther(value, context) {\r\n        if (value instanceof StaticSymbol) {\r\n            let baseSymbol = this.symbolResolver.getStaticSymbol(value.filePath, value.name);\r\n            const index = this.visitStaticSymbol(baseSymbol, context);\r\n            return { __symbol: index, members: value.members };\r\n        }\r\n    }\r\n    /**\r\n     * Strip line and character numbers from ngsummaries.\r\n     * Emitting them causes white spaces changes to retrigger upstream\r\n     * recompilations in bazel.\r\n     * TODO: find out a way to have line and character numbers in errors without\r\n     * excessive recompilation in bazel.\r\n     */\r\n    visitStringMap(map, context) {\r\n        if (map['__symbolic'] === 'resolved') {\r\n            return visitValue(map['symbol'], this, context);\r\n        }\r\n        if (map['__symbolic'] === 'error') {\r\n            delete map['line'];\r\n            delete map['character'];\r\n        }\r\n        return super.visitStringMap(map, context);\r\n    }\r\n    /**\r\n     * Returns null if the options.resolveValue is true, and the summary for the symbol\r\n     * resolved to a type or could not be resolved.\r\n     */\r\n    visitStaticSymbol(baseSymbol, flags) {\r\n        let index = this.indexBySymbol.get(baseSymbol);\r\n        let summary = null;\r\n        if (flags & 1 /* ResolveValue */ &&\r\n            this.summaryResolver.isLibraryFile(baseSymbol.filePath)) {\r\n            if (this.unprocessedSymbolSummariesBySymbol.has(baseSymbol)) {\r\n                // the summary for this symbol was already added\r\n                // -> nothing to do.\r\n                return index;\r\n            }\r\n            summary = this.loadSummary(baseSymbol);\r\n            if (summary && summary.metadata instanceof StaticSymbol) {\r\n                // The summary is a reexport\r\n                index = this.visitStaticSymbol(summary.metadata, flags);\r\n                // reset the summary as it is just a reexport, so we don't want to store it.\r\n                summary = null;\r\n            }\r\n        }\r\n        else if (index != null) {\r\n            // Note: == on purpose to compare with undefined!\r\n            // No summary and the symbol is already added -> nothing to do.\r\n            return index;\r\n        }\r\n        // Note: == on purpose to compare with undefined!\r\n        if (index == null) {\r\n            index = this.symbols.length;\r\n            this.symbols.push(baseSymbol);\r\n        }\r\n        this.indexBySymbol.set(baseSymbol, index);\r\n        if (summary) {\r\n            this.addSummary(summary);\r\n        }\r\n        return index;\r\n    }\r\n    loadSummary(symbol) {\r\n        let summary = this.summaryResolver.resolveSummary(symbol);\r\n        if (!summary) {\r\n            // some symbols might originate from a plain typescript library\r\n            // that just exported .d.ts and .metadata.json files, i.e. where no summary\r\n            // files were created.\r\n            const resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\r\n            if (resolvedSymbol) {\r\n                summary = { symbol: resolvedSymbol.symbol, metadata: resolvedSymbol.metadata };\r\n            }\r\n        }\r\n        return summary;\r\n    }\r\n}\r\nclass ForJitSerializer {\r\n    constructor(outputCtx, symbolResolver, summaryResolver) {\r\n        this.outputCtx = outputCtx;\r\n        this.symbolResolver = symbolResolver;\r\n        this.summaryResolver = summaryResolver;\r\n        this.data = [];\r\n    }\r\n    addSourceType(summary, metadata) {\r\n        this.data.push({ summary, metadata, isLibrary: false });\r\n    }\r\n    addLibType(summary) {\r\n        this.data.push({ summary, metadata: null, isLibrary: true });\r\n    }\r\n    serialize(exportAsArr) {\r\n        const exportAsBySymbol = new Map();\r\n        for (const { symbol, exportAs } of exportAsArr) {\r\n            exportAsBySymbol.set(symbol, exportAs);\r\n        }\r\n        const ngModuleSymbols = new Set();\r\n        for (const { summary, metadata, isLibrary } of this.data) {\r\n            if (summary.summaryKind === CompileSummaryKind.NgModule) {\r\n                // collect the symbols that refer to NgModule classes.\r\n                // Note: we can't just rely on `summary.type.summaryKind` to determine this as\r\n                // we don't add the summaries of all referenced symbols when we serialize type summaries.\r\n                // See serializeSummaries for details.\r\n                ngModuleSymbols.add(summary.type.reference);\r\n                const modSummary = summary;\r\n                for (const mod of modSummary.modules) {\r\n                    ngModuleSymbols.add(mod.reference);\r\n                }\r\n            }\r\n            if (!isLibrary) {\r\n                const fnName = summaryForJitName(summary.type.reference.name);\r\n                createSummaryForJitFunction(this.outputCtx, summary.type.reference, this.serializeSummaryWithDeps(summary, metadata));\r\n            }\r\n        }\r\n        ngModuleSymbols.forEach((ngModuleSymbol) => {\r\n            if (this.summaryResolver.isLibraryFile(ngModuleSymbol.filePath)) {\r\n                let exportAs = exportAsBySymbol.get(ngModuleSymbol) || ngModuleSymbol.name;\r\n                const jitExportAsName = summaryForJitName(exportAs);\r\n                this.outputCtx.statements.push(variable(jitExportAsName)\r\n                    .set(this.serializeSummaryRef(ngModuleSymbol))\r\n                    .toDeclStmt(null, [StmtModifier.Exported]));\r\n            }\r\n        });\r\n    }\r\n    serializeSummaryWithDeps(summary, metadata) {\r\n        const expressions = [this.serializeSummary(summary)];\r\n        let providers = [];\r\n        if (metadata instanceof CompileNgModuleMetadata) {\r\n            expressions.push(...\r\n            // For directives / pipes, we only add the declared ones,\r\n            // and rely on transitively importing NgModules to get the transitive\r\n            // summaries.\r\n            metadata.declaredDirectives.concat(metadata.declaredPipes)\r\n                .map(type => type.reference)\r\n                // For modules,\r\n                // we also add the summaries for modules\r\n                // from libraries.\r\n                // This is ok as we produce reexports for all transitive modules.\r\n                .concat(metadata.transitiveModule.modules.map(type => type.reference)\r\n                .filter(ref => ref !== metadata.type.reference))\r\n                .map((ref) => this.serializeSummaryRef(ref)));\r\n            // Note: We don't use `NgModuleSummary.providers`, as that one is transitive,\r\n            // and we already have transitive modules.\r\n            providers = metadata.providers;\r\n        }\r\n        else if (summary.summaryKind === CompileSummaryKind.Directive) {\r\n            const dirSummary = summary;\r\n            providers = dirSummary.providers.concat(dirSummary.viewProviders);\r\n        }\r\n        // Note: We can't just refer to the `ngsummary.ts` files for `useClass` providers (as we do for\r\n        // declaredDirectives / declaredPipes), as we allow\r\n        // providers without ctor arguments to skip the `@Injectable` decorator,\r\n        // i.e. we didn't generate .ngsummary.ts files for these.\r\n        expressions.push(...providers.filter(provider => !!provider.useClass).map(provider => this.serializeSummary({\r\n            summaryKind: CompileSummaryKind.Injectable,\r\n            type: provider.useClass\r\n        })));\r\n        return literalArr(expressions);\r\n    }\r\n    serializeSummaryRef(typeSymbol) {\r\n        const jitImportedSymbol = this.symbolResolver.getStaticSymbol(summaryForJitFileName(typeSymbol.filePath), summaryForJitName(typeSymbol.name));\r\n        return this.outputCtx.importExpr(jitImportedSymbol);\r\n    }\r\n    serializeSummary(data) {\r\n        const outputCtx = this.outputCtx;\r\n        class Transformer {\r\n            visitArray(arr, context) {\r\n                return literalArr(arr.map(entry => visitValue(entry, this, context)));\r\n            }\r\n            visitStringMap(map, context) {\r\n                return new LiteralMapExpr(Object.keys(map).map((key) => new LiteralMapEntry(key, visitValue(map[key], this, context), false)));\r\n            }\r\n            visitPrimitive(value, context) {\r\n                return literal(value);\r\n            }\r\n            visitOther(value, context) {\r\n                if (value instanceof StaticSymbol) {\r\n                    return outputCtx.importExpr(value);\r\n                }\r\n                else {\r\n                    throw new Error(`Illegal State: Encountered value ${value}`);\r\n                }\r\n            }\r\n        }\r\n        return visitValue(data, new Transformer(), null);\r\n    }\r\n}\r\nclass FromJsonDeserializer extends ValueTransformer {\r\n    constructor(symbolCache, summaryResolver) {\r\n        super();\r\n        this.symbolCache = symbolCache;\r\n        this.summaryResolver = summaryResolver;\r\n    }\r\n    deserialize(libraryFileName, json) {\r\n        const data = JSON.parse(json);\r\n        const allImportAs = [];\r\n        this.symbols = data.symbols.map((serializedSymbol) => this.symbolCache.get(this.summaryResolver.fromSummaryFileName(serializedSymbol.filePath, libraryFileName), serializedSymbol.name));\r\n        data.symbols.forEach((serializedSymbol, index) => {\r\n            const symbol = this.symbols[index];\r\n            const importAs = serializedSymbol.importAs;\r\n            if (typeof importAs === 'number') {\r\n                allImportAs.push({ symbol, importAs: this.symbols[importAs] });\r\n            }\r\n            else if (typeof importAs === 'string') {\r\n                allImportAs.push({ symbol, importAs: this.symbolCache.get(ngfactoryFilePath(libraryFileName), importAs) });\r\n            }\r\n        });\r\n        const summaries = visitValue(data.summaries, this, null);\r\n        return { moduleName: data.moduleName, summaries, importAs: allImportAs };\r\n    }\r\n    visitStringMap(map, context) {\r\n        if ('__symbol' in map) {\r\n            const baseSymbol = this.symbols[map['__symbol']];\r\n            const members = map['members'];\r\n            return members.length ? this.symbolCache.get(baseSymbol.filePath, baseSymbol.name, members) :\r\n                baseSymbol;\r\n        }\r\n        else {\r\n            return super.visitStringMap(map, context);\r\n        }\r\n    }\r\n}\r\nfunction isCall(metadata) {\r\n    return metadata && metadata.__symbolic === 'call';\r\n}\r\nfunction isFunctionCall(metadata) {\r\n    return isCall(metadata) && unwrapResolvedMetadata(metadata.expression) instanceof StaticSymbol;\r\n}\r\nfunction isMethodCallOnVariable(metadata) {\r\n    return isCall(metadata) && metadata.expression && metadata.expression.__symbolic === 'select' &&\r\n        unwrapResolvedMetadata(metadata.expression.expression) instanceof StaticSymbol;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass AotCompiler {\r\n    constructor(_config, _options, _host, reflector, _metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _typeCheckCompiler, _ngModuleCompiler, _injectableCompiler, _outputEmitter, _summaryResolver, _symbolResolver) {\r\n        this._config = _config;\r\n        this._options = _options;\r\n        this._host = _host;\r\n        this.reflector = reflector;\r\n        this._metadataResolver = _metadataResolver;\r\n        this._templateParser = _templateParser;\r\n        this._styleCompiler = _styleCompiler;\r\n        this._viewCompiler = _viewCompiler;\r\n        this._typeCheckCompiler = _typeCheckCompiler;\r\n        this._ngModuleCompiler = _ngModuleCompiler;\r\n        this._injectableCompiler = _injectableCompiler;\r\n        this._outputEmitter = _outputEmitter;\r\n        this._summaryResolver = _summaryResolver;\r\n        this._symbolResolver = _symbolResolver;\r\n        this._templateAstCache = new Map();\r\n        this._analyzedFiles = new Map();\r\n        this._analyzedFilesForInjectables = new Map();\r\n    }\r\n    clearCache() {\r\n        this._metadataResolver.clearCache();\r\n    }\r\n    analyzeModulesSync(rootFiles) {\r\n        const analyzeResult = analyzeAndValidateNgModules(rootFiles, this._host, this._symbolResolver, this._metadataResolver);\r\n        analyzeResult.ngModules.forEach(ngModule => this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, true));\r\n        return analyzeResult;\r\n    }\r\n    analyzeModulesAsync(rootFiles) {\r\n        const analyzeResult = analyzeAndValidateNgModules(rootFiles, this._host, this._symbolResolver, this._metadataResolver);\r\n        return Promise\r\n            .all(analyzeResult.ngModules.map(ngModule => this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false)))\r\n            .then(() => analyzeResult);\r\n    }\r\n    _analyzeFile(fileName) {\r\n        let analyzedFile = this._analyzedFiles.get(fileName);\r\n        if (!analyzedFile) {\r\n            analyzedFile =\r\n                analyzeFile(this._host, this._symbolResolver, this._metadataResolver, fileName);\r\n            this._analyzedFiles.set(fileName, analyzedFile);\r\n        }\r\n        return analyzedFile;\r\n    }\r\n    _analyzeFileForInjectables(fileName) {\r\n        let analyzedFile = this._analyzedFilesForInjectables.get(fileName);\r\n        if (!analyzedFile) {\r\n            analyzedFile = analyzeFileForInjectables(this._host, this._symbolResolver, this._metadataResolver, fileName);\r\n            this._analyzedFilesForInjectables.set(fileName, analyzedFile);\r\n        }\r\n        return analyzedFile;\r\n    }\r\n    findGeneratedFileNames(fileName) {\r\n        const genFileNames = [];\r\n        const file = this._analyzeFile(fileName);\r\n        // Make sure we create a .ngfactory if we have a injectable/directive/pipe/NgModule\r\n        // or a reference to a non source file.\r\n        // Note: This is overestimating the required .ngfactory files as the real calculation is harder.\r\n        // Only do this for StubEmitFlags.Basic, as adding a type check block\r\n        // does not change this file (as we generate type check blocks based on NgModules).\r\n        if (this._options.allowEmptyCodegenFiles || file.directives.length || file.pipes.length ||\r\n            file.injectables.length || file.ngModules.length || file.exportsNonSourceFiles) {\r\n            genFileNames.push(ngfactoryFilePath(file.fileName, true));\r\n            if (this._options.enableSummariesForJit) {\r\n                genFileNames.push(summaryForJitFileName(file.fileName, true));\r\n            }\r\n        }\r\n        const fileSuffix = normalizeGenFileSuffix(splitTypescriptSuffix(file.fileName, true)[1]);\r\n        file.directives.forEach((dirSymbol) => {\r\n            const compMeta = this._metadataResolver.getNonNormalizedDirectiveMetadata(dirSymbol).metadata;\r\n            if (!compMeta.isComponent) {\r\n                return;\r\n            }\r\n            // Note: compMeta is a component and therefore template is non null.\r\n            compMeta.template.styleUrls.forEach((styleUrl) => {\r\n                const normalizedUrl = this._host.resourceNameToFileName(styleUrl, file.fileName);\r\n                if (!normalizedUrl) {\r\n                    throw syntaxError(`Couldn't resolve resource ${styleUrl} relative to ${file.fileName}`);\r\n                }\r\n                const needsShim = (compMeta.template.encapsulation ||\r\n                    this._config.defaultEncapsulation) === ViewEncapsulation.Emulated;\r\n                genFileNames.push(_stylesModuleUrl(normalizedUrl, needsShim, fileSuffix));\r\n                if (this._options.allowEmptyCodegenFiles) {\r\n                    genFileNames.push(_stylesModuleUrl(normalizedUrl, !needsShim, fileSuffix));\r\n                }\r\n            });\r\n        });\r\n        return genFileNames;\r\n    }\r\n    emitBasicStub(genFileName, originalFileName) {\r\n        const outputCtx = this._createOutputContext(genFileName);\r\n        if (genFileName.endsWith('.ngfactory.ts')) {\r\n            if (!originalFileName) {\r\n                throw new Error(`Assertion error: require the original file for .ngfactory.ts stubs. File: ${genFileName}`);\r\n            }\r\n            const originalFile = this._analyzeFile(originalFileName);\r\n            this._createNgFactoryStub(outputCtx, originalFile, 1 /* Basic */);\r\n        }\r\n        else if (genFileName.endsWith('.ngsummary.ts')) {\r\n            if (this._options.enableSummariesForJit) {\r\n                if (!originalFileName) {\r\n                    throw new Error(`Assertion error: require the original file for .ngsummary.ts stubs. File: ${genFileName}`);\r\n                }\r\n                const originalFile = this._analyzeFile(originalFileName);\r\n                _createEmptyStub(outputCtx);\r\n                originalFile.ngModules.forEach(ngModule => {\r\n                    // create exports that user code can reference\r\n                    createForJitStub(outputCtx, ngModule.type.reference);\r\n                });\r\n            }\r\n        }\r\n        else if (genFileName.endsWith('.ngstyle.ts')) {\r\n            _createEmptyStub(outputCtx);\r\n        }\r\n        // Note: for the stubs, we don't need a property srcFileUrl,\r\n        // as later on in emitAllImpls we will create the proper GeneratedFiles with the\r\n        // correct srcFileUrl.\r\n        // This is good as e.g. for .ngstyle.ts files we can't derive\r\n        // the url of components based on the genFileUrl.\r\n        return this._codegenSourceModule('unknown', outputCtx);\r\n    }\r\n    emitTypeCheckStub(genFileName, originalFileName) {\r\n        const originalFile = this._analyzeFile(originalFileName);\r\n        const outputCtx = this._createOutputContext(genFileName);\r\n        if (genFileName.endsWith('.ngfactory.ts')) {\r\n            this._createNgFactoryStub(outputCtx, originalFile, 2 /* TypeCheck */);\r\n        }\r\n        return outputCtx.statements.length > 0 ?\r\n            this._codegenSourceModule(originalFile.fileName, outputCtx) :\r\n            null;\r\n    }\r\n    loadFilesAsync(fileNames, tsFiles) {\r\n        const files = fileNames.map(fileName => this._analyzeFile(fileName));\r\n        const loadingPromises = [];\r\n        files.forEach(file => file.ngModules.forEach(ngModule => loadingPromises.push(this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false))));\r\n        const analyzedInjectables = tsFiles.map(tsFile => this._analyzeFileForInjectables(tsFile));\r\n        return Promise.all(loadingPromises).then(_ => ({\r\n            analyzedModules: mergeAndValidateNgFiles(files),\r\n            analyzedInjectables: analyzedInjectables,\r\n        }));\r\n    }\r\n    loadFilesSync(fileNames, tsFiles) {\r\n        const files = fileNames.map(fileName => this._analyzeFile(fileName));\r\n        files.forEach(file => file.ngModules.forEach(ngModule => this._metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, true)));\r\n        const analyzedInjectables = tsFiles.map(tsFile => this._analyzeFileForInjectables(tsFile));\r\n        return {\r\n            analyzedModules: mergeAndValidateNgFiles(files),\r\n            analyzedInjectables: analyzedInjectables,\r\n        };\r\n    }\r\n    _createNgFactoryStub(outputCtx, file, emitFlags) {\r\n        let componentId = 0;\r\n        file.ngModules.forEach((ngModuleMeta, ngModuleIndex) => {\r\n            // Note: the code below needs to executed for StubEmitFlags.Basic and StubEmitFlags.TypeCheck,\r\n            // so we don't change the .ngfactory file too much when adding the type-check block.\r\n            // create exports that user code can reference\r\n            this._ngModuleCompiler.createStub(outputCtx, ngModuleMeta.type.reference);\r\n            // add references to the symbols from the metadata.\r\n            // These can be used by the type check block for components,\r\n            // and they also cause TypeScript to include these files into the program too,\r\n            // which will make them part of the analyzedFiles.\r\n            const externalReferences = [\r\n                // Add references that are available from all the modules and imports.\r\n                ...ngModuleMeta.transitiveModule.directives.map(d => d.reference),\r\n                ...ngModuleMeta.transitiveModule.pipes.map(d => d.reference),\r\n                ...ngModuleMeta.importedModules.map(m => m.type.reference),\r\n                ...ngModuleMeta.exportedModules.map(m => m.type.reference),\r\n                // Add references that might be inserted by the template compiler.\r\n                ...this._externalIdentifierReferences([Identifiers$1.TemplateRef, Identifiers$1.ElementRef]),\r\n            ];\r\n            const externalReferenceVars = new Map();\r\n            externalReferences.forEach((ref, typeIndex) => {\r\n                externalReferenceVars.set(ref, `_decl${ngModuleIndex}_${typeIndex}`);\r\n            });\r\n            externalReferenceVars.forEach((varName, reference) => {\r\n                outputCtx.statements.push(variable(varName)\r\n                    .set(NULL_EXPR.cast(DYNAMIC_TYPE))\r\n                    .toDeclStmt(expressionType(outputCtx.importExpr(reference, /* typeParams */ null, /* useSummaries */ false))));\r\n            });\r\n            if (emitFlags & 2 /* TypeCheck */) {\r\n                // add the type-check block for all components of the NgModule\r\n                ngModuleMeta.declaredDirectives.forEach((dirId) => {\r\n                    const compMeta = this._metadataResolver.getDirectiveMetadata(dirId.reference);\r\n                    if (!compMeta.isComponent) {\r\n                        return;\r\n                    }\r\n                    componentId++;\r\n                    this._createTypeCheckBlock(outputCtx, `${compMeta.type.reference.name}_Host_${componentId}`, ngModuleMeta, this._metadataResolver.getHostComponentMetadata(compMeta), [compMeta.type], externalReferenceVars);\r\n                    this._createTypeCheckBlock(outputCtx, `${compMeta.type.reference.name}_${componentId}`, ngModuleMeta, compMeta, ngModuleMeta.transitiveModule.directives, externalReferenceVars);\r\n                });\r\n            }\r\n        });\r\n        if (outputCtx.statements.length === 0) {\r\n            _createEmptyStub(outputCtx);\r\n        }\r\n    }\r\n    _externalIdentifierReferences(references) {\r\n        const result = [];\r\n        for (let reference of references) {\r\n            const token = createTokenForExternalReference(this.reflector, reference);\r\n            if (token.identifier) {\r\n                result.push(token.identifier.reference);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    _createTypeCheckBlock(ctx, componentId, moduleMeta, compMeta, directives, externalReferenceVars) {\r\n        const { template: parsedTemplate, pipes: usedPipes } = this._parseTemplate(compMeta, moduleMeta, directives);\r\n        ctx.statements.push(...this._typeCheckCompiler.compileComponent(componentId, compMeta, parsedTemplate, usedPipes, externalReferenceVars, ctx));\r\n    }\r\n    emitMessageBundle(analyzeResult, locale) {\r\n        const errors = [];\r\n        const htmlParser = new HtmlParser();\r\n        // TODO(vicb): implicit tags & attributes\r\n        const messageBundle = new MessageBundle(htmlParser, [], {}, locale);\r\n        analyzeResult.files.forEach(file => {\r\n            const compMetas = [];\r\n            file.directives.forEach(directiveType => {\r\n                const dirMeta = this._metadataResolver.getDirectiveMetadata(directiveType);\r\n                if (dirMeta && dirMeta.isComponent) {\r\n                    compMetas.push(dirMeta);\r\n                }\r\n            });\r\n            compMetas.forEach(compMeta => {\r\n                const html = compMeta.template.template;\r\n                // Template URL points to either an HTML or TS file depending on whether\r\n                // the file is used with `templateUrl:` or `template:`, respectively.\r\n                const templateUrl = compMeta.template.templateUrl;\r\n                const interpolationConfig = InterpolationConfig.fromArray(compMeta.template.interpolation);\r\n                errors.push(...messageBundle.updateFromTemplate(html, templateUrl, interpolationConfig));\r\n            });\r\n        });\r\n        if (errors.length) {\r\n            throw new Error(errors.map(e => e.toString()).join('\\n'));\r\n        }\r\n        return messageBundle;\r\n    }\r\n    emitAllPartialModules2(files) {\r\n        // Using reduce like this is a select many pattern (where map is a select pattern)\r\n        return files.reduce((r, file) => {\r\n            r.push(...this._emitPartialModule2(file.fileName, file.injectables));\r\n            return r;\r\n        }, []);\r\n    }\r\n    _emitPartialModule2(fileName, injectables) {\r\n        const context = this._createOutputContext(fileName);\r\n        injectables.forEach(injectable => this._injectableCompiler.compile(injectable, context));\r\n        if (context.statements && context.statements.length > 0) {\r\n            return [{ fileName, statements: [...context.constantPool.statements, ...context.statements] }];\r\n        }\r\n        return [];\r\n    }\r\n    emitAllImpls(analyzeResult) {\r\n        const { ngModuleByPipeOrDirective, files } = analyzeResult;\r\n        const sourceModules = files.map(file => this._compileImplFile(file.fileName, ngModuleByPipeOrDirective, file.directives, file.pipes, file.ngModules, file.injectables));\r\n        return flatten(sourceModules);\r\n    }\r\n    _compileImplFile(srcFileUrl, ngModuleByPipeOrDirective, directives, pipes, ngModules, injectables) {\r\n        const fileSuffix = normalizeGenFileSuffix(splitTypescriptSuffix(srcFileUrl, true)[1]);\r\n        const generatedFiles = [];\r\n        const outputCtx = this._createOutputContext(ngfactoryFilePath(srcFileUrl, true));\r\n        generatedFiles.push(...this._createSummary(srcFileUrl, directives, pipes, ngModules, injectables, outputCtx));\r\n        // compile all ng modules\r\n        ngModules.forEach((ngModuleMeta) => this._compileModule(outputCtx, ngModuleMeta));\r\n        // compile components\r\n        directives.forEach((dirType) => {\r\n            const compMeta = this._metadataResolver.getDirectiveMetadata(dirType);\r\n            if (!compMeta.isComponent) {\r\n                return;\r\n            }\r\n            const ngModule = ngModuleByPipeOrDirective.get(dirType);\r\n            if (!ngModule) {\r\n                throw new Error(`Internal Error: cannot determine the module for component ${identifierName(compMeta.type)}!`);\r\n            }\r\n            // compile styles\r\n            const componentStylesheet = this._styleCompiler.compileComponent(outputCtx, compMeta);\r\n            // Note: compMeta is a component and therefore template is non null.\r\n            compMeta.template.externalStylesheets.forEach((stylesheetMeta) => {\r\n                // Note: fill non shim and shim style files as they might\r\n                // be shared by component with and without ViewEncapsulation.\r\n                const shim = this._styleCompiler.needsStyleShim(compMeta);\r\n                generatedFiles.push(this._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, shim, fileSuffix));\r\n                if (this._options.allowEmptyCodegenFiles) {\r\n                    generatedFiles.push(this._codegenStyles(srcFileUrl, compMeta, stylesheetMeta, !shim, fileSuffix));\r\n                }\r\n            });\r\n            // compile components\r\n            const compViewVars = this._compileComponent(outputCtx, compMeta, ngModule, ngModule.transitiveModule.directives, componentStylesheet, fileSuffix);\r\n            this._compileComponentFactory(outputCtx, compMeta, ngModule, fileSuffix);\r\n        });\r\n        if (outputCtx.statements.length > 0 || this._options.allowEmptyCodegenFiles) {\r\n            const srcModule = this._codegenSourceModule(srcFileUrl, outputCtx);\r\n            generatedFiles.unshift(srcModule);\r\n        }\r\n        return generatedFiles;\r\n    }\r\n    _createSummary(srcFileName, directives, pipes, ngModules, injectables, ngFactoryCtx) {\r\n        const symbolSummaries = this._symbolResolver.getSymbolsOf(srcFileName)\r\n            .map(symbol => this._symbolResolver.resolveSymbol(symbol));\r\n        const typeData = [\r\n            ...ngModules.map(meta => ({\r\n                summary: this._metadataResolver.getNgModuleSummary(meta.type.reference),\r\n                metadata: this._metadataResolver.getNgModuleMetadata(meta.type.reference)\r\n            })),\r\n            ...directives.map(ref => ({\r\n                summary: this._metadataResolver.getDirectiveSummary(ref),\r\n                metadata: this._metadataResolver.getDirectiveMetadata(ref)\r\n            })),\r\n            ...pipes.map(ref => ({\r\n                summary: this._metadataResolver.getPipeSummary(ref),\r\n                metadata: this._metadataResolver.getPipeMetadata(ref)\r\n            })),\r\n            ...injectables.map(ref => ({\r\n                summary: this._metadataResolver.getInjectableSummary(ref.symbol),\r\n                metadata: this._metadataResolver.getInjectableSummary(ref.symbol).type\r\n            }))\r\n        ];\r\n        const forJitOutputCtx = this._options.enableSummariesForJit ?\r\n            this._createOutputContext(summaryForJitFileName(srcFileName, true)) :\r\n            null;\r\n        const { json, exportAs } = serializeSummaries(srcFileName, forJitOutputCtx, this._summaryResolver, this._symbolResolver, symbolSummaries, typeData, this._options.createExternalSymbolFactoryReexports);\r\n        exportAs.forEach((entry) => {\r\n            ngFactoryCtx.statements.push(variable(entry.exportAs).set(ngFactoryCtx.importExpr(entry.symbol)).toDeclStmt(null, [\r\n                StmtModifier.Exported\r\n            ]));\r\n        });\r\n        const summaryJson = new GeneratedFile(srcFileName, summaryFileName(srcFileName), json);\r\n        const result = [summaryJson];\r\n        if (forJitOutputCtx) {\r\n            result.push(this._codegenSourceModule(srcFileName, forJitOutputCtx));\r\n        }\r\n        return result;\r\n    }\r\n    _compileModule(outputCtx, ngModule) {\r\n        const providers = [];\r\n        if (this._options.locale) {\r\n            const normalizedLocale = this._options.locale.replace(/_/g, '-');\r\n            providers.push({\r\n                token: createTokenForExternalReference(this.reflector, Identifiers$1.LOCALE_ID),\r\n                useValue: normalizedLocale,\r\n            });\r\n        }\r\n        if (this._options.i18nFormat) {\r\n            providers.push({\r\n                token: createTokenForExternalReference(this.reflector, Identifiers$1.TRANSLATIONS_FORMAT),\r\n                useValue: this._options.i18nFormat\r\n            });\r\n        }\r\n        this._ngModuleCompiler.compile(outputCtx, ngModule, providers);\r\n    }\r\n    _compileComponentFactory(outputCtx, compMeta, ngModule, fileSuffix) {\r\n        const hostMeta = this._metadataResolver.getHostComponentMetadata(compMeta);\r\n        const hostViewFactoryVar = this._compileComponent(outputCtx, hostMeta, ngModule, [compMeta.type], null, fileSuffix)\r\n            .viewClassVar;\r\n        const compFactoryVar = componentFactoryName(compMeta.type.reference);\r\n        const inputsExprs = [];\r\n        for (let propName in compMeta.inputs) {\r\n            const templateName = compMeta.inputs[propName];\r\n            // Don't quote so that the key gets minified...\r\n            inputsExprs.push(new LiteralMapEntry(propName, literal(templateName), false));\r\n        }\r\n        const outputsExprs = [];\r\n        for (let propName in compMeta.outputs) {\r\n            const templateName = compMeta.outputs[propName];\r\n            // Don't quote so that the key gets minified...\r\n            outputsExprs.push(new LiteralMapEntry(propName, literal(templateName), false));\r\n        }\r\n        outputCtx.statements.push(variable(compFactoryVar)\r\n            .set(importExpr(Identifiers$1.createComponentFactory).callFn([\r\n            literal(compMeta.selector), outputCtx.importExpr(compMeta.type.reference),\r\n            variable(hostViewFactoryVar), new LiteralMapExpr(inputsExprs),\r\n            new LiteralMapExpr(outputsExprs),\r\n            literalArr(compMeta.template.ngContentSelectors.map(selector => literal(selector)))\r\n        ]))\r\n            .toDeclStmt(importType(Identifiers$1.ComponentFactory, [expressionType(outputCtx.importExpr(compMeta.type.reference))], [TypeModifier.Const]), [StmtModifier.Final, StmtModifier.Exported]));\r\n    }\r\n    _compileComponent(outputCtx, compMeta, ngModule, directiveIdentifiers, componentStyles, fileSuffix) {\r\n        const { template: parsedTemplate, pipes: usedPipes } = this._parseTemplate(compMeta, ngModule, directiveIdentifiers);\r\n        const stylesExpr = componentStyles ? variable(componentStyles.stylesVar) : literalArr([]);\r\n        const viewResult = this._viewCompiler.compileComponent(outputCtx, compMeta, parsedTemplate, stylesExpr, usedPipes);\r\n        if (componentStyles) {\r\n            _resolveStyleStatements(this._symbolResolver, componentStyles, this._styleCompiler.needsStyleShim(compMeta), fileSuffix);\r\n        }\r\n        return viewResult;\r\n    }\r\n    _parseTemplate(compMeta, ngModule, directiveIdentifiers) {\r\n        if (this._templateAstCache.has(compMeta.type.reference)) {\r\n            return this._templateAstCache.get(compMeta.type.reference);\r\n        }\r\n        const preserveWhitespaces = compMeta.template.preserveWhitespaces;\r\n        const directives = directiveIdentifiers.map(dir => this._metadataResolver.getDirectiveSummary(dir.reference));\r\n        const pipes = ngModule.transitiveModule.pipes.map(pipe => this._metadataResolver.getPipeSummary(pipe.reference));\r\n        const result = this._templateParser.parse(compMeta, compMeta.template.htmlAst, directives, pipes, ngModule.schemas, templateSourceUrl(ngModule.type, compMeta, compMeta.template), preserveWhitespaces);\r\n        this._templateAstCache.set(compMeta.type.reference, result);\r\n        return result;\r\n    }\r\n    _createOutputContext(genFilePath) {\r\n        const importExpr$1 = (symbol, typeParams = null, useSummaries = true) => {\r\n            if (!(symbol instanceof StaticSymbol)) {\r\n                throw new Error(`Internal error: unknown identifier ${JSON.stringify(symbol)}`);\r\n            }\r\n            const arity = this._symbolResolver.getTypeArity(symbol) || 0;\r\n            const { filePath, name, members } = this._symbolResolver.getImportAs(symbol, useSummaries) || symbol;\r\n            const importModule = this._fileNameToModuleName(filePath, genFilePath);\r\n            // It should be good enough to compare filePath to genFilePath and if they are equal\r\n            // there is a self reference. However, ngfactory files generate to .ts but their\r\n            // symbols have .d.ts so a simple compare is insufficient. They should be canonical\r\n            // and is tracked by #17705.\r\n            const selfReference = this._fileNameToModuleName(genFilePath, genFilePath);\r\n            const moduleName = importModule === selfReference ? null : importModule;\r\n            // If we are in a type expression that refers to a generic type then supply\r\n            // the required type parameters. If there were not enough type parameters\r\n            // supplied, supply any as the type. Outside a type expression the reference\r\n            // should not supply type parameters and be treated as a simple value reference\r\n            // to the constructor function itself.\r\n            const suppliedTypeParams = typeParams || [];\r\n            const missingTypeParamsCount = arity - suppliedTypeParams.length;\r\n            const allTypeParams = suppliedTypeParams.concat(newArray(missingTypeParamsCount, DYNAMIC_TYPE));\r\n            return members.reduce((expr, memberName) => expr.prop(memberName), importExpr(new ExternalReference(moduleName, name, null), allTypeParams));\r\n        };\r\n        return { statements: [], genFilePath, importExpr: importExpr$1, constantPool: new ConstantPool() };\r\n    }\r\n    _fileNameToModuleName(importedFilePath, containingFilePath) {\r\n        return this._summaryResolver.getKnownModuleName(importedFilePath) ||\r\n            this._symbolResolver.getKnownModuleName(importedFilePath) ||\r\n            this._host.fileNameToModuleName(importedFilePath, containingFilePath);\r\n    }\r\n    _codegenStyles(srcFileUrl, compMeta, stylesheetMetadata, isShimmed, fileSuffix) {\r\n        const outputCtx = this._createOutputContext(_stylesModuleUrl(stylesheetMetadata.moduleUrl, isShimmed, fileSuffix));\r\n        const compiledStylesheet = this._styleCompiler.compileStyles(outputCtx, compMeta, stylesheetMetadata, isShimmed);\r\n        _resolveStyleStatements(this._symbolResolver, compiledStylesheet, isShimmed, fileSuffix);\r\n        return this._codegenSourceModule(srcFileUrl, outputCtx);\r\n    }\r\n    _codegenSourceModule(srcFileUrl, ctx) {\r\n        return new GeneratedFile(srcFileUrl, ctx.genFilePath, ctx.statements);\r\n    }\r\n    listLazyRoutes(entryRoute, analyzedModules) {\r\n        const self = this;\r\n        if (entryRoute) {\r\n            const symbol = parseLazyRoute(entryRoute, this.reflector).referencedModule;\r\n            return visitLazyRoute(symbol);\r\n        }\r\n        else if (analyzedModules) {\r\n            const allLazyRoutes = [];\r\n            for (const ngModule of analyzedModules.ngModules) {\r\n                const lazyRoutes = listLazyRoutes(ngModule, this.reflector);\r\n                for (const lazyRoute of lazyRoutes) {\r\n                    allLazyRoutes.push(lazyRoute);\r\n                }\r\n            }\r\n            return allLazyRoutes;\r\n        }\r\n        else {\r\n            throw new Error(`Either route or analyzedModules has to be specified!`);\r\n        }\r\n        function visitLazyRoute(symbol, seenRoutes = new Set(), allLazyRoutes = []) {\r\n            // Support pointing to default exports, but stop recursing there,\r\n            // as the StaticReflector does not yet support default exports.\r\n            if (seenRoutes.has(symbol) || !symbol.name) {\r\n                return allLazyRoutes;\r\n            }\r\n            seenRoutes.add(symbol);\r\n            const lazyRoutes = listLazyRoutes(self._metadataResolver.getNgModuleMetadata(symbol, true), self.reflector);\r\n            for (const lazyRoute of lazyRoutes) {\r\n                allLazyRoutes.push(lazyRoute);\r\n                visitLazyRoute(lazyRoute.referencedModule, seenRoutes, allLazyRoutes);\r\n            }\r\n            return allLazyRoutes;\r\n        }\r\n    }\r\n}\r\nfunction _createEmptyStub(outputCtx) {\r\n    // Note: We need to produce at least one import statement so that\r\n    // TypeScript knows that the file is an es6 module. Otherwise our generated\r\n    // exports / imports won't be emitted properly by TypeScript.\r\n    outputCtx.statements.push(importExpr(Identifiers$1.ComponentFactory).toStmt());\r\n}\r\nfunction _resolveStyleStatements(symbolResolver, compileResult, needsShim, fileSuffix) {\r\n    compileResult.dependencies.forEach((dep) => {\r\n        dep.setValue(symbolResolver.getStaticSymbol(_stylesModuleUrl(dep.moduleUrl, needsShim, fileSuffix), dep.name));\r\n    });\r\n}\r\nfunction _stylesModuleUrl(stylesheetUrl, shim, suffix) {\r\n    return `${stylesheetUrl}${shim ? '.shim' : ''}.ngstyle${suffix}`;\r\n}\r\nfunction analyzeNgModules(fileNames, host, staticSymbolResolver, metadataResolver) {\r\n    const files = _analyzeFilesIncludingNonProgramFiles(fileNames, host, staticSymbolResolver, metadataResolver);\r\n    return mergeAnalyzedFiles(files);\r\n}\r\nfunction analyzeAndValidateNgModules(fileNames, host, staticSymbolResolver, metadataResolver) {\r\n    return validateAnalyzedModules(analyzeNgModules(fileNames, host, staticSymbolResolver, metadataResolver));\r\n}\r\nfunction validateAnalyzedModules(analyzedModules) {\r\n    if (analyzedModules.symbolsMissingModule && analyzedModules.symbolsMissingModule.length) {\r\n        const messages = analyzedModules.symbolsMissingModule.map(s => `Cannot determine the module for class ${s.name} in ${s.filePath}! Add ${s.name} to the NgModule to fix it.`);\r\n        throw syntaxError(messages.join('\\n'));\r\n    }\r\n    return analyzedModules;\r\n}\r\n// Analyzes all of the program files,\r\n// including files that are not part of the program\r\n// but are referenced by an NgModule.\r\nfunction _analyzeFilesIncludingNonProgramFiles(fileNames, host, staticSymbolResolver, metadataResolver) {\r\n    const seenFiles = new Set();\r\n    const files = [];\r\n    const visitFile = (fileName) => {\r\n        if (seenFiles.has(fileName) || !host.isSourceFile(fileName)) {\r\n            return false;\r\n        }\r\n        seenFiles.add(fileName);\r\n        const analyzedFile = analyzeFile(host, staticSymbolResolver, metadataResolver, fileName);\r\n        files.push(analyzedFile);\r\n        analyzedFile.ngModules.forEach(ngModule => {\r\n            ngModule.transitiveModule.modules.forEach(modMeta => visitFile(modMeta.reference.filePath));\r\n        });\r\n    };\r\n    fileNames.forEach((fileName) => visitFile(fileName));\r\n    return files;\r\n}\r\nfunction analyzeFile(host, staticSymbolResolver, metadataResolver, fileName) {\r\n    const abstractDirectives = [];\r\n    const directives = [];\r\n    const pipes = [];\r\n    const injectables = [];\r\n    const ngModules = [];\r\n    const hasDecorators = staticSymbolResolver.hasDecorators(fileName);\r\n    let exportsNonSourceFiles = false;\r\n    const isDeclarationFile = fileName.endsWith('.d.ts');\r\n    // Don't analyze .d.ts files that have no decorators as a shortcut\r\n    // to speed up the analysis. This prevents us from\r\n    // resolving the references in these files.\r\n    // Note: exportsNonSourceFiles is only needed when compiling with summaries,\r\n    // which is not the case when .d.ts files are treated as input files.\r\n    if (!isDeclarationFile || hasDecorators) {\r\n        staticSymbolResolver.getSymbolsOf(fileName).forEach((symbol) => {\r\n            const resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\r\n            const symbolMeta = resolvedSymbol.metadata;\r\n            if (!symbolMeta || symbolMeta.__symbolic === 'error') {\r\n                return;\r\n            }\r\n            let isNgSymbol = false;\r\n            if (symbolMeta.__symbolic === 'class') {\r\n                if (metadataResolver.isDirective(symbol)) {\r\n                    isNgSymbol = true;\r\n                    // This directive either has a selector or doesn't. Selector-less directives get tracked\r\n                    // in abstractDirectives, not directives. The compiler doesn't deal with selector-less\r\n                    // directives at all, really, other than to persist their metadata. This is done so that\r\n                    // apps will have an easier time migrating to Ivy, which requires the selector-less\r\n                    // annotations to be applied.\r\n                    if (!metadataResolver.isAbstractDirective(symbol)) {\r\n                        // The directive is an ordinary directive.\r\n                        directives.push(symbol);\r\n                    }\r\n                    else {\r\n                        // The directive has no selector and is an \"abstract\" directive, so track it\r\n                        // accordingly.\r\n                        abstractDirectives.push(symbol);\r\n                    }\r\n                }\r\n                else if (metadataResolver.isPipe(symbol)) {\r\n                    isNgSymbol = true;\r\n                    pipes.push(symbol);\r\n                }\r\n                else if (metadataResolver.isNgModule(symbol)) {\r\n                    const ngModule = metadataResolver.getNgModuleMetadata(symbol, false);\r\n                    if (ngModule) {\r\n                        isNgSymbol = true;\r\n                        ngModules.push(ngModule);\r\n                    }\r\n                }\r\n                else if (metadataResolver.isInjectable(symbol)) {\r\n                    isNgSymbol = true;\r\n                    const injectable = metadataResolver.getInjectableMetadata(symbol, null, false);\r\n                    if (injectable) {\r\n                        injectables.push(injectable);\r\n                    }\r\n                }\r\n            }\r\n            if (!isNgSymbol) {\r\n                exportsNonSourceFiles =\r\n                    exportsNonSourceFiles || isValueExportingNonSourceFile(host, symbolMeta);\r\n            }\r\n        });\r\n    }\r\n    return {\r\n        fileName,\r\n        directives,\r\n        abstractDirectives,\r\n        pipes,\r\n        ngModules,\r\n        injectables,\r\n        exportsNonSourceFiles,\r\n    };\r\n}\r\nfunction analyzeFileForInjectables(host, staticSymbolResolver, metadataResolver, fileName) {\r\n    const injectables = [];\r\n    const shallowModules = [];\r\n    if (staticSymbolResolver.hasDecorators(fileName)) {\r\n        staticSymbolResolver.getSymbolsOf(fileName).forEach((symbol) => {\r\n            const resolvedSymbol = staticSymbolResolver.resolveSymbol(symbol);\r\n            const symbolMeta = resolvedSymbol.metadata;\r\n            if (!symbolMeta || symbolMeta.__symbolic === 'error') {\r\n                return;\r\n            }\r\n            if (symbolMeta.__symbolic === 'class') {\r\n                if (metadataResolver.isInjectable(symbol)) {\r\n                    const injectable = metadataResolver.getInjectableMetadata(symbol, null, false);\r\n                    if (injectable) {\r\n                        injectables.push(injectable);\r\n                    }\r\n                }\r\n                else if (metadataResolver.isNgModule(symbol)) {\r\n                    const module = metadataResolver.getShallowModuleMetadata(symbol);\r\n                    if (module) {\r\n                        shallowModules.push(module);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return { fileName, injectables, shallowModules };\r\n}\r\nfunction isValueExportingNonSourceFile(host, metadata) {\r\n    let exportsNonSourceFiles = false;\r\n    class Visitor {\r\n        visitArray(arr, context) {\r\n            arr.forEach(v => visitValue(v, this, context));\r\n        }\r\n        visitStringMap(map, context) {\r\n            Object.keys(map).forEach((key) => visitValue(map[key], this, context));\r\n        }\r\n        visitPrimitive(value, context) { }\r\n        visitOther(value, context) {\r\n            if (value instanceof StaticSymbol && !host.isSourceFile(value.filePath)) {\r\n                exportsNonSourceFiles = true;\r\n            }\r\n        }\r\n    }\r\n    visitValue(metadata, new Visitor(), null);\r\n    return exportsNonSourceFiles;\r\n}\r\nfunction mergeAnalyzedFiles(analyzedFiles) {\r\n    const allNgModules = [];\r\n    const ngModuleByPipeOrDirective = new Map();\r\n    const allPipesAndDirectives = new Set();\r\n    analyzedFiles.forEach(af => {\r\n        af.ngModules.forEach(ngModule => {\r\n            allNgModules.push(ngModule);\r\n            ngModule.declaredDirectives.forEach(d => ngModuleByPipeOrDirective.set(d.reference, ngModule));\r\n            ngModule.declaredPipes.forEach(p => ngModuleByPipeOrDirective.set(p.reference, ngModule));\r\n        });\r\n        af.directives.forEach(d => allPipesAndDirectives.add(d));\r\n        af.pipes.forEach(p => allPipesAndDirectives.add(p));\r\n    });\r\n    const symbolsMissingModule = [];\r\n    allPipesAndDirectives.forEach(ref => {\r\n        if (!ngModuleByPipeOrDirective.has(ref)) {\r\n            symbolsMissingModule.push(ref);\r\n        }\r\n    });\r\n    return {\r\n        ngModules: allNgModules,\r\n        ngModuleByPipeOrDirective,\r\n        symbolsMissingModule,\r\n        files: analyzedFiles\r\n    };\r\n}\r\nfunction mergeAndValidateNgFiles(files) {\r\n    return validateAnalyzedModules(mergeAnalyzedFiles(files));\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst FORMATTED_MESSAGE = 'ngFormattedMessage';\r\nfunction indentStr(level) {\r\n    if (level <= 0)\r\n        return '';\r\n    if (level < 6)\r\n        return ['', ' ', '  ', '   ', '    ', '     '][level];\r\n    const half = indentStr(Math.floor(level / 2));\r\n    return half + half + (level % 2 === 1 ? ' ' : '');\r\n}\r\nfunction formatChain(chain, indent = 0) {\r\n    if (!chain)\r\n        return '';\r\n    const position = chain.position ?\r\n        `${chain.position.fileName}(${chain.position.line + 1},${chain.position.column + 1})` :\r\n        '';\r\n    const prefix = position && indent === 0 ? `${position}: ` : '';\r\n    const postfix = position && indent !== 0 ? ` at ${position}` : '';\r\n    let message = `${prefix}${chain.message}${postfix}`;\r\n    if (chain.next) {\r\n        for (const kid of chain.next) {\r\n            message += '\\n' + formatChain(kid, indent + 2);\r\n        }\r\n    }\r\n    return `${indentStr(indent)}${message}`;\r\n}\r\nfunction formattedError(chain) {\r\n    const message = formatChain(chain) + '.';\r\n    const error = syntaxError(message);\r\n    error[FORMATTED_MESSAGE] = true;\r\n    error.chain = chain;\r\n    error.position = chain.position;\r\n    return error;\r\n}\r\nfunction isFormattedError(error) {\r\n    return !!error[FORMATTED_MESSAGE];\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nconst ANGULAR_CORE = '@angular/core';\r\nconst ANGULAR_ROUTER = '@angular/router';\r\nconst HIDDEN_KEY = /^\\$.*\\$$/;\r\nconst IGNORE = {\r\n    __symbolic: 'ignore'\r\n};\r\nconst USE_VALUE$1 = 'useValue';\r\nconst PROVIDE = 'provide';\r\nconst REFERENCE_SET = new Set([USE_VALUE$1, 'useFactory', 'data', 'id', 'loadChildren']);\r\nconst TYPEGUARD_POSTFIX = 'TypeGuard';\r\nconst USE_IF = 'UseIf';\r\nfunction shouldIgnore(value) {\r\n    return value && value.__symbolic == 'ignore';\r\n}\r\n/**\r\n * A static reflector implements enough of the Reflector API that is necessary to compile\r\n * templates statically.\r\n */\r\nclass StaticReflector {\r\n    constructor(summaryResolver, symbolResolver, knownMetadataClasses = [], knownMetadataFunctions = [], errorRecorder) {\r\n        this.summaryResolver = summaryResolver;\r\n        this.symbolResolver = symbolResolver;\r\n        this.errorRecorder = errorRecorder;\r\n        this.annotationCache = new Map();\r\n        this.shallowAnnotationCache = new Map();\r\n        this.propertyCache = new Map();\r\n        this.parameterCache = new Map();\r\n        this.methodCache = new Map();\r\n        this.staticCache = new Map();\r\n        this.conversionMap = new Map();\r\n        this.resolvedExternalReferences = new Map();\r\n        this.annotationForParentClassWithSummaryKind = new Map();\r\n        this.initializeConversionMap();\r\n        knownMetadataClasses.forEach((kc) => this._registerDecoratorOrConstructor(this.getStaticSymbol(kc.filePath, kc.name), kc.ctor));\r\n        knownMetadataFunctions.forEach((kf) => this._registerFunction(this.getStaticSymbol(kf.filePath, kf.name), kf.fn));\r\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Directive, [createDirective, createComponent]);\r\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Pipe, [createPipe]);\r\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.NgModule, [createNgModule]);\r\n        this.annotationForParentClassWithSummaryKind.set(CompileSummaryKind.Injectable, [createInjectable, createPipe, createDirective, createComponent, createNgModule]);\r\n    }\r\n    componentModuleUrl(typeOrFunc) {\r\n        const staticSymbol = this.findSymbolDeclaration(typeOrFunc);\r\n        return this.symbolResolver.getResourcePath(staticSymbol);\r\n    }\r\n    /**\r\n     * Invalidate the specified `symbols` on program change.\r\n     * @param symbols\r\n     */\r\n    invalidateSymbols(symbols) {\r\n        for (const symbol of symbols) {\r\n            this.annotationCache.delete(symbol);\r\n            this.shallowAnnotationCache.delete(symbol);\r\n            this.propertyCache.delete(symbol);\r\n            this.parameterCache.delete(symbol);\r\n            this.methodCache.delete(symbol);\r\n            this.staticCache.delete(symbol);\r\n            this.conversionMap.delete(symbol);\r\n        }\r\n    }\r\n    resolveExternalReference(ref, containingFile) {\r\n        let key = undefined;\r\n        if (!containingFile) {\r\n            key = `${ref.moduleName}:${ref.name}`;\r\n            const declarationSymbol = this.resolvedExternalReferences.get(key);\r\n            if (declarationSymbol)\r\n                return declarationSymbol;\r\n        }\r\n        const refSymbol = this.symbolResolver.getSymbolByModule(ref.moduleName, ref.name, containingFile);\r\n        const declarationSymbol = this.findSymbolDeclaration(refSymbol);\r\n        if (!containingFile) {\r\n            this.symbolResolver.recordModuleNameForFileName(refSymbol.filePath, ref.moduleName);\r\n            this.symbolResolver.recordImportAs(declarationSymbol, refSymbol);\r\n        }\r\n        if (key) {\r\n            this.resolvedExternalReferences.set(key, declarationSymbol);\r\n        }\r\n        return declarationSymbol;\r\n    }\r\n    findDeclaration(moduleUrl, name, containingFile) {\r\n        return this.findSymbolDeclaration(this.symbolResolver.getSymbolByModule(moduleUrl, name, containingFile));\r\n    }\r\n    tryFindDeclaration(moduleUrl, name, containingFile) {\r\n        return this.symbolResolver.ignoreErrorsFor(() => this.findDeclaration(moduleUrl, name, containingFile));\r\n    }\r\n    findSymbolDeclaration(symbol) {\r\n        const resolvedSymbol = this.symbolResolver.resolveSymbol(symbol);\r\n        if (resolvedSymbol) {\r\n            let resolvedMetadata = resolvedSymbol.metadata;\r\n            if (resolvedMetadata && resolvedMetadata.__symbolic === 'resolved') {\r\n                resolvedMetadata = resolvedMetadata.symbol;\r\n            }\r\n            if (resolvedMetadata instanceof StaticSymbol) {\r\n                return this.findSymbolDeclaration(resolvedSymbol.metadata);\r\n            }\r\n        }\r\n        return symbol;\r\n    }\r\n    tryAnnotations(type) {\r\n        const originalRecorder = this.errorRecorder;\r\n        this.errorRecorder = (error, fileName) => { };\r\n        try {\r\n            return this.annotations(type);\r\n        }\r\n        finally {\r\n            this.errorRecorder = originalRecorder;\r\n        }\r\n    }\r\n    annotations(type) {\r\n        return this._annotations(type, (type, decorators) => this.simplify(type, decorators), this.annotationCache);\r\n    }\r\n    shallowAnnotations(type) {\r\n        return this._annotations(type, (type, decorators) => this.simplify(type, decorators, true), this.shallowAnnotationCache);\r\n    }\r\n    _annotations(type, simplify, annotationCache) {\r\n        let annotations = annotationCache.get(type);\r\n        if (!annotations) {\r\n            annotations = [];\r\n            const classMetadata = this.getTypeMetadata(type);\r\n            const parentType = this.findParentType(type, classMetadata);\r\n            if (parentType) {\r\n                const parentAnnotations = this.annotations(parentType);\r\n                annotations.push(...parentAnnotations);\r\n            }\r\n            let ownAnnotations = [];\r\n            if (classMetadata['decorators']) {\r\n                ownAnnotations = simplify(type, classMetadata['decorators']);\r\n                if (ownAnnotations) {\r\n                    annotations.push(...ownAnnotations);\r\n                }\r\n            }\r\n            if (parentType && !this.summaryResolver.isLibraryFile(type.filePath) &&\r\n                this.summaryResolver.isLibraryFile(parentType.filePath)) {\r\n                const summary = this.summaryResolver.resolveSummary(parentType);\r\n                if (summary && summary.type) {\r\n                    const requiredAnnotationTypes = this.annotationForParentClassWithSummaryKind.get(summary.type.summaryKind);\r\n                    const typeHasRequiredAnnotation = requiredAnnotationTypes.some((requiredType) => ownAnnotations.some(ann => requiredType.isTypeOf(ann)));\r\n                    if (!typeHasRequiredAnnotation) {\r\n                        this.reportError(formatMetadataError(metadataError(`Class ${type.name} in ${type.filePath} extends from a ${CompileSummaryKind[summary.type.summaryKind]} in another compilation unit without duplicating the decorator`, \r\n                        /* summary */ undefined, `Please add a ${requiredAnnotationTypes.map((type) => type.ngMetadataName)\r\n                            .join(' or ')} decorator to the class`), type), type);\r\n                    }\r\n                }\r\n            }\r\n            annotationCache.set(type, annotations.filter(ann => !!ann));\r\n        }\r\n        return annotations;\r\n    }\r\n    propMetadata(type) {\r\n        let propMetadata = this.propertyCache.get(type);\r\n        if (!propMetadata) {\r\n            const classMetadata = this.getTypeMetadata(type);\r\n            propMetadata = {};\r\n            const parentType = this.findParentType(type, classMetadata);\r\n            if (parentType) {\r\n                const parentPropMetadata = this.propMetadata(parentType);\r\n                Object.keys(parentPropMetadata).forEach((parentProp) => {\r\n                    propMetadata[parentProp] = parentPropMetadata[parentProp];\r\n                });\r\n            }\r\n            const members = classMetadata['members'] || {};\r\n            Object.keys(members).forEach((propName) => {\r\n                const propData = members[propName];\r\n                const prop = propData\r\n                    .find(a => a['__symbolic'] == 'property' || a['__symbolic'] == 'method');\r\n                const decorators = [];\r\n                // hasOwnProperty() is used here to make sure we do not look up methods\r\n                // on `Object.prototype`.\r\n                if (propMetadata === null || propMetadata === void 0 ? void 0 : propMetadata.hasOwnProperty(propName)) {\r\n                    decorators.push(...propMetadata[propName]);\r\n                }\r\n                propMetadata[propName] = decorators;\r\n                if (prop && prop['decorators']) {\r\n                    decorators.push(...this.simplify(type, prop['decorators']));\r\n                }\r\n            });\r\n            this.propertyCache.set(type, propMetadata);\r\n        }\r\n        return propMetadata;\r\n    }\r\n    parameters(type) {\r\n        if (!(type instanceof StaticSymbol)) {\r\n            this.reportError(new Error(`parameters received ${JSON.stringify(type)} which is not a StaticSymbol`), type);\r\n            return [];\r\n        }\r\n        try {\r\n            let parameters = this.parameterCache.get(type);\r\n            if (!parameters) {\r\n                const classMetadata = this.getTypeMetadata(type);\r\n                const parentType = this.findParentType(type, classMetadata);\r\n                const members = classMetadata ? classMetadata['members'] : null;\r\n                const ctorData = members ? members['__ctor__'] : null;\r\n                if (ctorData) {\r\n                    const ctor = ctorData.find(a => a['__symbolic'] == 'constructor');\r\n                    const rawParameterTypes = ctor['parameters'] || [];\r\n                    const parameterDecorators = this.simplify(type, ctor['parameterDecorators'] || []);\r\n                    parameters = [];\r\n                    rawParameterTypes.forEach((rawParamType, index) => {\r\n                        const nestedResult = [];\r\n                        const paramType = this.trySimplify(type, rawParamType);\r\n                        if (paramType)\r\n                            nestedResult.push(paramType);\r\n                        const decorators = parameterDecorators ? parameterDecorators[index] : null;\r\n                        if (decorators) {\r\n                            nestedResult.push(...decorators);\r\n                        }\r\n                        parameters.push(nestedResult);\r\n                    });\r\n                }\r\n                else if (parentType) {\r\n                    parameters = this.parameters(parentType);\r\n                }\r\n                if (!parameters) {\r\n                    parameters = [];\r\n                }\r\n                this.parameterCache.set(type, parameters);\r\n            }\r\n            return parameters;\r\n        }\r\n        catch (e) {\r\n            console.error(`Failed on type ${JSON.stringify(type)} with error ${e}`);\r\n            throw e;\r\n        }\r\n    }\r\n    _methodNames(type) {\r\n        let methodNames = this.methodCache.get(type);\r\n        if (!methodNames) {\r\n            const classMetadata = this.getTypeMetadata(type);\r\n            methodNames = {};\r\n            const parentType = this.findParentType(type, classMetadata);\r\n            if (parentType) {\r\n                const parentMethodNames = this._methodNames(parentType);\r\n                Object.keys(parentMethodNames).forEach((parentProp) => {\r\n                    methodNames[parentProp] = parentMethodNames[parentProp];\r\n                });\r\n            }\r\n            const members = classMetadata['members'] || {};\r\n            Object.keys(members).forEach((propName) => {\r\n                const propData = members[propName];\r\n                const isMethod = propData.some(a => a['__symbolic'] == 'method');\r\n                methodNames[propName] = methodNames[propName] || isMethod;\r\n            });\r\n            this.methodCache.set(type, methodNames);\r\n        }\r\n        return methodNames;\r\n    }\r\n    _staticMembers(type) {\r\n        let staticMembers = this.staticCache.get(type);\r\n        if (!staticMembers) {\r\n            const classMetadata = this.getTypeMetadata(type);\r\n            const staticMemberData = classMetadata['statics'] || {};\r\n            staticMembers = Object.keys(staticMemberData);\r\n            this.staticCache.set(type, staticMembers);\r\n        }\r\n        return staticMembers;\r\n    }\r\n    findParentType(type, classMetadata) {\r\n        const parentType = this.trySimplify(type, classMetadata['extends']);\r\n        if (parentType instanceof StaticSymbol) {\r\n            return parentType;\r\n        }\r\n    }\r\n    hasLifecycleHook(type, lcProperty) {\r\n        if (!(type instanceof StaticSymbol)) {\r\n            this.reportError(new Error(`hasLifecycleHook received ${JSON.stringify(type)} which is not a StaticSymbol`), type);\r\n        }\r\n        try {\r\n            return !!this._methodNames(type)[lcProperty];\r\n        }\r\n        catch (e) {\r\n            console.error(`Failed on type ${JSON.stringify(type)} with error ${e}`);\r\n            throw e;\r\n        }\r\n    }\r\n    guards(type) {\r\n        if (!(type instanceof StaticSymbol)) {\r\n            this.reportError(new Error(`guards received ${JSON.stringify(type)} which is not a StaticSymbol`), type);\r\n            return {};\r\n        }\r\n        const staticMembers = this._staticMembers(type);\r\n        const result = {};\r\n        for (let name of staticMembers) {\r\n            if (name.endsWith(TYPEGUARD_POSTFIX)) {\r\n                let property = name.substr(0, name.length - TYPEGUARD_POSTFIX.length);\r\n                let value;\r\n                if (property.endsWith(USE_IF)) {\r\n                    property = name.substr(0, property.length - USE_IF.length);\r\n                    value = USE_IF;\r\n                }\r\n                else {\r\n                    value = this.getStaticSymbol(type.filePath, type.name, [name]);\r\n                }\r\n                result[property] = value;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    _registerDecoratorOrConstructor(type, ctor) {\r\n        this.conversionMap.set(type, (context, args) => new ctor(...args));\r\n    }\r\n    _registerFunction(type, fn) {\r\n        this.conversionMap.set(type, (context, args) => fn.apply(undefined, args));\r\n    }\r\n    initializeConversionMap() {\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Injectable'), createInjectable);\r\n        this.injectionToken = this.findDeclaration(ANGULAR_CORE, 'InjectionToken');\r\n        this.opaqueToken = this.findDeclaration(ANGULAR_CORE, 'OpaqueToken');\r\n        this.ROUTES = this.tryFindDeclaration(ANGULAR_ROUTER, 'ROUTES');\r\n        this.ANALYZE_FOR_ENTRY_COMPONENTS =\r\n            this.findDeclaration(ANGULAR_CORE, 'ANALYZE_FOR_ENTRY_COMPONENTS');\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), createHost);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), createSelf);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), createSkipSelf);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Inject'), createInject);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), createOptional);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Attribute'), createAttribute);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChild'), createContentChild);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ContentChildren'), createContentChildren);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChild'), createViewChild);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'ViewChildren'), createViewChildren);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Input'), createInput);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Output'), createOutput);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Pipe'), createPipe);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostBinding'), createHostBinding);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'HostListener'), createHostListener);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Directive'), createDirective);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Component'), createComponent);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'NgModule'), createNgModule);\r\n        // Note: Some metadata classes can be used directly with Provider.deps.\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Host'), createHost);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Self'), createSelf);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'SkipSelf'), createSkipSelf);\r\n        this._registerDecoratorOrConstructor(this.findDeclaration(ANGULAR_CORE, 'Optional'), createOptional);\r\n    }\r\n    /**\r\n     * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\r\n     * All types passed to the StaticResolver should be pseudo-types returned by this method.\r\n     *\r\n     * @param declarationFile the absolute path of the file where the symbol is declared\r\n     * @param name the name of the type.\r\n     */\r\n    getStaticSymbol(declarationFile, name, members) {\r\n        return this.symbolResolver.getStaticSymbol(declarationFile, name, members);\r\n    }\r\n    /**\r\n     * Simplify but discard any errors\r\n     */\r\n    trySimplify(context, value) {\r\n        const originalRecorder = this.errorRecorder;\r\n        this.errorRecorder = (error, fileName) => { };\r\n        const result = this.simplify(context, value);\r\n        this.errorRecorder = originalRecorder;\r\n        return result;\r\n    }\r\n    /** @internal */\r\n    simplify(context, value, lazy = false) {\r\n        const self = this;\r\n        let scope = BindingScope$1.empty;\r\n        const calling = new Map();\r\n        const rootContext = context;\r\n        function simplifyInContext(context, value, depth, references) {\r\n            function resolveReferenceValue(staticSymbol) {\r\n                const resolvedSymbol = self.symbolResolver.resolveSymbol(staticSymbol);\r\n                return resolvedSymbol ? resolvedSymbol.metadata : null;\r\n            }\r\n            function simplifyEagerly(value) {\r\n                return simplifyInContext(context, value, depth, 0);\r\n            }\r\n            function simplifyLazily(value) {\r\n                return simplifyInContext(context, value, depth, references + 1);\r\n            }\r\n            function simplifyNested(nestedContext, value) {\r\n                if (nestedContext === context) {\r\n                    // If the context hasn't changed let the exception propagate unmodified.\r\n                    return simplifyInContext(nestedContext, value, depth + 1, references);\r\n                }\r\n                try {\r\n                    return simplifyInContext(nestedContext, value, depth + 1, references);\r\n                }\r\n                catch (e) {\r\n                    if (isMetadataError(e)) {\r\n                        // Propagate the message text up but add a message to the chain that explains how we got\r\n                        // here.\r\n                        // e.chain implies e.symbol\r\n                        const summaryMsg = e.chain ? 'references \\'' + e.symbol.name + '\\'' : errorSummary(e);\r\n                        const summary = `'${nestedContext.name}' ${summaryMsg}`;\r\n                        const chain = { message: summary, position: e.position, next: e.chain };\r\n                        // TODO(chuckj): retrieve the position information indirectly from the collectors node\r\n                        // map if the metadata is from a .ts file.\r\n                        self.error({\r\n                            message: e.message,\r\n                            advise: e.advise,\r\n                            context: e.context,\r\n                            chain,\r\n                            symbol: nestedContext\r\n                        }, context);\r\n                    }\r\n                    else {\r\n                        // It is probably an internal error.\r\n                        throw e;\r\n                    }\r\n                }\r\n            }\r\n            function simplifyCall(functionSymbol, targetFunction, args, targetExpression) {\r\n                if (targetFunction && targetFunction['__symbolic'] == 'function') {\r\n                    if (calling.get(functionSymbol)) {\r\n                        self.error({\r\n                            message: 'Recursion is not supported',\r\n                            summary: `called '${functionSymbol.name}' recursively`,\r\n                            value: targetFunction\r\n                        }, functionSymbol);\r\n                    }\r\n                    try {\r\n                        const value = targetFunction['value'];\r\n                        if (value && (depth != 0 || value.__symbolic != 'error')) {\r\n                            const parameters = targetFunction['parameters'];\r\n                            const defaults = targetFunction.defaults;\r\n                            args = args.map(arg => simplifyNested(context, arg))\r\n                                .map(arg => shouldIgnore(arg) ? undefined : arg);\r\n                            if (defaults && defaults.length > args.length) {\r\n                                args.push(...defaults.slice(args.length).map((value) => simplify(value)));\r\n                            }\r\n                            calling.set(functionSymbol, true);\r\n                            const functionScope = BindingScope$1.build();\r\n                            for (let i = 0; i < parameters.length; i++) {\r\n                                functionScope.define(parameters[i], args[i]);\r\n                            }\r\n                            const oldScope = scope;\r\n                            let result;\r\n                            try {\r\n                                scope = functionScope.done();\r\n                                result = simplifyNested(functionSymbol, value);\r\n                            }\r\n                            finally {\r\n                                scope = oldScope;\r\n                            }\r\n                            return result;\r\n                        }\r\n                    }\r\n                    finally {\r\n                        calling.delete(functionSymbol);\r\n                    }\r\n                }\r\n                if (depth === 0) {\r\n                    // If depth is 0 we are evaluating the top level expression that is describing element\r\n                    // decorator. In this case, it is a decorator we don't understand, such as a custom\r\n                    // non-angular decorator, and we should just ignore it.\r\n                    return IGNORE;\r\n                }\r\n                let position = undefined;\r\n                if (targetExpression && targetExpression.__symbolic == 'resolved') {\r\n                    const line = targetExpression.line;\r\n                    const character = targetExpression.character;\r\n                    const fileName = targetExpression.fileName;\r\n                    if (fileName != null && line != null && character != null) {\r\n                        position = { fileName, line, column: character };\r\n                    }\r\n                }\r\n                self.error({\r\n                    message: FUNCTION_CALL_NOT_SUPPORTED,\r\n                    context: functionSymbol,\r\n                    value: targetFunction,\r\n                    position\r\n                }, context);\r\n            }\r\n            function simplify(expression) {\r\n                if (isPrimitive(expression)) {\r\n                    return expression;\r\n                }\r\n                if (Array.isArray(expression)) {\r\n                    const result = [];\r\n                    for (const item of expression) {\r\n                        // Check for a spread expression\r\n                        if (item && item.__symbolic === 'spread') {\r\n                            // We call with references as 0 because we require the actual value and cannot\r\n                            // tolerate a reference here.\r\n                            const spreadArray = simplifyEagerly(item.expression);\r\n                            if (Array.isArray(spreadArray)) {\r\n                                for (const spreadItem of spreadArray) {\r\n                                    result.push(spreadItem);\r\n                                }\r\n                                continue;\r\n                            }\r\n                        }\r\n                        const value = simplify(item);\r\n                        if (shouldIgnore(value)) {\r\n                            continue;\r\n                        }\r\n                        result.push(value);\r\n                    }\r\n                    return result;\r\n                }\r\n                if (expression instanceof StaticSymbol) {\r\n                    // Stop simplification at builtin symbols or if we are in a reference context and\r\n                    // the symbol doesn't have members.\r\n                    if (expression === self.injectionToken || self.conversionMap.has(expression) ||\r\n                        (references > 0 && !expression.members.length)) {\r\n                        return expression;\r\n                    }\r\n                    else {\r\n                        const staticSymbol = expression;\r\n                        const declarationValue = resolveReferenceValue(staticSymbol);\r\n                        if (declarationValue != null) {\r\n                            return simplifyNested(staticSymbol, declarationValue);\r\n                        }\r\n                        else {\r\n                            return staticSymbol;\r\n                        }\r\n                    }\r\n                }\r\n                if (expression) {\r\n                    if (expression['__symbolic']) {\r\n                        let staticSymbol;\r\n                        switch (expression['__symbolic']) {\r\n                            case 'binop':\r\n                                let left = simplify(expression['left']);\r\n                                if (shouldIgnore(left))\r\n                                    return left;\r\n                                let right = simplify(expression['right']);\r\n                                if (shouldIgnore(right))\r\n                                    return right;\r\n                                switch (expression['operator']) {\r\n                                    case '&&':\r\n                                        return left && right;\r\n                                    case '||':\r\n                                        return left || right;\r\n                                    case '|':\r\n                                        return left | right;\r\n                                    case '^':\r\n                                        return left ^ right;\r\n                                    case '&':\r\n                                        return left & right;\r\n                                    case '==':\r\n                                        return left == right;\r\n                                    case '!=':\r\n                                        return left != right;\r\n                                    case '===':\r\n                                        return left === right;\r\n                                    case '!==':\r\n                                        return left !== right;\r\n                                    case '<':\r\n                                        return left < right;\r\n                                    case '>':\r\n                                        return left > right;\r\n                                    case '<=':\r\n                                        return left <= right;\r\n                                    case '>=':\r\n                                        return left >= right;\r\n                                    case '<<':\r\n                                        return left << right;\r\n                                    case '>>':\r\n                                        return left >> right;\r\n                                    case '+':\r\n                                        return left + right;\r\n                                    case '-':\r\n                                        return left - right;\r\n                                    case '*':\r\n                                        return left * right;\r\n                                    case '/':\r\n                                        return left / right;\r\n                                    case '%':\r\n                                        return left % right;\r\n                                    case '??':\r\n                                        return left !== null && left !== void 0 ? left : right;\r\n                                }\r\n                                return null;\r\n                            case 'if':\r\n                                let condition = simplify(expression['condition']);\r\n                                return condition ? simplify(expression['thenExpression']) :\r\n                                    simplify(expression['elseExpression']);\r\n                            case 'pre':\r\n                                let operand = simplify(expression['operand']);\r\n                                if (shouldIgnore(operand))\r\n                                    return operand;\r\n                                switch (expression['operator']) {\r\n                                    case '+':\r\n                                        return operand;\r\n                                    case '-':\r\n                                        return -operand;\r\n                                    case '!':\r\n                                        return !operand;\r\n                                    case '~':\r\n                                        return ~operand;\r\n                                }\r\n                                return null;\r\n                            case 'index':\r\n                                let indexTarget = simplifyEagerly(expression['expression']);\r\n                                let index = simplifyEagerly(expression['index']);\r\n                                if (indexTarget && isPrimitive(index))\r\n                                    return indexTarget[index];\r\n                                return null;\r\n                            case 'select':\r\n                                const member = expression['member'];\r\n                                let selectContext = context;\r\n                                let selectTarget = simplify(expression['expression']);\r\n                                if (selectTarget instanceof StaticSymbol) {\r\n                                    const members = selectTarget.members.concat(member);\r\n                                    selectContext =\r\n                                        self.getStaticSymbol(selectTarget.filePath, selectTarget.name, members);\r\n                                    const declarationValue = resolveReferenceValue(selectContext);\r\n                                    if (declarationValue != null) {\r\n                                        return simplifyNested(selectContext, declarationValue);\r\n                                    }\r\n                                    else {\r\n                                        return selectContext;\r\n                                    }\r\n                                }\r\n                                if (selectTarget && isPrimitive(member))\r\n                                    return simplifyNested(selectContext, selectTarget[member]);\r\n                                return null;\r\n                            case 'reference':\r\n                                // Note: This only has to deal with variable references, as symbol references have\r\n                                // been converted into 'resolved'\r\n                                // in the StaticSymbolResolver.\r\n                                const name = expression['name'];\r\n                                const localValue = scope.resolve(name);\r\n                                if (localValue != BindingScope$1.missing) {\r\n                                    return localValue;\r\n                                }\r\n                                break;\r\n                            case 'resolved':\r\n                                try {\r\n                                    return simplify(expression.symbol);\r\n                                }\r\n                                catch (e) {\r\n                                    // If an error is reported evaluating the symbol record the position of the\r\n                                    // reference in the error so it can\r\n                                    // be reported in the error message generated from the exception.\r\n                                    if (isMetadataError(e) && expression.fileName != null &&\r\n                                        expression.line != null && expression.character != null) {\r\n                                        e.position = {\r\n                                            fileName: expression.fileName,\r\n                                            line: expression.line,\r\n                                            column: expression.character\r\n                                        };\r\n                                    }\r\n                                    throw e;\r\n                                }\r\n                            case 'class':\r\n                                return context;\r\n                            case 'function':\r\n                                return context;\r\n                            case 'new':\r\n                            case 'call':\r\n                                // Determine if the function is a built-in conversion\r\n                                staticSymbol = simplifyInContext(context, expression['expression'], depth + 1, /* references */ 0);\r\n                                if (staticSymbol instanceof StaticSymbol) {\r\n                                    if (staticSymbol === self.injectionToken || staticSymbol === self.opaqueToken) {\r\n                                        // if somebody calls new InjectionToken, don't create an InjectionToken,\r\n                                        // but rather return the symbol to which the InjectionToken is assigned to.\r\n                                        // OpaqueToken is supported too as it is required by the language service to\r\n                                        // support v4 and prior versions of Angular.\r\n                                        return context;\r\n                                    }\r\n                                    const argExpressions = expression['arguments'] || [];\r\n                                    let converter = self.conversionMap.get(staticSymbol);\r\n                                    if (converter) {\r\n                                        const args = argExpressions.map(arg => simplifyNested(context, arg))\r\n                                            .map(arg => shouldIgnore(arg) ? undefined : arg);\r\n                                        return converter(context, args);\r\n                                    }\r\n                                    else {\r\n                                        // Determine if the function is one we can simplify.\r\n                                        const targetFunction = resolveReferenceValue(staticSymbol);\r\n                                        return simplifyCall(staticSymbol, targetFunction, argExpressions, expression['expression']);\r\n                                    }\r\n                                }\r\n                                return IGNORE;\r\n                            case 'error':\r\n                                let message = expression.message;\r\n                                if (expression['line'] != null) {\r\n                                    self.error({\r\n                                        message,\r\n                                        context: expression.context,\r\n                                        value: expression,\r\n                                        position: {\r\n                                            fileName: expression['fileName'],\r\n                                            line: expression['line'],\r\n                                            column: expression['character']\r\n                                        }\r\n                                    }, context);\r\n                                }\r\n                                else {\r\n                                    self.error({ message, context: expression.context }, context);\r\n                                }\r\n                                return IGNORE;\r\n                            case 'ignore':\r\n                                return expression;\r\n                        }\r\n                        return null;\r\n                    }\r\n                    return mapStringMap(expression, (value, name) => {\r\n                        if (REFERENCE_SET.has(name)) {\r\n                            if (name === USE_VALUE$1 && PROVIDE in expression) {\r\n                                // If this is a provider expression, check for special tokens that need the value\r\n                                // during analysis.\r\n                                const provide = simplify(expression.provide);\r\n                                if (provide === self.ROUTES || provide == self.ANALYZE_FOR_ENTRY_COMPONENTS) {\r\n                                    return simplify(value);\r\n                                }\r\n                            }\r\n                            return simplifyLazily(value);\r\n                        }\r\n                        return simplify(value);\r\n                    });\r\n                }\r\n                return IGNORE;\r\n            }\r\n            return simplify(value);\r\n        }\r\n        let result;\r\n        try {\r\n            result = simplifyInContext(context, value, 0, lazy ? 1 : 0);\r\n        }\r\n        catch (e) {\r\n            if (this.errorRecorder) {\r\n                this.reportError(e, context);\r\n            }\r\n            else {\r\n                throw formatMetadataError(e, context);\r\n            }\r\n        }\r\n        if (shouldIgnore(result)) {\r\n            return undefined;\r\n        }\r\n        return result;\r\n    }\r\n    getTypeMetadata(type) {\r\n        const resolvedSymbol = this.symbolResolver.resolveSymbol(type);\r\n        return resolvedSymbol && resolvedSymbol.metadata ? resolvedSymbol.metadata :\r\n            { __symbolic: 'class' };\r\n    }\r\n    reportError(error, context, path) {\r\n        if (this.errorRecorder) {\r\n            this.errorRecorder(formatMetadataError(error, context), (context && context.filePath) || path);\r\n        }\r\n        else {\r\n            throw error;\r\n        }\r\n    }\r\n    error({ message, summary, advise, position, context, value, symbol, chain }, reportingContext) {\r\n        this.reportError(metadataError(message, summary, advise, position, symbol, context, chain), reportingContext);\r\n    }\r\n}\r\nconst METADATA_ERROR = 'ngMetadataError';\r\nfunction metadataError(message, summary, advise, position, symbol, context, chain) {\r\n    const error = syntaxError(message);\r\n    error[METADATA_ERROR] = true;\r\n    if (advise)\r\n        error.advise = advise;\r\n    if (position)\r\n        error.position = position;\r\n    if (summary)\r\n        error.summary = summary;\r\n    if (context)\r\n        error.context = context;\r\n    if (chain)\r\n        error.chain = chain;\r\n    if (symbol)\r\n        error.symbol = symbol;\r\n    return error;\r\n}\r\nfunction isMetadataError(error) {\r\n    return !!error[METADATA_ERROR];\r\n}\r\nconst REFERENCE_TO_NONEXPORTED_CLASS = 'Reference to non-exported class';\r\nconst VARIABLE_NOT_INITIALIZED = 'Variable not initialized';\r\nconst DESTRUCTURE_NOT_SUPPORTED = 'Destructuring not supported';\r\nconst COULD_NOT_RESOLVE_TYPE = 'Could not resolve type';\r\nconst FUNCTION_CALL_NOT_SUPPORTED = 'Function call not supported';\r\nconst REFERENCE_TO_LOCAL_SYMBOL = 'Reference to a local symbol';\r\nconst LAMBDA_NOT_SUPPORTED = 'Lambda not supported';\r\nfunction expandedMessage(message, context) {\r\n    switch (message) {\r\n        case REFERENCE_TO_NONEXPORTED_CLASS:\r\n            if (context && context.className) {\r\n                return `References to a non-exported class are not supported in decorators but ${context.className} was referenced.`;\r\n            }\r\n            break;\r\n        case VARIABLE_NOT_INITIALIZED:\r\n            return 'Only initialized variables and constants can be referenced in decorators because the value of this variable is needed by the template compiler';\r\n        case DESTRUCTURE_NOT_SUPPORTED:\r\n            return 'Referencing an exported destructured variable or constant is not supported in decorators and this value is needed by the template compiler';\r\n        case COULD_NOT_RESOLVE_TYPE:\r\n            if (context && context.typeName) {\r\n                return `Could not resolve type ${context.typeName}`;\r\n            }\r\n            break;\r\n        case FUNCTION_CALL_NOT_SUPPORTED:\r\n            if (context && context.name) {\r\n                return `Function calls are not supported in decorators but '${context.name}' was called`;\r\n            }\r\n            return 'Function calls are not supported in decorators';\r\n        case REFERENCE_TO_LOCAL_SYMBOL:\r\n            if (context && context.name) {\r\n                return `Reference to a local (non-exported) symbols are not supported in decorators but '${context.name}' was referenced`;\r\n            }\r\n            break;\r\n        case LAMBDA_NOT_SUPPORTED:\r\n            return `Function expressions are not supported in decorators`;\r\n    }\r\n    return message;\r\n}\r\nfunction messageAdvise(message, context) {\r\n    switch (message) {\r\n        case REFERENCE_TO_NONEXPORTED_CLASS:\r\n            if (context && context.className) {\r\n                return `Consider exporting '${context.className}'`;\r\n            }\r\n            break;\r\n        case DESTRUCTURE_NOT_SUPPORTED:\r\n            return 'Consider simplifying to avoid destructuring';\r\n        case REFERENCE_TO_LOCAL_SYMBOL:\r\n            if (context && context.name) {\r\n                return `Consider exporting '${context.name}'`;\r\n            }\r\n            break;\r\n        case LAMBDA_NOT_SUPPORTED:\r\n            return `Consider changing the function expression into an exported function`;\r\n    }\r\n    return undefined;\r\n}\r\nfunction errorSummary(error) {\r\n    if (error.summary) {\r\n        return error.summary;\r\n    }\r\n    switch (error.message) {\r\n        case REFERENCE_TO_NONEXPORTED_CLASS:\r\n            if (error.context && error.context.className) {\r\n                return `references non-exported class ${error.context.className}`;\r\n            }\r\n            break;\r\n        case VARIABLE_NOT_INITIALIZED:\r\n            return 'is not initialized';\r\n        case DESTRUCTURE_NOT_SUPPORTED:\r\n            return 'is a destructured variable';\r\n        case COULD_NOT_RESOLVE_TYPE:\r\n            return 'could not be resolved';\r\n        case FUNCTION_CALL_NOT_SUPPORTED:\r\n            if (error.context && error.context.name) {\r\n                return `calls '${error.context.name}'`;\r\n            }\r\n            return `calls a function`;\r\n        case REFERENCE_TO_LOCAL_SYMBOL:\r\n            if (error.context && error.context.name) {\r\n                return `references local variable ${error.context.name}`;\r\n            }\r\n            return `references a local variable`;\r\n    }\r\n    return 'contains the error';\r\n}\r\nfunction mapStringMap(input, transform) {\r\n    if (!input)\r\n        return {};\r\n    const result = {};\r\n    Object.keys(input).forEach((key) => {\r\n        const value = transform(input[key], key);\r\n        if (!shouldIgnore(value)) {\r\n            if (HIDDEN_KEY.test(key)) {\r\n                Object.defineProperty(result, key, { enumerable: false, configurable: true, value: value });\r\n            }\r\n            else {\r\n                result[key] = value;\r\n            }\r\n        }\r\n    });\r\n    return result;\r\n}\r\nfunction isPrimitive(o) {\r\n    return o === null || (typeof o !== 'function' && typeof o !== 'object');\r\n}\r\nclass BindingScope$1 {\r\n    static build() {\r\n        const current = new Map();\r\n        return {\r\n            define: function (name, value) {\r\n                current.set(name, value);\r\n                return this;\r\n            },\r\n            done: function () {\r\n                return current.size > 0 ? new PopulatedScope(current) : BindingScope$1.empty;\r\n            }\r\n        };\r\n    }\r\n}\r\nBindingScope$1.missing = {};\r\nBindingScope$1.empty = { resolve: name => BindingScope$1.missing };\r\nclass PopulatedScope extends BindingScope$1 {\r\n    constructor(bindings) {\r\n        super();\r\n        this.bindings = bindings;\r\n    }\r\n    resolve(name) {\r\n        return this.bindings.has(name) ? this.bindings.get(name) : BindingScope$1.missing;\r\n    }\r\n}\r\nfunction formatMetadataMessageChain(chain, advise) {\r\n    const expanded = expandedMessage(chain.message, chain.context);\r\n    const nesting = chain.symbol ? ` in '${chain.symbol.name}'` : '';\r\n    const message = `${expanded}${nesting}`;\r\n    const position = chain.position;\r\n    const next = chain.next ?\r\n        formatMetadataMessageChain(chain.next, advise) :\r\n        advise ? { message: advise } : undefined;\r\n    return { message, position, next: next ? [next] : undefined };\r\n}\r\nfunction formatMetadataError(e, context) {\r\n    if (isMetadataError(e)) {\r\n        // Produce a formatted version of the and leaving enough information in the original error\r\n        // to recover the formatting information to eventually produce a diagnostic error message.\r\n        const position = e.position;\r\n        const chain = {\r\n            message: `Error during template compile of '${context.name}'`,\r\n            position: position,\r\n            next: { message: e.message, next: e.chain, context: e.context, symbol: e.symbol }\r\n        };\r\n        const advise = e.advise || messageAdvise(e.message, e.context);\r\n        return formattedError(formatMetadataMessageChain(chain, advise));\r\n    }\r\n    return e;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass AotSummaryResolver {\r\n    constructor(host, staticSymbolCache) {\r\n        this.host = host;\r\n        this.staticSymbolCache = staticSymbolCache;\r\n        // Note: this will only contain StaticSymbols without members!\r\n        this.summaryCache = new Map();\r\n        this.loadedFilePaths = new Map();\r\n        // Note: this will only contain StaticSymbols without members!\r\n        this.importAs = new Map();\r\n        this.knownFileNameToModuleNames = new Map();\r\n    }\r\n    isLibraryFile(filePath) {\r\n        // Note: We need to strip the .ngfactory. file path,\r\n        // so this method also works for generated files\r\n        // (for which host.isSourceFile will always return false).\r\n        return !this.host.isSourceFile(stripGeneratedFileSuffix(filePath));\r\n    }\r\n    toSummaryFileName(filePath, referringSrcFileName) {\r\n        return this.host.toSummaryFileName(filePath, referringSrcFileName);\r\n    }\r\n    fromSummaryFileName(fileName, referringLibFileName) {\r\n        return this.host.fromSummaryFileName(fileName, referringLibFileName);\r\n    }\r\n    resolveSummary(staticSymbol) {\r\n        const rootSymbol = staticSymbol.members.length ?\r\n            this.staticSymbolCache.get(staticSymbol.filePath, staticSymbol.name) :\r\n            staticSymbol;\r\n        let summary = this.summaryCache.get(rootSymbol);\r\n        if (!summary) {\r\n            this._loadSummaryFile(staticSymbol.filePath);\r\n            summary = this.summaryCache.get(staticSymbol);\r\n        }\r\n        return (rootSymbol === staticSymbol && summary) || null;\r\n    }\r\n    getSymbolsOf(filePath) {\r\n        if (this._loadSummaryFile(filePath)) {\r\n            return Array.from(this.summaryCache.keys()).filter((symbol) => symbol.filePath === filePath);\r\n        }\r\n        return null;\r\n    }\r\n    getImportAs(staticSymbol) {\r\n        staticSymbol.assertNoMembers();\r\n        return this.importAs.get(staticSymbol);\r\n    }\r\n    /**\r\n     * Converts a file path to a module name that can be used as an `import`.\r\n     */\r\n    getKnownModuleName(importedFilePath) {\r\n        return this.knownFileNameToModuleNames.get(importedFilePath) || null;\r\n    }\r\n    addSummary(summary) {\r\n        this.summaryCache.set(summary.symbol, summary);\r\n    }\r\n    _loadSummaryFile(filePath) {\r\n        let hasSummary = this.loadedFilePaths.get(filePath);\r\n        if (hasSummary != null) {\r\n            return hasSummary;\r\n        }\r\n        let json = null;\r\n        if (this.isLibraryFile(filePath)) {\r\n            const summaryFilePath = summaryFileName(filePath);\r\n            try {\r\n                json = this.host.loadSummary(summaryFilePath);\r\n            }\r\n            catch (e) {\r\n                console.error(`Error loading summary file ${summaryFilePath}`);\r\n                throw e;\r\n            }\r\n        }\r\n        hasSummary = json != null;\r\n        this.loadedFilePaths.set(filePath, hasSummary);\r\n        if (json) {\r\n            const { moduleName, summaries, importAs } = deserializeSummaries(this.staticSymbolCache, this, filePath, json);\r\n            summaries.forEach((summary) => this.summaryCache.set(summary.symbol, summary));\r\n            if (moduleName) {\r\n                this.knownFileNameToModuleNames.set(filePath, moduleName);\r\n            }\r\n            importAs.forEach((importAs) => {\r\n                this.importAs.set(importAs.symbol, importAs.importAs);\r\n            });\r\n        }\r\n        return hasSummary;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nfunction createAotUrlResolver(host) {\r\n    return {\r\n        resolve: (basePath, url) => {\r\n            const filePath = host.resourceNameToFileName(url, basePath);\r\n            if (!filePath) {\r\n                throw syntaxError(`Couldn't resolve resource ${url} from ${basePath}`);\r\n            }\r\n            return filePath;\r\n        }\r\n    };\r\n}\r\n/**\r\n * Creates a new AotCompiler based on options and a host.\r\n */\r\nfunction createAotCompiler(compilerHost, options, errorCollector) {\r\n    let translations = options.translations || '';\r\n    const urlResolver = createAotUrlResolver(compilerHost);\r\n    const symbolCache = new StaticSymbolCache();\r\n    const summaryResolver = new AotSummaryResolver(compilerHost, symbolCache);\r\n    const symbolResolver = new StaticSymbolResolver(compilerHost, symbolCache, summaryResolver);\r\n    const staticReflector = new StaticReflector(summaryResolver, symbolResolver, [], [], errorCollector);\r\n    let htmlParser;\r\n    if (!!options.enableIvy) {\r\n        // Ivy handles i18n at the compiler level so we must use a regular parser\r\n        htmlParser = new HtmlParser();\r\n    }\r\n    else {\r\n        htmlParser = new I18NHtmlParser(new HtmlParser(), translations, options.i18nFormat, options.missingTranslation, console);\r\n    }\r\n    const config = new CompilerConfig({\r\n        defaultEncapsulation: ViewEncapsulation.Emulated,\r\n        useJit: false,\r\n        missingTranslation: options.missingTranslation,\r\n        preserveWhitespaces: options.preserveWhitespaces,\r\n        strictInjectionParameters: options.strictInjectionParameters,\r\n    });\r\n    const normalizer = new DirectiveNormalizer({ get: (url) => compilerHost.loadResource(url) }, urlResolver, htmlParser, config);\r\n    const expressionParser = new Parser$1(new Lexer());\r\n    const elementSchemaRegistry = new DomElementSchemaRegistry();\r\n    const tmplParser = new TemplateParser(config, staticReflector, expressionParser, elementSchemaRegistry, htmlParser, console, []);\r\n    const resolver = new CompileMetadataResolver(config, htmlParser, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, console, symbolCache, staticReflector, errorCollector);\r\n    // TODO(vicb): do not pass options.i18nFormat here\r\n    const viewCompiler = new ViewCompiler(staticReflector);\r\n    const typeCheckCompiler = new TypeCheckCompiler(options, staticReflector);\r\n    const compiler = new AotCompiler(config, options, compilerHost, staticReflector, resolver, tmplParser, new StyleCompiler(urlResolver), viewCompiler, typeCheckCompiler, new NgModuleCompiler(staticReflector), new InjectableCompiler(staticReflector, !!options.enableIvy), new TypeScriptEmitter(), summaryResolver, symbolResolver);\r\n    return { compiler, reflector: staticReflector };\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nclass SummaryResolver {\r\n}\r\nclass JitSummaryResolver {\r\n    constructor() {\r\n        this._summaries = new Map();\r\n    }\r\n    isLibraryFile() {\r\n        return false;\r\n    }\r\n    toSummaryFileName(fileName) {\r\n        return fileName;\r\n    }\r\n    fromSummaryFileName(fileName) {\r\n        return fileName;\r\n    }\r\n    resolveSummary(reference) {\r\n        return this._summaries.get(reference) || null;\r\n    }\r\n    getSymbolsOf() {\r\n        return [];\r\n    }\r\n    getImportAs(reference) {\r\n        return reference;\r\n    }\r\n    getKnownModuleName(fileName) {\r\n        return null;\r\n    }\r\n    addSummary(summary) {\r\n        this._summaries.set(summary.symbol, summary);\r\n    }\r\n}\r\n\r\nfunction interpretStatements(statements, reflector) {\r\n    const ctx = new _ExecutionContext(null, null, null, new Map());\r\n    const visitor = new StatementInterpreter(reflector);\r\n    visitor.visitAllStatements(statements, ctx);\r\n    const result = {};\r\n    ctx.exports.forEach((exportName) => {\r\n        result[exportName] = ctx.vars.get(exportName);\r\n    });\r\n    return result;\r\n}\r\nfunction _executeFunctionStatements(varNames, varValues, statements, ctx, visitor) {\r\n    const childCtx = ctx.createChildWihtLocalVars();\r\n    for (let i = 0; i < varNames.length; i++) {\r\n        childCtx.vars.set(varNames[i], varValues[i]);\r\n    }\r\n    const result = visitor.visitAllStatements(statements, childCtx);\r\n    return result ? result.value : null;\r\n}\r\nclass _ExecutionContext {\r\n    constructor(parent, instance, className, vars) {\r\n        this.parent = parent;\r\n        this.instance = instance;\r\n        this.className = className;\r\n        this.vars = vars;\r\n        this.exports = [];\r\n    }\r\n    createChildWihtLocalVars() {\r\n        return new _ExecutionContext(this, this.instance, this.className, new Map());\r\n    }\r\n}\r\nclass ReturnValue {\r\n    constructor(value) {\r\n        this.value = value;\r\n    }\r\n}\r\nfunction createDynamicClass(_classStmt, _ctx, _visitor) {\r\n    const propertyDescriptors = {};\r\n    _classStmt.getters.forEach((getter) => {\r\n        // Note: use `function` instead of arrow function to capture `this`\r\n        propertyDescriptors[getter.name] = {\r\n            configurable: false,\r\n            get: function () {\r\n                const instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\r\n                return _executeFunctionStatements([], [], getter.body, instanceCtx, _visitor);\r\n            }\r\n        };\r\n    });\r\n    _classStmt.methods.forEach(function (method) {\r\n        const paramNames = method.params.map(param => param.name);\r\n        // Note: use `function` instead of arrow function to capture `this`\r\n        propertyDescriptors[method.name] = {\r\n            writable: false,\r\n            configurable: false,\r\n            value: function (...args) {\r\n                const instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\r\n                return _executeFunctionStatements(paramNames, args, method.body, instanceCtx, _visitor);\r\n            }\r\n        };\r\n    });\r\n    const ctorParamNames = _classStmt.constructorMethod.params.map(param => param.name);\r\n    // Note: use `function` instead of arrow function to capture `this`\r\n    const ctor = function (...args) {\r\n        const instanceCtx = new _ExecutionContext(_ctx, this, _classStmt.name, _ctx.vars);\r\n        _classStmt.fields.forEach((field) => {\r\n            this[field.name] = undefined;\r\n        });\r\n        _executeFunctionStatements(ctorParamNames, args, _classStmt.constructorMethod.body, instanceCtx, _visitor);\r\n    };\r\n    const superClass = _classStmt.parent ? _classStmt.parent.visitExpression(_visitor, _ctx) : Object;\r\n    ctor.prototype = Object.create(superClass.prototype, propertyDescriptors);\r\n    return ctor;\r\n}\r\nclass StatementInterpreter {\r\n    constructor(reflector) {\r\n        this.reflector = reflector;\r\n    }\r\n    debugAst(ast) {\r\n        return debugOutputAstAsTypeScript(ast);\r\n    }\r\n    visitDeclareVarStmt(stmt, ctx) {\r\n        const initialValue = stmt.value ? stmt.value.visitExpression(this, ctx) : undefined;\r\n        ctx.vars.set(stmt.name, initialValue);\r\n        if (stmt.hasModifier(StmtModifier.Exported)) {\r\n            ctx.exports.push(stmt.name);\r\n        }\r\n        return null;\r\n    }\r\n    visitWriteVarExpr(expr, ctx) {\r\n        const value = expr.value.visitExpression(this, ctx);\r\n        let currCtx = ctx;\r\n        while (currCtx != null) {\r\n            if (currCtx.vars.has(expr.name)) {\r\n                currCtx.vars.set(expr.name, value);\r\n                return value;\r\n            }\r\n            currCtx = currCtx.parent;\r\n        }\r\n        throw new Error(`Not declared variable ${expr.name}`);\r\n    }\r\n    visitWrappedNodeExpr(ast, ctx) {\r\n        throw new Error('Cannot interpret a WrappedNodeExpr.');\r\n    }\r\n    visitTypeofExpr(ast, ctx) {\r\n        throw new Error('Cannot interpret a TypeofExpr');\r\n    }\r\n    visitReadVarExpr(ast, ctx) {\r\n        let varName = ast.name;\r\n        if (ast.builtin != null) {\r\n            switch (ast.builtin) {\r\n                case BuiltinVar.Super:\r\n                    return Object.getPrototypeOf(ctx.instance);\r\n                case BuiltinVar.This:\r\n                    return ctx.instance;\r\n                case BuiltinVar.CatchError:\r\n                    varName = CATCH_ERROR_VAR$2;\r\n                    break;\r\n                case BuiltinVar.CatchStack:\r\n                    varName = CATCH_STACK_VAR$2;\r\n                    break;\r\n                default:\r\n                    throw new Error(`Unknown builtin variable ${ast.builtin}`);\r\n            }\r\n        }\r\n        let currCtx = ctx;\r\n        while (currCtx != null) {\r\n            if (currCtx.vars.has(varName)) {\r\n                return currCtx.vars.get(varName);\r\n            }\r\n            currCtx = currCtx.parent;\r\n        }\r\n        throw new Error(`Not declared variable ${varName}`);\r\n    }\r\n    visitWriteKeyExpr(expr, ctx) {\r\n        const receiver = expr.receiver.visitExpression(this, ctx);\r\n        const index = expr.index.visitExpression(this, ctx);\r\n        const value = expr.value.visitExpression(this, ctx);\r\n        receiver[index] = value;\r\n        return value;\r\n    }\r\n    visitWritePropExpr(expr, ctx) {\r\n        const receiver = expr.receiver.visitExpression(this, ctx);\r\n        const value = expr.value.visitExpression(this, ctx);\r\n        receiver[expr.name] = value;\r\n        return value;\r\n    }\r\n    visitInvokeMethodExpr(expr, ctx) {\r\n        const receiver = expr.receiver.visitExpression(this, ctx);\r\n        const args = this.visitAllExpressions(expr.args, ctx);\r\n        let result;\r\n        if (expr.builtin != null) {\r\n            switch (expr.builtin) {\r\n                case BuiltinMethod.ConcatArray:\r\n                    result = receiver.concat(...args);\r\n                    break;\r\n                case BuiltinMethod.SubscribeObservable:\r\n                    result = receiver.subscribe({ next: args[0] });\r\n                    break;\r\n                case BuiltinMethod.Bind:\r\n                    result = receiver.bind(...args);\r\n                    break;\r\n                default:\r\n                    throw new Error(`Unknown builtin method ${expr.builtin}`);\r\n            }\r\n        }\r\n        else {\r\n            result = receiver[expr.name].apply(receiver, args);\r\n        }\r\n        return result;\r\n    }\r\n    visitInvokeFunctionExpr(stmt, ctx) {\r\n        const args = this.visitAllExpressions(stmt.args, ctx);\r\n        const fnExpr = stmt.fn;\r\n        if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\r\n            ctx.instance.constructor.prototype.constructor.apply(ctx.instance, args);\r\n            return null;\r\n        }\r\n        else {\r\n            const fn = stmt.fn.visitExpression(this, ctx);\r\n            return fn.apply(null, args);\r\n        }\r\n    }\r\n    visitTaggedTemplateExpr(expr, ctx) {\r\n        const templateElements = expr.template.elements.map((e) => e.text);\r\n        Object.defineProperty(templateElements, 'raw', { value: expr.template.elements.map((e) => e.rawText) });\r\n        const args = this.visitAllExpressions(expr.template.expressions, ctx);\r\n        args.unshift(templateElements);\r\n        const tag = expr.tag.visitExpression(this, ctx);\r\n        return tag.apply(null, args);\r\n    }\r\n    visitReturnStmt(stmt, ctx) {\r\n        return new ReturnValue(stmt.value.visitExpression(this, ctx));\r\n    }\r\n    visitDeclareClassStmt(stmt, ctx) {\r\n        const clazz = createDynamicClass(stmt, ctx, this);\r\n        ctx.vars.set(stmt.name, clazz);\r\n        if (stmt.hasModifier(StmtModifier.Exported)) {\r\n            ctx.exports.push(stmt.name);\r\n        }\r\n        return null;\r\n    }\r\n    visitExpressionStmt(stmt, ctx) {\r\n        return stmt.expr.visitExpression(this, ctx);\r\n    }\r\n    visitIfStmt(stmt, ctx) {\r\n        const condition = stmt.condition.visitExpression(this, ctx);\r\n        if (condition) {\r\n            return this.visitAllStatements(stmt.trueCase, ctx);\r\n        }\r\n        else if (stmt.falseCase != null) {\r\n            return this.visitAllStatements(stmt.falseCase, ctx);\r\n        }\r\n        return null;\r\n    }\r\n    visitTryCatchStmt(stmt, ctx) {\r\n        try {\r\n            return this.visitAllStatements(stmt.bodyStmts, ctx);\r\n        }\r\n        catch (e) {\r\n            const childCtx = ctx.createChildWihtLocalVars();\r\n            childCtx.vars.set(CATCH_ERROR_VAR$2, e);\r\n            childCtx.vars.set(CATCH_STACK_VAR$2, e.stack);\r\n            return this.visitAllStatements(stmt.catchStmts, childCtx);\r\n        }\r\n    }\r\n    visitThrowStmt(stmt, ctx) {\r\n        throw stmt.error.visitExpression(this, ctx);\r\n    }\r\n    visitInstantiateExpr(ast, ctx) {\r\n        const args = this.visitAllExpressions(ast.args, ctx);\r\n        const clazz = ast.classExpr.visitExpression(this, ctx);\r\n        return new clazz(...args);\r\n    }\r\n    visitLiteralExpr(ast, ctx) {\r\n        return ast.value;\r\n    }\r\n    visitLocalizedString(ast, context) {\r\n        return null;\r\n    }\r\n    visitExternalExpr(ast, ctx) {\r\n        return this.reflector.resolveExternalReference(ast.value);\r\n    }\r\n    visitConditionalExpr(ast, ctx) {\r\n        if (ast.condition.visitExpression(this, ctx)) {\r\n            return ast.trueCase.visitExpression(this, ctx);\r\n        }\r\n        else if (ast.falseCase != null) {\r\n            return ast.falseCase.visitExpression(this, ctx);\r\n        }\r\n        return null;\r\n    }\r\n    visitNotExpr(ast, ctx) {\r\n        return !ast.condition.visitExpression(this, ctx);\r\n    }\r\n    visitAssertNotNullExpr(ast, ctx) {\r\n        return ast.condition.visitExpression(this, ctx);\r\n    }\r\n    visitCastExpr(ast, ctx) {\r\n        return ast.value.visitExpression(this, ctx);\r\n    }\r\n    visitFunctionExpr(ast, ctx) {\r\n        const paramNames = ast.params.map((param) => param.name);\r\n        return _declareFn(paramNames, ast.statements, ctx, this);\r\n    }\r\n    visitDeclareFunctionStmt(stmt, ctx) {\r\n        const paramNames = stmt.params.map((param) => param.name);\r\n        ctx.vars.set(stmt.name, _declareFn(paramNames, stmt.statements, ctx, this));\r\n        if (stmt.hasModifier(StmtModifier.Exported)) {\r\n            ctx.exports.push(stmt.name);\r\n        }\r\n        return null;\r\n    }\r\n    visitUnaryOperatorExpr(ast, ctx) {\r\n        const rhs = () => ast.expr.visitExpression(this, ctx);\r\n        switch (ast.operator) {\r\n            case UnaryOperator.Plus:\r\n                return +rhs();\r\n            case UnaryOperator.Minus:\r\n                return -rhs();\r\n            default:\r\n                throw new Error(`Unknown operator ${ast.operator}`);\r\n        }\r\n    }\r\n    visitBinaryOperatorExpr(ast, ctx) {\r\n        var _a;\r\n        const lhs = () => ast.lhs.visitExpression(this, ctx);\r\n        const rhs = () => ast.rhs.visitExpression(this, ctx);\r\n        switch (ast.operator) {\r\n            case BinaryOperator.Equals:\r\n                return lhs() == rhs();\r\n            case BinaryOperator.Identical:\r\n                return lhs() === rhs();\r\n            case BinaryOperator.NotEquals:\r\n                return lhs() != rhs();\r\n            case BinaryOperator.NotIdentical:\r\n                return lhs() !== rhs();\r\n            case BinaryOperator.And:\r\n                return lhs() && rhs();\r\n            case BinaryOperator.Or:\r\n                return lhs() || rhs();\r\n            case BinaryOperator.Plus:\r\n                return lhs() + rhs();\r\n            case BinaryOperator.Minus:\r\n                return lhs() - rhs();\r\n            case BinaryOperator.Divide:\r\n                return lhs() / rhs();\r\n            case BinaryOperator.Multiply:\r\n                return lhs() * rhs();\r\n            case BinaryOperator.Modulo:\r\n                return lhs() % rhs();\r\n            case BinaryOperator.Lower:\r\n                return lhs() < rhs();\r\n            case BinaryOperator.LowerEquals:\r\n                return lhs() <= rhs();\r\n            case BinaryOperator.Bigger:\r\n                return lhs() > rhs();\r\n            case BinaryOperator.BiggerEquals:\r\n                return lhs() >= rhs();\r\n            case BinaryOperator.NullishCoalesce:\r\n                return (_a = lhs()) !== null && _a !== void 0 ? _a : rhs();\r\n            default:\r\n                throw new Error(`Unknown operator ${ast.operator}`);\r\n        }\r\n    }\r\n    visitReadPropExpr(ast, ctx) {\r\n        let result;\r\n        const receiver = ast.receiver.visitExpression(this, ctx);\r\n        result = receiver[ast.name];\r\n        return result;\r\n    }\r\n    visitReadKeyExpr(ast, ctx) {\r\n        const receiver = ast.receiver.visitExpression(this, ctx);\r\n        const prop = ast.index.visitExpression(this, ctx);\r\n        return receiver[prop];\r\n    }\r\n    visitLiteralArrayExpr(ast, ctx) {\r\n        return this.visitAllExpressions(ast.entries, ctx);\r\n    }\r\n    visitLiteralMapExpr(ast, ctx) {\r\n        const result = {};\r\n        ast.entries.forEach(entry => result[entry.key] = entry.value.visitExpression(this, ctx));\r\n        return result;\r\n    }\r\n    visitCommaExpr(ast, context) {\r\n        const values = this.visitAllExpressions(ast.parts, context);\r\n        return values[values.length - 1];\r\n    }\r\n    visitAllExpressions(expressions, ctx) {\r\n        return expressions.map((expr) => expr.visitExpression(this, ctx));\r\n    }\r\n    visitAllStatements(statements, ctx) {\r\n        for (let i = 0; i < statements.length; i++) {\r\n            const stmt = statements[i];\r\n            const val = stmt.visitStatement(this, ctx);\r\n            if (val instanceof ReturnValue) {\r\n                return val;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n}\r\nfunction _declareFn(varNames, statements, ctx, visitor) {\r\n    return (...args) => _executeFunctionStatements(varNames, args, statements, ctx, visitor);\r\n}\r\nconst CATCH_ERROR_VAR$2 = 'error';\r\nconst CATCH_STACK_VAR$2 = 'stack';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * An internal module of the Angular compiler that begins with component types,\r\n * extracts templates, and eventually produces a compiled version of the component\r\n * ready for linking into an application.\r\n *\r\n * @security  When compiling templates at runtime, you must ensure that the entire template comes\r\n * from a trusted source. Attacker-controlled data introduced by a template could expose your\r\n * application to XSS risks.  For more detail, see the [Security Guide](https://g.co/ng/security).\r\n */\r\nclass JitCompiler {\r\n    constructor(_metadataResolver, _templateParser, _styleCompiler, _viewCompiler, _ngModuleCompiler, _summaryResolver, _reflector, _jitEvaluator, _compilerConfig, _console, getExtraNgModuleProviders) {\r\n        this._metadataResolver = _metadataResolver;\r\n        this._templateParser = _templateParser;\r\n        this._styleCompiler = _styleCompiler;\r\n        this._viewCompiler = _viewCompiler;\r\n        this._ngModuleCompiler = _ngModuleCompiler;\r\n        this._summaryResolver = _summaryResolver;\r\n        this._reflector = _reflector;\r\n        this._jitEvaluator = _jitEvaluator;\r\n        this._compilerConfig = _compilerConfig;\r\n        this._console = _console;\r\n        this.getExtraNgModuleProviders = getExtraNgModuleProviders;\r\n        this._compiledTemplateCache = new Map();\r\n        this._compiledHostTemplateCache = new Map();\r\n        this._compiledDirectiveWrapperCache = new Map();\r\n        this._compiledNgModuleCache = new Map();\r\n        this._sharedStylesheetCount = 0;\r\n        this._addedAotSummaries = new Set();\r\n    }\r\n    compileModuleSync(moduleType) {\r\n        return SyncAsync.assertSync(this._compileModuleAndComponents(moduleType, true));\r\n    }\r\n    compileModuleAsync(moduleType) {\r\n        return Promise.resolve(this._compileModuleAndComponents(moduleType, false));\r\n    }\r\n    compileModuleAndAllComponentsSync(moduleType) {\r\n        return SyncAsync.assertSync(this._compileModuleAndAllComponents(moduleType, true));\r\n    }\r\n    compileModuleAndAllComponentsAsync(moduleType) {\r\n        return Promise.resolve(this._compileModuleAndAllComponents(moduleType, false));\r\n    }\r\n    getComponentFactory(component) {\r\n        const summary = this._metadataResolver.getDirectiveSummary(component);\r\n        return summary.componentFactory;\r\n    }\r\n    loadAotSummaries(summaries) {\r\n        this.clearCache();\r\n        this._addAotSummaries(summaries);\r\n    }\r\n    _addAotSummaries(fn) {\r\n        if (this._addedAotSummaries.has(fn)) {\r\n            return;\r\n        }\r\n        this._addedAotSummaries.add(fn);\r\n        const summaries = fn();\r\n        for (let i = 0; i < summaries.length; i++) {\r\n            const entry = summaries[i];\r\n            if (typeof entry === 'function') {\r\n                this._addAotSummaries(entry);\r\n            }\r\n            else {\r\n                const summary = entry;\r\n                this._summaryResolver.addSummary({ symbol: summary.type.reference, metadata: null, type: summary });\r\n            }\r\n        }\r\n    }\r\n    hasAotSummary(ref) {\r\n        return !!this._summaryResolver.resolveSummary(ref);\r\n    }\r\n    _filterJitIdentifiers(ids) {\r\n        return ids.map(mod => mod.reference).filter((ref) => !this.hasAotSummary(ref));\r\n    }\r\n    _compileModuleAndComponents(moduleType, isSync) {\r\n        return SyncAsync.then(this._loadModules(moduleType, isSync), () => {\r\n            this._compileComponents(moduleType, null);\r\n            return this._compileModule(moduleType);\r\n        });\r\n    }\r\n    _compileModuleAndAllComponents(moduleType, isSync) {\r\n        return SyncAsync.then(this._loadModules(moduleType, isSync), () => {\r\n            const componentFactories = [];\r\n            this._compileComponents(moduleType, componentFactories);\r\n            return {\r\n                ngModuleFactory: this._compileModule(moduleType),\r\n                componentFactories: componentFactories\r\n            };\r\n        });\r\n    }\r\n    _loadModules(mainModule, isSync) {\r\n        const loading = [];\r\n        const mainNgModule = this._metadataResolver.getNgModuleMetadata(mainModule);\r\n        // Note: for runtime compilation, we want to transitively compile all modules,\r\n        // so we also need to load the declared directives / pipes for all nested modules.\r\n        this._filterJitIdentifiers(mainNgModule.transitiveModule.modules).forEach((nestedNgModule) => {\r\n            // getNgModuleMetadata only returns null if the value passed in is not an NgModule\r\n            const moduleMeta = this._metadataResolver.getNgModuleMetadata(nestedNgModule);\r\n            this._filterJitIdentifiers(moduleMeta.declaredDirectives).forEach((ref) => {\r\n                const promise = this._metadataResolver.loadDirectiveMetadata(moduleMeta.type.reference, ref, isSync);\r\n                if (promise) {\r\n                    loading.push(promise);\r\n                }\r\n            });\r\n            this._filterJitIdentifiers(moduleMeta.declaredPipes)\r\n                .forEach((ref) => this._metadataResolver.getOrLoadPipeMetadata(ref));\r\n        });\r\n        return SyncAsync.all(loading);\r\n    }\r\n    _compileModule(moduleType) {\r\n        let ngModuleFactory = this._compiledNgModuleCache.get(moduleType);\r\n        if (!ngModuleFactory) {\r\n            const moduleMeta = this._metadataResolver.getNgModuleMetadata(moduleType);\r\n            // Always provide a bound Compiler\r\n            const extraProviders = this.getExtraNgModuleProviders(moduleMeta.type.reference);\r\n            const outputCtx = createOutputContext();\r\n            const compileResult = this._ngModuleCompiler.compile(outputCtx, moduleMeta, extraProviders);\r\n            ngModuleFactory = this._interpretOrJit(ngModuleJitUrl(moduleMeta), outputCtx.statements)[compileResult.ngModuleFactoryVar];\r\n            this._compiledNgModuleCache.set(moduleMeta.type.reference, ngModuleFactory);\r\n        }\r\n        return ngModuleFactory;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    _compileComponents(mainModule, allComponentFactories) {\r\n        const ngModule = this._metadataResolver.getNgModuleMetadata(mainModule);\r\n        const moduleByJitDirective = new Map();\r\n        const templates = new Set();\r\n        const transJitModules = this._filterJitIdentifiers(ngModule.transitiveModule.modules);\r\n        transJitModules.forEach((localMod) => {\r\n            const localModuleMeta = this._metadataResolver.getNgModuleMetadata(localMod);\r\n            this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach((dirRef) => {\r\n                moduleByJitDirective.set(dirRef, localModuleMeta);\r\n                const dirMeta = this._metadataResolver.getDirectiveMetadata(dirRef);\r\n                if (dirMeta.isComponent) {\r\n                    templates.add(this._createCompiledTemplate(dirMeta, localModuleMeta));\r\n                    if (allComponentFactories) {\r\n                        const template = this._createCompiledHostTemplate(dirMeta.type.reference, localModuleMeta);\r\n                        templates.add(template);\r\n                        allComponentFactories.push(dirMeta.componentFactory);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n        transJitModules.forEach((localMod) => {\r\n            const localModuleMeta = this._metadataResolver.getNgModuleMetadata(localMod);\r\n            this._filterJitIdentifiers(localModuleMeta.declaredDirectives).forEach((dirRef) => {\r\n                const dirMeta = this._metadataResolver.getDirectiveMetadata(dirRef);\r\n                if (dirMeta.isComponent) {\r\n                    dirMeta.entryComponents.forEach((entryComponentType) => {\r\n                        const moduleMeta = moduleByJitDirective.get(entryComponentType.componentType);\r\n                        templates.add(this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\r\n                    });\r\n                }\r\n            });\r\n            localModuleMeta.entryComponents.forEach((entryComponentType) => {\r\n                if (!this.hasAotSummary(entryComponentType.componentType)) {\r\n                    const moduleMeta = moduleByJitDirective.get(entryComponentType.componentType);\r\n                    templates.add(this._createCompiledHostTemplate(entryComponentType.componentType, moduleMeta));\r\n                }\r\n            });\r\n        });\r\n        templates.forEach((template) => this._compileTemplate(template));\r\n    }\r\n    clearCacheFor(type) {\r\n        this._compiledNgModuleCache.delete(type);\r\n        this._metadataResolver.clearCacheFor(type);\r\n        this._compiledHostTemplateCache.delete(type);\r\n        const compiledTemplate = this._compiledTemplateCache.get(type);\r\n        if (compiledTemplate) {\r\n            this._compiledTemplateCache.delete(type);\r\n        }\r\n    }\r\n    clearCache() {\r\n        // Note: don't clear the _addedAotSummaries, as they don't change!\r\n        this._metadataResolver.clearCache();\r\n        this._compiledTemplateCache.clear();\r\n        this._compiledHostTemplateCache.clear();\r\n        this._compiledNgModuleCache.clear();\r\n    }\r\n    _createCompiledHostTemplate(compType, ngModule) {\r\n        if (!ngModule) {\r\n            throw new Error(`Component ${stringify(compType)} is not part of any NgModule or the module has not been imported into your module.`);\r\n        }\r\n        let compiledTemplate = this._compiledHostTemplateCache.get(compType);\r\n        if (!compiledTemplate) {\r\n            const compMeta = this._metadataResolver.getDirectiveMetadata(compType);\r\n            assertComponent(compMeta);\r\n            const hostMeta = this._metadataResolver.getHostComponentMetadata(compMeta, compMeta.componentFactory.viewDefFactory);\r\n            compiledTemplate =\r\n                new CompiledTemplate(true, compMeta.type, hostMeta, ngModule, [compMeta.type]);\r\n            this._compiledHostTemplateCache.set(compType, compiledTemplate);\r\n        }\r\n        return compiledTemplate;\r\n    }\r\n    _createCompiledTemplate(compMeta, ngModule) {\r\n        let compiledTemplate = this._compiledTemplateCache.get(compMeta.type.reference);\r\n        if (!compiledTemplate) {\r\n            assertComponent(compMeta);\r\n            compiledTemplate = new CompiledTemplate(false, compMeta.type, compMeta, ngModule, ngModule.transitiveModule.directives);\r\n            this._compiledTemplateCache.set(compMeta.type.reference, compiledTemplate);\r\n        }\r\n        return compiledTemplate;\r\n    }\r\n    _compileTemplate(template) {\r\n        if (template.isCompiled) {\r\n            return;\r\n        }\r\n        const compMeta = template.compMeta;\r\n        const externalStylesheetsByModuleUrl = new Map();\r\n        const outputContext = createOutputContext();\r\n        const componentStylesheet = this._styleCompiler.compileComponent(outputContext, compMeta);\r\n        compMeta.template.externalStylesheets.forEach((stylesheetMeta) => {\r\n            const compiledStylesheet = this._styleCompiler.compileStyles(createOutputContext(), compMeta, stylesheetMeta);\r\n            externalStylesheetsByModuleUrl.set(stylesheetMeta.moduleUrl, compiledStylesheet);\r\n        });\r\n        this._resolveStylesCompileResult(componentStylesheet, externalStylesheetsByModuleUrl);\r\n        const pipes = template.ngModule.transitiveModule.pipes.map(pipe => this._metadataResolver.getPipeSummary(pipe.reference));\r\n        const { template: parsedTemplate, pipes: usedPipes } = this._parseTemplate(compMeta, template.ngModule, template.directives);\r\n        const compileResult = this._viewCompiler.compileComponent(outputContext, compMeta, parsedTemplate, variable(componentStylesheet.stylesVar), usedPipes);\r\n        const evalResult = this._interpretOrJit(templateJitUrl(template.ngModule.type, template.compMeta), outputContext.statements);\r\n        const viewClass = evalResult[compileResult.viewClassVar];\r\n        const rendererType = evalResult[compileResult.rendererTypeVar];\r\n        template.compiled(viewClass, rendererType);\r\n    }\r\n    _parseTemplate(compMeta, ngModule, directiveIdentifiers) {\r\n        // Note: ! is ok here as components always have a template.\r\n        const preserveWhitespaces = compMeta.template.preserveWhitespaces;\r\n        const directives = directiveIdentifiers.map(dir => this._metadataResolver.getDirectiveSummary(dir.reference));\r\n        const pipes = ngModule.transitiveModule.pipes.map(pipe => this._metadataResolver.getPipeSummary(pipe.reference));\r\n        return this._templateParser.parse(compMeta, compMeta.template.htmlAst, directives, pipes, ngModule.schemas, templateSourceUrl(ngModule.type, compMeta, compMeta.template), preserveWhitespaces);\r\n    }\r\n    _resolveStylesCompileResult(result, externalStylesheetsByModuleUrl) {\r\n        result.dependencies.forEach((dep, i) => {\r\n            const nestedCompileResult = externalStylesheetsByModuleUrl.get(dep.moduleUrl);\r\n            const nestedStylesArr = this._resolveAndEvalStylesCompileResult(nestedCompileResult, externalStylesheetsByModuleUrl);\r\n            dep.setValue(nestedStylesArr);\r\n        });\r\n    }\r\n    _resolveAndEvalStylesCompileResult(result, externalStylesheetsByModuleUrl) {\r\n        this._resolveStylesCompileResult(result, externalStylesheetsByModuleUrl);\r\n        return this._interpretOrJit(sharedStylesheetJitUrl(result.meta, this._sharedStylesheetCount++), result.outputCtx.statements)[result.stylesVar];\r\n    }\r\n    _interpretOrJit(sourceUrl, statements) {\r\n        if (!this._compilerConfig.useJit) {\r\n            return interpretStatements(statements, this._reflector);\r\n        }\r\n        else {\r\n            return this._jitEvaluator.evaluateStatements(sourceUrl, statements, this._reflector, this._compilerConfig.jitDevMode);\r\n        }\r\n    }\r\n}\r\nclass CompiledTemplate {\r\n    constructor(isHost, compType, compMeta, ngModule, directives) {\r\n        this.isHost = isHost;\r\n        this.compType = compType;\r\n        this.compMeta = compMeta;\r\n        this.ngModule = ngModule;\r\n        this.directives = directives;\r\n        this._viewClass = null;\r\n        this.isCompiled = false;\r\n    }\r\n    compiled(viewClass, rendererType) {\r\n        this._viewClass = viewClass;\r\n        this.compMeta.componentViewType.setDelegate(viewClass);\r\n        for (let prop in rendererType) {\r\n            this.compMeta.rendererType[prop] = rendererType[prop];\r\n        }\r\n        this.isCompiled = true;\r\n    }\r\n}\r\nfunction assertComponent(meta) {\r\n    if (!meta.isComponent) {\r\n        throw new Error(`Could not compile '${identifierName(meta.type)}' because it is not a component.`);\r\n    }\r\n}\r\nfunction createOutputContext() {\r\n    const importExpr$1 = (symbol) => importExpr({ name: identifierName(symbol), moduleName: null, runtime: symbol });\r\n    return { statements: [], genFilePath: '', importExpr: importExpr$1, constantPool: new ConstantPool() };\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Provides access to reflection data about symbols that the compiler needs.\r\n */\r\nclass CompileReflector {\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Create a {@link UrlResolver} with no package prefix.\r\n */\r\nfunction createUrlResolverWithoutPackagePrefix() {\r\n    return new UrlResolver();\r\n}\r\nfunction createOfflineCompileUrlResolver() {\r\n    return new UrlResolver('.');\r\n}\r\nconst UrlResolver = class UrlResolverImpl {\r\n    constructor(_packagePrefix = null) {\r\n        this._packagePrefix = _packagePrefix;\r\n    }\r\n    /**\r\n     * Resolves the `url` given the `baseUrl`:\r\n     * - when the `url` is null, the `baseUrl` is returned,\r\n     * - if `url` is relative ('path/to/here', './path/to/here'), the resolved url is a combination of\r\n     * `baseUrl` and `url`,\r\n     * - if `url` is absolute (it has a scheme: 'http://', 'https://' or start with '/'), the `url` is\r\n     * returned as is (ignoring the `baseUrl`)\r\n     */\r\n    resolve(baseUrl, url) {\r\n        let resolvedUrl = url;\r\n        if (baseUrl != null && baseUrl.length > 0) {\r\n            resolvedUrl = _resolveUrl(baseUrl, resolvedUrl);\r\n        }\r\n        const resolvedParts = _split(resolvedUrl);\r\n        let prefix = this._packagePrefix;\r\n        if (prefix != null && resolvedParts != null &&\r\n            resolvedParts[_ComponentIndex.Scheme] == 'package') {\r\n            let path = resolvedParts[_ComponentIndex.Path];\r\n            prefix = prefix.replace(/\\/+$/, '');\r\n            path = path.replace(/^\\/+/, '');\r\n            return `${prefix}/${path}`;\r\n        }\r\n        return resolvedUrl;\r\n    }\r\n};\r\n/**\r\n * Extract the scheme of a URL.\r\n */\r\nfunction getUrlScheme(url) {\r\n    const match = _split(url);\r\n    return (match && match[_ComponentIndex.Scheme]) || '';\r\n}\r\n// The code below is adapted from Traceur:\r\n// https://github.com/google/traceur-compiler/blob/9511c1dafa972bf0de1202a8a863bad02f0f95a8/src/runtime/url.js\r\n/**\r\n * Builds a URI string from already-encoded parts.\r\n *\r\n * No encoding is performed.  Any component may be omitted as either null or\r\n * undefined.\r\n *\r\n * @param opt_scheme The scheme such as 'http'.\r\n * @param opt_userInfo The user name before the '@'.\r\n * @param opt_domain The domain such as 'www.google.com', already\r\n *     URI-encoded.\r\n * @param opt_port The port number.\r\n * @param opt_path The path, already URI-encoded.  If it is not\r\n *     empty, it must begin with a slash.\r\n * @param opt_queryData The URI-encoded query data.\r\n * @param opt_fragment The URI-encoded fragment identifier.\r\n * @return The fully combined URI.\r\n */\r\nfunction _buildFromEncodedParts(opt_scheme, opt_userInfo, opt_domain, opt_port, opt_path, opt_queryData, opt_fragment) {\r\n    const out = [];\r\n    if (opt_scheme != null) {\r\n        out.push(opt_scheme + ':');\r\n    }\r\n    if (opt_domain != null) {\r\n        out.push('//');\r\n        if (opt_userInfo != null) {\r\n            out.push(opt_userInfo + '@');\r\n        }\r\n        out.push(opt_domain);\r\n        if (opt_port != null) {\r\n            out.push(':' + opt_port);\r\n        }\r\n    }\r\n    if (opt_path != null) {\r\n        out.push(opt_path);\r\n    }\r\n    if (opt_queryData != null) {\r\n        out.push('?' + opt_queryData);\r\n    }\r\n    if (opt_fragment != null) {\r\n        out.push('#' + opt_fragment);\r\n    }\r\n    return out.join('');\r\n}\r\n/**\r\n * A regular expression for breaking a URI into its component parts.\r\n *\r\n * {@link https://tools.ietf.org/html/rfc3986#appendix-B} says\r\n * As the \"first-match-wins\" algorithm is identical to the \"greedy\"\r\n * disambiguation method used by POSIX regular expressions, it is natural and\r\n * commonplace to use a regular expression for parsing the potential five\r\n * components of a URI reference.\r\n *\r\n * The following line is the regular expression for breaking-down a\r\n * well-formed URI reference into its components.\r\n *\r\n * <pre>\r\n * ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\r\n *  12            3  4          5       6  7        8 9\r\n * </pre>\r\n *\r\n * The numbers in the second line above are only to assist readability; they\r\n * indicate the reference points for each subexpression (i.e., each paired\r\n * parenthesis). We refer to the value matched for subexpression <n> as $<n>.\r\n * For example, matching the above expression to\r\n * <pre>\r\n *     http://www.ics.uci.edu/pub/ietf/uri/#Related\r\n * </pre>\r\n * results in the following subexpression matches:\r\n * <pre>\r\n *    $1 = http:\r\n *    $2 = http\r\n *    $3 = //www.ics.uci.edu\r\n *    $4 = www.ics.uci.edu\r\n *    $5 = /pub/ietf/uri/\r\n *    $6 = <undefined>\r\n *    $7 = <undefined>\r\n *    $8 = #Related\r\n *    $9 = Related\r\n * </pre>\r\n * where <undefined> indicates that the component is not present, as is the\r\n * case for the query component in the above example. Therefore, we can\r\n * determine the value of the five components as\r\n * <pre>\r\n *    scheme    = $2\r\n *    authority = $4\r\n *    path      = $5\r\n *    query     = $7\r\n *    fragment  = $9\r\n * </pre>\r\n *\r\n * The regular expression has been modified slightly to expose the\r\n * userInfo, domain, and port separately from the authority.\r\n * The modified version yields\r\n * <pre>\r\n *    $1 = http              scheme\r\n *    $2 = <undefined>       userInfo -\\\r\n *    $3 = www.ics.uci.edu   domain     | authority\r\n *    $4 = <undefined>       port     -/\r\n *    $5 = /pub/ietf/uri/    path\r\n *    $6 = <undefined>       query without ?\r\n *    $7 = Related           fragment without #\r\n * </pre>\r\n * @internal\r\n */\r\nconst _splitRe = new RegExp('^' +\r\n    '(?:' +\r\n    '([^:/?#.]+)' + // scheme - ignore special characters\r\n    // used by other URL parts such as :,\r\n    // ?, /, #, and .\r\n    ':)?' +\r\n    '(?://' +\r\n    '(?:([^/?#]*)@)?' + // userInfo\r\n    '([\\\\w\\\\d\\\\-\\\\u0100-\\\\uffff.%]*)' + // domain - restrict to letters,\r\n    // digits, dashes, dots, percent\r\n    // escapes, and unicode characters.\r\n    '(?::([0-9]+))?' + // port\r\n    ')?' +\r\n    '([^?#]+)?' + // path\r\n    '(?:\\\\?([^#]*))?' + // query\r\n    '(?:#(.*))?' + // fragment\r\n    '$');\r\n/**\r\n * The index of each URI component in the return value of goog.uri.utils.split.\r\n * @enum {number}\r\n */\r\nvar _ComponentIndex;\r\n(function (_ComponentIndex) {\r\n    _ComponentIndex[_ComponentIndex[\"Scheme\"] = 1] = \"Scheme\";\r\n    _ComponentIndex[_ComponentIndex[\"UserInfo\"] = 2] = \"UserInfo\";\r\n    _ComponentIndex[_ComponentIndex[\"Domain\"] = 3] = \"Domain\";\r\n    _ComponentIndex[_ComponentIndex[\"Port\"] = 4] = \"Port\";\r\n    _ComponentIndex[_ComponentIndex[\"Path\"] = 5] = \"Path\";\r\n    _ComponentIndex[_ComponentIndex[\"QueryData\"] = 6] = \"QueryData\";\r\n    _ComponentIndex[_ComponentIndex[\"Fragment\"] = 7] = \"Fragment\";\r\n})(_ComponentIndex || (_ComponentIndex = {}));\r\n/**\r\n * Splits a URI into its component parts.\r\n *\r\n * Each component can be accessed via the component indices; for example:\r\n * <pre>\r\n * goog.uri.utils.split(someStr)[goog.uri.utils.CompontentIndex.QUERY_DATA];\r\n * </pre>\r\n *\r\n * @param uri The URI string to examine.\r\n * @return Each component still URI-encoded.\r\n *     Each component that is present will contain the encoded value, whereas\r\n *     components that are not present will be undefined or empty, depending\r\n *     on the browser's regular expression implementation.  Never null, since\r\n *     arbitrary strings may still look like path names.\r\n */\r\nfunction _split(uri) {\r\n    return uri.match(_splitRe);\r\n}\r\n/**\r\n * Removes dot segments in given path component, as described in\r\n * RFC 3986, section 5.2.4.\r\n *\r\n * @param path A non-empty path component.\r\n * @return Path component with removed dot segments.\r\n */\r\nfunction _removeDotSegments(path) {\r\n    if (path == '/')\r\n        return '/';\r\n    const leadingSlash = path[0] == '/' ? '/' : '';\r\n    const trailingSlash = path[path.length - 1] === '/' ? '/' : '';\r\n    const segments = path.split('/');\r\n    const out = [];\r\n    let up = 0;\r\n    for (let pos = 0; pos < segments.length; pos++) {\r\n        const segment = segments[pos];\r\n        switch (segment) {\r\n            case '':\r\n            case '.':\r\n                break;\r\n            case '..':\r\n                if (out.length > 0) {\r\n                    out.pop();\r\n                }\r\n                else {\r\n                    up++;\r\n                }\r\n                break;\r\n            default:\r\n                out.push(segment);\r\n        }\r\n    }\r\n    if (leadingSlash == '') {\r\n        while (up-- > 0) {\r\n            out.unshift('..');\r\n        }\r\n        if (out.length === 0)\r\n            out.push('.');\r\n    }\r\n    return leadingSlash + out.join('/') + trailingSlash;\r\n}\r\n/**\r\n * Takes an array of the parts from split and canonicalizes the path part\r\n * and then joins all the parts.\r\n */\r\nfunction _joinAndCanonicalizePath(parts) {\r\n    let path = parts[_ComponentIndex.Path];\r\n    path = path == null ? '' : _removeDotSegments(path);\r\n    parts[_ComponentIndex.Path] = path;\r\n    return _buildFromEncodedParts(parts[_ComponentIndex.Scheme], parts[_ComponentIndex.UserInfo], parts[_ComponentIndex.Domain], parts[_ComponentIndex.Port], path, parts[_ComponentIndex.QueryData], parts[_ComponentIndex.Fragment]);\r\n}\r\n/**\r\n * Resolves a URL.\r\n * @param base The URL acting as the base URL.\r\n * @param to The URL to resolve.\r\n */\r\nfunction _resolveUrl(base, url) {\r\n    const parts = _split(encodeURI(url));\r\n    const baseParts = _split(base);\r\n    if (parts[_ComponentIndex.Scheme] != null) {\r\n        return _joinAndCanonicalizePath(parts);\r\n    }\r\n    else {\r\n        parts[_ComponentIndex.Scheme] = baseParts[_ComponentIndex.Scheme];\r\n    }\r\n    for (let i = _ComponentIndex.Scheme; i <= _ComponentIndex.Port; i++) {\r\n        if (parts[i] == null) {\r\n            parts[i] = baseParts[i];\r\n        }\r\n    }\r\n    if (parts[_ComponentIndex.Path][0] == '/') {\r\n        return _joinAndCanonicalizePath(parts);\r\n    }\r\n    let path = baseParts[_ComponentIndex.Path];\r\n    if (path == null)\r\n        path = '/';\r\n    const index = path.lastIndexOf('/');\r\n    path = path.substring(0, index + 1) + parts[_ComponentIndex.Path];\r\n    parts[_ComponentIndex.Path] = path;\r\n    return _joinAndCanonicalizePath(parts);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass Extractor {\r\n    constructor(host, staticSymbolResolver, messageBundle, metadataResolver) {\r\n        this.host = host;\r\n        this.staticSymbolResolver = staticSymbolResolver;\r\n        this.messageBundle = messageBundle;\r\n        this.metadataResolver = metadataResolver;\r\n    }\r\n    extract(rootFiles) {\r\n        const { files, ngModules } = analyzeAndValidateNgModules(rootFiles, this.host, this.staticSymbolResolver, this.metadataResolver);\r\n        return Promise\r\n            .all(ngModules.map(ngModule => this.metadataResolver.loadNgModuleDirectiveAndPipeMetadata(ngModule.type.reference, false)))\r\n            .then(() => {\r\n            const errors = [];\r\n            files.forEach(file => {\r\n                const compMetas = [];\r\n                file.directives.forEach(directiveType => {\r\n                    const dirMeta = this.metadataResolver.getDirectiveMetadata(directiveType);\r\n                    if (dirMeta && dirMeta.isComponent) {\r\n                        compMetas.push(dirMeta);\r\n                    }\r\n                });\r\n                compMetas.forEach(compMeta => {\r\n                    const html = compMeta.template.template;\r\n                    // Template URL points to either an HTML or TS file depending on\r\n                    // whether the file is used with `templateUrl:` or `template:`,\r\n                    // respectively.\r\n                    const templateUrl = compMeta.template.templateUrl;\r\n                    const interpolationConfig = InterpolationConfig.fromArray(compMeta.template.interpolation);\r\n                    errors.push(...this.messageBundle.updateFromTemplate(html, templateUrl, interpolationConfig));\r\n                });\r\n            });\r\n            if (errors.length) {\r\n                throw new Error(errors.map(e => e.toString()).join('\\n'));\r\n            }\r\n            return this.messageBundle;\r\n        });\r\n    }\r\n    static create(host, locale) {\r\n        const htmlParser = new HtmlParser();\r\n        const urlResolver = createAotUrlResolver(host);\r\n        const symbolCache = new StaticSymbolCache();\r\n        const summaryResolver = new AotSummaryResolver(host, symbolCache);\r\n        const staticSymbolResolver = new StaticSymbolResolver(host, symbolCache, summaryResolver);\r\n        const staticReflector = new StaticReflector(summaryResolver, staticSymbolResolver);\r\n        const config = new CompilerConfig({ defaultEncapsulation: ViewEncapsulation.Emulated, useJit: false });\r\n        const normalizer = new DirectiveNormalizer({ get: (url) => host.loadResource(url) }, urlResolver, htmlParser, config);\r\n        const elementSchemaRegistry = new DomElementSchemaRegistry();\r\n        const resolver = new CompileMetadataResolver(config, htmlParser, new NgModuleResolver(staticReflector), new DirectiveResolver(staticReflector), new PipeResolver(staticReflector), summaryResolver, elementSchemaRegistry, normalizer, console, symbolCache, staticReflector);\r\n        // TODO(vicb): implicit tags & attributes\r\n        const messageBundle = new MessageBundle(htmlParser, [], {}, locale);\r\n        const extractor = new Extractor(host, staticSymbolResolver, messageBundle, resolver);\r\n        return { extractor, staticReflector };\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nvar FactoryTarget$1;\r\n(function (FactoryTarget) {\r\n    FactoryTarget[FactoryTarget[\"Directive\"] = 0] = \"Directive\";\r\n    FactoryTarget[FactoryTarget[\"Component\"] = 1] = \"Component\";\r\n    FactoryTarget[FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\r\n    FactoryTarget[FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\r\n    FactoryTarget[FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\r\n})(FactoryTarget$1 || (FactoryTarget$1 = {}));\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Processes `Target`s with a given set of directives and performs a binding operation, which\r\n * returns an object similar to TypeScript's `ts.TypeChecker` that contains knowledge about the\r\n * target.\r\n */\r\nclass R3TargetBinder {\r\n    constructor(directiveMatcher) {\r\n        this.directiveMatcher = directiveMatcher;\r\n    }\r\n    /**\r\n     * Perform a binding operation on the given `Target` and return a `BoundTarget` which contains\r\n     * metadata about the types referenced in the template.\r\n     */\r\n    bind(target) {\r\n        if (!target.template) {\r\n            // TODO(alxhub): handle targets which contain things like HostBindings, etc.\r\n            throw new Error('Binding without a template not yet supported');\r\n        }\r\n        // First, parse the template into a `Scope` structure. This operation captures the syntactic\r\n        // scopes in the template and makes them available for later use.\r\n        const scope = Scope.apply(target.template);\r\n        // Use the `Scope` to extract the entities present at every level of the template.\r\n        const templateEntities = extractTemplateEntities(scope);\r\n        // Next, perform directive matching on the template using the `DirectiveBinder`. This returns:\r\n        //   - directives: Map of nodes (elements & ng-templates) to the directives on them.\r\n        //   - bindings: Map of inputs, outputs, and attributes to the directive/element that claims\r\n        //     them. TODO(alxhub): handle multiple directives claiming an input/output/etc.\r\n        //   - references: Map of #references to their targets.\r\n        const { directives, bindings, references } = DirectiveBinder.apply(target.template, this.directiveMatcher);\r\n        // Finally, run the TemplateBinder to bind references, variables, and other entities within the\r\n        // template. This extracts all the metadata that doesn't depend on directive matching.\r\n        const { expressions, symbols, nestingLevel, usedPipes } = TemplateBinder.apply(target.template, scope);\r\n        return new R3BoundTarget(target, directives, bindings, references, expressions, symbols, nestingLevel, templateEntities, usedPipes);\r\n    }\r\n}\r\n/**\r\n * Represents a binding scope within a template.\r\n *\r\n * Any variables, references, or other named entities declared within the template will\r\n * be captured and available by name in `namedEntities`. Additionally, child templates will\r\n * be analyzed and have their child `Scope`s available in `childScopes`.\r\n */\r\nclass Scope {\r\n    constructor(parentScope, template) {\r\n        this.parentScope = parentScope;\r\n        this.template = template;\r\n        /**\r\n         * Named members of the `Scope`, such as `Reference`s or `Variable`s.\r\n         */\r\n        this.namedEntities = new Map();\r\n        /**\r\n         * Child `Scope`s for immediately nested `Template`s.\r\n         */\r\n        this.childScopes = new Map();\r\n    }\r\n    static newRootScope() {\r\n        return new Scope(null, null);\r\n    }\r\n    /**\r\n     * Process a template (either as a `Template` sub-template with variables, or a plain array of\r\n     * template `Node`s) and construct its `Scope`.\r\n     */\r\n    static apply(template) {\r\n        const scope = Scope.newRootScope();\r\n        scope.ingest(template);\r\n        return scope;\r\n    }\r\n    /**\r\n     * Internal method to process the template and populate the `Scope`.\r\n     */\r\n    ingest(template) {\r\n        if (template instanceof Template) {\r\n            // Variables on an <ng-template> are defined in the inner scope.\r\n            template.variables.forEach(node => this.visitVariable(node));\r\n            // Process the nodes of the template.\r\n            template.children.forEach(node => node.visit(this));\r\n        }\r\n        else {\r\n            // No overarching `Template` instance, so process the nodes directly.\r\n            template.forEach(node => node.visit(this));\r\n        }\r\n    }\r\n    visitElement(element) {\r\n        // `Element`s in the template may have `Reference`s which are captured in the scope.\r\n        element.references.forEach(node => this.visitReference(node));\r\n        // Recurse into the `Element`'s children.\r\n        element.children.forEach(node => node.visit(this));\r\n    }\r\n    visitTemplate(template) {\r\n        // References on a <ng-template> are defined in the outer scope, so capture them before\r\n        // processing the template's child scope.\r\n        template.references.forEach(node => this.visitReference(node));\r\n        // Next, create an inner scope and process the template within it.\r\n        const scope = new Scope(this, template);\r\n        scope.ingest(template);\r\n        this.childScopes.set(template, scope);\r\n    }\r\n    visitVariable(variable) {\r\n        // Declare the variable if it's not already.\r\n        this.maybeDeclare(variable);\r\n    }\r\n    visitReference(reference) {\r\n        // Declare the variable if it's not already.\r\n        this.maybeDeclare(reference);\r\n    }\r\n    // Unused visitors.\r\n    visitContent(content) { }\r\n    visitBoundAttribute(attr) { }\r\n    visitBoundEvent(event) { }\r\n    visitBoundText(text) { }\r\n    visitText(text) { }\r\n    visitTextAttribute(attr) { }\r\n    visitIcu(icu) { }\r\n    maybeDeclare(thing) {\r\n        // Declare something with a name, as long as that name isn't taken.\r\n        if (!this.namedEntities.has(thing.name)) {\r\n            this.namedEntities.set(thing.name, thing);\r\n        }\r\n    }\r\n    /**\r\n     * Look up a variable within this `Scope`.\r\n     *\r\n     * This can recurse into a parent `Scope` if it's available.\r\n     */\r\n    lookup(name) {\r\n        if (this.namedEntities.has(name)) {\r\n            // Found in the local scope.\r\n            return this.namedEntities.get(name);\r\n        }\r\n        else if (this.parentScope !== null) {\r\n            // Not in the local scope, but there's a parent scope so check there.\r\n            return this.parentScope.lookup(name);\r\n        }\r\n        else {\r\n            // At the top level and it wasn't found.\r\n            return null;\r\n        }\r\n    }\r\n    /**\r\n     * Get the child scope for a `Template`.\r\n     *\r\n     * This should always be defined.\r\n     */\r\n    getChildScope(template) {\r\n        const res = this.childScopes.get(template);\r\n        if (res === undefined) {\r\n            throw new Error(`Assertion error: child scope for ${template} not found`);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n/**\r\n * Processes a template and matches directives on nodes (elements and templates).\r\n *\r\n * Usually used via the static `apply()` method.\r\n */\r\nclass DirectiveBinder {\r\n    constructor(matcher, directives, bindings, references) {\r\n        this.matcher = matcher;\r\n        this.directives = directives;\r\n        this.bindings = bindings;\r\n        this.references = references;\r\n    }\r\n    /**\r\n     * Process a template (list of `Node`s) and perform directive matching against each node.\r\n     *\r\n     * @param template the list of template `Node`s to match (recursively).\r\n     * @param selectorMatcher a `SelectorMatcher` containing the directives that are in scope for\r\n     * this template.\r\n     * @returns three maps which contain information about directives in the template: the\r\n     * `directives` map which lists directives matched on each node, the `bindings` map which\r\n     * indicates which directives claimed which bindings (inputs, outputs, etc), and the `references`\r\n     * map which resolves #references (`Reference`s) within the template to the named directive or\r\n     * template node.\r\n     */\r\n    static apply(template, selectorMatcher) {\r\n        const directives = new Map();\r\n        const bindings = new Map();\r\n        const references = new Map();\r\n        const matcher = new DirectiveBinder(selectorMatcher, directives, bindings, references);\r\n        matcher.ingest(template);\r\n        return { directives, bindings, references };\r\n    }\r\n    ingest(template) {\r\n        template.forEach(node => node.visit(this));\r\n    }\r\n    visitElement(element) {\r\n        this.visitElementOrTemplate(element.name, element);\r\n    }\r\n    visitTemplate(template) {\r\n        this.visitElementOrTemplate('ng-template', template);\r\n    }\r\n    visitElementOrTemplate(elementName, node) {\r\n        // First, determine the HTML shape of the node for the purpose of directive matching.\r\n        // Do this by building up a `CssSelector` for the node.\r\n        const cssSelector = createCssSelector(elementName, getAttrsForDirectiveMatching(node));\r\n        // Next, use the `SelectorMatcher` to get the list of directives on the node.\r\n        const directives = [];\r\n        this.matcher.match(cssSelector, (_, directive) => directives.push(directive));\r\n        if (directives.length > 0) {\r\n            this.directives.set(node, directives);\r\n        }\r\n        // Resolve any references that are created on this node.\r\n        node.references.forEach(ref => {\r\n            let dirTarget = null;\r\n            // If the reference expression is empty, then it matches the \"primary\" directive on the node\r\n            // (if there is one). Otherwise it matches the host node itself (either an element or\r\n            // <ng-template> node).\r\n            if (ref.value.trim() === '') {\r\n                // This could be a reference to a component if there is one.\r\n                dirTarget = directives.find(dir => dir.isComponent) || null;\r\n            }\r\n            else {\r\n                // This should be a reference to a directive exported via exportAs.\r\n                dirTarget =\r\n                    directives.find(dir => dir.exportAs !== null && dir.exportAs.some(value => value === ref.value)) ||\r\n                        null;\r\n                // Check if a matching directive was found.\r\n                if (dirTarget === null) {\r\n                    // No matching directive was found - this reference points to an unknown target. Leave it\r\n                    // unmapped.\r\n                    return;\r\n                }\r\n            }\r\n            if (dirTarget !== null) {\r\n                // This reference points to a directive.\r\n                this.references.set(ref, { directive: dirTarget, node });\r\n            }\r\n            else {\r\n                // This reference points to the node itself.\r\n                this.references.set(ref, node);\r\n            }\r\n        });\r\n        const setAttributeBinding = (attribute, ioType) => {\r\n            const dir = directives.find(dir => dir[ioType].hasBindingPropertyName(attribute.name));\r\n            const binding = dir !== undefined ? dir : node;\r\n            this.bindings.set(attribute, binding);\r\n        };\r\n        // Node inputs (bound attributes) and text attributes can be bound to an\r\n        // input on a directive.\r\n        node.inputs.forEach(input => setAttributeBinding(input, 'inputs'));\r\n        node.attributes.forEach(attr => setAttributeBinding(attr, 'inputs'));\r\n        if (node instanceof Template) {\r\n            node.templateAttrs.forEach(attr => setAttributeBinding(attr, 'inputs'));\r\n        }\r\n        // Node outputs (bound events) can be bound to an output on a directive.\r\n        node.outputs.forEach(output => setAttributeBinding(output, 'outputs'));\r\n        // Recurse into the node's children.\r\n        node.children.forEach(child => child.visit(this));\r\n    }\r\n    // Unused visitors.\r\n    visitContent(content) { }\r\n    visitVariable(variable) { }\r\n    visitReference(reference) { }\r\n    visitTextAttribute(attribute) { }\r\n    visitBoundAttribute(attribute) { }\r\n    visitBoundEvent(attribute) { }\r\n    visitBoundAttributeOrEvent(node) { }\r\n    visitText(text) { }\r\n    visitBoundText(text) { }\r\n    visitIcu(icu) { }\r\n}\r\n/**\r\n * Processes a template and extract metadata about expressions and symbols within.\r\n *\r\n * This is a companion to the `DirectiveBinder` that doesn't require knowledge of directives matched\r\n * within the template in order to operate.\r\n *\r\n * Expressions are visited by the superclass `RecursiveAstVisitor`, with custom logic provided\r\n * by overridden methods from that visitor.\r\n */\r\nclass TemplateBinder extends RecursiveAstVisitor$1 {\r\n    constructor(bindings, symbols, usedPipes, nestingLevel, scope, template, level) {\r\n        super();\r\n        this.bindings = bindings;\r\n        this.symbols = symbols;\r\n        this.usedPipes = usedPipes;\r\n        this.nestingLevel = nestingLevel;\r\n        this.scope = scope;\r\n        this.template = template;\r\n        this.level = level;\r\n        this.pipesUsed = [];\r\n        // Save a bit of processing time by constructing this closure in advance.\r\n        this.visitNode = (node) => node.visit(this);\r\n    }\r\n    // This method is defined to reconcile the type of TemplateBinder since both\r\n    // RecursiveAstVisitor and Visitor define the visit() method in their\r\n    // interfaces.\r\n    visit(node, context) {\r\n        if (node instanceof AST) {\r\n            node.visit(this, context);\r\n        }\r\n        else {\r\n            node.visit(this);\r\n        }\r\n    }\r\n    /**\r\n     * Process a template and extract metadata about expressions and symbols within.\r\n     *\r\n     * @param template the nodes of the template to process\r\n     * @param scope the `Scope` of the template being processed.\r\n     * @returns three maps which contain metadata about the template: `expressions` which interprets\r\n     * special `AST` nodes in expressions as pointing to references or variables declared within the\r\n     * template, `symbols` which maps those variables and references to the nested `Template` which\r\n     * declares them, if any, and `nestingLevel` which associates each `Template` with a integer\r\n     * nesting level (how many levels deep within the template structure the `Template` is), starting\r\n     * at 1.\r\n     */\r\n    static apply(template, scope) {\r\n        const expressions = new Map();\r\n        const symbols = new Map();\r\n        const nestingLevel = new Map();\r\n        const usedPipes = new Set();\r\n        // The top-level template has nesting level 0.\r\n        const binder = new TemplateBinder(expressions, symbols, usedPipes, nestingLevel, scope, template instanceof Template ? template : null, 0);\r\n        binder.ingest(template);\r\n        return { expressions, symbols, nestingLevel, usedPipes };\r\n    }\r\n    ingest(template) {\r\n        if (template instanceof Template) {\r\n            // For <ng-template>s, process only variables and child nodes. Inputs, outputs, templateAttrs,\r\n            // and references were all processed in the scope of the containing template.\r\n            template.variables.forEach(this.visitNode);\r\n            template.children.forEach(this.visitNode);\r\n            // Set the nesting level.\r\n            this.nestingLevel.set(template, this.level);\r\n        }\r\n        else {\r\n            // Visit each node from the top-level template.\r\n            template.forEach(this.visitNode);\r\n        }\r\n    }\r\n    visitElement(element) {\r\n        // Visit the inputs, outputs, and children of the element.\r\n        element.inputs.forEach(this.visitNode);\r\n        element.outputs.forEach(this.visitNode);\r\n        element.children.forEach(this.visitNode);\r\n    }\r\n    visitTemplate(template) {\r\n        // First, visit inputs, outputs and template attributes of the template node.\r\n        template.inputs.forEach(this.visitNode);\r\n        template.outputs.forEach(this.visitNode);\r\n        template.templateAttrs.forEach(this.visitNode);\r\n        // References are also evaluated in the outer context.\r\n        template.references.forEach(this.visitNode);\r\n        // Next, recurse into the template using its scope, and bumping the nesting level up by one.\r\n        const childScope = this.scope.getChildScope(template);\r\n        const binder = new TemplateBinder(this.bindings, this.symbols, this.usedPipes, this.nestingLevel, childScope, template, this.level + 1);\r\n        binder.ingest(template);\r\n    }\r\n    visitVariable(variable) {\r\n        // Register the `Variable` as a symbol in the current `Template`.\r\n        if (this.template !== null) {\r\n            this.symbols.set(variable, this.template);\r\n        }\r\n    }\r\n    visitReference(reference) {\r\n        // Register the `Reference` as a symbol in the current `Template`.\r\n        if (this.template !== null) {\r\n            this.symbols.set(reference, this.template);\r\n        }\r\n    }\r\n    // Unused template visitors\r\n    visitText(text) { }\r\n    visitContent(content) { }\r\n    visitTextAttribute(attribute) { }\r\n    visitIcu(icu) {\r\n        Object.keys(icu.vars).forEach(key => icu.vars[key].visit(this));\r\n        Object.keys(icu.placeholders).forEach(key => icu.placeholders[key].visit(this));\r\n    }\r\n    // The remaining visitors are concerned with processing AST expressions within template bindings\r\n    visitBoundAttribute(attribute) {\r\n        attribute.value.visit(this);\r\n    }\r\n    visitBoundEvent(event) {\r\n        event.handler.visit(this);\r\n    }\r\n    visitBoundText(text) {\r\n        text.value.visit(this);\r\n    }\r\n    visitPipe(ast, context) {\r\n        this.usedPipes.add(ast.name);\r\n        return super.visitPipe(ast, context);\r\n    }\r\n    // These five types of AST expressions can refer to expression roots, which could be variables\r\n    // or references in the current scope.\r\n    visitPropertyRead(ast, context) {\r\n        this.maybeMap(context, ast, ast.name);\r\n        return super.visitPropertyRead(ast, context);\r\n    }\r\n    visitSafePropertyRead(ast, context) {\r\n        this.maybeMap(context, ast, ast.name);\r\n        return super.visitSafePropertyRead(ast, context);\r\n    }\r\n    visitPropertyWrite(ast, context) {\r\n        this.maybeMap(context, ast, ast.name);\r\n        return super.visitPropertyWrite(ast, context);\r\n    }\r\n    visitMethodCall(ast, context) {\r\n        this.maybeMap(context, ast, ast.name);\r\n        return super.visitMethodCall(ast, context);\r\n    }\r\n    visitSafeMethodCall(ast, context) {\r\n        this.maybeMap(context, ast, ast.name);\r\n        return super.visitSafeMethodCall(ast, context);\r\n    }\r\n    maybeMap(scope, ast, name) {\r\n        // If the receiver of the expression isn't the `ImplicitReceiver`, this isn't the root of an\r\n        // `AST` expression that maps to a `Variable` or `Reference`.\r\n        if (!(ast.receiver instanceof ImplicitReceiver)) {\r\n            return;\r\n        }\r\n        // Check whether the name exists in the current scope. If so, map it. Otherwise, the name is\r\n        // probably a property on the top-level component context.\r\n        let target = this.scope.lookup(name);\r\n        if (target !== null) {\r\n            this.bindings.set(ast, target);\r\n        }\r\n    }\r\n}\r\n/**\r\n * Metadata container for a `Target` that allows queries for specific bits of metadata.\r\n *\r\n * See `BoundTarget` for documentation on the individual methods.\r\n */\r\nclass R3BoundTarget {\r\n    constructor(target, directives, bindings, references, exprTargets, symbols, nestingLevel, templateEntities, usedPipes) {\r\n        this.target = target;\r\n        this.directives = directives;\r\n        this.bindings = bindings;\r\n        this.references = references;\r\n        this.exprTargets = exprTargets;\r\n        this.symbols = symbols;\r\n        this.nestingLevel = nestingLevel;\r\n        this.templateEntities = templateEntities;\r\n        this.usedPipes = usedPipes;\r\n    }\r\n    getEntitiesInTemplateScope(template) {\r\n        var _a;\r\n        return (_a = this.templateEntities.get(template)) !== null && _a !== void 0 ? _a : new Set();\r\n    }\r\n    getDirectivesOfNode(node) {\r\n        return this.directives.get(node) || null;\r\n    }\r\n    getReferenceTarget(ref) {\r\n        return this.references.get(ref) || null;\r\n    }\r\n    getConsumerOfBinding(binding) {\r\n        return this.bindings.get(binding) || null;\r\n    }\r\n    getExpressionTarget(expr) {\r\n        return this.exprTargets.get(expr) || null;\r\n    }\r\n    getTemplateOfSymbol(symbol) {\r\n        return this.symbols.get(symbol) || null;\r\n    }\r\n    getNestingLevel(template) {\r\n        return this.nestingLevel.get(template) || 0;\r\n    }\r\n    getUsedDirectives() {\r\n        const set = new Set();\r\n        this.directives.forEach(dirs => dirs.forEach(dir => set.add(dir)));\r\n        return Array.from(set.values());\r\n    }\r\n    getUsedPipes() {\r\n        return Array.from(this.usedPipes);\r\n    }\r\n}\r\nfunction extractTemplateEntities(rootScope) {\r\n    const entityMap = new Map();\r\n    function extractScopeEntities(scope) {\r\n        if (entityMap.has(scope.template)) {\r\n            return entityMap.get(scope.template);\r\n        }\r\n        const currentEntities = scope.namedEntities;\r\n        let templateEntities;\r\n        if (scope.parentScope !== null) {\r\n            templateEntities = new Map([...extractScopeEntities(scope.parentScope), ...currentEntities]);\r\n        }\r\n        else {\r\n            templateEntities = new Map(currentEntities);\r\n        }\r\n        entityMap.set(scope.template, templateEntities);\r\n        return templateEntities;\r\n    }\r\n    const scopesToProcess = [rootScope];\r\n    while (scopesToProcess.length > 0) {\r\n        const scope = scopesToProcess.pop();\r\n        for (const childScope of scope.childScopes.values()) {\r\n            scopesToProcess.push(childScope);\r\n        }\r\n        extractScopeEntities(scope);\r\n    }\r\n    const templateEntities = new Map();\r\n    for (const [template, entities] of entityMap) {\r\n        templateEntities.set(template, new Set(entities.values()));\r\n    }\r\n    return templateEntities;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nfunction compileClassMetadata(metadata) {\r\n    var _a, _b;\r\n    // Generate an ngDevMode guarded call to setClassMetadata with the class identifier and its\r\n    // metadata.\r\n    const fnCall = importExpr(Identifiers.setClassMetadata).callFn([\r\n        metadata.type,\r\n        metadata.decorators,\r\n        (_a = metadata.ctorParameters) !== null && _a !== void 0 ? _a : literal(null),\r\n        (_b = metadata.propDecorators) !== null && _b !== void 0 ? _b : literal(null),\r\n    ]);\r\n    const iife = fn([], [devOnlyGuardedExpression(fnCall).toStmt()]);\r\n    return iife.callFn([]);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\r\n * must update this constant to prevent old partial-linkers from incorrectly processing the\r\n * declaration.\r\n *\r\n * Do not include any prerelease in these versions as they are ignored.\r\n */\r\nconst MINIMUM_PARTIAL_LINKER_VERSION = '12.0.0';\r\nfunction compileDeclareClassMetadata(metadata) {\r\n    const definitionMap = new DefinitionMap();\r\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION));\r\n    definitionMap.set('version', literal('12.1.0'));\r\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\r\n    definitionMap.set('type', metadata.type);\r\n    definitionMap.set('decorators', metadata.decorators);\r\n    definitionMap.set('ctorParameters', metadata.ctorParameters);\r\n    definitionMap.set('propDecorators', metadata.propDecorators);\r\n    return importExpr(Identifiers.declareClassMetadata).callFn([definitionMap.toLiteralMap()]);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\r\n * must update this constant to prevent old partial-linkers from incorrectly processing the\r\n * declaration.\r\n *\r\n * Do not include any prerelease in these versions as they are ignored.\r\n */\r\nconst MINIMUM_PARTIAL_LINKER_VERSION$1 = '12.0.0';\r\n/**\r\n * Compile a directive declaration defined by the `R3DirectiveMetadata`.\r\n */\r\nfunction compileDeclareDirectiveFromMetadata(meta) {\r\n    const definitionMap = createDirectiveDefinitionMap(meta);\r\n    const expression = importExpr(Identifiers.declareDirective).callFn([definitionMap.toLiteralMap()]);\r\n    const type = createDirectiveType(meta);\r\n    return { expression, type, statements: [] };\r\n}\r\n/**\r\n * Gathers the declaration fields for a directive into a `DefinitionMap`. This allows for reusing\r\n * this logic for components, as they extend the directive metadata.\r\n */\r\nfunction createDirectiveDefinitionMap(meta) {\r\n    const definitionMap = new DefinitionMap();\r\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$1));\r\n    definitionMap.set('version', literal('12.1.0'));\r\n    // e.g. `type: MyDirective`\r\n    definitionMap.set('type', meta.internalType);\r\n    // e.g. `selector: 'some-dir'`\r\n    if (meta.selector !== null) {\r\n        definitionMap.set('selector', literal(meta.selector));\r\n    }\r\n    definitionMap.set('inputs', conditionallyCreateMapObjectLiteral(meta.inputs, true));\r\n    definitionMap.set('outputs', conditionallyCreateMapObjectLiteral(meta.outputs));\r\n    definitionMap.set('host', compileHostMetadata(meta.host));\r\n    definitionMap.set('providers', meta.providers);\r\n    if (meta.queries.length > 0) {\r\n        definitionMap.set('queries', literalArr(meta.queries.map(compileQuery)));\r\n    }\r\n    if (meta.viewQueries.length > 0) {\r\n        definitionMap.set('viewQueries', literalArr(meta.viewQueries.map(compileQuery)));\r\n    }\r\n    if (meta.exportAs !== null) {\r\n        definitionMap.set('exportAs', asLiteral(meta.exportAs));\r\n    }\r\n    if (meta.usesInheritance) {\r\n        definitionMap.set('usesInheritance', literal(true));\r\n    }\r\n    if (meta.lifecycle.usesOnChanges) {\r\n        definitionMap.set('usesOnChanges', literal(true));\r\n    }\r\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\r\n    return definitionMap;\r\n}\r\n/**\r\n * Compiles the metadata of a single query into its partial declaration form as declared\r\n * by `R3DeclareQueryMetadata`.\r\n */\r\nfunction compileQuery(query) {\r\n    const meta = new DefinitionMap();\r\n    meta.set('propertyName', literal(query.propertyName));\r\n    if (query.first) {\r\n        meta.set('first', literal(true));\r\n    }\r\n    meta.set('predicate', Array.isArray(query.predicate) ? asLiteral(query.predicate) : query.predicate);\r\n    if (!query.emitDistinctChangesOnly) {\r\n        // `emitDistinctChangesOnly` is special because we expect it to be `true`.\r\n        // Therefore we explicitly emit the field, and explicitly place it only when it's `false`.\r\n        meta.set('emitDistinctChangesOnly', literal(false));\r\n    }\r\n    else {\r\n        // The linker will assume that an absent `emitDistinctChangesOnly` flag is by default `true`.\r\n    }\r\n    if (query.descendants) {\r\n        meta.set('descendants', literal(true));\r\n    }\r\n    meta.set('read', query.read);\r\n    if (query.static) {\r\n        meta.set('static', literal(true));\r\n    }\r\n    return meta.toLiteralMap();\r\n}\r\n/**\r\n * Compiles the host metadata into its partial declaration form as declared\r\n * in `R3DeclareDirectiveMetadata['host']`\r\n */\r\nfunction compileHostMetadata(meta) {\r\n    const hostMetadata = new DefinitionMap();\r\n    hostMetadata.set('attributes', toOptionalLiteralMap(meta.attributes, expression => expression));\r\n    hostMetadata.set('listeners', toOptionalLiteralMap(meta.listeners, literal));\r\n    hostMetadata.set('properties', toOptionalLiteralMap(meta.properties, literal));\r\n    if (meta.specialAttributes.styleAttr) {\r\n        hostMetadata.set('styleAttribute', literal(meta.specialAttributes.styleAttr));\r\n    }\r\n    if (meta.specialAttributes.classAttr) {\r\n        hostMetadata.set('classAttribute', literal(meta.specialAttributes.classAttr));\r\n    }\r\n    if (hostMetadata.values.length > 0) {\r\n        return hostMetadata.toLiteralMap();\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Compile a component declaration defined by the `R3ComponentMetadata`.\r\n */\r\nfunction compileDeclareComponentFromMetadata(meta, template, additionalTemplateInfo) {\r\n    const definitionMap = createComponentDefinitionMap(meta, template, additionalTemplateInfo);\r\n    const expression = importExpr(Identifiers.declareComponent).callFn([definitionMap.toLiteralMap()]);\r\n    const type = createComponentType(meta);\r\n    return { expression, type, statements: [] };\r\n}\r\n/**\r\n * Gathers the declaration fields for a component into a `DefinitionMap`.\r\n */\r\nfunction createComponentDefinitionMap(meta, template, templateInfo) {\r\n    const definitionMap = createDirectiveDefinitionMap(meta);\r\n    definitionMap.set('template', getTemplateExpression(template, templateInfo));\r\n    if (templateInfo.isInline) {\r\n        definitionMap.set('isInline', literal(true));\r\n    }\r\n    definitionMap.set('styles', toOptionalLiteralArray(meta.styles, literal));\r\n    definitionMap.set('components', compileUsedDirectiveMetadata(meta, directive => directive.isComponent === true));\r\n    definitionMap.set('directives', compileUsedDirectiveMetadata(meta, directive => directive.isComponent !== true));\r\n    definitionMap.set('pipes', compileUsedPipeMetadata(meta));\r\n    definitionMap.set('viewProviders', meta.viewProviders);\r\n    definitionMap.set('animations', meta.animations);\r\n    if (meta.changeDetection !== undefined) {\r\n        definitionMap.set('changeDetection', importExpr(Identifiers.ChangeDetectionStrategy)\r\n            .prop(ChangeDetectionStrategy[meta.changeDetection]));\r\n    }\r\n    if (meta.encapsulation !== ViewEncapsulation.Emulated) {\r\n        definitionMap.set('encapsulation', importExpr(Identifiers.ViewEncapsulation).prop(ViewEncapsulation[meta.encapsulation]));\r\n    }\r\n    if (meta.interpolation !== DEFAULT_INTERPOLATION_CONFIG) {\r\n        definitionMap.set('interpolation', literalArr([literal(meta.interpolation.start), literal(meta.interpolation.end)]));\r\n    }\r\n    if (template.preserveWhitespaces === true) {\r\n        definitionMap.set('preserveWhitespaces', literal(true));\r\n    }\r\n    return definitionMap;\r\n}\r\nfunction getTemplateExpression(template, templateInfo) {\r\n    // If the template has been defined using a direct literal, we use that expression directly\r\n    // without any modifications. This is ensures proper source mapping from the partially\r\n    // compiled code to the source file declaring the template. Note that this does not capture\r\n    // template literals referenced indirectly through an identifier.\r\n    if (templateInfo.inlineTemplateLiteralExpression !== null) {\r\n        return templateInfo.inlineTemplateLiteralExpression;\r\n    }\r\n    // If the template is defined inline but not through a literal, the template has been resolved\r\n    // through static interpretation. We create a literal but cannot provide any source span. Note\r\n    // that we cannot use the expression defining the template because the linker expects the template\r\n    // to be defined as a literal in the declaration.\r\n    if (templateInfo.isInline) {\r\n        return literal(templateInfo.content, null, null);\r\n    }\r\n    // The template is external so we must synthesize an expression node with\r\n    // the appropriate source-span.\r\n    const contents = templateInfo.content;\r\n    const file = new ParseSourceFile(contents, templateInfo.sourceUrl);\r\n    const start = new ParseLocation(file, 0, 0, 0);\r\n    const end = computeEndLocation(file, contents);\r\n    const span = new ParseSourceSpan(start, end);\r\n    return literal(contents, null, span);\r\n}\r\nfunction computeEndLocation(file, contents) {\r\n    const length = contents.length;\r\n    let lineStart = 0;\r\n    let lastLineStart = 0;\r\n    let line = 0;\r\n    do {\r\n        lineStart = contents.indexOf('\\n', lastLineStart);\r\n        if (lineStart !== -1) {\r\n            lastLineStart = lineStart + 1;\r\n            line++;\r\n        }\r\n    } while (lineStart !== -1);\r\n    return new ParseLocation(file, length, line, length - lastLineStart);\r\n}\r\n/**\r\n * Compiles the directives as registered in the component metadata into an array literal of the\r\n * individual directives. If the component does not use any directives, then null is returned.\r\n */\r\nfunction compileUsedDirectiveMetadata(meta, predicate) {\r\n    const wrapType = meta.declarationListEmitMode !== 0 /* Direct */ ?\r\n        generateForwardRef :\r\n        (expr) => expr;\r\n    const directives = meta.directives.filter(predicate);\r\n    return toOptionalLiteralArray(directives, directive => {\r\n        const dirMeta = new DefinitionMap();\r\n        dirMeta.set('type', wrapType(directive.type));\r\n        dirMeta.set('selector', literal(directive.selector));\r\n        dirMeta.set('inputs', toOptionalLiteralArray(directive.inputs, literal));\r\n        dirMeta.set('outputs', toOptionalLiteralArray(directive.outputs, literal));\r\n        dirMeta.set('exportAs', toOptionalLiteralArray(directive.exportAs, literal));\r\n        return dirMeta.toLiteralMap();\r\n    });\r\n}\r\n/**\r\n * Compiles the pipes as registered in the component metadata into an object literal, where the\r\n * pipe's name is used as key and a reference to its type as value. If the component does not use\r\n * any pipes, then null is returned.\r\n */\r\nfunction compileUsedPipeMetadata(meta) {\r\n    if (meta.pipes.size === 0) {\r\n        return null;\r\n    }\r\n    const wrapType = meta.declarationListEmitMode !== 0 /* Direct */ ?\r\n        generateForwardRef :\r\n        (expr) => expr;\r\n    const entries = [];\r\n    for (const [name, pipe] of meta.pipes) {\r\n        entries.push({ key: name, value: wrapType(pipe), quoted: true });\r\n    }\r\n    return literalMap(entries);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\r\n * must update this constant to prevent old partial-linkers from incorrectly processing the\r\n * declaration.\r\n *\r\n * Do not include any prerelease in these versions as they are ignored.\r\n */\r\nconst MINIMUM_PARTIAL_LINKER_VERSION$2 = '12.0.0';\r\nfunction compileDeclareFactoryFunction(meta) {\r\n    const definitionMap = new DefinitionMap();\r\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$2));\r\n    definitionMap.set('version', literal('12.1.0'));\r\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\r\n    definitionMap.set('type', meta.internalType);\r\n    definitionMap.set('deps', compileDependencies(meta.deps));\r\n    definitionMap.set('target', importExpr(Identifiers.FactoryTarget).prop(FactoryTarget[meta.target]));\r\n    return {\r\n        expression: importExpr(Identifiers.declareFactory).callFn([definitionMap.toLiteralMap()]),\r\n        statements: [],\r\n        type: createFactoryType(meta),\r\n    };\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\r\n * must update this constant to prevent old partial-linkers from incorrectly processing the\r\n * declaration.\r\n *\r\n * Do not include any prerelease in these versions as they are ignored.\r\n */\r\nconst MINIMUM_PARTIAL_LINKER_VERSION$3 = '12.0.0';\r\n/**\r\n * Compile a Injectable declaration defined by the `R3InjectableMetadata`.\r\n */\r\nfunction compileDeclareInjectableFromMetadata(meta) {\r\n    const definitionMap = createInjectableDefinitionMap(meta);\r\n    const expression = importExpr(Identifiers.declareInjectable).callFn([definitionMap.toLiteralMap()]);\r\n    const type = createInjectableType(meta);\r\n    return { expression, type, statements: [] };\r\n}\r\n/**\r\n * Gathers the declaration fields for a Injectable into a `DefinitionMap`.\r\n */\r\nfunction createInjectableDefinitionMap(meta) {\r\n    const definitionMap = new DefinitionMap();\r\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$3));\r\n    definitionMap.set('version', literal('12.1.0'));\r\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\r\n    definitionMap.set('type', meta.internalType);\r\n    // Only generate providedIn property if it has a non-null value\r\n    if (meta.providedIn !== undefined) {\r\n        const providedIn = convertFromProviderExpression(meta.providedIn);\r\n        if (providedIn.value !== null) {\r\n            definitionMap.set('providedIn', providedIn);\r\n        }\r\n    }\r\n    if (meta.useClass !== undefined) {\r\n        definitionMap.set('useClass', convertFromProviderExpression(meta.useClass));\r\n    }\r\n    if (meta.useExisting !== undefined) {\r\n        definitionMap.set('useExisting', convertFromProviderExpression(meta.useExisting));\r\n    }\r\n    if (meta.useValue !== undefined) {\r\n        definitionMap.set('useValue', convertFromProviderExpression(meta.useValue));\r\n    }\r\n    // Factories do not contain `ForwardRef`s since any types are already wrapped in a function call\r\n    // so the types will not be eagerly evaluated. Therefore we do not need to process this expression\r\n    // with `convertFromProviderExpression()`.\r\n    if (meta.useFactory !== undefined) {\r\n        definitionMap.set('useFactory', meta.useFactory);\r\n    }\r\n    if (meta.deps !== undefined) {\r\n        definitionMap.set('deps', literalArr(meta.deps.map(compileDependency)));\r\n    }\r\n    return definitionMap;\r\n}\r\n/**\r\n * Convert an `R3ProviderExpression` to an `Expression`, possibly wrapping its expression in a\r\n * `forwardRef()` call.\r\n *\r\n * If `R3ProviderExpression.isForwardRef` is true then the expression was originally wrapped in a\r\n * `forwardRef()` call to prevent the value from being eagerly evaluated in the code.\r\n *\r\n * Normally, the linker will statically process the code, putting the `expression` inside a factory\r\n * function so the `forwardRef()` wrapper is not evaluated before it has been defined. But if the\r\n * partial declaration is evaluated by the JIT compiler the `forwardRef()` call is still needed to\r\n * prevent eager evaluation of the `expression`.\r\n *\r\n * So in partial declarations, expressions that could be forward-refs are wrapped in `forwardRef()`\r\n * calls, and this is then unwrapped in the linker as necessary.\r\n *\r\n * See `packages/compiler-cli/src/ngtsc/annotations/src/injectable.ts` and\r\n * `packages/compiler/src/jit_compiler_facade.ts` for more information.\r\n */\r\nfunction convertFromProviderExpression({ expression, isForwardRef }) {\r\n    return isForwardRef ? generateForwardRef(expression) : expression;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\r\n * must update this constant to prevent old partial-linkers from incorrectly processing the\r\n * declaration.\r\n *\r\n * Do not include any prerelease in these versions as they are ignored.\r\n */\r\nconst MINIMUM_PARTIAL_LINKER_VERSION$4 = '12.0.0';\r\nfunction compileDeclareInjectorFromMetadata(meta) {\r\n    const definitionMap = createInjectorDefinitionMap(meta);\r\n    const expression = importExpr(Identifiers.declareInjector).callFn([definitionMap.toLiteralMap()]);\r\n    const type = createInjectorType(meta);\r\n    return { expression, type, statements: [] };\r\n}\r\n/**\r\n * Gathers the declaration fields for an Injector into a `DefinitionMap`.\r\n */\r\nfunction createInjectorDefinitionMap(meta) {\r\n    const definitionMap = new DefinitionMap();\r\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$4));\r\n    definitionMap.set('version', literal('12.1.0'));\r\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\r\n    definitionMap.set('type', meta.internalType);\r\n    definitionMap.set('providers', meta.providers);\r\n    if (meta.imports.length > 0) {\r\n        definitionMap.set('imports', literalArr(meta.imports));\r\n    }\r\n    return definitionMap;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\r\n * must update this constant to prevent old partial-linkers from incorrectly processing the\r\n * declaration.\r\n *\r\n * Do not include any prerelease in these versions as they are ignored.\r\n */\r\nconst MINIMUM_PARTIAL_LINKER_VERSION$5 = '12.0.0';\r\nfunction compileDeclareNgModuleFromMetadata(meta) {\r\n    const definitionMap = createNgModuleDefinitionMap(meta);\r\n    const expression = importExpr(Identifiers.declareNgModule).callFn([definitionMap.toLiteralMap()]);\r\n    const type = createNgModuleType(meta);\r\n    return { expression, type, statements: [] };\r\n}\r\n/**\r\n * Gathers the declaration fields for an NgModule into a `DefinitionMap`.\r\n */\r\nfunction createNgModuleDefinitionMap(meta) {\r\n    const definitionMap = new DefinitionMap();\r\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$5));\r\n    definitionMap.set('version', literal('12.1.0'));\r\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\r\n    definitionMap.set('type', meta.internalType);\r\n    // We only generate the keys in the metadata if the arrays contain values.\r\n    // We must wrap the arrays inside a function if any of the values are a forward reference to a\r\n    // not-yet-declared class. This is to support JIT execution of the `ɵɵngDeclareNgModule()` call.\r\n    // In the linker these wrappers are stripped and then reapplied for the `ɵɵdefineNgModule()` call.\r\n    if (meta.bootstrap.length > 0) {\r\n        definitionMap.set('bootstrap', refsToArray(meta.bootstrap, meta.containsForwardDecls));\r\n    }\r\n    if (meta.declarations.length > 0) {\r\n        definitionMap.set('declarations', refsToArray(meta.declarations, meta.containsForwardDecls));\r\n    }\r\n    if (meta.imports.length > 0) {\r\n        definitionMap.set('imports', refsToArray(meta.imports, meta.containsForwardDecls));\r\n    }\r\n    if (meta.exports.length > 0) {\r\n        definitionMap.set('exports', refsToArray(meta.exports, meta.containsForwardDecls));\r\n    }\r\n    if (meta.schemas !== null && meta.schemas.length > 0) {\r\n        definitionMap.set('schemas', literalArr(meta.schemas.map(ref => ref.value)));\r\n    }\r\n    if (meta.id !== null) {\r\n        definitionMap.set('id', meta.id);\r\n    }\r\n    return definitionMap;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Every time we make a breaking change to the declaration interface or partial-linker behavior, we\r\n * must update this constant to prevent old partial-linkers from incorrectly processing the\r\n * declaration.\r\n *\r\n * Do not include any prerelease in these versions as they are ignored.\r\n */\r\nconst MINIMUM_PARTIAL_LINKER_VERSION$6 = '12.0.0';\r\n/**\r\n * Compile a Pipe declaration defined by the `R3PipeMetadata`.\r\n */\r\nfunction compileDeclarePipeFromMetadata(meta) {\r\n    const definitionMap = createPipeDefinitionMap(meta);\r\n    const expression = importExpr(Identifiers.declarePipe).callFn([definitionMap.toLiteralMap()]);\r\n    const type = createPipeType(meta);\r\n    return { expression, type, statements: [] };\r\n}\r\n/**\r\n * Gathers the declaration fields for a Pipe into a `DefinitionMap`.\r\n */\r\nfunction createPipeDefinitionMap(meta) {\r\n    const definitionMap = new DefinitionMap();\r\n    definitionMap.set('minVersion', literal(MINIMUM_PARTIAL_LINKER_VERSION$6));\r\n    definitionMap.set('version', literal('12.1.0'));\r\n    definitionMap.set('ngImport', importExpr(Identifiers.core));\r\n    // e.g. `type: MyPipe`\r\n    definitionMap.set('type', meta.internalType);\r\n    // e.g. `name: \"myPipe\"`\r\n    definitionMap.set('name', literal(meta.pipeName));\r\n    if (meta.pure === false) {\r\n        // e.g. `pure: false`\r\n        definitionMap.set('pure', literal(meta.pure));\r\n    }\r\n    return definitionMap;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n// This file only reexports content of the `src` folder. Keep it that way.\r\n// This function call has a global side effects and publishes the compiler into global namespace for\r\n// the late binding of the Compiler to the @angular/core for jit compilation.\r\npublishFacade(_global);\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n// This file only reexports content of the `src` folder. Keep it that way.\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\nexport { AST, ASTWithName, ASTWithSource, AbsoluteSourceSpan, AotCompiler, AotSummaryResolver, ArrayType, AssertNotNull, AstMemoryEfficientTransformer, AstPath, AstTransformer$1 as AstTransformer, AttrAst, Attribute, Binary, BinaryOperator, BinaryOperatorExpr, BindingPipe, BoundDirectivePropertyAst, BoundElementProperty, BoundElementPropertyAst, BoundEventAst, BoundTextAst, BuiltinMethod, BuiltinType, BuiltinTypeName, BuiltinVar, CONTENT_ATTR, CUSTOM_ELEMENTS_SCHEMA, CastExpr, Chain, ClassField, ClassMethod, ClassStmt, CommaExpr, Comment$1 as Comment, CompileDirectiveMetadata, CompileMetadataResolver, CompileNgModuleMetadata, CompilePipeMetadata, CompileReflector, CompileShallowModuleMetadata, CompileStylesheetMetadata, CompileSummaryKind, CompileTemplateMetadata, CompiledStylesheet, CompilerConfig, Conditional, ConditionalExpr, ConstantPool, CssSelector, DEFAULT_INTERPOLATION_CONFIG, DYNAMIC_TYPE, DeclareFunctionStmt, DeclareVarStmt, DirectiveAst, DirectiveNormalizer, DirectiveResolver, DomElementSchemaRegistry, EOF, ERROR_COMPONENT_TYPE, Element$1 as Element, ElementAst, ElementSchemaRegistry, EmbeddedTemplateAst, EmitterVisitorContext, EmptyExpr, Expansion, ExpansionCase, Expression, ExpressionBinding, ExpressionStatement, ExpressionType, ExternalExpr, ExternalReference, Extractor, FactoryTarget, FunctionCall, FunctionExpr, GeneratedFile, HOST_ATTR, HtmlParser, HtmlTagDefinition, I18NHtmlParser, Identifiers$1 as Identifiers, IfStmt, ImplicitReceiver, InstantiateExpr, Interpolation, InterpolationConfig, InvokeFunctionExpr, InvokeMethodExpr, IvyParser, JSDocComment, JitCompiler, JitEvaluator, JitSummaryResolver, KeyedRead, KeyedWrite, LeadingComment, Lexer, LiteralArray, LiteralArrayExpr, LiteralExpr, LiteralMap, LiteralMapExpr, LiteralPrimitive, LocalizedString, MapType, MessageBundle, MethodCall, NAMED_ENTITIES, NGSP_UNICODE, NONE_TYPE, NO_ERRORS_SCHEMA, NgContentAst, NgModuleCompiler, NgModuleResolver, NodeWithI18n, NonNullAssert, NotExpr, NullTemplateVisitor, ParseError, ParseErrorLevel, ParseLocation, ParseSourceFile, ParseSourceSpan, ParseSpan, ParseTreeResult, ParsedEvent, ParsedProperty, ParsedPropertyType, ParsedVariable, Parser$1 as Parser, ParserError, PipeResolver, PrefixNot, PropertyRead, PropertyWrite, ProviderAst, ProviderAstType, ProviderMeta, Quote, R3BoundTarget, Identifiers as R3Identifiers, R3TargetBinder, ReadKeyExpr, ReadPropExpr, ReadVarExpr, RecursiveAstVisitor$1 as RecursiveAstVisitor, RecursiveTemplateAstVisitor, RecursiveVisitor$1 as RecursiveVisitor, ReferenceAst, ResolvedStaticSymbol, ResourceLoader, ReturnStatement, STRING_TYPE, SafeKeyedRead, SafeMethodCall, SafePropertyRead, SelectorContext, SelectorListContext, SelectorMatcher, Serializer, SplitInterpolation, Statement, StaticReflector, StaticSymbol, StaticSymbolCache, StaticSymbolResolver, StmtModifier, StyleCompiler, StylesCompileDependency, SummaryResolver, TagContentType, TaggedTemplateExpr, TemplateBindingParseResult, TemplateLiteral, TemplateLiteralElement, TemplateParseError, TemplateParseResult, TemplateParser, Text$3 as Text, TextAst, ThisReceiver, ThrowStmt, BoundAttribute as TmplAstBoundAttribute, BoundEvent as TmplAstBoundEvent, BoundText as TmplAstBoundText, Content as TmplAstContent, Element as TmplAstElement, Icu as TmplAstIcu, RecursiveVisitor as TmplAstRecursiveVisitor, Reference as TmplAstReference, Template as TmplAstTemplate, Text as TmplAstText, TextAttribute as TmplAstTextAttribute, Variable as TmplAstVariable, Token$1 as Token, TokenType$1 as TokenType, TransitiveCompileNgModuleMetadata, TreeError, TryCatchStmt, Type$1 as Type, TypeScriptEmitter, TypeofExpr, Unary, UnaryOperator, UnaryOperatorExpr, UrlResolver, VERSION$1 as VERSION, VariableAst, VariableBinding, Version, ViewCompiler, WrappedNodeExpr, WriteKeyExpr, WritePropExpr, WriteVarExpr, Xliff, Xliff2, Xmb, XmlParser, Xtb, _ParseAST, analyzeAndValidateNgModules, analyzeFile, analyzeFileForInjectables, analyzeNgModules, collectExternalReferences, compileClassMetadata, compileComponentFromMetadata, compileDeclareClassMetadata, compileDeclareComponentFromMetadata, compileDeclareDirectiveFromMetadata, compileDeclareFactoryFunction, compileDeclareInjectableFromMetadata, compileDeclareInjectorFromMetadata, compileDeclareNgModuleFromMetadata, compileDeclarePipeFromMetadata, compileDirectiveFromMetadata, compileFactoryFunction, compileInjectable, compileInjector, compileNgModule, compilePipeFromMetadata, componentFactoryName, computeMsgId, core, createAotCompiler, createAotUrlResolver, createElementCssSelector, createInjectableType, createLoweredSymbol, createOfflineCompileUrlResolver, createR3ProviderExpression, createUrlResolverWithoutPackagePrefix, debugOutputAstAsTypeScript, devOnlyGuardedExpression, findNode, flatten, formattedError, getHtmlTagDefinition, getMissingNgModuleMetadataErrorData, getNsPrefix, getParseErrors, getSafePropertyAccessString, getUrlScheme, hostViewClassName, identifierModuleUrl, identifierName, isEmptyExpression, isFormattedError, isIdentifier, isLoweredSymbol, isNgContainer, isNgContent, isNgTemplate, isQuote, isSyntaxError, jsDocComment, leadingComment, literalMap, makeBindingParser, mergeAnalyzedFiles, mergeNsAndName, ngModuleJitUrl, parseHostBindings, parseTemplate, preserveWhitespacesDefault, publishFacade, r3JitTypeSourceSpan, removeSummaryDuplicates, rendererTypeName, sanitizeIdentifier, sharedStylesheetJitUrl, splitClasses, splitNsName, syntaxError, templateJitUrl, templateSourceUrl, templateVisitAll, toTypeScript, tokenName, tokenReference, typeSourceSpan, unescapeIdentifier, unwrapResolvedMetadata, verifyHostBindings, viewClassName, visitAll$1 as visitAll };\r\n//# sourceMappingURL=compiler.js.map\r\n"]},"metadata":{},"sourceType":"module"}